# Цикли

## List comprehension
List comprehension в Python - це компактний спосіб створення нового списку на основі наявного списку або іншої ітерованої послідовності, наприклад, рядка. Він дає змогу більш елегантно і стисло написати код, роблячи його більш читабельним і ефективним.

Загальний синтаксис для створення list comprehension виглядає наступним чином:

```{{python}}
new_list = [expression for item in iterable if condition]
```

де:

- `expression` - вираз, який застосовуватиметься до кожного елемента списку або послідовності
- `item` - змінна, що представляє поточний елемент послідовності, що ітерується;
- `iterable` - список або інша послідовність, що ітерується;
- `condition` (необов'язково) - умова, за якою буде фільтруватися вихідна послідовність.

Нижче наведено кілька прикладів для кращого розуміння:

1. Припустимо, у нас є список із числами, ми хочемо створити новий список із квадратами цих чисел. Варіант рішення:

```{python}
numbers = [1, 2, 3, 4, 5]
squares = []
for i in numbers:
    squares.append(i**2)

print(squares)
```

А ось так виглядало б рішення за допомогою list comprehension:

```{python}
numbers = [1, 2, 3, 4, 5]
squares = [x**2 for x in numbers]

print(squares)
```

Інакше кажучи, результат роботи нашого циклу відразу поміщається в список.

2. Створення нового списку, що містить тільки парні числа з вихідного списку:

Стандартний розв'язок:

```{python}
numbers = [1, 2, 3, 4, 5]
even_numbers = []
for i in numbers:
    if i % 2 == 0:
        even_numbers.append(i)

print(even_numbers)
```

List comprehension:

```{python}
numbers = [1, 2, 3, 4, 5]
even_numbers = [x for x in numbers if x % 2 == 0]

print(even_numbers)
```

3. Створення нового списку, що містить довжини слів із вихідного списку:

```{python}
words = ["hello", "world", "python", "list"]
word_lengths = [len(word) for word in words]

print(word_lengths)
```

## Функція `enumerate`
Функція `enumerate()` у Python використовується для додавання індексів до елементів послідовності (наприклад, списку або рядка) під час ітерації по цій послідовності. Вона повертає об'єкт-лічильник, який містить пари (індекс, елемент). 

Припустимо, у нас є список замовлень, кожне з яких представлено у вигляді словника з різними властивостями, такими як `"номер"`, `"клієнт"`, `"дата"` тощо. Наше завдання - вивести на екран інформацію за кожним замовленням, а також додати порядкові номери до кожної властивості цього замовлення.

```{python}
orders = [
    {"номер": "001", "клієнт": "John", "дата": "2022-01-01", "статус": "в обробці"},
    {"номер": "002", "клієнт": "Alice", "дата": "2022-01-02", "статус": "виконано"},
    {"номер": "003", "клієнт": "Bob", "дата": "2022-01-03", "статус": "виконано"},
    {"номер": "004", "клієнт": "Eva", "дата": "2022-01-04", "статус": "в обробці"},
]
for index, order in enumerate(orders, start=1):
    print(f"Замовлення {index}:")
    for key, value in order.items():
        print(f"{key}: {value}")
    print()
```

::: {.callout-warning}
Зверніть увагу, ми явно вказали, що хочемо почати нумерацію з 1 за допомогою `enumerate(orders, start=1)`. Функція `enumerate()` допомагає нам додати порядкові номери до кожного замовлення в списку ітерацією по ньому. Це може бути особливо корисно, коли нам потрібно обробляти й аналізувати дані з урахуванням їхніх позицій у структурі даних.
:::

## Оператори `continue` та `break`

Оператор `continue` і оператор `break` є керуючими операторами в циклах, їх використовують для зміни поведінки виконання циклу. 

Оператор `continue` використовується для пропуску частини тіла циклу, що залишилася, і переходу до наступної ітерації циклу. Якщо зустрінеться оператор `continue`, то код нижче за нього в поточній ітерації циклу не буде виконано, а виконання циклу продовжиться відразу з наступної ітерації.

Приклад:

```{python}
for i in range(1, 6):
    if i == 3:
        continue
    print(i)
```

У цьому прикладі в циклі `for` ми перебираємо значення від 1 до 5. Якщо значення `i` дорівнює 3, оператор `continue` пропустить решту тіла циклу і перейде до наступної ітерації. У результаті у виводі буде пропущено число 3.

Оператор `break` використовується для переривання виконання циклу. Якщо зустрінеться оператор `break`, виконання циклу буде припинено і відбувається вихід із циклу.

Приклад:

```{python}
for i in range(1, 6):
    if i == 3:
        break
    print(i)
```

У цьому прикладі в циклі `for` ми також перебираємо значення від 1 до 5. Однак, якщо значення `i` дорівнює 3, оператор `break` перериває виконання циклу. У результаті у виводі будуть тільки числа 1 і 2.

Таким чином, оператор `continue` і оператор `break` дають змогу керувати потоком виконання циклів залежно від заданих умов. Ці оператори можуть бути дуже корисними при розв'язанні різних задач на програмування.

Давайте розглянемо приклад їхнього спільного використання:

```{python}
employees = [
    {'name': 'John', 'qualification': 'low'},
    {'name': 'Alice', 'qualification': 'high'},
    {'name': 'Bob', 'qualification': 'medium'},
    {'name': 'Eva', 'qualification': 'low'},
    {'name': 'Mike', 'qualification': 'high'},
    {'name': 'Lisa', 'qualification': 'medium'}
]
found_high_qualification_employee = False
for employee in employees:
    qualification = employee['qualification']
    if qualification == 'low':
        continue # Пропускаємо працівника з низькою кваліфікацією
    elif qualification == 'high':
        found_high_qualification_employee = True
        high_qualification_employee = employee
        break # Знайдено працівника з високою кваліфікацією, припиняємо пошук
if found_high_qualification_employee:
    print("Працівника з високою кваліфікацією знайдено!")
    print(high_qualification_employee)
else:
    print("Працівника з високою кваліфікацією не знайдено.")
```

У цьому прикладі ми створюємо список `employees`, який містить дані про працівників. Потім ми проходимося по кожному працівнику в циклі `for`. Якщо рівень кваліфікації працівника низький (low), ми використовуємо оператор `continue` для пропуску поточного працівника і переходимо до наступного. Якщо рівень кваліфікації працівника високий (high), ми використовуємо оператор `break` для переривання циклу і запису інформації про знайденого працівника. Після виконання циклу ми перевіряємо, чи було знайдено працівника з високою кваліфікацією, і виводимо відповідну інформацію.

## WHILE vs. FOR

`while` і `for` - це два основні типи циклів у мові програмування Python. Цикл `while` виконує набір інструкцій доти, доки вказана умова істинна. Наприклад, якщо вам потрібно виконати певну дію доти, доки користувач не введе правильне значення, ви можете використовувати цикл `while`. Приклад:

```{{python}}
secret_number = 7
guess = 0
while guess != secret_number:
    guess = int(input("Вгадайте число від 1 до 10: "))
print("Вітаю, ви вгадали число!")
```

Цикл `for`, з іншого боку, виконує набір інструкцій для кожного елемента в послідовності (наприклад, рядку, списку, кортежі тощо). Приклад:

```{python}
fruits = ["яблуко", "банан", "груша"]
for fruit in fruits:
    print(fruit)
```

Цикл `while` зазвичай використовується, коли невідома точна кількість повторень, а ви здебільшого покладаєтеся на перевірку умови для зупинки циклу. З іншого боку, цикл `for` зазвичай використовується, коли ви заздалегідь знаєте, скільки разів цикл повинен виконатися, і ви хочете працювати з елементами послідовності.

Вибір між циклом `while` і циклом `for` залежить від специфіки завдання. Якщо у вас є явно певна кількість елементів або потрібно опрацювати кожен елемент у послідовності, то цикл `for` може бути більш зручним вибором. Якщо ж ви чекаєте певної події або хочете повторювати дію до виконання певної умови, то цикл `while` буде більш підходящим.

## Завдання

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-01}
<br>
У змінних `a` і `b` збережено два цілих додатних числа, таких що `a <= b`. Напишіть програму, яка знаходить суму всіх чисел від `a` до `b`, кратних `3` або `5`. Збережіть суму у змінну `result`. Якщо між `a` і `b` немає таких чисел, то збережіть у `result` нуль.

**Приклад:**

```{{python}}
# Приклад 1
a = 1
b = 10
result = 33

# Приклад 2
a = 9
b = 9
result = 9

# Приклад 3
a = 1
b = 2
result = 0
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = 1
b = 10

result = 0
for i in range(a, b + 1):
    if i % 3 == 0 or i % 5 == 0:
        result += i
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-02}
<br>
Напишіть програму на Python, яка визначає, чи є задане число `num` простим.

Якщо `num` - просте число, то збережіть у змінну result рядок `"це просте число"`. Якщо число не просте, то збережіть у змінну `result` рядок `"це не просте число"`.

Використовуйте цикл для розв'язання цієї задачі.

**Приклад:**

```{{python}}
# Приклад 1
num = 7
result = "це просте число"

# Приклад 2
num = 8
result = "це не просте число"
```

::: {.callout-note collapse="true"}
## Підказка

Просте число - це число, яке ділиться тільки на 1 і на саме себе.
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

num = 7

result = "це просте число"
for i in range(2, num):
    if num % i == 0:
        result = "це не просте число"
        break
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-03}
<br>
У змінній `number` збережено число, напишіть код, який перевірить, чи є `number` ступенем двійки? Ряд ступенів двійки:

`1, 2, 4, 8, 16, 32, 64 ...`

Результат перевірки `True` або `False` збережіть у змінну `is_two_power`.

::: {.callout-note collapse="true"}
## Підказка

Просте число - це число, яке ділиться тільки на 1 і на саме себе.
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

number = 64

if number < 1:
    is_two_power = False
elif number == 1:
    is_two_power = True    
else:
    while number % 2 == 0:
        number = number / 2
    is_two_power = number == 1

# або
is_two_power = False
for i in range(1, int(number) + 1):
    if 2 ** i == number or number == 1:
        is_two_power = True
        break
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-04}
<br>
Для приготування однієї порції **еспресо** потрібно приблизно **7 г. меленої кави**. Для приготування **лате** необхідно збити **180 мл. молока** і додати до еспресо, а для приготування **капучино** - **100 мл. молока**.

Задано дві змінні:

- `coffee` - запас меленої кави в кав'ярні (у кілограмах);
- `milk` - запас молока в кав'ярні (у літрах).

Напишіть програму, яка порахує, **скільки відвідувачів** зможе обслужити кав'ярня, якщо відомо, що:
1. У кав'ярні готують три напої на вибір: американо (еспресо + вода), лате і капучино.
2. Кожен відвідувач замовляє тільки один напій.
3. Відомо, що кожен третій замовлений напій - капучино, а кожен п'ятий - лате.
4. Якщо молоко закінчилося, то кав'ярня працює, доки не прийде відвідувач, який бажає замовити каву з молоком.
5. Запас води для американо не обмежений.

Результат збережіть у змінну `visitors`. 

**Не забудьте перевести кілограми в грами, а літри - в мілілітри.**

**Приклад:**

```{{python}}
# Приклад 1
coffee = 0.1
milk = 1
visitors = 14

# Приклад 2
coffee = 0.07
milk = 0.1
visitors = 4
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

coffee = 1
milk = 2

coffee *= 1000
milk *= 1000
visitors = 0
while coffee >=7:
    if (visitors+1) % 3 == 0:
        if milk >=100:
            milk -= 100
            coffee -= 7
            visitors += 1
        else:
            break
    elif (visitors+1) % 5 == 0:
        if milk >= 180:
            milk -= 180
            coffee -= 7
            visitors += 1
        else:
            break
    else:
        coffee -= 7
        visitors += 1

# або
coffee *= 1000
milk *= 1000
visitors = 0
while True:
    if coffee < 7 or ((visitors + 1) % 3 == 0 and milk < 100) or ((visitors + 1) % 5 == 0 and milk < 180):
        break
    visitors += 1
    coffee -= 7
    if visitors % 3 == 0 :
        milk -= 100
    elif visitors % 5 == 0:
        milk -= 180
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-05}
<br>
Дано список чисел `a`.  Напишіть програму, яка поверне `True`, якщо у списку більше непарних чисел, і `False` - у всіх інших випадках. Результат збережіть у `result`. 

**Приклад:**

```{{python}}
# Приклад 1
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
result = True

# Приклад 2
a = [1, 2, 3, 4, 5, 6, 7, 8, 10]
result = False

# Приклад 3
a = [1, 2, 3, 4]
result = False
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

count_odd = 0
count_even = 0
for i in a:
    if i % 2 == 0:
        count_even += 1
    else:
        count_odd += 1

result = count_odd > count_even

# або
result = sum(1 if int(i) % 2 else -1 for i in a) > 0
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-06}
<br>
Є словник `grades`, що містить інформацію про шкільні предмети та їхні оцінки. У список `good_subjects` збережіть назви всіх предметів, у яких оцінка більша або дорівнює 7. 

**Приклад:**

```{{python}}
grades = {"Математика": 9, "Історія": 6, "Біологія": 6, "Географія": 8}
good_subjects = ["Математика", "Географія"]

grades = {"Алгебра": 6, "Геометрія": 6}
good_subjects = []
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

grades = {"Математика": 9, "Історія": 6, "Біологія": 6, "Географія": 8}

good_subjects = []
for subject, grade in grades.items():
    if grade >= 7:
        good_subjects.append(subject)        
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-07}
<br>
Напишіть програму, яка прийматиме список чисел `nums` і повертатиме два числа, абсолютна різниця яких мінімальна. Пару чисел збережіть у змінну `result` у вигляді списку, відсортованого за зростанням.

Якщо кілька пар дають мінімальну абсолютну різницю, виберіть ту пару елементів, сума яких більша.

**Приклад:**

```{{python}}
# Приклад 1
nums = [40, 16, 8, 17, 15]
result = [16, 17]
# пара 16 і 15 не підходить, оскільки сума 16 і 17 більша за

# Приклад 2
nums = [0, 2, 35, 42, 45, 14, -6, -1]
result = [-1, 0]
```

::: {.callout-note collapse="true"}
## Підказка

1. Створіть змінну `min_diff` і збережіть у неї позитивну нескінченність. Це буде змінна зі значенням мінімальної абсолютної різниці. Далі почніть рахувати абсолютну різницю між числами в списку, на кожній ітерації перевіряйте, чи менша поточна різниця, ніж значення у змінній `min_diff`, якщо це так, то зберігайте в `min_diff` поточне значення і продовжуйте пошуки.
2. Запис нескінченності у Python: `float("inf")` [див. @lst-inf].
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

nums = [40, 16, 8, 17, 15]

min_diff = float("inf")
result = []
for i in range(len(nums)):
    for j in range(i + 1, len(nums)):
        diff = abs(nums[i] - nums[j])
        if diff < min_diff:
            min_diff = diff
            result = [nums[i], nums[j]]
        elif diff == min_diff:
            if sum(result) < nums[i] + nums[j]:
                result = [nums[i], nums[j]]

# або
nums.sort() 
min_diff = float('inf')  
result = []
for i in range(len(nums) - 1):
    diff = abs(nums[i] - nums[i+1])  
    if diff < min_diff:
        min_diff = diff
        result = [nums[i], nums[i+1]]
    elif diff == min_diff and sum([nums[i], nums[i+1]]) > sum(result):
        result = [nums[i], nums[i+1]]
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-08}
<br>
Напишіть програму, що приймає у вигляді аргументів два списки `lst_1` і `lst_2` і визначає, чи є вони протилежними один одному. Результат перевірки збережіть у `result` у форматі `True` або `False`.

Кожна пара списків складатиметься з однакових елементів (типу `a` і `b`). Список вважається анти-списком, якщо всі елементи в ньому протилежні відповідним елементам у першому списку.

**Приклад:**

```{{python}}
lst_1 = ["1", "0", "0", "1"]
lst_2 = ["0", "1", "1", "0"]
result = True

lst_1 = ["1", "0", "0", "1"]
lst_2 = ["0", "1", "1", "1"]
result = False
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

lst_1 = ["1", "0", "0", "1"]
lst_2 = ["0", "1", "1", "0"]

result = True
for i in range(len(lst_1)):
    if lst_1[i] == lst_2[i]:
        result = False
        break

# або
result = all({a, b} == set(lst_1) for a, b in zip(lst_1, lst_2))
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-09}
<br>
Задано змінну `m` - список зі списків однакової довжини. Перевірте, що суми елементів на діагоналях рівні.

Результат перевірки збережіть у `result` у форматі `True` або `False`.

**Приклад:**

```{{python}}
# Приклад 1
m = [[1, 23, 4], 
     [3, 2, 1],
     [6, 3, 4]]
result = False

# Приклад 2
m = [[1, 23, 4], 
     [3, 2, 1],
     [1, 3, 4]]
result = True
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

m = [[1, 23, 4], 
     [3, 2, 1],
     [6, 3, 4]]

n = len(m)
main_diagonal_sum = sum(m[i][i] for i in range(n))
secondary_diagonal_sum = sum(m[i][n-i-1] for i in range(n))
result = main_diagonal_sum == secondary_diagonal_sum

# або

result = sum([m[i][i] for i in range(len(m))]) == sum([m[i][len(m[i]) - i - 1] for i in range(len(m))])
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-10}
<br>
Напишіть програму, яка приймає словник `input_dict` і повертає рядок вигляду: `ключ=значення&ключ=значення` 

Рядок має бути лексикографічно відсортований за ключами вихідного словника. Збережіть отриману відповідь у `result`. 

**Приклад:**

```{{python}}
input_dict = {'lesson': 2, 'task': 21, 'course': 'python'}
result = 'course=python&lesson=2&task=21'
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

input_dict = {'lesson': 2, 'task': 21, 'course': 'python'}

result = '&'.join([f'{key}={value}' for key, value in sorted(input_dict.items())])
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-11}
<br>
Напишіть програму, яка приймає один рядок `input_str` і повертає інший `result`, у якому кожна буква вихідного рядка повторюється двічі.

**Приклад:**

```{{python}}
input_str = "String"
result = "SSttrriinngg"
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

input_str = "String"

result = ''.join([char * 2 for char in input_str])
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-11}
<br>
Напишіть програму, яка прийматиме число `n` і перевірятиме, чи кратна кожна його цифра цифрі, що стоїть ліворуч від неї. Відповідь збережіть у `result` у вигляді масиву булевих значень результатів перевірок.

`result` завжди має починатися з `False`, оскільки ліворуч від першої цифри нічого немає. 

**Приклад:**

```{{python}}
n = 54412
result = [False, False, True, False, True]
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

n_str = str(n)
result = [False]
for i in range(1,len(n_str)):
    if int(n_str[i-1]) == 0 or int(n_str[i]) % int(n_str[i-1]) != 0:
        result.append(False)
    else:
        result.append(True)
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-12}
<br>
Уявімо, що ми організовуємо іспит, у нас є список студентів, які мають виступити з усною доповіддю. Для виступу відбираються тільки ті студенти, які набрали понад 90 балів за письмову роботу. Наше завдання зробити так, щоб студенти виступали по черзі, відсортовані за прізвищем.

Наприклад, якщо в нас є учасники Бабак, Андющенко, Власенко, то виступати вони мають у такому порядку: Андющенко, Бабак, Власенко.

У словнику `students` збережено дані про студентів, ключ - прізвище, значення - кількість балів за іспит, створіть список `students_order`, у якому кожен елемент - це кортеж (`tuple`) з номером виступу студента та його прізвищем. У `students_order` мають бути тільки ті студенти, у яких понад 90 балів. Порядок визначається сортуванням за прізвищем.

**Приклад:**

```{{python}}
students = {'Бабак': 80, 'Андющенко': 99, 'Власенко': 100}
students_order = [(1, 'Андющенко'), (2, 'Власенко')]
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

students = {'Бабак': 80, 'Андющенко': 99, 'Власенко': 100}

students_order = [name for name in sorted(students.keys()) if students[name] > 90]
students_order = list(enumerate(students_order, 1))
```

::::
:::::

::::: {.callout-note icon=false}
## 
:::: {#exr-py-loops-13}
<br>
Давайте навчимося розгадувати таємні шифри! У `my_string` зберігається зашифрований рядок, наприклад:

```{{python}}
my_string = 'qircxfcgwxeciscwgwvzlfrciclibecpfvqzg'
```

У словнику `secret_dict` зберігається ключ до шифру, набір символів, які потрібно замінити:

```{{python}}
secret_dict = {
 'b': 'k',
 'c': ' ',
 'g': 'n',
 'q': 'h',
 'z': 'o',
 'v': 't',
 'w': 'a',
 'f': 'y',
 'x': 'm',
 'r': ','}
```

Таким чином, словник `secret_dict` каже нам, що в рядку `my_string` літеру "b" потрібно замінити на "k", "c" на "пробіл" тощо. Якщо ми зробимо такі заміни в рядку `my_string`, то `'qircxfcgwxeciscwggwwvzlfrciclibecpfvvqzg'` перетвориться на `'hi, my name is anatoly, i like python'`.

Напишіть програму, яка розшифровує рядок `my_string` за допомогою словника `secret_dict`. Розшифрований рядок збережіть у змінну `decrypted_string`.

**Приклад:**

```{{python}}
my_string = 'zis jqd qbdx qjjgsd bcd zjm fbc bvbx'
secret_dict = {
'v': 'w',
'x': 'y',
'i': 'h',
'q': 'l',
'c': 'n',
'b': 'a',
'f': 'r',
'j': 'o',
's': 'e',
'z': 't',
'g': 'k'}

decrypted_string = 'the old lady looked and tom ran away'
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

my_string = 'zis jqd qbdx qjjgsd bcd zjm fbc bvbx'
secret_dict = {
'v': 'w',
'x': 'y',
'i': 'h',
'q': 'l',
'c': 'n',
'b': 'a',
'f': 'r',
'j': 'o',
's': 'e',
'z': 't',
'g': 'k'}

decrypted_string = ''
for letter in my_string:
    if letter in secret_dict:
        decrypted_string += secret_dict[letter]
    else:
        decrypted_string += letter
```

::::
:::::