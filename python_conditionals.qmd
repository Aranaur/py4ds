---
engine: knitr
---

# Умовні оператори

**Умовні оператори** - це умовні вирази в Python, а в інших мовах - це здатність задавати питання і відповідати на них, щоб вирішити, чи хочете ви виконати цей рядок коду або інший. Вони дозволяють вам логічно вирішувати проблеми, пов'язані з розгалуженнями у вашому власному коді.

Порівнювати можна і числа, і рядки. Результат порівняння - це `True` або `False`, залежно від того, чи вірний або невірний вираз написано.

## Оператори порівняння

Виявляється, що Python постачається з великою кількістю вбудованого синтаксису. Наприклад, ось лише деякі з символів, які ви можете використовувати у Python, щоб ставити запитання, зокрема математичні. 

Змінні та значення можна порівнювати між собою за допомогою операцій порівняння:

- `x < y`:      `x` строго менше `y`,
- `x <= y`:     `x` менше або дорівнює `y`,
- `x > y`:      `x` строго більше `y`,
- `x >= y`:     `x` більше або дорівнює `y`,
- `x == y `:    `x` дорівнює `y`,
- `x != y`:     `x` не дорівнює `y`.

Для того, щоб ставити запитання з використанням цих символів нам знадобиться ще одне ключове слово в Python. І це ключове слово, досить просто, як і в англійській мові, - `if`. Ви можете задавати питання в Python-коді на кшталт: якщо відповідь на це питання істинна, то виконайте цей код для мене.

Давайте створимо новий файл `compare.py` і спробуємо використати ці оператори порівняння:

```{.bash filename="Terminal"}
code hello.py
```

Наступний код буде порівнювати значення і приймати рішення на основі цих значень:

```{python}
#| eval: false
#| label: compare_eval

x = int(input('Введіть число x: ')) # 1
y = int(input('Введіть число y: ')) # 2

if x < y:
    print('x менше y')
if x > y:
    print('x більше y')
if x == y:
    print('x дорівнює y')
```

```{python}
#| echo: false
#| label: compare_echo

x = 1
y = 2

if x < y:
    print('x менше y')
if x > y:
    print('x більше y')
if x == y:
    print('x дорівнює y')
```

Давайте побудуємо діаграму того, як працює цей код:

```{mermaid}
%%| label: fig-mermaid-1
%%| fig-cap: Діаграма роботи коду з порівняннями
%%| fig-align: center

%%{init:{"theme":"base", "flowchart": {"htmlLabels": true}}}%%

flowchart TB
    A(Початок) --> B{x < y}
    B -- True --> C["'x менше y'"]
    C --> D{x > y}
    B -- False --> D
    D -- True --> E["'x більше y'"]
    E --> F{x == y}
    D -- False --> F
    F -- True --> G["'x дорівнює y'"]
    G --> H(Кінець)
    F -- False --> H
```

За такої конфігурації коду, ми тричі викликаємо ключове слово `if`, щоб задати три різні запитання. Якщо відповідь на запитання є `True`, то виконується код, який знаходиться після нього. Якщо відповідь на запитання є `False`, то код, який знаходиться після нього, не виконується.

Такий код виконує свою задачу, але він не є найкращим. Якщо ви помітите, ми використовуємо три окремі запитання, щоб визначити, яке з двох чисел є більшим. Це можна зробити краще, використовуючи ключове слово `elif`. 

`elif` - це скорочення від `else if`. Це означає, що якщо попередні запитання були `False`, то ви можете задати нове запитання. Якщо відповідь на це запитання є `True`, то виконується код, який знаходиться після нього. Якщо відповідь на це запитання є `False`, то код, який знаходиться після нього, не виконується. Давайте перепишемо наш код з використанням `elif`:

```{python}
#| eval: false
#| label: compare_eval_elif

x = int(input('Введіть число x: ')) # 1
y = int(input('Введіть число y: ')) # 2

if x < y:
    print('x менше y')
elif x > y:
    print('x більше y')
elif x == y:
    print('x дорівнює y')
```

```{python}
#| echo: false
#| label: compare_echo_elif

x = 1
y = 2

if x < y:
    print('x менше y')
elif x > y:
    print('x більше y')
elif x == y:
    print('x дорівнює y')
```

Отже, яке покращення я щойно зробив? Давайте подивимось на діаграму:

```{mermaid}
%%| label: fig-mermaid-2
%%| fig-cap: Діаграма роботи коду з порівняннями з elif
%%| fig-align: center

%%{init:{"theme":"base", "flowchart": {"htmlLabels": true}}}%%

flowchart TB
    A(Початок) --> B{x < y}
    B -- True --> C["'x менше y'"]
    C --> H(Кінець)
    B -- False --> D{x > y}
    D -- True --> E["'x більше y'"]
    E --> H
    D -- False --> F{x == y}
    F -- True --> G["'x дорівнює y'"]
    G --> H
    F -- False --> H
```

Цього разу ми використовуємо три запитання, але якщо відповідь на перше запитання є `True`, то виконується код, який знаходиться після нього, і код, який знаходиться після наступних запитань, не виконується. Якщо відповідь на перше запитання є `False`, то виконується наступне запитання. Якщо відповідь на друге запитання є `True`, то виконується код, який знаходиться після нього, і код, який знаходиться після наступного запитання, не виконується. Якщо відповідь друге це запитання є `False`, то виконується наступне запитання. І так далі. Якщо відповідь на всі запитання є `False`, то жоден код не виконується.

Що це нам дає? Це дає нам можливість задавати багато запитань, але виконувати код лише одного запитання, якщо відповідь на нього є `True`. Це дозволяє нам писати більш читабельний код, а також економити час на виконання коду.

Але, якщо замислитись, то чи є сенс задавати третє, останнє питання `x == y`? Число `x` може бути або меншим за `y`, або більшим за `y`, або дорівнюватиме `y`. Якщо виключити перші два сценарії, то логічно, що `x` має дорівнювати `y`. В таких випадках ми можемо використовувати ключове слово `else` і не перевіряти зайвої умови. Давайте перепишемо наш код з використанням `else`:

```{python}
#| eval: false
#| label: compare_eval_else

x = int(input('Введіть число x: ')) # 1
y = int(input('Введіть число y: ')) # 1

if x < y:
    print('x менше y')
elif x > y:
    print('x більше y')
else:
    print('x дорівнює y')
```

```{python}
#| echo: false
#| label: compare_echo_else

x = 1
y = 1

if x < y:
    print('x менше y')
elif x > y:
    print('x більше y')
else:
    print('x дорівнює y')
```

Давайте подивимось на діаграму:

```{mermaid}
%%| label: fig-mermaid-3
%%| fig-cap: Діаграма роботи коду з порівняннями з else
%%| fig-align: center

%%{init:{"theme":"base", "flowchart": {"htmlLabels": true}}}%%

flowchart TB
    A(Початок) --> B{x < y}
    B -- True --> C["'x менше y'"]
    C --> H(Кінець)
    B -- False --> D{x > y}
    D -- True --> E["'x більше y'"]
    E --> H
    D -- False --> F["'x дорівнює y'"]
    F --> H
```

Ви можете побачити на цих діаграмах відносне зменшення складності програми. Чим менше рядків коду, тим менша ймовірність того, що ви зробите помилку, і тим легше його читати іншим людям. Крім того, такий підхід дозволяє нам економити час на виконання коду, оскільки ми не будемо перевіряти зайві умови.

## Логічні оператори `or`, `and` та `not`

Ви можете використовувати логічні оператори `or`, `and` та `not` для створення більш складних умов. Ці оператори дозволяють вам об'єднувати умови, щоб визначити, чи хочете ви виконати цей рядок коду або інший.

### Логічний оператор `or`

Цього разу перевіримо, чи дорівнює `x` числу `y`. Для цього використаємо оператори `or`:

```{python}
#| eval: false
#| label: compare_eval_or

x = int(input('Введіть число x: ')) # 1
y = int(input('Введіть число y: ')) # 2

if x < y or x > y:
    print('x не дорівнює y')
else:
    print('x дорівнює y')
```

```{python}
#| echo: false
#| label: compare_echo_or

x = 1
y = 2

if x < y or x > y:
    print('x не дорівнює y')
else:
    print('x дорівнює y')
```

Діаграма роботи коду з оператором `or`:

```{mermaid}
%%| label: fig-mermaid-4
%%| fig-cap: Діаграма роботи коду з порівняннями з or
%%| fig-align: center

%%{init:{"theme":"base", "flowchart": {"htmlLabels": true}}}%%

flowchart TB
    A(Початок) --> B{x < y}
    B -- True --> C["'x не дорівнює y'"]
    C --> H(Кінець)
    B -- False --> D{x > y}
    D -- True --> C
    D -- False --> F["'x дорівнює y'"]
    F --> H
```

Чи можемо ми покращити цей код? Так, можемо. Насправді нам не має потреби перевіряти дві умови щодо нерівності `x` та `y`. Значно краще одразу перевірити, чи не дорівнює `x` числу `y`. Для цього ми можемо викорситати оператор заперечення `!=`:

```{python}
#| eval: false
#| label: compare_eval_not

x = int(input('Введіть число x: ')) # 1
y = int(input('Введіть число y: ')) # 2

if x != y:
    print('x не дорівнює y')
else:
    print('x дорівнює y')
```

```{python}
#| echo: false
#| label: compare_echo_not

x = 1
y = 2

if x != y:
    print('x не дорівнює y')
else:
    print('x дорівнює y')
```

Діаграма роботи коду з оператором заперечення `!=`:

```{mermaid}
%%| label: fig-mermaid-5
%%| fig-cap: Діаграма роботи коду з оператором заперечення !=
%%| fig-align: center

%%{init:{"theme":"base", "flowchart": {"htmlLabels": true}}}%%

flowchart TB
    A(Початок) --> B{x != y}
    B -- True --> C["'x не дорівнює y'"]
    C --> H(Кінець)
    B -- False --> D["'x дорівнює y'"]
    D --> H
```

Такий код працює так само, як і попередній, але він є більш читабельним і ефективним.

### Логічний оператор `and`

Давайте розберемо роботу ще одного оператора - `and`. Цей оператор дозволяє нам перевірити, чи виконуються обидві умови. Цього разу я пропоную створити програму `grade.py`, яка буде визначати оцінку студента за його балами:

```{.bash filename="Terminal"}
code grade.py
```
У змінну `score` будемо приймати значення балу. Система оцінювання в різних університетах може дещо відрізнятися, але в цілому вона виглядає так:

- `90 <= score <= 100` - `A`
- `80 <= score < 90` - `B`
- `70 <= score < 80` - `C`
- `66 <= score < 70` - `D`
- `60 <= score < 66` - `E`
- `21 <= score < 60` - `FX`
- `score < 20` - `F`

Давайте напишемо код, який буде визначати оцінку студента за його балами:

```{python}
#| eval: false
#| label: grade_eval

score = int(input('Введіть бал: ')) # 90

if score >= 90 and score <= 100:
    print('Оцінка: A')
elif score >= 80 and score < 90:
    print('Оцінка: B')
elif score >= 70 and score < 80:
    print('Оцінка: C')
elif score >= 66 and score < 70:
    print('Оцінка: D')
elif score >= 60 and score < 66:
    print('Оцінка: E')
elif score >= 21 and score < 60:
    print('Оцінка: FX')
else:
    print('Оцінка: F')
```

```{python}
#| echo: false
#| label: grade_echo

score = 90

if score >= 90 and score <= 100:
    print('Оцінка: A')
elif score >= 80 and score < 90:
    print('Оцінка: B')
elif score >= 70 and score < 80:
    print('Оцінка: C')
elif score >= 66 and score < 70:
    print('Оцінка: D')
elif score >= 60 and score < 66:
    print('Оцінка: E')
elif score >= 21 and score < 60:
    print('Оцінка: FX')
else:
    print('Оцінка: F')
```

Python дозволяє поміняти місцями `score` і відповідний бал при порівнянні. Такий код буде працювати так само, як і попередній:

```{python}
#| eval: false
#| label: grade_eval_swap

score = int(input('Введіть бал: ')) # 80

if 90 <= score and score <= 100:
    print('Оцінка: A')
elif 80 <= score and score < 90:
    print('Оцінка: B')
elif 70 <= score and score < 80:
    print('Оцінка: C')
elif 66 <= score and score < 70:
    print('Оцінка: D')
elif 60 <= score and score < 66:
    print('Оцінка: E')
elif 21 <= score and score < 60:
    print('Оцінка: FX')
else:
    print('Оцінка: F')
```

```{python}
#| echo: false
#| label: grade_echo_swap

score = 80

if 90 <= score and score <= 100:
    print('Оцінка: A')
elif 80 <= score and score < 90:
    print('Оцінка: B')
elif 70 <= score and score < 80:
    print('Оцінка: C')
elif 66 <= score and score < 70:
    print('Оцінка: D')
elif 60 <= score and score < 66:
    print('Оцінка: E')
elif 21 <= score and score < 60:
    print('Оцінка: FX')
else:
    print('Оцінка: F')
```

Крім того, Python дозволяє об'єднувати діапазони порівнянь:

```{python}
#| eval: false
#| label: grade_eval_range

score = int(input('Введіть бал: ')) # 70

if 90 <= score <= 100:
    print('Оцінка: A')
elif 80 <= score < 90:
    print('Оцінка: B')
elif 70 <= score < 80:
    print('Оцінка: C')
elif 66 <= score < 70:
    print('Оцінка: D')
elif 60 <= score < 66:
    print('Оцінка: E')
elif 21 <= score < 60:
    print('Оцінка: FX')
else:
    print('Оцінка: F')
```

```{python}
#| echo: false
#| label: grade_echo_range

score = 70

if 90 <= score <= 100:
    print('Оцінка: A')
elif 80 <= score < 90:
    print('Оцінка: B')
elif 70 <= score < 80:
    print('Оцінка: C')
elif 66 <= score < 70:
    print('Оцінка: D')
elif 60 <= score < 66:
    print('Оцінка: E')
elif 21 <= score < 60:
    print('Оцінка: FX')
else:
    print('Оцінка: F')
```

В даному випадку це здебільшого естетичне покращення, Python все ще виконує ті ж самі порівняння.

Якщо переосмислити логіку, то можна зробити це ще краще. Якщо ми знаємо, що вхідні дані на даний момент будуть в межах від 0 до 100, ми можемо зробити деякі припущення: якщо `score` більше або дорівнює 90, то оцінка буде `A`, після цього ми можемо перевірити, чи `score` більше або дорівнює 80, якщо так, то оцінка буде `B`, і так далі. Це дозволить нам зменшити кількість перевірок, які ми робимо. Давайте перепишемо наш код:

```{python}
#| eval: false
#| label: grade_eval_optimized

score = int(input('Введіть бал: ')) # 70

if score >= 90:
    print('Оцінка: A')
elif score >= 80:
    print('Оцінка: B')
elif score >= 70:
    print('Оцінка: C')
elif score >= 66:
    print('Оцінка: D')
elif score >= 60:
    print('Оцінка: E')
elif score >= 21:
    print('Оцінка: FX')
else:
    print('Оцінка: F')
```

```{python}
#| echo: false
#| label: grade_echo_optimized

score = 70

if score >= 90:
    print('Оцінка: A')
elif score >= 80:
    print('Оцінка: B')
elif score >= 70:
    print('Оцінка: C')
elif score >= 66:
    print('Оцінка: D')
elif score >= 60:
    print('Оцінка: E')
elif score >= 21:
    print('Оцінка: FX')
else:
    print('Оцінка: F')
```

Така невеличка оптимізація дозволяє нам зменшити кількість перевірок і пришвидшити виконання коду.

## Парність та оператор `%`

Давайте розглянемо ще один приклад. Напишемо програму `parity.py`, яка буде перевіряти, чи є число парним:

```{.bash filename="Terminal"}
code parity.py
```

У змінну `x` будемо приймати значення числа. Якщо число ділиться на 2 без остачі, то воно є парним. Давайте напишемо код, який буде перевіряти, чи є число парним:

```{python}
#| eval: false
#| label: parity_eval

x = int(input('Введіть число: ')) # 2

if x % 2 == 0:
    print('Число парне')
else:
    print('Число непарне')
```

```{python}
#| echo: false
#| label: parity_echo

x = 2

if x % 2 == 0:
    print('Число парне')
else:
    print('Число непарне')
```

Як ми можемо покращити цей результат? Згадаймо, що у нас є можливість вигадувати власні функції. Припустимо, що нам потрібно вміти визначати, чи є число парним або непарним. Ми можемо створити функцію `is_even`, яка буде приймати число і повертати `True`, якщо число парне, і `False` в протилежному випадку. Це називається **булевими значеннями** `bool` - один з типів даних в Python. Давайте перепишемо наш код:

```{python}
#| eval: false
#| label: is_even_eval

def main():
    x = int(input('Введіть число: ')) # 2

    if is_even(x):
        print('Число парне')
    else:
        print('Число непарне')

def is_even(n):
    if x % 2 == 0:
        return True
    else:
        return False

main()
```

```{python}
#| echo: false
#| label: is_even_echo

def main():
    x = 2

    if is_even(x):
        print('Число парне')
    else:
        print('Число непарне')

def is_even(n):
    if x % 2 == 0:
        return True
    else:
        return False

main()
```

Чи можемо ми покращити дизайн цього коду? Так, можемо. І я покажу вам дещо, що зараз широко відоме як щось "пітоничне" (англ. *pythonic*) - це спосіб вирішення задачі притаманний мові програмування Python. Замість того, щоб ставити питання `if-else`, використовуючи чотири рядки, в Python ви можете згорнути його в один більш елегантний рядок коду:

```{python}
#| eval: false
#| label: is_even_eval_pythonic

def main():
    x = int(input('Введіть число: ')) # 2

    if is_even(x):
        print('Число парне')
    else:
        print('Число непарне')

def is_even(n):
    return True if n % 2 == 0 else False

main()
```

```{python}
#| echo: false
#| label: is_even_echo_pythonic

def main():
    x = 2

    if is_even(x):
        print('Число парне')
    else:
        print('Число непарне')

def is_even(n):
    return True if n % 2 == 0 else False

main()
```

Згідно з ідеєю не просто писати правильний код, а писати все кращий і кращий код, але при цьому залишати його читабельним, я можу зробити ще кращий варіант: `n % 2 == 0` поверне `True`, якщо `n` парне, і `False` в протилежному випадку. Таким чином, я можу просто повернути результат виразу `n % 2 == 0`:

```{python}
#| eval: false
#| label: is_even_eval_pythonic_short

def main():
    x = int(input('Введіть число: ')) # 2

    if is_even(x):
        print('Число парне')
    else:
        print('Число непарне')

def is_even(n):
    return n % 2 == 0

main()
```

```{python}
#| echo: false
#| label: is_even_echo_pythonic_short

def main():
    x = 2

    if is_even(x):
        print('Число парне')
    else:
        print('Число непарне')

def is_even(n):
    return n % 2 == 0

main()
```

Мабуть, це найелегантніший спосіб реалізувати цю задачу, але він може бути не так очевидним для початківців.

## Оператор зіставлення з шаблонами: `match`

Ключове слово, яке ви можете використовувати в останніх версіях Python, називається `match` - це механізм зіставлення з шаблонами. Це дозволяє вам виконувати дії в залежності від значення змінної.

Створимо програму `house.py`, яка запитує у користувача його ім'я, а потім просто виводить гуртожиток[^house], на якому він навчається у книгах про Гаррі Поттера.

[^house]: В оригіналі використовується слово "house". Я вирішив притримуватись офіційного українського перекладу.

```{.bash filename="Terminal"}
code house.py
```

Для початку у змінну `name` будемо приймати ім'я. Далі за допомогою конструкції `if-elif-else` будемо визначати до якого гуртожитку належить студент. Давайте напишемо код:

```{python}
#| eval: false
#| label: house_eval

name = input('Введіть ім\'я: ') # Драко

if name == 'Гаррі':
    print('Ґрифіндор')
elif name == 'Герміона':
    print('Ґрифіндор')
elif name == 'Рон':
    print('Ґрифіндор')
elif name == 'Драко':
    print('Слизерин')
else:
    print('Хто?')
```

```{python}
#| echo: false
#| label: house_echo

name = 'Драко'

if name == 'Гаррі':
    print('Ґрифіндор')
elif name == 'Герміона':
    print('Ґрифіндор')
elif name == 'Рон':
    print('Ґрифіндор')
elif name == 'Драко':
    print('Слизерин')
else:
    print('Хто?')
```

У цьому коді є певна повторюваність: Гаррі, Герміона та Рон належать до Гріфіндору. Давайте об'єднаємо ці умови в одну:

```{python}
#| eval: false
#| label: house_eval_united

name = input('Введіть ім\'я: ') # Герміона

if name == 'Гаррі' or name == 'Герміона' or name == 'Рон':
    print('Ґрифіндор')
elif name == 'Драко':
    print('Слизерин')
else:
    print('Хто?')
```

```{python}
#| echo: false
#| label: house_echo_united

name = 'Герміона'

if name == 'Гаррі' or name == 'Герміона' or name == 'Рон':
    print('Ґрифіндор')
elif name == 'Драко':
    print('Слизерин')
else:
    print('Хто?')
```

Що ж, виявляється, є ще один підхід, який, можливо, зробить ваш код трохи менш багатослівним. Ви можете уявити, наскільки складним може стати цей код, якщо у нас будуть не тільки Гаррі, Герміона і Рон, але й ціла купа інших імен для Грифіндору, Слизерину і всіх інших гуртожитків Гоґвортсу. Якщо ви хочете зробити це більш елегантним, ви можете використовувати ключове слово `match`:

```{python}
#| eval: false
#| label: house_eval_match

name = input('Введіть ім\'я: ') # Рон

match name:
    case 'Гаррі':
        print('Ґрифіндор')
    case 'Герміона':
        print('Ґрифіндор')
    case 'Рон':
        print('Ґрифіндор')
    case 'Драко':
        print('Слизерин')
    case _:
        print('Хто?')
```

```{python}
#| echo: false
#| label: house_echo_match

name = 'Рон'

match name:
    case 'Гаррі':
        print('Ґрифіндор')
    case 'Герміона':
        print('Ґрифіндор')
    case 'Рон':
        print('Ґрифіндор')
    case 'Драко':
        print('Слизерин')
    case _:
        print('Хто?')
```

Зверніть увагу на те, що я використовую `_` для визначення варіанту за замовчуванням. Це означає, що якщо жоден з варіантів не відповідає значенню `name`, то виконається варіант за замовчуванням. Це дозволяє нам уникнути використання `else` в кінці.

Тепер у нас знову є три оператори `case` для Гаррі, Герміони та Рона. Для об'єднання цих трьох операторів `case` ми можемо використовувати оператор `|`:

```{python}
#| eval: false
#| label: house_eval_match_or

name = input('Введіть ім\'я: ') # Гаррі

match name:
    case 'Гаррі' | 'Герміона' | 'Рон':
        print('Ґрифіндор')
    case 'Драко':
        print('Слизерин')
    case _:
        print('Хто?')
```

```{python}
#| echo: false
#| label: house_echo_match_or

name = 'Гаррі'

match name:
    case 'Гаррі' | 'Герміона' | 'Рон':
        print('Ґрифіндор')
    case 'Драко':
        print('Слизерин')
    case _:
        print('Хто?')
```

Як завжди у випадку з Python і програмуванням загалом, існують різні способи розв'язання цих задач. Це просто ще один інструмент у вашому арсеналі. Можливо, він покращив ситуацію та зробив ваш код більш читабельним.

Варто зазначити, що Вам не потрібен оператор `break` для виходу з `case`, Ви просто використовуєте `_` як паличку-виручалочку в кінці коду.

## Порівняння рядків

Порівняння рядків влаштовано трохи хитріше. Почнемо з простого та розглянемо порівняння двох однакових рядків:

```{python}
print('abc' == 'abc')
```

А якщо записати так:

```{python}
print('abc' > 'abc')
```

Давайте розберемося, чому `'abc' > 'aba'` поверне нам `True`. Порівняння рядків у Python відбувається лексикографічно, тобто посимвольно зліва направо. Якщо символи збігаються, Python переходить до наступного символу в рядку і продовжує порівняти доти, доки не знайде різниця між символами в рядку. Якщо символи в рядках різняться, то Python визначає, який рядок "більше" (за алфавітом, у прямому значенні за номером в алфавіті). Якщо символи до цієї позиції збігаються, то рядок, у якого наступний символ більший, вважається "більшим". При цьому, якщо літери збігаються, то також враховується розмір, маленька літера більша за великий `'a' > 'A'` . Розглянемо приклади:

```{python}
str1 = 'hello'
str2 = 'world'
print(str1 < str2 ) 
```

```{python}
str1 = 'apple'
str2 = 'banana'
print(str1 > str2) 
```

```{python}
str1 = 'abc'
str2 = 'aba'
print(str1 > str2 ) 
```

## Завдання

::::: question
:::: {#exr-py-basic-10}
<br>
Вкажіть усі порівняння, внаслідок яких ми отримаємо `True`.

- [ ] `'ІВАН' < 'іван'`
- [ ] `'Python' < 'R'`
- [ ] `'big number' != 'bug number'`
- [ ] `'ЯЯЯ' == 'Я Я'`
- [ ] `'гірка' >= 'зірка'`

::: {.callout-tip collapse="true"}
## Підказка

Якщо ви сумніваєтеся, виконайте ці порівняння в Python і подивіться на результат.
:::

::: {.callout-tip collapse="true"}
## Правильні відповіді

- [x] `'ІВАН' < 'іван'`: розмір букв відіграє роль при порівнянні, хоч це й однакове слово, але маленький "іван" більше.
- [x] `'Python' < 'R'`: порівняння відбувається за першим символом, `'R'` стоїть в алфавіті правіше, значить `'R' > 'P'`, отримуємо `True`
- [x] `'big number' != 'bug number'`: рядки різняться в одному символі, отримуємо `True`
- [ ] `'ЯЯЯ' == 'Я Я'`: пробіли грають роль при порівнянні, пробіл буде менше будь-якого символу. Отримуємо `False`.
- [ ] `'гірка' >= 'зірка'`: порівняння відбувається за першим символом, `'з'` більше ніж `'г'`, отримуємо `False`
:::

::::
:::::

::::: question
:::: {#exr-py-basic-11}
<br>
У змінній `m` зберігається ціле позитивне число – тривалість сну в хвилинах. Якщо тривалість сну становитиме **від 7 до 9 години включно**, то в змінну `optimal_sleep_duration` збережіть значення `True`. В іншому випадку призначте це змінною значення `False`.

Приклад:
```
m = 410  
optimal_sleep_duration = False

m = 500
optimal_sleep_duration = True
```
```{python}
#| code-fold: true
#| code-summary: "Рішення"

m = 410
optimal_sleep_duration = m / 60 >= 7 and m / 60 <= 9

# або
optimal_sleep_duration = 7 * 60 <= m <= 9 * 60
```

::::
:::::

::::: question
:::: {#exr-py-basic-12}
<br>
У змінній `x` зберігається ціле число. Перевірте, чи це число **ділиться без залишку** на `3` і на `7`. Результат збережіть в змінну `result`. Змінна результат повинен мати **логічний тип даних**.

Приклад: 
- якщо `x = 7`, то `result = False`.
- якщо `x = 21`, то `result = True`.

```{python}
#| code-fold: true
#| code-summary: "Рішення"

x = 21
result = x % 3 == 0 and x % 7 == 0
```

::::
:::::

::::: question
:::: {#exr-py-str-01}
<br>
У змінних `str_1` і `str_2` збережено два рядки. Якщо рядки містять однакові літери, вам потрібно зберегти у змінну `is_the_same_letters` значення `True`, якщо літери в рядках відрізняються - збережіть у змінну значення `False`.

Ми не враховуємо порядок букв, їхню кількість і регістр.

**Приклад:**

```{{python}}
str_1 = 'AaB'
str_2 = 'Ab'
is_the_same_letters = True 

str_1 = 'Aa'
str_2 = 'AaB'
is_the_same_letters = False
```

::: {.callout-tip collapse="true"}
## Підказка

Подивіться, що вийде, якщо застосувати `set` до рядка: `set(str_1)`, як нам може це допомогти з рішенням?
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

str_1 = 'AaB'
str_2 = 'Ab'

is_the_same_letters = set(str_1.lower()) == set(str_2.lower())
```

::::
:::::

::::: question
:::: {#exr-py-str-03}
<br>
Дано два рядки `str_1` і `str_2`. Збережіть у `result` `True`, якщо `str_1` є анаграмою `str_2`, і `False` в іншому випадку. Регістр літер (велика чи маленька буква) не повинен впливати на роботу програми. Тобто `'Літо'` і 'Тіло' 'це валідна анаграма.

Анаграма - це слово або фраза, утворена шляхом перестановки літер іншого слова або фрази, зазвичай з використанням усіх вихідних літер рівно один раз.

**Приклад:**

```{{python}}
str_1 = "Привіт"
str_2 = "Провал"
result = False

str_1 = "Літо"
str_2 = "Тіло"
result = True
```

::: {.callout-tip collapse="true"}
## Підказка

Спробуйте застосувати функцію `sorted()` до рядка.
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

str_1 = "Привіт"
str_2 = "Провал"

result = sorted(str_1.lower()) == sorted(str_2.lower())
```

::::
:::::

::::: question
:::: {#exr-py-if-01}
<br>
У змінних `a` та `b` задано значення довжини та ширини прямокутника відповідно. Перевірте, чи є цей прямокутник квадратом.

Збережіть у змінну `result` значення `True`, якщо це квадрат, інакше `False`. 

**Приклад:**

```{{python}}
# Приклад 1
a = 121 
b = 100 
result = False

# Приклад 2
a = 10 
b = 10 
result = True
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = 121
b = 100
result = a == b

# або
result = True if a == b else False
```

::::
:::::

::::: question
:::: {#exr-py-if-02}
<br>
У змінних `a` і `b` задано два числа. Квадрат якого числа більший? Збережіть це число в `result`.  

**Приклад:**

```{{python}}
# Приклад 1
a = 1 
b = 2 
result = 2

# Приклад 2
a = 2 
b = -3 
result = -3
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = 1
b = 2
result = a if a ** 2 > b ** 2 else b
```

::::
:::::

::::: question
:::: {#exr-py-if-03}
<br>
Катя і Діма вирішили купити квартиру в Києві. Сімейний бюджет обмежений, тому їм підходять такі варіанти:

1. Вартість не більше 1.5 млн, площа не менше 50 квадратних метрів, віддаленість від метро не більше 25 хвилин пішки.
2. Вартість не більше 1.3 млн, площа не менше 35 квадратних метрів, віддаленість від метро не більше 5 хвилин пішки.

Напишіть програму, яка отримує на вхід вартість квартири `p`, площу `s` і віддаленість від метро `d`, і зберігає у змінну `result` повідомлення про те, підходить квартира чи ні у форматі `True` або `False`.

**Приклад:**

```{{python}}
#Приклад 1
p = 1295000 #вартість
s = 32 #площа
d = 13 #віддаленість від метро

result = False

#Приклад 2
p = 1498000 #вартість
s = 51.9 #площа
d = 23 #віддаленість від метро

result = True
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

p = 1295000
s = 32
d = 13

result = (p <= 1500000 and s >= 50 and d <= 25) or (p <= 1300000 and s >= 35 and d <= 5)

# або

if p <= 1500000 and s >= 50 and d <= 25:
    result = True
elif p <= 1300000 and s >= 35 and d <= 5:
    result = True
else: 
    result = False
```

::::
:::::

::::: question
:::: {#exr-py-if-03}
<br>
Катя завершила навчання на курсі Machine Learning і набрала `K` балів за розв'язання задач. Щоб отримати сертифікат про проходження курсу, необхідно набрати щонайменше `M` балів. Якщо Катя набрала від `L` балів, то отримає сертифікат з відзнакою. 

Змінні `K`, `M` і `L` уже визначені. 

Напишіть програму, яка збереже у змінну `result` інформацію про результати проходження курсу в такому форматі:
- `"Недостатньо балів"`, якщо Каті не вистачило балів для отримання сертифіката,
- `"Сертифікат видано"`, якщо Катя набрала кількість балів, необхідну для отримання сертифіката,
- `"Видано сертифікат з відзнакою"`, якщо Катя набрала `≥ L` балів.

**Приклад:**

```{{python}}
# Приклад 1
K = 121 #кількість балів, отриманих Катею
M = 100 #кількість балів, необхідна для отримання сертифіката
L = 150 #кількість балів, необхідна для отримання сертифіката з відзнакою

result = "Сертифікат видано"

# Приклад 2
K = 148 
M = 110 
L = 145 

result = "Видано сертифікат з відзнакою"
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

K = 121
M = 100
L = 150

if K < M:
    result = "Недостатньо балів"
elif K >= L:
    result = "Видано сертифікат з відзнакою"
else:
    result = "Сертифікат видано"
```

::::
:::::

::::: question
:::: {#exr-py-if-04}
<br>
Компанія вирішила виплатити співробітникам премію в розмірі:

- 2 оклади, якщо його стаж роботи ≥ 2 роки
- 5 окладів, якщо стаж роботи ≥ 5 років
- 10 окладів, якщо стаж роботи ≥ 15 років

У змінній `x` - зарплата співробітника, у змінній `y` - стаж. Обчисліть розмір премії, результат збережіть у змінну `result`. 

**Приклад:**

```{{python}}
# Приклад 1
x = 150000
y = 3
result = 300000

# Приклад 2
x = 100000
y = 1
result = 0

# Приклад 3
x = 200000
y = 16
result = 2000000
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

x = 150000
y = 3

if y >= 15:
    result = 10 * x
elif y >= 5:
    result = 5 * x
elif y >= 2:
    result = 2 * x
else:
    result = 0
```

::::
:::::

::::: question
:::: {#exr-py-if-05}
<br>
Дано словник `dict_age`, у якому зберігається інформація про вік трьох братів у форматі:

- ключ - це ім'я
- значення - це вік, число цілих років.

Якщо вік у братів різний і виходить однозначно визначити середнього брата, збережіть ім'я середнього брата у змінну `result`.

Якщо хоча б у двох братів вік однаковий, то збережіть у змінну `result` порожній рядок.

**Приклад:**

```{{python}}
dict_age = {'Антон': 5, 
            'Денис': 14, 
            'Борис': 9}
result = 'Борис'

dict_age = {'Марк': 5, 
            'Авель': 5, 
            'Карп': 9}
result = ''
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

dict_age = {'Антон': 5, 
            'Денис': 14, 
            'Борис': 9}

ages = list(dict_age.values())
if len(set(ages)) == 3:
    middle_index = ages.index(sorted(ages)[1])
    result = list(dict_age.keys())[middle_index]    
else:
    result = ''
```

::::
:::::

::::: question
:::: {#exr-py-if-06}
<br>
Напишіть програму, яка прийматиме довжини сторін трикутника `a`, `b` і `c`, визначатиме, чи є він прямокутним, і зберігатиме результат перевірки в `result` у форматі `True` або `False`. 

- Прямокутний трикутник - це трикутник, у якому один кут прямий (тобто 90 градусів).
- Найдовша сторона (гіпотенуза) не обов'язково буде останнім аргументом.
- Усі аргументи будуть цілими числами.

**Приклад:**

```{{python}}
a = 3
b = 5
c = 4
result = True

a = 70
b = 130
c = 110
result = False
```

::: {.callout-tip collapse="true"}
## Підказка

Пам'ятаєте теорему Піфагора? Квадрат гіпотенузи дорівнює сумі квадратів катетів (двох інших сторін)
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = 3
b = 5
c = 4

if a > b and a > c:
    if a ** 2 == b ** 2 + c ** 2:
        result = True
    else:
        result = False
elif b > a and b > c:
    if b ** 2 == a ** 2 + c ** 2:
        result = True
    else:
        result = False
else:
    if c ** 2 == a ** 2 + b ** 2:
        result = True
    else:
        result = False

# або

values_list = sorted([a, b, c])
if values_list[-1]**2 == values_list[0]**2 + values_list[1]**2:
    result = True
else:
    result = False
```

::::
:::::

::::: question
:::: {#exr-py-if-06}
<br>
Напишіть програму, яка буде вираховувати або довжину кола, або периметр квадрата, виходячи з переданих аргументів.

На вхід подаються буква у змінній `f` і число у змінній `v`.

Буква визначатиме геометричну фігуру:

`'S'` - квадрат
`'С'` - коло

Якщо буквою задано квадрат, то другий аргумент, число `v`, вважається довжиною сторони квадрата. В іншому випадку число вважається радіусом кола.

Результат збережіть у `result`

Число `pi` візьміть рівним `3.14`.

::: {.callout-tip collapse="true"}
## Підказка

Пам'ятаєте теорему Піфагора? Квадрат гіпотенузи дорівнює сумі квадратів катетів (двох інших сторін)
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

f = 'S'
v = 5

if f == 'S':
    result = v * 4
else:
    result = 2 * 3.14 * v
```

::::
:::::