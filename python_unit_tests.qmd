# Модульне тестування

До цього моменту ми писали код, запускаючи програми, вводили вхідні дані, отримували результати і якщо щось йшло не по плану - виправляли це. Набагато краще виробити звичку тестувати власний код, використовуючи інший код. І саме на цьому ми зосередимось і цій частині.

Повернемося до файлу `calculator.py` ([див. @lst-calculator-eval]), який ми використовували для обчислення математичних виразів:


```{python}
#| label: calculator-test-eval
#| eval: false

def main():
    x = int(input('Введіть число: ')) # '2'
    print(f'Число {x} в квадраті дорівнює {square(x)}')

def square(n):
    return pow(n, 2)

main()
```


```{python}
#| label: calculator-test-echo
#| echo: false

def main():
    x = 2
    print(f'Число {x} в квадраті дорівнює {square(x)}')

def square(n):
    return pow(n, 2)

main()
```

Все наче працює, але я не тестував цей код, і не обов'язково, що він повністю працює. Ми повинні протестувати деякі репрезентативні вхідні дані. Але перш ніж ми це зробимо, давайте візьмемо собі за звичку переконуватися, що `main()` не завжди викликається ([див. @lst-name-main]). Тому слід переписати код:

```{python}
#| label: calculator-test-eval-fix
#| eval: false

def main():
    x = int(input('Введіть число: ')) # '2'
    print(f'Число {x} в квадраті дорівнює {square(x)}')

def square(n):
    return pow(n, 2)

if __name__ == '__main__':
    main()
```

Напишемо код, який буде тестувати програму `calculator.py`. Для цього створимо новий файл `test_calculator.py`:

```{.bash filename="Terminal"}
code test_calculator.py
```

Раніше для тестування програм, кожного разу я вводив дані вручну. Це стає незручно. Було б добре, якби я міг автоматично тестувати свою програму знову і знову, за допомогою якогось автоматизованого процесу, що запускає мій власний код. Тож давайте зробимо це. 

Імпортуємо функцію `square` з `calculator.py` та створимо функцію `test_square`, яка буде тестувати функцію `square`. 

```{python}
#| label: calculator-test-square
#| eval: false

from calculator import square

def main():
    test_square()

def test_square():
    if square(2) != 4:
        print('2 у квадраті не дорівнює 4')
    if square(3) != 9:
        print('3 у квадраті не дорівнює 9')
    else:
        print('Все працює')

if __name__ == '__main__':
    main()
```

Тепер запустимо тестування:

```{.bash filename="Terminal"}
python test_calculator.py
```

```{.output}
Все працює
```

Тут мені пощастило, і все працює. Але якщо екстраполювати цей простий приклад не на два тести, а на значно більше, код стане набагато складнішим, ніж сама функція.

## Тестування з використанням `assert`

Існують інші варіанти тестування, які допоможуть нам зробити код більш читабельним. Наприклад, використання функції `assert` - ключовим словом, яке перевіряє, чи є вираз істинним. Якщо вираз істинний, то нічого не відбувається. Але якщо вираз є хибним, то ви отримаєте помилку. Давайте перепишемо функцію `test_square` з використанням `assert`:

```{python}
#| label: calculator-test-square-assert
#| eval: false

from calculator import square

def main():
    test_square()

def test_square():
    assert square(2) == 4
    assert square(3) == 9

if __name__ == '__main__':
    main()
```

