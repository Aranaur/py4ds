<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>sql_basics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="sql_basics_files/libs/clipboard/clipboard.min.js"></script>
<script src="sql_basics_files/libs/quarto-html/quarto.js"></script>
<script src="sql_basics_files/libs/quarto-html/popper.min.js"></script>
<script src="sql_basics_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="sql_basics_files/libs/quarto-html/anchor.min.js"></script>
<link href="sql_basics_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="sql_basics_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="sql_basics_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="sql_basics_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="sql_basics_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Базові запити</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="select" class="level2">
<h2 class="anchored" data-anchor-id="select">SELECT</h2>
<p>Давайте напишемо перший запит мовою SQL:</p>
<pre class="{sql}"><code>#| connection: con

SELECT *
FROM courier_actions
LIMIT 5</code></pre>
<p>Даний запис можна дослівно перекласти:</p>
<ul>
<li><code>SELECT *</code>: “взяти все”.</li>
<li><code>FROM courier_actions</code>: з таблиці <code>courier_actions</code>.</li>
<li><code>LIMIT 10</code>: вивести тільки перші 10 спостережень.</li>
</ul>
<p>Ми можемо написати більш явний запит і отримати той сами результат:</p>
<pre class="{sql}"><code>#| connection: con

SELECT 
    action, 
    courier_id, 
    order_id, 
    time
FROM 
    courier_actions
LIMIT 5</code></pre>
<p>На практиці таблиці можуть бути дуже великими, тому дуже бажано використовувати оператор <code>LIMIT</code> для того щоб не виводити всю таблицю, що може займати багато часу. Крім того, можливо такий запит навіть не буде виконано, оскільки розумні дата інженери заборонили виконувати такі запити.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Оператор <code>FROM</code> завжди вказується після оператора <code>SELECT</code>. У зворотному порядку їх записувати не можна – база даних поверне помилку.</p>
</div>
</div>
</section>
<section id="order-by" class="level2">
<h2 class="anchored" data-anchor-id="order-by">ORDER BY</h2>
<p>Для сортування значень по будь-якій колонці SQL використовується оператор <code>ORDER BY</code> з ключовими словами <code>ASC</code> (за зростанням) або <code>DESC</code> (за спаданням).</p>
<p>При цьому за умовчанням сортування відбувається за зростанням, тобто <code>ASC</code> не обов’язково вказувати. Для сортування за спаданням після <code>ORDER BY</code> необхідно явно вказати <code>DESC</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> column_1           <span class="co">-- сортування за зростанням</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> column_1 <span class="kw">ASC</span>       <span class="co">-- сортування за зростанням</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> column_1 <span class="kw">DESC</span>      <span class="co">-- сортування за спаданням</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="exr-sql01" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 1 </strong></span>Виведіть всі записи з таблиці <code>products</code>, відсортувавши їх за найменуванням товарів <em>у алфавітному порядку</em>, тобто. за зростанням. Для сортування використовуйте оператор <code>ORDER BY</code>.</p>
<p>Поля у результуючій таблиці: <code>product_id</code>, <code>name</code>, <code>price</code></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Сортування можна робити не тільки по полях зі значеннями, вираженими числами, але й по полях, значення яких представлені у вигляді тексту, як у нашому випадку.</p>
</div>
</div>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT product_id,
       name,
       price
FROM   products
ORDER BY name
LIMIT 5</code></pre>
</div>
<p>Сортувати результат SQL-запиту можна відразу за декількома колонками, вказуючи їх після <code>ORDER BY</code> через кому разом із напрямком сортування (<code>ASC</code> або <code>DESC</code>):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> column_1 <span class="kw">DESC</span>, column_2    <span class="co">-- спочатку сортування по першій колонці (за спаданням),</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">-- потім по другій (за зростанням)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Важливо пам’ятати, що при роботі з великими таблицями потрібно по можливості обмежувати кількість виведених записів, щоб не створювати зайве навантаження на базу даних.</p>
</div>
</div>
<p>Оператори <code>ORDER BY</code> та <code>LIMIT</code> можна поєднувати в одному запиті, при цьому оператор <code>LIMIT</code> записується та виконується після оператора <code>ORDER BY</code>, обмежуючи кількість записів у вже відсортованому результаті:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> column_1 <span class="kw">DESC</span>, column_2</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">LIMIT</span> <span class="dv">5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="exr-sql02" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2 </strong></span>Відсортуйте таблицю <code>courier_actions</code> спочатку по колонці <code>courier_id</code> за зростанням id кур’єра, потім по колонці <code>action</code> (знову за зростанням), а потім по колонці <code>time</code>, але вже за спаданням — від останньої дії до першої. Не забудьте включити колонку <code>order_id</code>.</p>
<p>Додайте в запит оператор <code>LIMIT</code> та виведіть лише <strong>перші 1000 рядків</strong> результуючої таблиці.</p>
<p>Поля у результуючій таблиці: <code>courier_id</code>, <code>order_id</code>, <code>action</code>, <code>time</code>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Як ви вже здогадалися, сортувати таблиці можна навіть по полях з датами та часом.</p>
</div>
</div>
<pre class="{sql}"><code>#| connection: con

SELECT courier_id,
       order_id,
       action,
       time
FROM   courier_actions
ORDER BY courier_id, action, time DESC limit 5</code></pre>
</div>
<p>Зараз важливо запам’ятати порядок запису всіх відомих нам ключових слів:</p>
<ol type="1">
<li><code>SELECT</code></li>
<li><code>FROM</code></li>
<li><code>ORDER BY</code></li>
<li><code>LIMIT</code></li>
</ol>
<p>Також важливо зрозуміти, що порядок їх виконання дещо відрізняється від того, в якій послідовності вони вказуються в SQL-запиті:</p>
<ol type="1">
<li>Спочатку виконується оператор <code>FROM</code> – відбувається вибір потрібної таблиці.</li>
<li>Потім <code>SELECT</code> - відбираються вказані стовпці.</li>
<li>Потім <code>ORDER BY</code> - проводиться сортування результуючої таблиці.</li>
<li>І наприкінці <code>LIMIT</code> — обмежується кількість записів, що виводяться.</li>
</ol>
<div id="exr-sql03" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 3 </strong></span>Використовуючи оператори <code>SELECT</code>, <code>FROM</code>, <code>ORDER BY</code> та <code>LIMIT</code>, визначте 5 найдорожчих товарів у таблиці <code>products</code>, які доставляє наш сервіс. Виведіть їх найменування та ціну.</p>
<p>Поля у результуючій таблиці: <code>name</code>, <code>price</code>.</p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT name,
       price
FROM   products
ORDER BY price desc limit 5</code></pre>
</div>
</section>
<section id="as" class="level2">
<h2 class="anchored" data-anchor-id="as">AS</h2>
<p>При складанні SQL-запитів колонкам у результуючій таблиці можна надавати будь-які інші імена (їх ще називають «аліасами»). Це можна робити за допомогою оператора <code>AS</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> name <span class="kw">AS</span> new_name</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Якщо раптом вам здасться, що на написання оператора <code>AS</code> йде занадто багато часу і сил, його можна опустити, вказавши нове ім’я колонки без нього. Наступний запис також спрацює:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> name new_name</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="exr-sql04" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 4 </strong></span>Повторіть запит із з попереднього прикладу (<strong>?@exm-sql03</strong>), але тепер колонки <code>name</code> і <code>price</code> перейменуйте відповідно на <code>product_name</code> і <code>product_price</code>.</p>
<p>Поля у результуючій таблиці: <code>product_name</code>, <code>product_price</code></p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT name AS product_name,
       price AS product_price
FROM   products
ORDER BY price desc limit 5</code></pre>
</div>
</section>
<section id="length" class="level2">
<h2 class="anchored" data-anchor-id="length">LENGTH</h2>
<p>У SQL-запитах до колонок таблиць можна використовувати різні функції, наприклад, як в Excel.</p>
<p>У загальному вигляді синтаксис функцій виглядає приблизно так:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">function</span>(a, b, c, <span class="op">..</span>.)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Замість <code>function</code> вказується назва функції, а дужках — її аргументи. Як аргументи можуть виступати як колонки зі значеннями, так і окремі значення. Залежно від функції кількість аргументів може відрізнятися.</p>
<p>Якщо ви коли-небудь працювали в Excel, то вам, напевно, знайомі різні функції на кшталт <code>SUM</code>, <code>MIN</code>, <code>MAX</code> тощо, які роблять деякі обчислення по стовпцях. У SQL вони називаються <em>агрегуючими функціями</em>.</p>
<p>Зараз як приклад розглянемо функцію <code>LENGTH</code>. Вона виконує досить просте завдання — підраховує кількість символів у поданому їй на вхід значенні текстового типу (текстовий тип даних часто називають рядком — від англ. «string»). Іншими словами, функція <code>LENGTH</code> вимірює довжину деякого рядка у символах:</p>
<pre class="{sql}"><code>#| connection: con

SELECT LENGTH('I.love.Python') as py_love</code></pre>
<p>Функція <code>LENGTH</code> також може застосовуватись до всього стовпця. У такому випадку довжина символів буде порахована для кожного значення в стовпці. Відповідний запит виглядатиме так:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">LENGTH</span>(<span class="kw">column</span>) <span class="kw">AS</span> column_length</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="exr-sql05" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 5 </strong></span>Використовуючи оператори <code>SELECT</code>, <code>FROM</code>, <code>ORDER BY</code> та <code>LIMIT</code>, а також функцію <code>LENGTH</code>, визначте товар із найдовшою назвою у таблиці <code>products</code>. Виведіть його найменування, довжину найменування у символах, а також ціну цього товару. Назвіть колонку з довжиною найменування в символах <code>name_length</code>.</p>
<p>Поля у результуючій таблиці: <code>name</code>, <code>name_length</code>, <code>price</code>.</p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT name,
       length(name) as name_length,
       price
FROM   products
ORDER BY name_length desc limit 1</code></pre>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Зверніть увагу, що в цьому прикладі ви сортуєте результуючу таблицю по розрахунковій колонці <code>name_length</code>, якої спочатку не було таблиці <code>products</code>.</p>
<p>Таке сортування за новими колонками можливе, оскільки це узгоджується з порядком виконання операторів у запиті: спочатку виконується вибір колонок і всі перетворення над ними в операторі <code>SELECT</code> — і тільки потім проводиться сортування за вказаними в <code>ORDER BY</code> стовпчиками. Тобто на момент сортування всі розрахункові поля вже існують, а значить, їх можна вказувати в <code>ORDER BY</code>.</p>
<p>Також зверніть увагу, що ми двічі вказуємо колонку <code>name</code> в операторі <code>SELECT</code>: вперше просто звертаємося до неї за ім’ям, а вдруге - використовуємо її як аргумент функції <code>LENGTH</code>. У цьому випадку теж немає жодних протиріч - ми можемо вибирати колонку стільки разів, скільки необхідно, причому для цього навіть необов’язково надавати цим колонкам різні аліаси (база даних сама перейменує дублікат колонки).</p>
</div>
</div>
</div>
<p>У SQL, як й у багатьох інших мовах, функції можна застосовувати до інших функцій, тобто. послідовно:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> function_one(function_two(a, b), c)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>У наведеній вище конструкції <code>a</code>, <code>b</code>, <code>c</code> аргументи функцій. При цьому одним із аргументів функції <code>function_one</code> є результат виконання функції <code>function_two</code>.</p>
<p>Таким чином, спочатку буде виконана функція <code>function_two</code>, а потім її результат буде поданий на вхід функції <code>function_one</code> як один з аргументів.</p>
<p>Розглянемо такий випадок на прикладі функцій <code>UPPER</code> та <code>LEFT</code>. Функція <code>UPPER</code> наводить подане їй на вхід текстове значення до верхнього регістру:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UPPER</span>(<span class="st">'I.love.Python'</span>) <span class="kw">AS</span> upper_all</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>I.LOVE.PYTHON</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Функція <code>LEFT</code> повертає перші <code>n</code> символів у рядку:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span>(<span class="st">'I.love.Python'</span>, <span class="dv">6</span>) <span class="kw">AS</span> first_n</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>I.love</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ми можемо застосувати ці функції послідовно і в результаті отримаємо перші три символів верхнього регістру:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UPPER</span>(<span class="kw">LEFT</span>(<span class="st">'I.love.Python'</span>, <span class="dv">6</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>I.LOVE</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Caution
</div>
</div>
<div class="callout-body-container callout-body">
<p>Важливо: зверніть увагу, що у блоці <code>SELECT</code> не можна виконати дві операції окремо, тобто. ми не можемо спочатку створити розрахункову колонку з першими шістьма символами, а потім відразу ж звернутися до цієї нової колонки, застосувавши до неї функцію <code>UPPER</code>.</p>
</div>
</div>
<p>Наступний запит не буде виконано, база даних поверне помилку:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span>(<span class="st">'I.love.Python'</span>, <span class="dv">3</span>) <span class="kw">AS</span> first_n,</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UPPER</span>(first_n) <span class="kw">AS</span> upper_first_n</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>Error running <span class="kw">query</span>: <span class="kw">column</span> <span class="ot">"new_name"</span> does <span class="kw">not</span> exist</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>В межах одного запиту колонки створюються не по черзі, а разом, тому в межах одного запиту колонки <code>upper_first_n</code> не існує, поки блок <code>SELECT</code> не буде повністю виконаний. Дуже важливо враховувати цю особливість мови.</p>
<p>Однак на практиці до нових колонок доводиться звертатися досить часто — саме для цього є підзапити (запити до інших запитів). А поки що нам достатньо розуміти, що застосовувати функції до розрахункових колонок у тому ж запиті не можна.</p>
</section>
<section id="split_part" class="level2">
<h2 class="anchored" data-anchor-id="split_part">SPLIT_PART</h2>
<p>Функція <code>SPLIT_PART</code> розбиває поданий їй на вхід рядок на кілька частин відповідно до зазначеного роздільника та повертає одну з частин.</p>
<p>Крім самого рядка (або колонки зі значеннями рядкового типу), функція приймає ще два аргументи — роздільник і порядковий номер частини, яку необхідно повернути. Подивіться наступний приклад:</p>
<div id="exr-sql06" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6 </strong></span>&nbsp;</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> SPLIT_PART(<span class="st">'I.love.Python'</span>, <span class="st">'.'</span>, <span class="dv">3</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>Python</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>У прикладі вище рядок ‘I.love.Python’ було розбито на три частини (‘I’, ‘love’ та ‘Python’) по роздільнику “.”. Функція повернула ‘Python’, оскільки третім аргументом ми вказали частину із порядковим номером 3.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Докладніше з іншими функціями для роботи з рядками можна ознайомитись за <a href="https://duckdb.org/docs/sql/functions/char">посиланням</a>.</p>
</div>
</div>
<div id="exr-sql07" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 7 </strong></span>Застосуйте послідовно функції <code>UPPER</code> та <code>SPLIT_PART</code> до колонки <code>name</code> та перетворіть найменування товарів у таблиці <code>products</code> так, щоб від назв залишилося тільки перше слово, записане у верхньому регістрі. Колонку з новою назвою, що складається із першого слова, назвіть <code>first_word</code>.</p>
<p>У результаті виведіть вихідні найменування товарів, нові найменування з першого слова, а також ціну товарів. Результат відсортуйте за зростанням початкового найменування товару в колонці <code>name</code>.</p>
<p>Поля у результуючій таблиці: <code>name</code>, <code>first_word</code>, <code>price</code></p>
<pre class="{sql}"><code>#| connection: con

SELECT
    name,
    UPPER(SPLIT_PART(name, ' ', 1)) AS first_word,
    price
FROM
    products
ORDER BY
    name</code></pre>
</div>
</section>
<section id="cast" class="level2">
<h2 class="anchored" data-anchor-id="cast">CAST</h2>
<p>Іноді виникає необхідність змінити тип даних у якійсь колонці результуючої таблиці, не змінюючи при цьому властивості вихідної таблиці, наприклад, перетворити число на текст (тип даних <code>VARCHAR</code>). І тому існує функція <code>CAST</code>.</p>
<p>На вхід функції <code>CAST</code> необхідно подати ім’я колонки, вказавши через <code>AS</code> тип даних, до якого потрібно привести всі значення:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">CAST</span>(<span class="kw">column</span> <span class="kw">AS</span> <span class="dt">VARCHAR</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Також можна змінити тип даних за допомогою спеціального синтаксису з двома двокрапками («<code>::</code>»):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">column</span>:<span class="ch">:VARCHAR</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Наприклад, переведемо текст ‘100’ у число 100:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">CAST</span>(<span class="st">'100'</span> <span class="kw">AS</span> <span class="dt">INTEGER</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="dv">100</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Зверніть увагу, що для успішної конвертації значення повинні бути конвертованими у вказаний тип. Наприклад, текст, який не виглядає як число, перевести до числового типу даних не вийде:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">CAST</span>(<span class="st">'text'</span> <span class="kw">AS</span> <span class="dt">INTEGER</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>Error running <span class="kw">query</span>: invalid input syntax <span class="cf">for</span> <span class="kw">type</span> <span class="dt">integer</span>: <span class="ot">"text"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Аналогічним чином можна, наприклад, перетворити текст на дату (якщо він виглядає як дата):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="st">'2022-12-31'</span>:<span class="ch">:DATE</span> <span class="kw">as</span> <span class="dt">date</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="dv">2022</span><span class="op">-</span><span class="dv">12</span><span class="op">-</span><span class="dv">31</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Докладніше з функцією <code>CAST</code> та перетворенням типів даних можна ознайомитись за цим <a href="https://duckdb.org/docs/sql/expressions/cast">посиланням</a>.</p>
<p>Про самі типи даних можна почитати <a href="https://duckdb.org/docs/sql/data_types/overview">тут</a>.</p>
</div>
</div>
<div id="exr-sql08" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 8 </strong></span>Змініть тип колонки <code>price</code> з таблиці <code>products</code> на <code>VARCHAR</code>. Виведіть колонки з найменуванням товарів, ціною у вихідному форматі та ціною у форматі <code>VARCHAR</code>. Нову колонку з ціною у новому форматі назвіть <code>price_char</code>.</p>
<p>Результат відсортуйте за зростанням початкового найменування товару в колонці name. Кількість записів, що виводяться, не обмежуйте.</p>
<p>Поля в результуючій таблиці: <code>name</code>, <code>price</code>, <code>price_char</code></p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT 
    name,
    price,
    CAST(price as VARCHAR) as price_char
FROM
    products
ORDER BY
    name</code></pre>
</div>
</section>
<section id="concat" class="level2">
<h2 class="anchored" data-anchor-id="concat">CONCAT</h2>
<p>У цьому підрозділі ми ще трохи попрацюємо з текстовими даними та розглянемо функцію <code>CONCAT</code>, за допомогою якої можна з’єднувати в один рядок значення кількох стовпців.</p>
<p>Функція <code>CONCAT</code> приймає на вхід кілька аргументів і повертає результат їхньої послідовної складання один з одним. Хороша аналогія - складання речень з різних карток зі словами:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">CONCAT</span>(<span class="st">'SQL'</span>, <span class="st">' '</span>, <span class="st">'Python '</span>, <span class="dv">2023</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>SQL Python <span class="dv">2023</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>При цьому аргументи не обов’язково мають бути виражені текстовими значеннями — головне, вони мають бути конвертованими в текст. У прикладі вище число 2023 можна конвертувати в текст ‘2023’, тому запит працює без помилок.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ознайомитись з іншими прикладами використання функції <code>CONCAT</code> можна за <a href="https://duckdb.org/docs/sql/functions/char">посиланням</a>.</p>
</div>
</div>
<div id="exr-sql09" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9 </strong></span>Для перших 5 записів з таблиці <code>orders</code> виведіть інформацію у такому вигляді (зверніть увагу на пробіли):</p>
<p>Замовлення № [<code>id_замовлення</code>] створено [<code>дата</code>]</p>
<p>Отриману колонку назвіть <code>order_info</code>.</p>
<p>Приклад результату:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>Замовлення № <span class="dv">65</span> створено <span class="dv">2022</span><span class="op">-</span><span class="dv">09</span><span class="op">-</span><span class="dv">01</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT 
    CONCAT(
        'Замовлення № ',
        order_id,
        ' створено ',
        creation_time::DATE
        ) as order_info
FROM   
    orders
LIMIT 5</code></pre>
</div>
</section>
<section id="date_part" class="level2">
<h2 class="anchored" data-anchor-id="date_part">DATE_PART</h2>
<p>Як ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (<code>DATE</code>) і часу (<code>TIMESTAMP</code>). Давайте трохи попрацюємо з такими даними.</p>
<p>Насправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція <code>DATE_PART</code>. Її синтаксис наступний:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> DATE_PART(part, <span class="kw">column</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>На місці <code>part</code> необхідно в лапках вказати ту частину, яку потрібно витягти: <code>'year'</code>, <code>'month'</code>, <code>'day'</code>, <code>'hour'</code> тощо. На місці <code>column</code> слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> DATE_PART(<span class="st">'day'</span>, <span class="dt">DATE</span> <span class="st">'2022-01-12'</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="fl">12.00</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> DATE_PART(<span class="st">'minute'</span>, <span class="dt">TIMESTAMP</span> <span class="st">'2022-01-12 20:31:05'</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="fl">31.00</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Вище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами <code>dates</code>. Тоді запит виглядав би так:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> DATE_PART(<span class="st">'day'</span>, dates)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ознайомитись з іншими прикладами використання функції <code>DATE_PART</code> можна за <a href="https://duckdb.org/docs/sql/functions/timestamptz">посиланням</a>.</p>
</div>
</div>
<div id="exr-sql10" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10 </strong></span>Виведіть id десяти відсотків кур’єрів та їхні роки народження з таблиці <code>couriers</code>, використовуючи вибірку Бернуллі та встановіть початкове значення генератора випадкових величин (<code>seed</code>) рівний 123.</p>
<p>Рік народження необхідно одержати з колонки <code>birth_date</code>. Нову колонку з роком назвіть <code>birth_year</code>.</p>
<p>Поля у результуючій таблиці: <code>courier_id</code>, <code>birth_year</code></p>
<p>У цьому прикладі ми використаємо випадкову вибірки Бернуллі за допомогою оператора <code>USING SAMPLE</code>, після котрого вказується розмір вибірки, а в дужках метод формування та початкове значення генератора випадкових величин.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ознайомитись з прикладами формування вибірок у DuckDB можна за <a href="https://duckdb.org/docs/sql/samples.html">посиланням</a>.</p>
</div>
</div>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT courier_id,
       date_part('year', birth_date) birth_year
FROM   couriers
USING SAMPLE 10 PERCENT (bernoulli, 123)</code></pre>
</div>
</section>
<section id="coalesce" class="level2">
<h2 class="anchored" data-anchor-id="coalesce">COALESCE</h2>
<p>Ви могли помітити, що в минулому прикладі (<strong>?@exm-sql10</strong>) для окремих рядків функція <code>DATE_PART</code> не повернула рік народження кур’єра, а замість них утворилися порожні значення. Якщо не помітили, уважно подивіться на результат запиту.</p>
<p>Насправді це сталося тому, що в наших даних у колонці <code>birth_date</code> є перепустки — так звані значення <code>NULL</code> (у виводі результату це <code>NA</code>). Іншими словами, для окремих кур’єрів просто не вказано їхні дні народження. Є безліч варіантів, чому так могло статися, але ми зараз не маємо часу все це з’ясовувати — нам просто потрібно навчитися якось обробляти такі випадки.</p>
<p>Давайте зробимо так, щоб замість порожніх значень функція <code>DATE_PART</code> повертала якесь інше значення. У цьому нам допоможе функція <code>COALESCE</code>, яка повертає перше не <code>NULL</code> значення зі списку поданих на вхід аргументів.</p>
<p>Роботу <code>COALESCE</code> можна описати так: вона буквально читає список значень зліва направо і, як тільки бачить значення, яке не є <code>NULL</code>, відразу ж повертає його та припиняє читання списку. Подивіться уважно на такі приклади:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">COALESCE</span>(<span class="kw">NULL</span>, <span class="st">'I am not NULL'</span> , <span class="st">'I.love.Python'</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>I am <span class="kw">not</span> <span class="kw">NULL</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">COALESCE</span>(<span class="kw">NULL</span>, <span class="dv">25</span>, <span class="dv">100</span>, <span class="dv">150</span>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="dv">25</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">COALESCE</span>(<span class="st">'NULL'</span>, <span class="st">'I am not NULL'</span>, <span class="st">'I.love.Python'</span>)</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a><span class="kw">NULL</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Одним із аргументів функції <code>COALESCE</code> може бути результат виконання іншої функції:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">COALESCE</span>(<span class="kw">NULL</span>, <span class="fu">LOWER</span>(<span class="st">'I am not NULL'</span>), <span class="st">'I.love.Python'</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>i am <span class="kw">not</span> <span class="kw">null</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Щоб заповнити пропуски в колонці, достатньо застосувати функцію <code>COALESCE</code> до колонки з пропусками та вказати як другий аргумент те значення, яке ми хочемо бачити замість <code>NULL</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">COALESCE</span>(<span class="kw">column</span>, <span class="st">'filler value'</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Функція <code>COALESCE</code> застосовується до кожного значення колонки. Якщо це значення виявиться <code>NULL</code>, вона замінить його значення, вказане другим аргументом. Якщо значення колонці, навпаки, виявиться не <code>NULL</code>, то функція просто поверне це значення.</p>
<p>При цьому до колонки з перепустками можна заздалегідь застосовувати різні інші функції:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">COALESCE</span>(<span class="kw">LEFT</span>(<span class="kw">column</span>, <span class="dv">5</span>), <span class="st">'filler value'</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>З іншими прикладами використання функції <code>COALESCE</code> можна за <a href="https://duckdb.org/docs/sql/functions/utility">посиланням</a>.</p>
</div>
</div>
<div id="exr-sql11" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 11 </strong></span>Як і в попередньому прикладі (<strong>?@exm-sql10</strong>), знову виведіть id десяти відсотків кур’єрів та їх роки народження, тільки тепер до вилученого року застосуйте функцію <code>COALESCE</code>. Вкажіть параметри функції так, щоб замість значення <code>NULL</code> в результат потрапляло текстове значення <code>unknown</code>. Назви полів залиште колишніми.</p>
<p>Поля у результуючій таблиці: <code>courier_id</code>, <code>birth_year</code></p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT
    courier_id,
    COALESCE(date_part('year', birth_date)::VARCHAR, 'unknown') birth_year
FROM
    couriers
USING SAMPLE 10 PERCENT (bernoulli, 123)</code></pre>
</div>
</section>
<section id="арифметичні-оператори" class="level2">
<h2 class="anchored" data-anchor-id="арифметичні-оператори">Арифметичні оператори</h2>
<p>Для роботи з числовими значеннями в <strong>DuckDB</strong> доступны різні арифметичні оператори. Нижче наведена таблиця з найбільш вживаними операторами:</p>
<table class="table">
<thead>
<tr class="header">
<th><strong>Оператор</strong></th>
<th><strong>Опис</strong></th>
<th><strong>Приклад</strong></th>
<th><strong>Результат</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>Додавання</td>
<td>2 + 3</td>
<td>5</td>
</tr>
<tr class="even">
<td>-</td>
<td>Віднімання</td>
<td>2 - 3</td>
<td>-1</td>
</tr>
<tr class="odd">
<td>*</td>
<td>Множення</td>
<td>2 * 3</td>
<td>6</td>
</tr>
<tr class="even">
<td>/</td>
<td>Ділення</td>
<td>4 / 2</td>
<td>2</td>
</tr>
<tr class="odd">
<td>%</td>
<td>Залишок від ділення</td>
<td>5 % 4</td>
<td>1</td>
</tr>
<tr class="even">
<td>^</td>
<td>Піднесення до степеня</td>
<td>2 ^ 3</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>Якби ми захотіли перевести 7600 гривен у долари за курсом 1 долар = 40 гривень, то операція виглядала б так:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="dv">7500</span> <span class="op">/</span> <span class="dv">40</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="dv">190</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Якби нам потрібно було відняти з кожного значення в одній із колонок нашої таблиці якесь число (наприклад, 100), то запит виглядав би так:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">column</span> <span class="op">-</span> <span class="dv">100</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Крім того, в арифметичних операціях можуть брати участь одразу кілька колонок. Наприклад, для кожного рядка таблиці можна обчислити середнє арифметичне двох чисел, які містяться у двох різних колонках:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> (column_1 <span class="op">+</span> column_2) <span class="op">/</span> <span class="dv">2</span> <span class="kw">AS</span> average</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ознайомитись з усіма арифметичними операторами можна за <a href="https://duckdb.org/docs/sql/functions/numeric.html#numeric-operators">посиланням</a>.</p>
</div>
</div>
<div id="exr-sql12" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 12 </strong></span>Давайте уявимо, що з якоїсь незрозумілої причини ми раптом вирішили відразу підвищити ціну всіх товарів у таблиці <code>products</code> на <strong>5%</strong>.</p>
<p>Виведіть id та найменування всіх товарів, їх стару та нову ціну. Колонку зі старою ціною назвіть <code>old_price</code>, а колонку з новою – <code>new_price</code>.</p>
<p>Результат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.</p>
<p>Поля в результуючій таблиці: <code>product_id</code>, <code>name</code>, <code>old_price</code>, <code>new_price</code>.</p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT 
    product_id,
    name,
    price as old_price,
    price * 1.05 as new_price
FROM
    products
ORDER BY
    new_price DESC, product_id</code></pre>
</div>
</section>
<section id="математичні-функції" class="level2">
<h2 class="anchored" data-anchor-id="математичні-функції">Математичні функції</h2>
<p>Поряд з арифметичними операторами <strong>DuckDB</strong> також доступні різні математичні функції. Наприклад, для округлення чисел можна використовувати функцію <code>ROUND</code>:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">ROUND</span>(<span class="fl">100.5454</span>, <span class="dv">2</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="fl">100.55</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">ROUND</span>(<span class="fl">100.551</span>, <span class="dv">1</span>)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="fl">100.6</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">ROUND</span>(<span class="fl">100.5511</span>)</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>Результат:</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a><span class="fl">101.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Першим аргументом вказується саме значення, яке хочемо округлити. Другим число знаків після точки, до якої хочемо округлити. Другий аргумент вказувати не обов’язково: якщо його не вказати, відбудеться округлення до цілого числа (проте тип даних при цьому не зміниться).</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Ознайомитись з усіма арифметичними операторами можна за <a href="https://duckdb.org/docs/sql/functions/numeric.html#numeric-functions">посиланням</a>.</p>
</div>
</div>
<div id="exr-sql13" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 13 </strong></span>Знову, як і в минулому завданні (<strong>?@exm-sql12</strong>), підвищите ціну всіх товарів на 5%, тільки тепер до колонки з новою ціною застосуйте функцію <code>ROUND</code>. Виведіть id та найменування товарів, їх стару ціну, а також нову ціну із округленням. Нову ціну округліть до десятих, але тип даних не змінюйте.</p>
<p>Результат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.</p>
<p>Поля в результуючій таблиці: <code>product_id</code>, <code>name</code>, <code>old_price</code>, <code>new_price</code>.</p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT 
    product_id,
    name,
    price as old_price,
    ROUND(price * 1.05, 1) as new_price
FROM
    products
ORDER BY
    new_price DESC, product_id</code></pre>
</div>
</section>
<section id="case" class="level2">
<h2 class="anchored" data-anchor-id="case">CASE</h2>
<p>А якби ми захотіли підвищити ціну не на всі товари, а, скажімо, тільки на дорогі?</p>
<p>Для цього нам потрібно було б створити деяку функцію, яка перевіряла б кожне значення в колонці <code>price</code> і порівнювала б його з якимось пороговим значенням. Якби ціна виявлялася вищою за цей поріг, то функція підвищувала б ціну, а якщо ні — залишала б без змін.</p>
<p>І таку функцію можна задати за допомогою умовної конструкції <code>CASE</code>. Вона має наступний синтаксис:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="cf">CASE</span>  </span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="cf">WHEN</span> logical_expression_1 <span class="cf">THEN</span> expression_1</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="cf">WHEN</span> logical_expression_2 <span class="cf">THEN</span> expression_2</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="op">..</span>.</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="cf">ELSE</span> expression_else</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span> <span class="kw">AS</span> case_example</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ця конструкція може бути громіздкою, але насправді в ній немає нічого складного. Логіка роботи оператора <code>CASE</code> досить проста:</p>
<ol type="1">
<li>На кожному етапі <code>WHEN - THEN</code> обчислюється деякий логічний вираз <code>logical_expression</code>, що стоїть після <code>WHEN</code>. Якщо воно виявляється істинним (<code>TRUE</code>), то в якості результату оператор повертає вираз <code>expression</code>, що стоїть після <code>THEN</code>, і закінчує свою роботу.</li>
<li>Якщо вираз виявляється помилковим (<code>FALSE</code>), то оператор продовжує роботу та перевіряє наступну умову.</li>
<li>Якщо жодна з умов не проходить перевірку на істинність, повертається вираз, вказаний після <code>ELSE</code>. При цьому <code>ELSE</code> вказувати не обов’язково - якщо його не вказати, то повернеться порожнє значення <code>NULL</code> (у разі, якщо всі перевірки після <code>WHEN</code> виявилися помилковими).</li>
<li>Насамкінець обов’язково вказується ключове слово <code>END</code>, яке говорить про закінчення конструкції <code>CASE</code>. Також після <code>END</code> новому розрахунковому полю за допомогою <code>AS</code> можна надати деяке ім’я, але це робити не обов’язково. Обов’язковими є лише ключові слова <code>CASE</code>, <code>WHEN</code>, <code>THEN</code> та <code>END</code>.</li>
</ol>
<p>Наступна конструкція розіб’є весь список найменувань на три категорії: «м’ясо», «риба» та «інше». Відповідно, якщо у перших двох умовах ми не врахуємо якісь назви з колонки <code>name</code> (наприклад, «телятину»), то вони потраплять до категорії «інше».</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> name,</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>       <span class="cf">CASE</span> </span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>       <span class="cf">WHEN</span> name<span class="op">=</span><span class="st">'свинина'</span> <span class="kw">OR</span> name<span class="op">=</span><span class="st">'баранина'</span> <span class="kw">OR</span> name<span class="op">=</span><span class="st">'курка'</span> <span class="cf">THEN</span> <span class="ot">"м'ясо"</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">WHEN</span> name<span class="op">=</span><span class="st">'тріска'</span> <span class="kw">OR</span> name<span class="op">=</span><span class="st">'форель'</span> <span class="kw">OR</span> name<span class="op">=</span><span class="st">'окунь'</span> <span class="cf">THEN</span> <span class="st">'риба'</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>       <span class="cf">ELSE</span> <span class="st">'інше'</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">END</span> <span class="kw">AS</span> сategory</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> <span class="kw">table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Тепер трохи про логічні вирази: SQL можуть включати <em>оператори порівняння</em> і <em>логічні операції</em>.</p>
<p>До <strong>операторів порівняння</strong> належать:</p>
<ul>
<li><code>=</code> («рівно»)</li>
<li><code>&lt;&gt;</code> або <code>!=</code> («не дорівнює»)</li>
<li><code>&lt;</code> («менше»)</li>
<li><code>&gt;</code> («більше»)</li>
<li><code>&lt;=</code> («менше або дорівнює»)</li>
<li><code>&gt;=</code> («більше чи дорівнює»)</li>
</ul>
<p>Результатом роботи операторів порівняння можуть бути три стани:</p>
<ul>
<li><code>TRUE</code> («істина»)</li>
<li><code>FALSE</code> (помилка)</li>
<li><code>NULL</code> («невизначений стан» - коли одне з порівнюваних значень <code>NULL</code>)</li>
</ul>
<p>З цими трьома станами можна проводити такі логічні операції:</p>
<ul>
<li><code>AND</code> («І»)</li>
<li><code>OR</code> («АБО»)</li>
<li><code>NOT</code> («НЕ»)</li>
</ul>
<p>Результатом цих логічних операцій також можуть бути три вищевказані логічні стани (<code>TRUE</code>, <code>FALSE</code> або <code>NULL</code>):</p>
<table class="table">
<thead>
<tr class="header">
<th><code>a</code></th>
<th><code>b</code></th>
<th><code>a AND b</code></th>
<th><code>a OR b</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TRUE</td>
<td>TRUE</td>
<td>TRUE</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>TRUE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>TRUE</td>
</tr>
<tr class="odd">
<td>TRUE</td>
<td>NULL</td>
<td>NULL</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
<tr class="odd">
<td>FALSE</td>
<td>NULL</td>
<td>FALSE</td>
<td>NULL</td>
</tr>
<tr class="even">
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<table class="table">
<thead>
<tr class="header">
<th><code>a</code></th>
<th><code>NOT a</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TRUE</td>
<td>FALSE</td>
</tr>
<tr class="even">
<td>FALSE</td>
<td>TRUE</td>
</tr>
<tr class="odd">
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<p>Таким чином, оператори порівняння та логічні операції дозволяють писати комплексні логічні вирази.</p>
<p>Запам’ятати всі ці таблиці та комбінації не обов’язково. Головне, завжди тримайте цю пам’ятку під рукою.</p>
<p>Припустимо, відомо, що <span class="math inline">\(a=10\)</span> і <span class="math inline">\(b=5\)</span>. Тоді наступний логічний вираз поверне <code>TRUE</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ex">a</span> <span class="op">&gt;</span>= 10 OR b <span class="op">&gt;</span> 10</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Також важливо розуміти, що є пріоритети виконання операцій:</p>
<ol type="1">
<li>множення та поділ (<code>*</code> та <code>/</code>)</li>
<li>додавання та віднімання (<code>+</code> та <code>-</code>)</li>
<li>оператори порівняння (<code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>)</li>
<li><code>NOT</code></li>
<li><code>AND</code></li>
<li><code>OR</code></li>
</ol>
<p>На порядок виконання операторів можна також впливати за допомогою дужок. Вирази, поміщені в дужки, матимуть найвищий пріоритет — як у математиці.</p>
<div id="exr-sql14" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 14 </strong></span>Підвищіть ціну на <strong>5%</strong> тільки на товари, вартість яких <strong>перевищує 100 одиниць</strong>. Ціну решти товарів залиште без змін. Також <strong>не підвищуйте ціну на ікру</strong> <em>(caviar)</em>, яка й так коштує <strong>800 одиниць</strong>. Виведіть id та найменування всіх товарів, їх стару та нову ціну. Ціну округляти не потрібно.</p>
<p>Результат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.</p>
<p>Поля в результуючій таблиці: <code>product_id</code>, <code>name</code>, <code>old_price</code>, <code>new_price</code></p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT 
    product_id,
    name,
    price as old_price,
    CASE
    WHEN price &lt;= 100 or name = 'caviar' THEN price
    ELSE price * 1.05
    END AS new_price
FROM
    products
ORDER BY
    new_price DESC, product_id</code></pre>
</div>
<p>Уявіть, що до вас звернувся менеджер із сусіднього відділу із проханням порахувати ПДВ кожного товару. Жодних додаткових даних він вам не надав, тому ви вирішили виконати завдання на власний розсуд, вважаючи, що ПДВ єдиний для всіх товарів і становить 20%.</p>
<div id="exr-sql15" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 15 </strong></span>Обчисліть ПДВ кожного товару у таблиці <code>products</code> та розрахуйте ціну без урахування ПДВ. Виведіть всю інформацію про товари, включаючи суму податку та ціну без його врахування. Колонки із сумою податку та ціною без ПДВ назвіть відповідно <code>tax</code> та <code>price_before_tax</code>. Округліть значення у цих колонках <strong>до двох знаків після коми</strong>.</p>
<p>Результат відсортуйте спочатку за спаданням ціни товару без урахування ПДВ, потім за зростанням id товару.</p>
<p>Поля в результуючій таблиці: <code>product_id</code>, <code>name</code>, <code>price</code>, <code>tax</code>, <code>price_before_tax</code>.</p>
<p><strong>Рішення:</strong></p>
<pre class="{sql}"><code>#| connection: con

SELECT 
    product_id,
    name,
    price,
    ROUND((price * 0.2) / 1.2, 2) as tax,
    ROUND(price / 1.2, 2) as price_before_tax
FROM
    products
ORDER BY
    price_before_tax DESC, product_id</code></pre>
</div>
</section>
<section id="типові-помилки-при-написанні-sql-запитів." class="level2">
<h2 class="anchored" data-anchor-id="типові-помилки-при-написанні-sql-запитів.">Типові помилки при написанні SQL-запитів.</h2>
<ul>
<li>Неправильний порядок або помилки у ключових словах. Правильний порядок операторів у запиті виглядає так:</li>
</ul>
<div class="sourceCode" id="cb52"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span>      <span class="co">-- перерахування полів результуючої таблиці</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span>        <span class="co">-- вказівка джерела даних</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span>       <span class="co">-- фільтрація даних</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span>    <span class="co">-- угруповання даних</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="kw">HAVING</span>      <span class="co">-- фільтрація даних після угруповання</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span>    <span class="co">-- сортування результуючої таблиці</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="kw">LIMIT</span>       <span class="co">-- обмеження кількості записів, що виводяться</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Неправильно названі функції та оператори, що використовуються в запиті (наприклад, <code>DATEPART</code>, а не <code>DATE_PART</code>).</li>
<li>Неправильно вказано імена стовпців.</li>
<li>Неправильно виконано сортування записів.</li>
<li>Неправильно проведено розрахунки.</li>
<li>Пропущена кома при перерахуванні стовпців у <code>SELECT</code></li>
<li>Зайва кома після імені останнього стовпця в <code>SELECT</code></li>
<li>Не закриті дужки (перевірте, що кількість дужок дорівнює кількості закривають).</li>
<li>Допущено помилку в підзапиті (перед виконанням всього запиту перевірте, чи працюють окремі підзапити).</li>
<li>Запущено відразу кілька запитів, не розділених крапкою з комою.</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>