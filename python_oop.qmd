# Об'єктно-орієнтоване програмування

У світі програмування існують різні парадигми мов програмування - різні способи вирішення проблем за допомогою коду. Це трохи важко побачити спочатку, якщо ви вивчили лише одну мову. Але з часом, якщо і коли ви вивчите інші мови, окрім Python, ви почнете помічати певні закономірності і певні можливості одних мов, але не інших. Досі у світі Python ми з вами здебільшого писали процедурний код, тобто писали процедури, писали функції і робили все зверху донизу. Все відбувається крок за кроком, як і можна було б очікувати від алгоритму. Але на цьому шляху ми спробували ще одну парадигму, відому як *функціональне програмування* за допомогою Python, завдяки якій ми змогли передавати функції по колу.

Цього разу ми зосередимося на іншій парадигмі, і розглянемо її більш детально, а саме на **об'єктно-орієнтованому програмуванні (ООП)**. Можливо дехто з вас вже мали досвід програмування і вивчали такі мови, як Java, які за своєю суттю є об'єктно-орієнтованими, Python дійсно дозволяє вам бути більш гнучкими, коли мова йде про те, як ви вирішуєте проблеми за допомогою коду. Але виявляється, що ООП, об'єктно-орієнтоване програмування, є досить переконливим рішенням проблем, з якими ви незмінно стикаєтесь, коли ваші програми стають довшими, більшими та складнішими. 

## Використання структур даних

### Кортежі

Почнемо з простого прикладу і потрошку будемо додавати все нові і нові функції. Подивимось, чи не призведе це до труднощів. 

Для початку створимо програму `student.py`, яка буде приймати ім'я та гуртожиток студента у світі Гарі Поттера:

```{.bash filename="Terminal"}
code student.py
```

```{python}
#| label: student-py
#| eval: false

name = input("Ім'я: ")
house = input("Гуртожиток: ")

print(f"{name} з {house}")
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Грифіндор

Гаррі з Грифіндор
```

Раніше ми навчилися використовувати власні функції. Використаємо функціональний підхід і створимо функції `get_name()` та `get_house()`, які будуть повертати ім'я та гуртожиток студента відповідно:

```{python}
#| label: student-py-2
#| eval: false

def main():
    name = get_name()
    house = get_house()
    print(f"{name} з {house}")

def get_name():
    return input("Ім'я: ")

def get_house():
    return input("Гуртожиток: ")

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Грифіндор

Гаррі з Грифіндор
```

Розвиваючи та узагальнюючи цей код, мо можемо створити функцію `get_student()`, яка буде повертати ім'я та гуртожиток студента:

```{python}
#| label: student-py-3
#| eval: false

def main():
    name, house = get_student()
    print(f"{name} з {house}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return name, house # це одне значення, якє є кортежем

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Грифіндор

Гаррі з Грифіндор
```

Насправді, коли ми повертаємо значення з функції, ми повертаємо кортеж (англ. *tuple*) - один з типів даних Python, який дуже схожий на список, але він **не може бути змінений**. Це означає, що ми можемо використовувати кортежі, якщо ми хочемо повернути кілька значень з функції. І навіть записати їх у дужках, що інтуїтивно буде вказувати на використання кортежу: `return (name, house)`.

Ми можемо не розпаковувати кортеж в окремі змінні, а замість цього використовувати індексацію, щоб отримати доступ до значень у кортежі:

```{python}
#| label: student-py-4
#| eval: false

def main():
    student = get_student()
    print(f"{student[0]} з {student[1]}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return name, house

if __name__ == "__main__":
    main()
```

Для демонстрації незмінності кортежів, спробуємо змінити значення у кортежі через умовні оператори, для цього введемо умову, що якщо ім'я студента - Падма, то змінимо її гуртожиток на Рейвенкло:

```{python}
#| label: student-py-5
#| eval: false

def main():
    student = get_student()
    if student[0] == "Падма":
        student[1] = "Рейвенклов"
    print(f"{student[0]} з {student[1]}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return (name, house)

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Падма
Гуртожиток: Грифіндор

TypeError: 'tuple' object does not support item assignment
```

Якщо ми передбачаємо можливість змінити значення у кортежі, то ми можемо використати список замість кортежу: `return [name, house]`: 

```{python}
#| label: student-py-6
#| eval: false

def main():
    student = get_student()
    if student[0] == "Падма":
        student[1] = "Рейвенклов"
    print(f"{student[0]} з {student[1]}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return [name, house]

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Падма
Гуртожиток: Грифіндор

Падма з Рейвенклов
```

### Словники

Задачу з введенням ім'я та гуртожитку можна вирішити через словник:

```{python}
#| label: student-py-7
#| eval: false

def main():
    student = get_student()
    print(f"{student['name']} з {student['house']}")

def get_student():
    student = {}
    student['name'] = input("Ім'я: ")
    student['house'] = input("Гуртожиток: ")
    return student

if __name__ == "__main__":
    main()
```

Нам не обов'язково створювати пустий словник, ми можемо одразу повертати словник з ім'ям та гуртожитком:

```{python}
#| label: student-py-8
#| eval: false

def main():
    student = get_student()
    print(f"{student['name']} з {student['house']}")

def get_student():
    return {
        'name': input("Ім'я: "),
        'house': input("Гуртожиток: ")
    }

if __name__ == "__main__":
    main()
```

Якщо ми захочемо враховувати можливість змінити гуртожиток, якщо ім'я студента - Падма, то ми можемо використати умовний оператор:

```{python}
#| label: student-py-9
#| eval: false

def main():
    student = get_student()
    if student['name'] == "Падма":
        student['house'] = "Рейвенклов"
    print(f"{student['name']} з {student['house']}")

def get_student():
    return {
        'name': input("Ім'я: "),
        'house': input("Гуртожиток: ")
    }

if __name__ == "__main__":
    main()
```

На невеликих прикладах все виглядає досить просто. Уявіть, що в перспективі з'явиться необхідність додати більше інформації про студента: патронус, магічні здібності, тощо. Було б значно зручніше, якби Python дозволяв нам створювати власні типи даних, які могли б містити інформацію про студента. І це можливо завдяки об'єктно-орієнтованому програмуванню.

## Класи

**Класи** (англ. *classes*) - це щось на зразок шаблону, який дозволяє створювати власні типи даних, давати їм імена.

Для створення класу використовується ключове слово `class`, за яким слідує ім'я класу, а потім двокрапка. Ім'я класу повинно починатися з великої літери, а якщо ім'я складається з декількох слів, то кожне слово повинно починатися з великої літери. Наприклад, `Student`: 

```{python}
#| label: student-class-1
#| eval: false

class Student:
    pass
```

Для того, щоб наша програма почала використовувати клас, ми повинні створити екземпляр класу, тобто об'єкт. Це можна зробити, використовуючи ім'я класу, за яким слідує дужка. Наприклад, `Student()`.

Класи мають **атрибути** (англ. *attributes*), свого роду властивості, які дозволяють вам вказувати значення всередині них. Для того, щоб вказати атрибут, використовується крапка, за якою слідує ім'я атрибуту. Наприклад, `student.name`:

```{python}
#| label: student-class-2
#| eval: false

class Student:
    pass
    
def main():
    student = get_student()
    print(f"{student.name} з {student.house}")

def get_student():
    student = Student()
    student.name = input("Ім'я: ")
    student.house = input("Гуртожиток: ")
    return student

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Грифіндор

Гаррі з Грифіндор
```




::: {.callout-note}
Документація до класів Python: <https://docs.python.org/3/tutorial/classes.html>
:::