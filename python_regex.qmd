# Регулярні вирази

**Регулярні вирази** (англ. *regular expressions*, *regexes*) - це патерни, які використовуються для знаходження певних комбінацій символів у тексті. Наприклад, якщо користувач вводить адресу електронної пошти у вашій програмі, на веб-сайті або в додатку на телефоні, в ідеалі ви хочете мати можливість перевірити, що він дійсно ввів адресу електронної пошти, а не щось інше. Використовуючи регулярні вирази, ми можемо перевірити, чи відповідає введений текст певному формату. Це дуже корисно, оскільки ви можете використовувати регулярні вирази для перевірки введення користувача, або для пошуку певних комбінацій символів у тексті.

Вони дуже потужні, але в той же час достатньо складні. Якщо ви вперше з ними зіткнулися, то вони здаються дуже незрозумілими. Але якщо ви вже з ними працювали, то ви не зможете без них.

Для початку розглянемо декілька задач і спробуємо їх вирішити використовуючи більш простий синтаксис, і подивитися, з якими обмеженнями ми зіткнемося.

Створимо файл `validate.py` метою якого є перевірка адреси електронної пошти користувача.

```{.bash filename="Terminal"}
code validate.py
```

Напишемо просту програму, яка буде приймати від користувача адресу електронної пошти і перевіряти, чи вона відповідає певному формату. Одразу використаємо метод `strip()` для видалення зайвих пробілів з початку і кінця рядка. Але як перевірити, що введене значення дійсно є валідним для електронної пошти? Перша ідея, яка з'являється - це перевірити, чи введений текст містить символ `@`. Якщо так, то ми можемо припустити, що це адреса електронної пошти. Давайте спробуємо це зробити:

```{python}
#| label: validate-eval-at
#| eval: false

email = input("Введіть email: ").strip()

if "@" in email:
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти
```

Зрозуміло, що така програма не є ідеальною, оскільки ми можемо ввести тільки один або декілька символів `@` і програма буде пропускати такі випадки.

Наступна ідея - це додати додаткову перевірку, що введений текст містить символ `.`. Якщо так, то ми можемо припустити, що це адреса електронної пошти. Давайте спробуємо це зробити:

```{python}
#| label: validate-eval-dot
#| eval: false

email = input("Введіть email: ").strip()

if "@" in email and "." in email:
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти
```

Програма все ще не ідеальна. Давайте припустимо, що крапка може бути тільки після символа `@`. Для цього ми можемо поділити введений рядок на дві частини, використовуючи метод `split()` і перевірити, що друга частина містить крапку. Давайте спробуємо це зробити:

```{python}
#| label: validate-eval-split
#| eval: false

email = input("Введіть email: ").strip()

username, domain = email.split("@")

if username and "." in domain:
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Невалідна адреса електронної пошти
```

Тепер давайте звузимо сферу застосування цієї програми і будемо шукати валідні адреси українських навчальних закладів, які мають домен `.edu`. Для цього ми можемо використати метод `endswith()`:

```{python}
#| label: validate-eval-endswith
#| eval: false

email = input("Введіть email: ").strip()

username, domain = email.split("@")

if username and domain.endswith(".edu"):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти

python validate.py
Введіть email: potter@.hogwarts.edu
Валідна адреса електронної пошти
```

Ми можемо продовжувати роботу над цією програмою. В кінцевому підсумку нам доведеться писати багато коду, просто щоб валідувати адресу електронної пошти.

## Бібліотека `re`

В Python є бібліотека для регулярних виразів, яка лаконічно називається `re`. В ній є багато можливостей для визначення, перевірки і заміни шаблонів.

::: {.callout-note}
Документація до бібліотеки `re` доступна за посиланням <https://docs.python.org/3/library/re.html>.
:::

Почнемо з однієї з найбільш універсальних функцій пошуку:

`re.search(pattern, string, flags=0)`:

-  `pattern` - регулярний вираз, який ми шукаємо
-  `string` - рядок, в якому ми шукаємо
-  `flags` - додаткові флаги, які визначають поведінку функції

Ця функція повертає об'єкт, який містить інформацію про знайдений шаблон. Якщо шаблон не знайдено, то функція повертає `None`.

Давайте спробуємо переписати нашу програму використовуючи функцію `re.search()`:

```{python}
#| label: validate-re-search
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search("@", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти

python validate.py
Введіть email: @
Валідна адреса електронної пошти
```

Цей варіант програми працює так само, як і наш перший варіант, але вже з використанням пакету `re`.

## Регулярні вирази

Повернемось до нашого прикладу з пошуком адреси електронної пошти українського навчального закладу. Нам треба уточнити потер пошуку: ліворуч від символа `@` може бути певний запис, праворуч від символа `@` має бути також якийсь запис, який закінчується на `.edu`. Для цього існує ряд спеціальних символів, які дозволяють визначити певні шаблони:

| **Регулярний вираз** | **Опис** | **Приклади** |
|:-----------------:|:------|----------|
| `.`             | Будь-який символ | `a.b` відповідає "acb", "a1b", "a#b" |
| `*`             | 0 або більше повторень попереднього символу | `ab*c` відповідає "ac", "abc", "abbc" |
| `+`             | 1 або більше повторень попереднього символу | `ab+c` відповідає "abc", "abbc", але не "ac" |
| `?`             | 0 або 1 повторення попереднього символу | `colou?r` відповідає "color" і "colour" |
| `{n}`           | Рівно `n` повторень попереднього символу | `a{3}b` відповідає "aaab" |
| `{n, m}`        | Від `n` до `m` повторень попереднього символу | `a{2,4}b` відповідає "aab", "aaab" і "aaaab" |
| `{n,}`          | Від `n` повторень попереднього символу | `a{2,}b` відповідає "aab", "aaab", "aaaab" і так далі |
| `^`             | Початок рядка | `^start` відповідає, якщо рядок починається з "start" |
| `$`             | Кінець рядка | `end$` відповідає, якщо рядок закінчується на "end" |
| `[]`            | Набір символів | `[aeiou]` відповідає будь-якому голосному символу |
| `[^]`           | Набір символів, які не повинні зустрічатися | `[^0-9]` відповідає будь-якому символу, крім цифр |
| `A|B`           | Або | `cat|dog` відповідає "cat" або "dog" |
| `(...)`         | Група символів | `(ab)+` відповідає "ab", "abab", "ababab" і так далі |
| `?:...`         | Не захоплювати групу | `(?:ab)+` відповідає "ab", "abab", "ababab" і так далі |

: {tbl-colwidths="[25,50,25]"}

Давайте спробуємо переписати нашу програму використовуючи функцію `re.search()` і регулярний вираз:

```{python}
#| label: validate-re-search-edu-ua
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(".*@.*", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

Комп'ютер використовує свого роду машину, реалізовану в програмному забезпеченні, відомому як **скінченний автомат** (англ. *finite state machine*) або **недетермінований скінченний автомат**. Візуально це можна зобразити так:

![Вираз: `.*@.*`](img/python/regex-email-00.png)

Функція `re.search()` у стартовому стані, потім вона зчитує електронну адресу користувача зліва направо і вирішує, чи залишатися в цьому першому стані (`q1`), чи переходити в наступний (`q2`) за умови наявності символу `@`. Далі комп'ютер перевірить, чи дійшов він до кінцевого стану, який зображено подвійними колами. Це означає, що якщо комп'ютер опинився у другому стані прийняття після того, як прочитав увесь введений користувачем текст, то введена електронна адреса є дійсною.

Ми можемо переписати нашу програму з використанням регулярного виразу `.+`, який означає "один або більше будь-яких символів":


```{python}
#| label: validate-re-search-edu-ua-2
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(".+@.+", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

В такому випадку візуалізація недетермінованого скінченного автомату буде наступна:

![Вираз: `.+@.+`](img/python/regex-email-01.png)

Цього разу у стані `q1` ми перевіряємо **наявність будь-якого символу**, далі переходимо у стан `q2`, де перевіряємо **1 або більше будь-яких символів**, далі переходимо у стан `q3`, за умови наявності символу `@`, після чого повторюється процедури першого та другого стану. У разі успіху ми опинимося у кінцевому стані.

Підемо далі і додамо перевірку, що домен закінчується на `.edu.ua`:

```{python}
#| label: validate-re-search-edu-ua-3
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r".+@.+\.edu", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти

python validate.py
Введіть email: potter?hogwarts.edu
Невалідна адреса електронної пошти
```

::: {.callout-warning}
Зверніть увагу, що ми використовуємо символ `\` для екранування крапки, оскільки в іншому випадку крапка буде сприйматися як будь-який символ.

Крім того, слід враховувати, що комбінація символів `\n` вважається спеціальним символом, який позначає перехід на новий рядок. Тому ми вказуємо Python читати рядок як **"сирий"** (англ. *raw*), використовуючи префікс `r` перед рядком.
:::

Візуалізація:

![Вираз: `.+@.+\.edu`](img/python/regex-email-02.png)

## Початок та кінець рядка

Наша програма все ще має ряд недоліків. Наприклад, вона не враховує пробіли, які можуть зустрічатися у введеному тексті:

```{.bash filename="Terminal"}
python validate.py
Введіть email: Моя пошта potter@hogwarts.edu
Валідна адреса електронної пошти
```

Для таких випадків у світі регулярних виразів існують спеціальні символи початку `^` та кінця рядка `$`. Давайте спробуємо використати їх:

```{python}
#| label: validate-re-search-edu-ua-4
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^.+@.+\.edu$", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: Моя пошта potter@hogwarts.edu
Невалідна адреса електронної пошти
```

Візуалізація:

![Вираз: `^.+@.+\.edu$`](img/python/regex-email-03.png)

::: {.callout-note}
В пакеті `re` є функція `re.match()`, яка шукає відповідність регулярному виразу лише на початку рядка.
:::

## Пошук та вилучення

Є ще один значний недолік нашої програми. Вона не враховує умову одного символу `@` у адресі електронної пошти:

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@@@hogwarts.edu
Валідна адреса електронної пошти
```

Для цього ми можемо використати символи `[]` для визначення набору символів, які можуть зустрічатися у тексті та `[^]` для символів, які не повинні зустрічатися у тексті. Оскільки ми не хочемо щоб символ `@` зустрічався більше одного разу, то ми можемо використати наступний регулярний вираз `[^@]`:

```{python}
#| label: validate-re-search-edu-ua-5
#| eval: false 

import re

email = input("Введіть email: ").strip()

if re.search(r"^[^@]+@[^@]+\.edu$", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@@@hogwarts.edu
Невалідна адреса електронної пошти
```

Візуалізація:

![Вираз: `^[^@]+@[^@]+\.edu$`](img/python/regex-email-04.png)

## Слова та цифри

У світі стандартів існує багато різних специфікацій для адрес електронної пошти. Наприклад, вони повинні починатися з літери. Нам не потрібно перераховувати всі можливі літери алфавіту у нижньому та верхньому регістрі. Замість цього ми можемо використати спеціальний символ `[a-zA-Z]`, який означає будь-яку літеру англійського алфавіту незалежно від регістру. Якщо ж я хочу також врахувати цифри та символ `_`, то я можу використати спеціальний символ `[a-zA-Z0-9_]`. Давайте спробуємо використати цей регулярний вираз:

```{python}
#| label: validate-re-search-edu-ua-6
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^[a-zA-Z0-9_]+@[a-zA-Z0-9_]+\.edu$", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@@@hogwarts.edu
Невалідна адреса електронної пошти
```

Візуалізація:

![Вираз: `^[a-zA-Z0-9_]+@[a-zA-Z0-9_]+\.edu$`](img/python/regex-email-05.png)

Такі патерни досить часто зустрічаються, тому у регулярних виразах є готові спеціальні символи, які дозволяють замінити їх. Наприклад, спеціальний метасимвол `\w` означає будь-яку літеру англійського алфавіту незалежно від регістру, цифру або символ `_`. Також є спеціальний метасимвол `\d`, який означає будь-яку цифру. Давайте спробуємо використати ці спеціальні символи:

```{python}
#| label: validate-re-search-edu-ua-7
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^\w+@\w+\.edu$", email):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

Візуалізація:

![Вираз: `^\w+@\w+\.edu$`](img/python/regex-email-06.png)

Повний перелік спеціальних метасимволів:

| **Метасимвол** | **Опис** |
|:------------|:------|
| `\w` | Будь-яка літера англійського алфавіту незалежно від регістру, цифра або символ `_` |
| `\d` | Будь-яка цифра |
| `\s` | Будь-який пробіл |
| `\W` | Будь-який символ, крім літер англійського алфавіту незалежно від регістру, цифр та символу `_` |
| `\D` | Будь-який символ, крім цифри |
| `\S` | Будь-який символ, крім пробілу |

: {tbl-colwidths="[25,75]"}

## Флаги

Давайте припустимо, що при введені адреси електронної пошти користувач випадково натиснув клавішу <kbd>Caps Lock</kbd> і ввів адресу з використанням великих літер. Якщо ми використаємо наш регулярний вираз, то програма не буде вважати таку адресу валідною:

```{.bash filename="Terminal"}
python validate.py
Введіть email: POTTER@HOGWARTS.EDU
Невалідна адреса електронної пошти
```

Вирішити таку задачу можна декількома шляхами. Наприклад, ми можемо використати функцію `lower()` для перетворення всіх символів у нижній регістр. Це можна зробити на початку програми або використовуючи метод `lower()` для об'єкта `email`:

```{python}
#| label: validate-re-search-edu-ua-8
#| eval: false

import re

email = input("Введіть email: ").strip().lower()

if re.search(r"^\w+@\w+\.edu$", email): # або email.lower()
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

Але є інший спосіб. Ми можемо використати аргумент `flag` для функції `re.search()`, який може приймати наступні значення:

- `re.IGNORECASE` або `re.I` - ігнорувати регістр символів
- `re.MULTILINE` або `re.M` - використовувати багаторядковий режим
- `re.DOTALL` або `re.S` - використовувати режим, в якому крапка `.` відповідає будь-якому символу, включаючи символ нового рядка `\n`

Тож для нашої задачі код буде виглядати наступним чином:

```{python}
#| label: validate-re-search-edu-ua-9
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^\w+@\w+\.edu$", email, re.IGNORECASE):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: POTTER@HOGWARTS.EDU
Валідна адреса електронної пошти
```

## Опціональність

Припустимо, що адреса користувача містить піддомен `gryff.hogwarts.edu`. В такому випадку нам слід врахувати варіативність піддоменів. Для цього ми можемо використати спеціальний символ `?`, який означає 0 або 1 повторення попереднього символу. Давайте спробуємо використати цей символ:

```{python}
#| label: validate-re-search-edu-ua-10
#| eval: false

import re

email = input("Введіть email: ").strip()

if re.search(r"^\w+@(\w+\.)?edu$", email, re.IGNORECASE):
    print("Валідна адреса електронної пошти")
else:
    print("Невалідна адреса електронної пошти")
```

```{.bash filename="Terminal"}
python validate.py
Введіть email: potter@hogwarts.edu
Валідна адреса електронної пошти

python validate.py
Введіть email: potter@gryff.hogwarts.edu
Валідна адреса електронної пошти
```

Візуалізація:

![Вираз: `^\w+@(\w+\.)?edu$`](img/python/regex-email-07.png)

Запис `(\w+\.)?` означає, що група записів `\w+\.` може зустрічатися 0 або 1 раз. Таким чином, ми можемо врахувати варіативність піддоменів.

## Приклади з реального світу

Все що ми зробили до цього часу для відстеження адрес електронної пошти, все ще має ряд недоліків. Я наведу приклад регулярного виразу, який використовується в реальному світі для відстеження адрес електронної пошти:

```
^[a-zA-Z0-9_.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9-](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9-](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)
```

Візуально такий регулярний вираз виглядає так:

![Приклад валідації email](img/python/regex-email-08.png)

В інтернеті є ряд стандартів, які визначають, якими мають бути адреси електронної пошти. Один з них - це [RFC 5322](https://tools.ietf.org/html/rfc5322). Згідно цього стандарту 99.99% адрес електронної пошти можна відстежити за допомогою наступного регулярного виразу:

```
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```

Візуально такий запис виглядає наступним чином:

![Валідація email за RFC 5322](img/python/regex-email-09.png)

## Очищення тексту

Замість того, щоб просто перевіряти вхідні дані користувача і переконуватися, що вони виглядають так, як ми хочемо, давайте просто припустимо, що користувачі не збираються вводити дані саме так, як ми хочемо. Тому нам доведеться очистити їхні дані.

Створимо програму `format.py`, яка очищуватиме введене ім'я користувача:

```{.bash filename="Terminal"}
code format.py
```




