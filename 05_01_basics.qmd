# Базові запити

## SELECT

```{python}
#| file: _common.py
#| include: false
```

```{r}
#| include: false

source('_common.r')
source('_duckdb.r')
```

Давайте напишемо перший запит мовою SQL:
```{sql}
#| connection: con

SELECT *
FROM courier_actions
LIMIT 5
```

Даний запис можна дослівно перекласти:

- `SELECT *`: "взяти все".
- `FROM courier_actions`: з таблиці `courier_actions`.
- `LIMIT 10`: вивести тільки перші 10 спостережень.

Ми можемо написати більш явний запит і отримати той сами результат:
```{sql}
#| connection: con

SELECT 
    action, 
    courier_id, 
    order_id, 
    time
FROM 
    courier_actions
LIMIT 5
```

На практиці таблиці можуть бути дуже великими, тому дуже бажано використовувати оператор `LIMIT` для того щоб не виводити всю таблицю, що може займати багато часу. Крім того, можливо такий запит навіть не буде виконано, оскільки розумні дата інженери заборонили виконувати такі запити.

::: {.callout-note}
Оператор `FROM` завжди вказується після оператора `SELECT`. У зворотному порядку їх записувати не можна – база даних поверне помилку.
:::

## ORDER BY

Для сортування значень по будь-якій колонці SQL використовується оператор `ORDER BY` з ключовими словами `ASC` (за зростанням) або `DESC` (за спаданням).

При цьому за умовчанням сортування відбувається за зростанням, тобто `ASC` не обов'язково вказувати. Для сортування за спаданням після `ORDER BY` необхідно явно вказати `DESC`:

```{sql}
#| eval: false

SELECT column_1, column_2
FROM table
ORDER BY column_1           -- сортування за зростанням


SELECT column_1, column_2
FROM table
ORDER BY column_1 ASC       -- сортування за зростанням


SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC      -- сортування за спаданням
```

::: {#exm-sql01}
Виведіть всі записи з таблиці `products`, відсортувавши їх за найменуванням товарів *у алфавітному порядку*, тобто. за зростанням. Для сортування використовуйте оператор `ORDER BY`.

Поля у результуючій таблиці: `product_id`, `name`, `price`

::: {.callout-note}
Сортування можна робити не тільки по полях зі значеннями, вираженими числами, але й по полях, значення яких представлені у вигляді тексту, як у нашому випадку.
:::

**Рішення:**
```{sql}
#| connection: con

SELECT product_id,
       name,
       price
FROM   products
ORDER BY name
LIMIT 5
```
:::
Сортувати результат SQL-запиту можна відразу за декількома колонками, вказуючи їх після `ORDER BY` через кому разом із напрямком сортування (`ASC` або `DESC`):

```{sql}
#| eval: false

SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2    -- спочатку сортування по першій колонці (за спаданням),
                                    -- потім по другій (за зростанням)
```

::: {.callout-note}
Важливо пам'ятати, що при роботі з великими таблицями потрібно по можливості обмежувати кількість виведених записів, щоб не створювати зайве навантаження на базу даних.
:::

Оператори `ORDER BY` та `LIMIT` можна поєднувати в одному запиті, при цьому оператор `LIMIT` записується та виконується після оператора `ORDER BY`, обмежуючи кількість записів у вже відсортованому результаті:

```{sql}
#| eval: false

SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2
LIMIT 5
```

::: {#exm-sql02}
Відсортуйте таблицю `courier_actions` спочатку по колонці `courier_id` за зростанням id кур'єра, потім по колонці `action` (знову за зростанням), а потім по колонці `time`, але вже за спаданням — від останньої дії до першої. Не забудьте включити колонку `order_id`.

Додайте в запит оператор `LIMIT` та виведіть лише **перші 1000 рядків** результуючої таблиці.

Поля у результуючій таблиці: `courier_id`, `order_id`, `action`, `time`.

::: {.callout-note}
Як ви вже здогадалися, сортувати таблиці можна навіть по полях з датами та часом.
:::

```{sql}
#| connection: con

SELECT courier_id,
       order_id,
       action,
       time
FROM   courier_actions
ORDER BY courier_id, action, time DESC limit 5
```
:::

Зараз важливо запам'ятати порядок запису всіх відомих нам ключових слів:

1. `SELECT`
2. `FROM`
3. `ORDER BY`
4. `LIMIT`

Також важливо зрозуміти, що порядок їх виконання дещо відрізняється від того, в якій послідовності вони вказуються в SQL-запиті:

1. Спочатку виконується оператор `FROM` – відбувається вибір потрібної таблиці.
2. Потім `SELECT` - відбираються вказані стовпці.
3. Потім `ORDER BY` - проводиться сортування результуючої таблиці.
4. І наприкінці `LIMIT` — обмежується кількість записів, що виводяться.

::: {#exm-sql03}
Використовуючи оператори `SELECT`, `FROM`, `ORDER BY` та `LIMIT`, визначте 5 найдорожчих товарів у таблиці `products`, які доставляє наш сервіс. Виведіть їх найменування та ціну.

Поля у результуючій таблиці: `name`, `price`.

```{sql}
#| connection: con

SELECT name,
       price
FROM   products
ORDER BY price desc limit 5
```
:::


## AS
При складанні SQL-запитів колонкам у результуючій таблиці можна надавати будь-які інші імена (їх ще називають «аліасами»). Це можна робити за допомогою оператора `AS`:

```{sql}
#| eval: false

SELECT name AS new_name
FROM table
```

Якщо раптом вам здасться, що на написання оператора `AS` йде занадто багато часу і сил, його можна опустити, вказавши нове ім'я колонки без нього. Наступний запис також спрацює:

```{sql}
#| eval: false

SELECT name new_name
FROM table
```

::: {#exm-sql04}
Повторіть запит із з попереднього прикладу (@exm-sql03), але тепер колонки `name` і `price` перейменуйте відповідно на `product_name` і `product_price`.

Поля у результуючій таблиці: `product_name`, `product_price`

```{sql}
#| connection: con

SELECT name AS product_name,
       price AS product_price
FROM   products
ORDER BY price desc limit 5
```
:::

## LENGTH

У SQL-запитах до колонок таблиць можна використовувати різні функції, наприклад, як в Excel.

У загальному вигляді синтаксис функцій виглядає приблизно так:

```{sql}
#| eval: false

SELECT function(a, b, c, ...)
FROM table
```

Замість `function` вказується назва функції, а дужках — її аргументи. Як аргументи можуть виступати як колонки зі значеннями, так і окремі значення. Залежно від функції кількість аргументів може відрізнятися.

Якщо ви коли-небудь працювали в Excel, то вам, напевно, знайомі різні функції на кшталт `SUM`, `MIN`, `MAX` тощо, які роблять деякі обчислення по стовпцях. У SQL вони називаються *агрегуючими функціями*.

Зараз як приклад розглянемо функцію `LENGTH`. Вона виконує досить просте завдання — підраховує кількість символів у поданому їй на вхід значенні текстового типу (текстовий тип даних часто називають рядком — від англ. «string»). Іншими словами, функція `LENGTH` вимірює довжину деякого рядка у символах:

```{sql}
#| connection: con

SELECT LENGTH('You shall not pass!') as gendalf_say
```

Функція `LENGTH` також може застосовуватись до всього стовпця. У такому випадку довжина символів буде порахована для кожного значення в стовпці. Відповідний запит виглядатиме так:

```{sql}
#| eval: false

SELECT LENGTH(column) AS column_length
FROM table
```

::: {#exm-sql05}
Використовуючи оператори `SELECT`, `FROM`, `ORDER BY` та `LIMIT`, а також функцію `LENGTH`, визначте товар із найдовшою назвою у таблиці `products`. Виведіть його найменування, довжину найменування у символах, а також ціну цього товару. Назвіть колонку з довжиною найменування в символах `name_length`.

Поля у результуючій таблиці: `name`, `name_length`, `price`.

```{sql}
#| connection: con

SELECT name,
       length(name) as name_length,
       price
FROM   products
ORDER BY name_length desc limit 1
```

::: {.callout-note}
Зверніть увагу, що в цьому прикладі ви сортуєте результуючу таблицю по розрахунковій колонці `name_length`, якої спочатку не було таблиці `products`.

Таке сортування за новими колонками можливе, оскільки це узгоджується з порядком виконання операторів у запиті: спочатку виконується вибір колонок і всі перетворення над ними в операторі `SELECT` — і тільки потім проводиться сортування за вказаними в `ORDER BY` стовпчиками. Тобто на момент сортування всі розрахункові поля вже існують, а значить, їх можна вказувати в `ORDER BY`.

Також зверніть увагу, що ми двічі вказуємо колонку `name` в операторі `SELECT`: вперше просто звертаємося до неї за ім'ям, а вдруге - використовуємо її як аргумент функції `LENGTH`. У цьому випадку теж немає жодних протиріч - ми можемо вибирати колонку стільки разів, скільки необхідно, причому для цього навіть необов'язково надавати цим колонкам різні аліаси (база даних сама перейменує дублікат колонки).
:::

:::

У SQL, як й у багатьох інших мовах, функції можна застосовувати до інших функцій, тобто. послідовно:

```{sql}
#| eval: false

SELECT function_one(function_two(a, b), c)
```

У наведеній вище конструкції `a`, `b`, `c` аргументи функцій. При цьому одним із аргументів функції `function_one` є результат виконання функції `function_two`.

Таким чином, спочатку буде виконана функція `function_two`, а потім її результат буде поданий на вхід функції `function_one` як один з аргументів.

Розглянемо такий випадок на прикладі функцій `UPPER` та `LEFT`. Функція `UPPER` наводить подане їй на вхід текстове значення до верхнього регістру:

```{sql}
#| eval: false

SELECT 
    UPPER('You Shall not pass!') AS upper_all

Результат:
YOU SHALL NOT PASS!
```

Функція `LEFT` повертає перші `n` символів у рядку:

```{sql}
#| eval: false

SELECT 
    LEFT('You shall not pass!', 9) AS first_n

Результат:
You shall
```

Ми можемо застосувати ці функції послідовно і в результаті отримаємо перші три символів верхнього регістру:

```{sql}
#| eval: false

SELECT 
    UPPER(LEFT('You shall not pass!', 3))

Результат:
YOU
```

::: {.callout-caution}
Важливо: зверніть увагу, що у блоці `SELECT` не можна виконати дві операції окремо, тобто. ми не можемо спочатку створити розрахункову колонку з першими шістьма символами, а потім відразу ж звернутися до цієї нової колонки, застосувавши до неї функцію `UPPER`.
:::

Наступний запит не буде виконано, база даних поверне помилку:

```{sql}
#| eval: false

SELECT 
    LEFT('You shall not pass!', 3) AS first_n,
    UPPER(first_n) AS upper_first_n

Результат:
Error running query: column "new_name" does not exist
```

В межах одного запиту колонки створюються не по черзі, а разом, тому в межах одного запиту колонки `upper_first_n` не існує, поки блок `SELECT` не буде повністю виконаний. Дуже важливо враховувати цю особливість мови.

Однак на практиці до нових колонок доводиться звертатися досить часто — саме для цього є підзапити (запити до інших запитів). А поки що нам достатньо розуміти, що застосовувати функції до розрахункових колонок у тому ж запиті не можна.

## SPLIT_PART

Функція `SPLIT_PART` розбиває поданий їй на вхід рядок на кілька частин відповідно до зазначеного роздільника та повертає одну з частин.

Крім самого рядка (або колонки зі значеннями рядкового типу), функція приймає ще два аргументи — роздільник і порядковий номер частини, яку необхідно повернути. Подивіться наступний приклад:

::: {#exm-sql06}
```{sql}
#| eval: false

SELECT SPLIT_PART('You shall not pass!', ' ', 4)

Результат:
pass!
```
:::

У прикладі вище рядок 'You Shall not pass!' було розбито на чотири частини ('You', 'shall', 'not' і 'pass!') по роздільнику "пробіл". Функція повернула 'pass', оскільки третім аргументом ми вказали частину із порядковим номером 4.

::: {.callout-note}
Докладніше з іншими функціями для роботи з рядками можна ознайомитись за [посиланням](https://www.postgresqltutorial.com/postgresql-string-functions/).
:::

::: {#exm-sql07}
Застосуйте послідовно функції `UPPER` та `SPLIT_PART` до колонки `name` та перетворіть найменування товарів у таблиці `products` так, щоб від назв залишилося тільки перше слово, записане у верхньому регістрі. Колонку з новою назвою, що складається із першого слова, назвіть `first_word`.

У результаті виведіть вихідні найменування товарів, нові найменування з першого слова, а також ціну товарів. Результат відсортуйте за зростанням початкового найменування товару в колонці `name`.

Поля у результуючій таблиці: `name`, `first_word`, `price`
```{sql}
#| connection: con

SELECT
    name,
    UPPER(SPLIT_PART(name, ' ', 1)) AS first_word,
    price
FROM
    products
ORDER BY
    name
```
:::

## CAST

Іноді виникає необхідність змінити тип даних у якійсь колонці результуючої таблиці, не змінюючи при цьому властивості вихідної таблиці, наприклад, перетворити число на текст (тип даних `VARCHAR`). І тому існує функція `CAST`.

На вхід функції `CAST` необхідно подати ім'я колонки, вказавши через `AS` тип даних, до якого потрібно привести всі значення:

```{sql}
#| eval: false

SELECT CAST(column AS VARCHAR)
FROM table
```

Також можна змінити тип даних за допомогою спеціального синтаксису з двома двокрапками («`::`»):

```{sql}
#| eval: false

SELECT column::VARCHAR
FROM table
```

Наприклад, переведемо текст '100' у число 100:

```{sql}
#| eval: false

SELECT CAST('100' AS INTEGER)

Результат:
100
```

Зверніть увагу, що для успішної конвертації значення повинні бути конвертованими у вказаний тип. Наприклад, текст, який не виглядає як число, перевести до числового типу даних не вийде:

```{sql}
#| eval: false

SELECT CAST('text' AS INTEGER)

Результат:
Error running query: invalid input syntax for type integer: "text"
```

Аналогічним чином можна, наприклад, перетворити текст на дату (якщо він виглядає як дата):

```{sql}
#| eval: false

SELECT '2022-12-31'::DATE as date

Результат:
2022-12-31
```

::: {.callout-note}
Докладніше з функцією `CAST` та перетворенням типів даних можна ознайомитись за цим [посиланням](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cast/).

Про самі типи даних можна почитати [тут](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-data-types/).
:::

::: {#exm-sql08}
Змініть тип колонки `price` з таблиці `products` на `VARCHAR`. Виведіть колонки з найменуванням товарів, ціною у вихідному форматі та ціною у форматі `VARCHAR`. Нову колонку з ціною у новому форматі назвіть `price_char`.

Результат відсортуйте за зростанням початкового найменування товару в колонці name. Кількість записів, що виводяться, не обмежуйте.

Поля в результуючій таблиці: `name`, `price`, `price_char`
```{sql}
#| connection: con

SELECT 
    name,
    price,
    CAST(price as VARCHAR) as price_char
FROM
    products
ORDER BY
    name
```
:::

## CONCAT

У цьому підрозділі ми ще трохи попрацюємо з текстовими даними та розглянемо функцію `CONCAT`, за допомогою якої можна з'єднувати в один рядок значення кількох стовпців.

Функція `CONCAT` приймає на вхід кілька аргументів і повертає результат їхньої послідовної складання один з одним. Хороша аналогія - складання речень з різних карток зі словами:

```{sql}
#| eval: false

SELECT CONCAT('SQL', ' ', 'Python ', 2023)

Результат:
SQL Python 2022
```

При цьому аргументи не обов'язково мають бути виражені текстовими значеннями — головне, вони мають бути конвертованими в текст. У прикладі вище число 2023 можна конвертувати в текст '2023', тому запит працює без помилок.

::: {.callout-note}
Ознайомитись з іншими прикладами використання функції `CONCAT` можна за [посиланням](https://www.postgresqltutorial.com/postgresql-string-functions/postgresql-concat-function/).
:::

::: {#exm-sql09}
Для перших 5 записів з таблиці `orders` виведіть інформацію у такому вигляді (зверніть увагу на пробіли):

Замовлення № [`id_замовлення`] створено [`дата`]

Отриману колонку назвіть `order_info`.

Приклад результату:
```{sql}
#| eval: false

Замовлення № 65 створено 2022-09-01
```

**Рішення:**
```{sql}
#| connection: con

SELECT 
    CONCAT('Замовлення № ', order_id, ' створено ', creation_time::DATE) as order_info
FROM   
    orders
LIMIT 5
```
:::

## DATE_PART

Як ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (`DATE`) і часу (`TIMESTAMP`). Давайте трохи попрацюємо з такими даними.

Насправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція `DATE_PART`. Її синтаксис наступний:

```{sql}
#| eval: false

SELECT DATE_PART(part, column)
```

На місці `part` необхідно в лапках вказати ту частину, яку потрібно витягти: `'year'`, `'month'`, `'day'`, `'hour'` тощо. На місці `column` слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:

```{sql}
#| eval: false

SELECT DATE_PART('day', DATE '2022-01-12')

Результат:
12.00


SELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')

Результат:
31.00
```

Вище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами `dates`. Тоді запит виглядав би так:

```{sql}
#| eval: false

SELECT DATE_PART('day', dates)
```

::: {.callout-note}
Ознайомитись з іншими прикладами використання функції `DATE_PART ` можна за [посиланням](https://duckdb.org/docs/sql/functions/timestamptz).
:::

::: {#exm-sql10}
Виведіть id десяти відсотків кур'єрів та їхні роки народження з таблиці `couriers`, використовуючи вибірку Бернуллі та встановіть початкове значення генератора випадкових величин (`seed`) рівний 123.

Рік народження необхідно одержати з колонки `birth_date`. Нову колонку з роком назвіть `birth_year`.

Поля у результуючій таблиці: `courier_id`, `birth_year`

У цьому прикладі ми використаємо випадкову вибірки Бернуллі за допомогою оператора `USING SAMPLE`, після котрого вказується розмір вибірки, а в дужках метод формування та початкове значення генератора випадкових величин.

::: {.callout-note}
Ознайомитись з прикладами формування вибірок у DuckDB можна за [посиланням](https://duckdb.org/docs/sql/samples.html).
:::

**Рішення:**
```{sql}
#| connection: con

SELECT courier_id,
       date_part('year', birth_date) birth_year
FROM   couriers
USING SAMPLE 10 PERCENT (bernoulli, 123)
```
:::

## COALESCE

Ви могли помітити, що в минулому прикладі (@exm-sql10) для окремих рядків функція `DATE_PART` не повернула рік народження кур'єра, а замість них утворилися порожні значення. Якщо не помітили, уважно подивіться на результат запиту.

Насправді це сталося тому, що в наших даних у колонці `birth_date` є перепустки — так звані значення `NULL` (у виводі результату це `NA`). Іншими словами, для окремих кур'єрів просто не вказано їхні дні народження. Є безліч варіантів, чому так могло статися, але ми зараз не маємо часу все це з'ясовувати — нам просто потрібно навчитися якось обробляти такі випадки.

Давайте зробимо так, щоб замість порожніх значень функція `DATE_PART` повертала якесь інше значення. У цьому нам допоможе функція `COALESCE`, яка повертає перше не `NULL` значення зі списку поданих на вхід аргументів.

Роботу `COALESCE` можна описати так: вона буквально читає список значень зліва направо і, як тільки бачить значення, яке не є `NULL`, відразу ж повертає його та припиняє читання списку. Подивіться уважно на такі приклади:

```{sql}
#| eval: false

SELECT COALESCE(NULL, 'I am not NULL' , 'I.love.Python')

Результат:
I am not NULL


SELECT COALESCE(NULL, 25, 100, 150)

Результат:
25


SELECT COALESCE('NULL', 'I am not NULL', 'I.love.Python')

Результат:
NULL
```

Одним із аргументів функції `COALESCE` може бути результат виконання іншої функції:

```{sql}
#| eval: false

SELECT COALESCE(NULL, LOWER('I am not NULL'), 'I.love.Python')

Результат:
i am not null
```

Щоб заповнити пропуски в колонці, достатньо застосувати функцію `COALESCE` до колонки з пропусками та вказати як другий аргумент те значення, яке ми хочемо бачити замість `NULL`:

```{sql}
#| eval: false

SELECT COALESCE(column, 'filler value')
FROM table
```

Функція `COALESCE` застосовується до кожного значення колонки. Якщо це значення виявиться `NULL`, вона замінить його значення, вказане другим аргументом. Якщо значення колонці, навпаки, виявиться не `NULL`, то функція просто поверне це значення.

При цьому до колонки з перепустками можна заздалегідь застосовувати різні інші функції:

```{sql}
#| eval: false

SELECT COALESCE(LEFT(column, 5), 'filler value')
FROM table
```

::: {.callout-note}
З іншими прикладами використання функції `COALESCE` можна за [посиланням](https://duckdb.org/docs/sql/functions/utility).
:::

::: {#exm-sql11}
Як і в попередньому прикладі (@exm-sql10), знову виведіть id десяти відсотків кур'єрів та їх роки народження, тільки тепер до вилученого року застосуйте функцію `COALESCE`. Вкажіть параметри функції так, щоб замість значення `NULL` в результат потрапляло текстове значення `unknown`. Назви полів залиште колишніми.

Поля у результуючій таблиці: `courier_id`, `birth_year`

**Рішення:**
```{sql}
#| connection: con

SELECT 
    courier_id,
    COALESCE(date_part('year', birth_date)::VARCHAR, 'unknown') birth_year
FROM
    couriers
USING SAMPLE 10 PERCENT (bernoulli, 123)
```
:::









## Типові помилки при написанні SQL-запитів.

- Неправильний порядок або помилки у ключових словах. Правильний порядок операторів у запиті виглядає так:

```{sql}
#| eval: false

SELECT      -- перерахування полів результуючої таблиці
FROM        -- вказівка джерела даних
WHERE       -- фільтрація даних
GROUP BY    -- угруповання даних
HAVING      -- фільтрація даних після угруповання
ORDER BY    -- сортування результуючої таблиці
LIMIT       -- обмеження кількості записів, що виводяться
```

- Неправильно названі функції та оператори, що використовуються в запиті (наприклад, `DATEPART`, а не `DATE_PART`).
- Неправильно вказано імена стовпців.
- Неправильно виконано сортування записів.
- Неправильно проведено розрахунки.
- Пропущена кома при перерахуванні стовпців у `SELECT`
- Зайва кома після імені останнього стовпця в `SELECT`
- Не закриті дужки (перевірте, що кількість дужок дорівнює кількості закривають).
- Допущено помилку в підзапиті (перед виконанням всього запиту перевірте, чи працюють окремі підзапити).
- Запущено відразу кілька запитів, не розділених крапкою з комою.

::: {.callout-note}
Зараз деякі пункти можуть бути незрозумілими, але з часом ви розберетеся, про що йдеться.
:::