# Списки та множини

## Списки

**Списки** - це один з найбільш використовуваних типів даних в Python. Вони дозволяють зберігати набір значень у впорядкованому вигляді. Списки можуть містити елементи різних типів, але зазвичай вони містять елементи одного типу. Списки створюються за допомогою квадратних дужок `[]` і можуть бути порожніми або містити довільну кількість елементів. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(fruits)
```

### Індексація списків

Потренуємося працювати з індексами списків. До будь-якого елемента списку можна звернутися за його індексом. Запам'ятайте, що індексація починається з нуля.

```{python}
fruits = ['apple', 'banana', 'orange']
print(fruits[0])
```

Також ми можемо робити зрізи:

```{python}
fruits = ['apple', 'banana', 'orange']
print(fruits[0:2])
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-01}
<br>
`my_list` зберігає список як мінімум з двома елементами.

Створіть змінні:

- `first_item` з першим елементом списку.
- `last_item` з останнім елементом списку.
- `reversed_list` з елементами списку `my_list` у зворотному порядку.
- `even_items` з елементами списку `my_list` із парними індексами.

**Приклади:**

```{.powershell}
my_list = ['apple', 123, True, 3.14, 'cherry', 45, 22]

first_item = 'apple'
last_item = 22
reversed_list = [22, 45, 'cherry', 3.14, True, 123, 'apple']
even_items = ['apple', True, 'cherry', 22]
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

my_list = ['apple', 123, True, 3.14, 'cherry', 45, 22]

first_item = my_list[0]
last_item = my_list[-1]
reversed_list = my_list[::-1]
even_items = my_list[::2]
```

:::
::::



### Методи списків

Погляньмо на всі методи списку. Не треба заучувати їх напам'ять. Але якщо ви зіткнетеся із завданням, в якому треба буде щось зробити зі списком, то перед тим, як намагатися самому придумати рішення, подивіться, може бути потрібний метод.

- `append()` - додає елемент у кінець списку. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.append('melon')
print(fruits)
```

- `clear()` - видаляє всі елементи списку. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.clear()
print(fruits)
```

- `copy()` - повертає копію списку. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits_copy = fruits.copy()
print(fruits_copy)
```

- `count(item)` - повертає кількість елементів із заданим значенням. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange', 'banana']
print(fruits.count('banana'))
```

- `extend(iterable)` - додає елементи іншого списку до поточного. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.extend(['melon', 'watermelon'])
print(fruits)
```

- `index(item, start, end)` - повертає індекс першого елемента, який збігається із заданим значенням (`item`) у діапазоні індексів від `start` до `end`. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange', 'banana']
print(fruits.index('banana'))
```

- `insert(index, item)` - додає елемент `item` на позицію `index`. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.insert(1, 'melon')
print(fruits)
```

- `pop(index)` - видаляє та повертає елемент із заданим індексом. Якщо індекс не вказано, видаляє та повертає останній елемент списку. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
removed_fruit = fruits.pop(1)
print(removed_fruit)
```

- `remove(item)` - видаляє перший елемент із заданим значенням. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.remove('banana')
print(fruits)
```

- `reverse()` - змінює порядок елементів у списку на зворотній. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.reverse()
print(fruits)
```

- `sort(key, reverse)` - сортує елементи списку. Наприклад:

```{python}
fruits = ['banana', 'orange', 'apple']
fruits.sort()
print(fruits)
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-04}
<br>
У змінній `my_list` збережено не порожній список, де є число 11.

Знайдіть перший індекс числа 11 my_list, збережіть індекс в змінну `eleven_index`.

У змінну `ten_count` збережіть скільки разів у списку `my_list` зустрічається число 10.

**Приклад:**

```
my_list = [1, 10, 0, 10, 11]
eleven_index = 4
ten_count = 2


my_list = [11, 2, 0, 6]
eleven_index = 0
ten_count = 0
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

my_list = [11, 2, 0, 6]
eleven_index = my_list.index(11)
ten_count = my_list.count(10)
```

:::
::::

::::: {.callout-note icon=false}
## Завдання
:::: {#exr-py-list-set-05}
<br>
У `student_names` збережено список з іменами студентів, додайте до списку два імені `'Anatoly'` та `'Oksana'`.

У `scores` збережено список із десяти цілих чисел, **видаліть із нього другий, п'ятий та останній елемент**.

У `lessons` збережений список з назвою уроків, відсортуйте назви уроків у списку за абеткою.

**Приклад:**

```
student_names = ['Ian', 'Ivan']
scores = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
lessons = ['Python', 'Analytics']

===>

student_names = ['Ian', 'Ivan', 'Anatoly', 'Oksana']
scores = [0, 2, 3, 5, 6, 7, 8, 9]
lessons = ['Analytics', 'Python']
```

::: {.callout-note collapse="true"}
## Підказка

Зверніть увагу, що потрібно видалити другий, п'ятий та останній елемент із списку. Коли ви видалили один елемент, індекси інших елементів змінились.
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

student_names = ['Ian', 'Ivan']
student_names.append('Anatoly')
student_names.append('Oksana')

scores = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
scores.pop(1)
scores.pop(3)
scores.pop()

lessons = ['Python', 'Analytics']
lessons.sort()
```

::::
:::::



### `pop()` vs. `remove()`

Давайте знову зупинимося на різниці цих методів. Методи `pop()` і `remove()` застосовуються для видалення елементів зі списків Python. 

- Метод `pop()` видаляє та повертає останній елемент зі списку. Якщо в дужках вказати індекс елемента, буде видалено елемент із зазначеним індексом. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
removed_fruit = fruits.pop()
print(fruits)
```

```{python}
print(removed_fruit)
```

А якщо ми хочемо видалити елемент за індексом, то потрібно вказати індекс у дужках методу:

```{python}
fruits = ['apple', 'banana', 'orange']
removed_fruit = fruits.pop(1)
print(fruits)
```

```{python}
print(removed_fruit)
```

- Метод `remove()` видаляє перший елемент зі списку, який збігається з переданим значенням. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.remove('banana')
print(fruits)
```

Важливо, що якщо у списку не буде елемента із зазначеним індексом або значенням, методи `pop()` та `remove()` повернуть помилки. Таким чином, основна відмінність між методами `pop()` і `remove()` полягає в тому, що `pop()` видаляє елемент за індексом, повертаючи його значення, а `remove()` видаляє перший знайдений елемент із заданим значенням.

## Множини

**Множини** - це набір унікальних елементів. Множини створюються за допомогою фігурних дужок `{}`. Наприклад:

```{python}
fruits = {'apple', 'apple', 'banana', 'orange'}
print(fruits)
```

### Методи множин

- `add(element)` - додає елемент до множини. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.add('melon')
print(fruits)
```

- `union(set)` - повертає об'єднання двох множин. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits2 = {'melon', 'watermelon'}
fruits3 = fruits.union(fruits2)
print(fruits3)
```

- `clear()` - видаляє всі елементи множини. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.clear()
print(fruits)
```

- `copy()` - повертає копію множини. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits_copy = fruits.copy()
print(fruits_copy)
```

- `difference(set)` - повертає різницю двох множин. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits2 = {'apple', 'melon', 'watermelon'}
fruits3 = fruits.difference(fruits2)
print(fruits3)
```

- `discard(element)` - видаляє елемент із множини, якщо він там є. Якщо елементу немає у множині, то нічого не відбувається. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.discard('apple')
print(fruits)
```

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.discard('watermelon')
print(fruits)
```

- `remove(element)` - видаляє елемент із множини, якщо він там є. Якщо елементу немає у множині, то видає помилку `KeyError`. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.remove('apple')
print(fruits)
```

```{python}
#| error: true
fruits = {'apple', 'banana', 'orange'}
fruits.remove('watermelon')
print(fruits)
```

- `intersection(set)` - повертає перетин двох множин. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits2 = {'apple', 'melon', 'watermelon'}
fruits3 = fruits.intersection(fruits2)
print(fruits3)
```

- `isdisjoint(set)` - повертає `True`, якщо дві множини не мають спільних елементів. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits2 = {'melon', 'watermelon'}
print(fruits.isdisjoint(fruits2))
```

- `issubset(set)` - повертає `True`, якщо множина є підмножиною іншої множини. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange', 'watermelon'}
fruits2 = {'banana', 'orange'}
print(fruits2.issubset(fruits))
```

## Корисні функції

Також давайте подивимося на різні функції, які допомагають нам працювати зі списками та множинами:

- `len()` - повертає кількість елементів у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(len(fruits))
```

```{python}
fruits = {'apple', 'banana', 'banana', 'apple'}
print(len(fruits))
```

- `max()` - повертає найбільший елемент у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(max(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(max(numbers))
```

```{python}
my_set = {5, 2, 8, 1, 8}
print(max(my_set))
```

- `min()` - повертає найменший елемент у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(min(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(min(numbers))
```

- `sorted()` - повертає відсортований список або множину. Вона може приймати параметр `reverse=True`, щоб відсортувати послідовність у зворотному порядку (за спаданням). Наприклад:

```{python}
fruits = ['banana', 'orange', 'apple']
print(sorted(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(sorted(numbers, reverse=True))
```

А от якщо відсортувати множину, то вийде список!

```{python}
my_set = {1, 1, 2, 2}
print(sorted(my_set))
```

### range()

Функція `range()` дозволяє створити послідовність чисел.

```
range(start, stop, step)
# start - з цього числа починаємо за замовчуванням 0
# stop - кінець послідовності, але саме число stop не включено до результату.
# step - крок переходу між числами за замовчуванням 1
```

Функція дозволяє нам генерувати послідовність цілих чисел із заданим початком, кінцем та кроком. Після виконання функція повертає спеціальний тип даних – `range`. Для зручнішої роботи з послідовністю можна перевести `range` до списку. Обов'язково потрібно вказати лише аргумент `stop`, початок та крок за умовчанням дорівнюють `0` і `1` відповідно. Розглянемо приклади:

```{python}
# від 0 до 4 з кроком 1
list(range(5))
```

```{python}
# від 2 до 9 з кроком 2
list(range(2, 10, 2))
```

```{python}
# від 10 до 2 з кроком 1
list(range(10, 1, -1))
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-02}
<br>
У змінну `var_1` збережіть список з числами **від -100 до 100 включно з кроком 1**.

У змінну var_2 збережіть список з числами **від 250 до 0 включно з кроком 2**.

У змінну var_3 збережіть список з усіма **непарними числами від 100 до 200**.


```{python}
#| code-fold: true
#| code-summary: "Рішення"

var_1 = list(range(-100, 101, 1))
var_2 = list(range(250, -1, -2))
var_3 = list(range(101, 200, 2))
```

:::
::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-03}
<br>
У змінних `a` та `b` зберігаються числа - початок і кінець діапазону. Напишіть програму, яка поверне суму всіх чисел із цього діапазону. Збережіть значення змінної `result`.

**Приклад:**

```
a = 1
b = 3 

result = 6
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = 1
b = 3
result = sum(range(a, b + 1))
```

:::
::::

## Змінні та незмінні об'єкти

Настав час розібратися з досить складною для початківців концепцією змінних і незмінних об'єктів у Python. Ми вже знаємо, що можемо змінювати створені списки, наприклад, замінити або видалити один із елементів у списку. Однак ця особливість списку, його змінність призводить до несподіваних на перший погляд наслідків:

```{python}
# збережемо список у змінну my_list_1
my_list_1 = [3, 1, 2]

# у змінну my_list_2 збережемо список my_list_1
my_list_2 = my_list_1

# змінимо список my_list_1
my_list_1.append(4)
my_list_1.sort()
my_list_1[0] = 100

# подивимося на обидва списки
print("Результат списку my_list_1:", my_list_1)
print("Результат списку my_list_2:", my_list_2)
```

Дивно, адже ми відсортували лише перший список, але другий також змінився! Вся справа в тому, що списки, масиви та словники — це об'єкти, що змінюються. Замість того, щоб створити ще одну коробочку в пам'яті з ім'ям `my_list_2` та покласти в неї список із коробочки `my_list_1`, Python просто запам'ятав, що тепер на вихідну коробочку посилаються дві змінні. Коли змінюємо список `my_list_1`, змінюється і `my_list_2`. І навпаки, при зміні `my_list_2` зміниться і `my_list_1`.

Саме тому список має метод `copy()`. Він дозволяє створити копію першого списку у новій змінній. У такому разі зміни першого списку вже не вплинуть на копію цього списку.

```{python}
# збережемо список у змінну my_list_1
my_list_1 = [3, 1, 2]

# у змінну my_list_2 збережемо список my_list_1 з методом copy()
my_list_2 = my_list_1.copy()

# змінимо список my_list_1
my_list_1.append(4)
my_list_1.sort()
my_list_1[0] = 100

# подивимося на обидва списки
print("Результат списку my_list_1:", my_list_1)
print("Результат списку my_list_2:", my_list_2)
```

Тому при роботі з об'єктами в Python важливо розуміти, чи змінюємо ми вихідний об'єкт чи створюємо новий. Уважно читайте документацію функцій та методів. Припустимо, ми маємо список `my_list`, ми хочемо завести новий список `my_list_ordered` з відсортованими елементами зі списку `my_list`:

```{python}
my_list = [1, 2, 3, -2]

# так правильно
my_list_ordered = sorted(my_list) # функція sorted повертає новий список, не змінює список my_list
print("Результат списку my_list_ordered:", my_list_ordered)
print("Результат списку my_list:", my_list)
```

```{python}
#| include: false

del my_list_ordered
```

```{python}
# так неправильно
my_list_ordered = my_list.sort() # метод sort нічого не повертає, а лише змінює список my_list
print("Результат списку my_list_ordered:", my_list_ordered)
print("Результат списку my_list:", my_list)
```

А ось вже знайомі нам числа `int` і `float`, рядки та логічні значення - це незмінні об'єкти. Тобто після створення об'єкта не можна змінити його значення, лише створити новий об'єкт із зміненим значенням.

## Кортежі

Незважаючи на деякі підводні камені, можливість змінювати списки та множини робить їх дуже зручними структурами для роботи. У процесі виконання програми ми можемо додавати, змінювати чи видаляти елементи.

Іноді можуть виникнути ситуації, коли хочемо зберігати набір елементів без можливості змінювати його. Тому у списків існує їхній незмінний аналог - **кортежі** (`tuple`). Кортежі створюються за допомогою круглих дужок `()`, а елементи розділені комами. Кортежі не можна змінювати після створення, тобто не можна додавати, видаляти чи змінювати елементи в кортежі. Тому кортежі краще використовувати, коли треба зберігати значення, які не змінюватимуться. Наприклад, назви місяців:

```{python}
#| error: true

# створимо кортеж
months = ('January', 'February', 'March', 'April', 'May',
           'June', 'July', 'August', 'September', 'October', 'November', 'December')

# спробуємо додати тринадцятий місяць
months[12] = 'Undecimber'

# або змінити другий місяць
months[1] = 'Лютий'
```

При виконанні коду отримаємо помилку `TypeError: 'tuple' object does no support item assignment`. Помилка говорить про те, що кортеж не підтримує зміну чи додавання елементів, тому спроба привласнення нового значення елементу викликає помилку `TypeError`.

Кортежі в основному використовуються в тих місцях, де потрібна ефективність та продуктивність. Кортежі займають менше місця, ніж списки, та обробляються швидше. При цьому кортежі, як і списки, підтримують індексацію. Наприклад, якщо ми хочемо отримати назву першого місяця, можемо використовувати вже звичний запис:

```{python}
month_index = 0
month_name = months[month_index] 
print(month_name)
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-06}
<br>
Створіть кортеж із назвами днів тижня та збережіть його у змінну `days_of_the_week`.

```
'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

days_of_the_week = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')
```

:::
::::