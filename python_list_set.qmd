# Списки та множини: `list`, `set`

## Списки

**Списки** - це один з найбільш використовуваних типів даних в Python. Вони дозволяють зберігати набір значень у впорядкованому вигляді. Списки можуть містити елементи різних типів, але зазвичай вони містять елементи одного типу. Списки створюються за допомогою квадратних дужок `[]` і можуть бути порожніми або містити довільну кількість елементів. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(fruits)
```

### Індексація списків

Потренуємося працювати з індексами списків. До будь-якого елемента списку можна звернутися за його індексом. Запам'ятайте, що індексація починається з нуля.

```{python}
fruits = ['apple', 'banana', 'orange']
print(fruits[0])
```

Також ми можемо робити зрізи:

```{python}
fruits = ['apple', 'banana', 'orange']
print(fruits[0:2])
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-01}
<br>
`my_list` зберігає список як мінімум з двома елементами.

Створіть змінні:

- `first_item` з першим елементом списку.
- `last_item` з останнім елементом списку.
- `reversed_list` з елементами списку `my_list` у зворотному порядку.
- `even_items` з елементами списку `my_list` із парними індексами.

**Приклади:**

```{.powershell}
my_list = ['apple', 123, True, 3.14, 'cherry', 45, 22]

first_item = 'apple'
last_item = 22
reversed_list = [22, 45, 'cherry', 3.14, True, 123, 'apple']
even_items = ['apple', True, 'cherry', 22]
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

my_list = ['apple', 123, True, 3.14, 'cherry', 45, 22]

first_item = my_list[0]
last_item = my_list[-1]
reversed_list = my_list[::-1]
even_items = my_list[::2]
```

:::
::::



### Методи списків

Погляньмо на всі методи списку. Не треба заучувати їх напам'ять. Але якщо ви зіткнетеся із завданням, в якому треба буде щось зробити зі списком, то перед тим, як намагатися самому придумати рішення, подивіться, може бути потрібний метод.

- `append()` - додає елемент у кінець списку. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.append('melon')
print(fruits)
```

- `clear()` - видаляє всі елементи списку. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.clear()
print(fruits)
```

- `copy()` - повертає копію списку. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits_copy = fruits.copy()
print(fruits_copy)
```

- `count(item)` - повертає кількість елементів із заданим значенням. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange', 'banana']
print(fruits.count('banana'))
```

- `extend(iterable)` - додає елементи іншого списку до поточного. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.extend(['melon', 'watermelon'])
print(fruits)
```

- `index(item, start, end)` - повертає індекс першого елемента, який збігається із заданим значенням (`item`) у діапазоні індексів від `start` до `end`. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange', 'banana']
print(fruits.index('banana'))
```

- `insert(index, item)` - додає елемент `item` на позицію `index`. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.insert(1, 'melon')
print(fruits)
```

- `pop(index)` - видаляє та повертає елемент із заданим індексом. Якщо індекс не вказано, видаляє та повертає останній елемент списку. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
removed_fruit = fruits.pop(1)
print(removed_fruit)
```

- `remove(item)` - видаляє перший елемент із заданим значенням. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.remove('banana')
print(fruits)
```

- `reverse()` - змінює порядок елементів у списку на зворотній. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.reverse()
print(fruits)
```

- `sort(key, reverse)` - сортує елементи списку. Наприклад:

```{python}
fruits = ['banana', 'orange', 'apple']
fruits.sort()
print(fruits)
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-04}
<br>
У змінній `my_list` збережено не порожній список, де є число 11.

Знайдіть перший індекс числа 11 my_list, збережіть індекс в змінну `eleven_index`.

У змінну `ten_count` збережіть скільки разів у списку `my_list` зустрічається число 10.

**Приклад:**

```{{python}}
my_list = [1, 10, 0, 10, 11]
eleven_index = 4
ten_count = 2


my_list = [11, 2, 0, 6]
eleven_index = 0
ten_count = 0
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

my_list = [11, 2, 0, 6]
eleven_index = my_list.index(11)
ten_count = my_list.count(10)
```

:::
::::

::::: {.callout-note icon=false}
## Завдання
:::: {#exr-py-list-set-05}
<br>
У `student_names` збережено список з іменами студентів, додайте до списку два імені `'Anatoly'` та `'Oksana'`.

У `scores` збережено список із десяти цілих чисел, **видаліть із нього другий, п'ятий та останній елемент**.

У `lessons` збережений список з назвою уроків, відсортуйте назви уроків у списку за абеткою.

**Приклад:**

```{{python}}
student_names = ['Ian', 'Ivan']
scores = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
lessons = ['Python', 'Analytics']

# =>

student_names = ['Ian', 'Ivan', 'Anatoly', 'Oksana']
scores = [0, 2, 3, 5, 6, 7, 8, 9]
lessons = ['Analytics', 'Python']
```

::: {.callout-note collapse="true"}
## Підказка

Зверніть увагу, що потрібно видалити другий, п'ятий та останній елемент із списку. Коли ви видалили один елемент, індекси інших елементів змінились.
:::

```{python}
#| code-fold: true
#| code-summary: "Рішення"

student_names = ['Ian', 'Ivan']
student_names.append('Anatoly')
student_names.append('Oksana')

scores = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
scores.pop(1)
scores.pop(3)
scores.pop()

lessons = ['Python', 'Analytics']
lessons.sort()
```

::::
:::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-09}
<br>
Дано два списки `list_1` і `list_2`. Відсортуйте `list_1` за зростанням, а `list_2` за спаданням.
Поєднайте `list_1` та `list_2` в один відсортований за зростанням список `list_3`.
У змінну `list_3_len` збережіть довжину `list_3`.

**Приклад:**

```{{python}}
list_1 = [1, 5, 3]
list_2 = [2, 8]
# -> 
list_1 = [1, 3, 5]
list_2 = [8, 2]
list_3 = [1, 2, 3, 5, 8]
list_3_len = 5
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

list_1 = [1, 5, 3]
list_2 = [2, 8]
list_1.sort()
list_2.sort(reverse=True)
list_3 = sorted(list_1 + list_2)
list_3_len = len(list_3)
```

:::
::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-12}
<br>
У змінній `a` зберігається список цілих невід'ємних чисел. Кількість чисел парна.
Напишіть програму, яка ділитиме цей список навпіл, визначатиме суми чисел у половинах списку (`sum_left` і `sum_right`). Якщо `sum_left` дорівнює `sum_right`, то збережіть у змінну `result` значення `True`, в іншому випадку - `False`.  

**Приклад:**

```{{python}}
a = [1, 2, 4, 3]

sum_left = 3
sum_right = 7
result = False
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = [1, 2, 4, 3]
half = len(a) // 2
sum_left = sum(a[:half])
sum_right = sum(a[half:])
result = sum_left == sum_right
```

:::
::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-13}
<br>
Дано список цілих чисел `a` і число `b`. Видаліть з `a` перше й останнє входження числа `b`.  

**Приклад:**

```{{python}}
a = [1, 2, 2, 1, 3, 2, 3]
b = 1 
# -> a = [2, 2, 3, 2, 3]

a = [1, 2, 2, 1, 3, 2, 3]
b = 2 
# -> a = [1, 2, 1, 3, 3]
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = [1, 2, 2, 1, 3, 2, 3]
b = 1
a.remove(b)
a.reverse()
a.remove(b)
a.reverse()
```

:::
::::



### `pop()` vs. `remove()`

Давайте знову зупинимося на різниці цих методів. Методи `pop()` і `remove()` застосовуються для видалення елементів зі списків Python. 

- Метод `pop()` видаляє та повертає останній елемент зі списку. Якщо в дужках вказати індекс елемента, буде видалено елемент із зазначеним індексом. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
removed_fruit = fruits.pop()
print(fruits)
```

```{python}
print(removed_fruit)
```

А якщо ми хочемо видалити елемент за індексом, то потрібно вказати індекс у дужках методу:

```{python}
fruits = ['apple', 'banana', 'orange']
removed_fruit = fruits.pop(1)
print(fruits)
```

```{python}
print(removed_fruit)
```

- Метод `remove()` видаляє перший елемент зі списку, який збігається з переданим значенням. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
fruits.remove('banana')
print(fruits)
```

Важливо, що якщо у списку не буде елемента із зазначеним індексом або значенням, методи `pop()` та `remove()` повернуть помилки. Таким чином, основна відмінність між методами `pop()` і `remove()` полягає в тому, що `pop()` видаляє елемент за індексом, повертаючи його значення, а `remove()` видаляє перший знайдений елемент із заданим значенням.

## Множини

**Множини** - це набір унікальних елементів. Множини створюються за допомогою фігурних дужок `{}`. Наприклад:

```{python}
fruits = {'apple', 'apple', 'banana', 'orange'}
print(fruits)
```

### Методи множин

- `add(element)` - додає елемент до множини. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.add('melon')
print(fruits)
```

- `union(set)` - повертає об'єднання двох множин. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits2 = {'melon', 'watermelon'}
fruits3 = fruits.union(fruits2)
print(fruits3)
```

- `clear()` - видаляє всі елементи множини. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.clear()
print(fruits)
```

- `copy()` - повертає копію множини. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits_copy = fruits.copy()
print(fruits_copy)
```

- `difference(set)` - повертає різницю двох множин. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits2 = {'apple', 'melon', 'watermelon'}
fruits3 = fruits.difference(fruits2)
print(fruits3)
```

- `discard(element)` - видаляє елемент із множини, якщо він там є. Якщо елементу немає у множині, то нічого не відбувається. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.discard('apple')
print(fruits)
```

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.discard('watermelon')
print(fruits)
```

- `remove(element)` - видаляє елемент із множини, якщо він там є. Якщо елементу немає у множині, то видає помилку `KeyError`. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits.remove('apple')
print(fruits)
```

```{python}
#| error: true
fruits = {'apple', 'banana', 'orange'}
fruits.remove('watermelon')
print(fruits)
```

- `intersection(set)` - повертає перетин двох множин. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits2 = {'apple', 'melon', 'watermelon'}
fruits3 = fruits.intersection(fruits2)
print(fruits3)
```

- `isdisjoint(set)` - повертає `True`, якщо дві множини не мають спільних елементів. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange'}
fruits2 = {'melon', 'watermelon'}
print(fruits.isdisjoint(fruits2))
```

- `issubset(set)` - повертає `True`, якщо множина є підмножиною іншої множини. Наприклад:

```{python}
fruits = {'apple', 'banana', 'orange', 'watermelon'}
fruits2 = {'banana', 'orange'}
print(fruits2.issubset(fruits))
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-08}
<br>
Дано два списки `list_1` і `list_2`. Відсортуйте `list_1` за зростанням, а `list_2` за спаданням.
Поєднайте `list_1` та `list_2` в один відсортований за зростанням список `list_3`.
У змінну `list_3_len` збережіть довжину `list_3`.

**Приклад:**

```{{python}}
list_1 = [1, 5, 3]
list_2 = [2, 8]
# -> 
list_1 = [1, 3, 5]
list_2 = [8, 2]
list_3 = [1, 2, 3, 5, 8]
list_3_len = 5
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

list_1 = [1, 5, 3]
list_2 = [2, 8]

```

:::
::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-10}
<br>
У змінній `menu` зберігається множина усіх позицій меню кав'ярні, а в змінній `stop` - множина позицій меню кав'ярні, недоступних для замовлення сьогодні. Збережіть у змінну `menu_today` позиції меню, доступні для замовлення сьогодні.

**Приклад:**

```{{python}}
menu = {'White Chocolate Mocha', 'Americano', 'Flat White', 'Latte', 
        'Blueberry Muffin', 'Chocolate Chip Cookie'}
stop = {'White Chocolate Mocha', 'Blueberry Muffin'}

menu_today = {'Americano', 'Flat White', 'Latte', 'Chocolate Chip Cookie'}
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

menu = {'White Chocolate Mocha', 'Americano', 'Flat White', 'Latte', 
        'Blueberry Muffin', 'Chocolate Chip Cookie'}
stop = {'White Chocolate Mocha', 'Blueberry Muffin'}

menu_today = menu - stop
# або
menu_today = menu.difference(stop)
```

:::
::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-11}
<br>
У змінній `my_set` множина (`set`) із чисел. У змінній `to_delete` число, яке потрібно видалити з `my_set`, якщо воно там є. Якщо такого числа немає в `my_set` нічого робити не треба.

**Приклад:**

```{{python}}
my_set = {0, 10, 100}
to_delete = 0
# ====>
my_set = {10, 100} # видалили 0

my_set = {0, 10, 100}
to_delete = -2
# ====>
my_set = {0, 10, 100} # нічого не робили

```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

my_set = {0, 10, 100}
to_delete = 0
my_set.discard(to_delete)
```

:::
::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-12}
<br>
У `students` зберігається множина студентів. Студент, ім'я якого записано в `new_student`, з іншого інституту, його ім'я потрібно додати в `students`. У змінній `churn_student` - студент, який хоче перевестися до іншого інституту, його ім'я потрібно прибрати зі `students`. 

**Приклад:**

```{{python}}
students = {'Крупін Владислав', 'Крашеніннікова Олександра', "Михолап Мар'яна", 'Дробина Юлія', 'Алексєєва Віталіна'}
new_student = 'Піщікова Катерина'
churn_student = "Михолап Мар'яна"
# ->
students = {'Крупін Владислав', 'Крашеніннікова Олександра', 'Дробина Юлія', 'Алексєєва Віталіна', 'Піщікова Катерина'}
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

students = {'Крупін Владислав', 'Крашеніннікова Олександра', 'Михолап Мар\'яна', 'Дробина Юлія', 'Алексєєва Віталіна'}
new_student = 'Піщікова Катерина'
churn_student = 'Михолап Мар\'яна'
students.add(new_student)
students.discard(churn_student)
# або
# students.remove(churn_student)
```

:::
::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-13}
<br>
У змінній `da_students` зберігаються імена студентів курсу "Аналітик даних", а у змінній `dv_students` - імена студентів курсу "Візуалізація даних". Збережіть у змінну `students` студентів, які навчаються на обох курсах.

Порядок елементів у `students` не має значення.

**Приклад:**

```{{python}}
# студенти курсу "Аналітик даних"
da_students = {'Крупін Владислав', 'Крашеніннікова Олександра', "Михолап Мар'яна", 'Дробина Юлія'}
# студенти курсу "Візуалізація даних"
dv_students = {"Михолап Мар'яна", 'Дробина Юлія', 'Алексєєва Віталіна'}

# результат
students = {"Михолап Мар'яна", 'Дробина Юлія'}
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

da_students = {'Крупін Владислав', 'Крашеніннікова Олександра', "Михолап Мар'яна", 'Дробина Юлія'}
dv_students = {"Михолап Мар'яна", 'Дробина Юлія', 'Алексєєва Віталіна'}
students = da_students & dv_students
# або
students = da_students.intersection(dv_students)
# або
students = da_students - dv_students
```

:::
::::

### Frozenset {#sec-frozenset}

У множини теж є незмінний аналог. **Frozenset** - це незмінний набір об'єктів, він має ту ж функціональність, що і `set`, але його елементи не можуть бути змінені після створення.

```{python}
my_frozenset = frozenset([1, 2, 3])
print(my_frozenset)
```

На старті ви не так часто зіштовхуватиметеся з `frozenset`, але чим глибше ви занурюватиметеся в розробку, тим вище ймовірність, що ви зустрінетеся з `frozenset` при роботі з множинами.

Зараз нам просто корисно знати, що існує незмінний аналог множин, надалі ми ще повернемося до `frozenset` і продемонструємо кілька прикладів його використання.

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-07}
<br>
- У змінній `numbers_list` збережено список із цілими числами. У списку щонайменше два різних цілих числа.
- У змінну `numbers_list_ordered` збережіть усі числа зі списку `numbers_list`, відсортовані за спаданням. При цьому список `numbers_list` не повинен змінюватися.
- У змінну `numbers_set` збережіть множину унікальних чисел зі списку `numbers_list`. Доповніть цю множину наступним цілим числом після максимального числа з `numbers_list`.
- У змінну `numbers_frozenset` збережіть незмінну множину з усіх унікальних чисел зі списку `numbers_list`, крім мінімального числа.

**Приклад:**

```{{python}}
# Приклад 1
numbers_list = [1, 5, 3, 3, 5]

numbers_list_ordered = [5, 5, 3, 3, 1]
numbers_set = set([1, 3, 5, 6])
numbers_frozenset = frozenset([3, 5])
```

```{{python}}
# Приклад 2
numbers_list = [-1, 0, 1]

numbers_list_ordered = [1, 0, -1]
numbers_set = set([-1, 0, 1, 2])
numbers_frozenset = frozenset([0, 1])
```

```{{python}}
# Приклад 3
numbers_list [-1, -5, -1]

numbers_list_ordered = [-1, -1, -5]
numbers_set = set([-5, -1, 0])
numbers_frozenset = frozenset([-1])
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

numbers_list = [1, 1, 5, 3, 3, 5]
numbers_list_ordered = sorted(numbers_list, reverse=True)
numbers_set = set(numbers_list)
numbers_set.add(max(numbers_list) + 1)
numbers_frozenset = frozenset(sorted(set(numbers_list))[1:]) 
```

:::
::::

## Корисні функції

Також давайте подивимося на різні функції, які допомагають нам працювати зі списками та множинами:

- `len()` - повертає кількість елементів у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(len(fruits))
```

```{python}
fruits = {'apple', 'banana', 'banana', 'apple'}
print(len(fruits))
```

- `max()` - повертає найбільший елемент у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(max(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(max(numbers))
```

```{python}
my_set = {5, 2, 8, 1, 8}
print(max(my_set))
```

- `min()` - повертає найменший елемент у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(min(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(min(numbers))
```

- `sorted()` - повертає відсортований список або множину. Вона може приймати параметр `reverse=True`, щоб відсортувати послідовність у зворотному порядку (за спаданням). Наприклад:

```{python}
fruits = ['banana', 'orange', 'apple']
print(sorted(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(sorted(numbers, reverse=True))
```

А от якщо відсортувати множину, то вийде список!

```{python}
my_set = {1, 1, 2, 2}
print(sorted(my_set))
```

### range()

Функція `range()` дозволяє створити послідовність чисел.

```
range(start, stop, step)
# start - з цього числа починаємо за замовчуванням 0
# stop - кінець послідовності, але саме число stop не включено до результату.
# step - крок переходу між числами за замовчуванням 1
```

Функція дозволяє нам генерувати послідовність цілих чисел із заданим початком, кінцем та кроком. Після виконання функція повертає спеціальний тип даних – `range`. Для зручнішої роботи з послідовністю можна перевести `range` до списку. Обов'язково потрібно вказати лише аргумент `stop`, початок та крок за умовчанням дорівнюють `0` і `1` відповідно. Розглянемо приклади:

```{python}
# від 0 до 4 з кроком 1
list(range(5))
```

```{python}
# від 2 до 9 з кроком 2
list(range(2, 10, 2))
```

```{python}
# від 10 до 2 з кроком 1
list(range(10, 1, -1))
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-02}
<br>
У змінну `var_1` збережіть список з числами **від -100 до 100 включно з кроком 1**.

У змінну var_2 збережіть список з числами **від 250 до 0 включно з кроком 2**.

У змінну var_3 збережіть список з усіма **непарними числами від 100 до 200**.


```{python}
#| code-fold: true
#| code-summary: "Рішення"

var_1 = list(range(-100, 101, 1))
var_2 = list(range(250, -1, -2))
var_3 = list(range(101, 200, 2))
```

:::
::::

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-03}
<br>
У змінних `a` та `b` зберігаються числа - початок і кінець діапазону. Напишіть програму, яка поверне суму всіх чисел із цього діапазону. Збережіть значення змінної `result`.

**Приклад:**

```{{python}}
a = 1
b = 3 

result = 6
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = 1
b = 3
result = sum(range(a, b + 1))
```

:::
::::

## Змінювані та незмінювані об'єкти {#sec-mutable-immutable}

Настав час розібратися з досить складною для початківців концепцією змінних і незмінних об'єктів у Python. Ми вже знаємо, що можемо змінювати створені списки, наприклад, замінити або видалити один із елементів у списку. Однак ця особливість списку, його змінність призводить до несподіваних на перший погляд наслідків:

```{python}
# збережемо список у змінну my_list_1
my_list_1 = [3, 1, 2]

# у змінну my_list_2 збережемо список my_list_1
my_list_2 = my_list_1

# змінимо список my_list_1
my_list_1.append(4)
my_list_1.sort()
my_list_1[0] = 100

# подивимося на обидва списки
print("Результат списку my_list_1:", my_list_1)
print("Результат списку my_list_2:", my_list_2)
```

Дивно, адже ми відсортували лише перший список, але другий також змінився! Вся справа в тому, що списки, масиви та словники — це об'єкти, що змінюються. Замість того, щоб створити ще одну коробочку в пам'яті з ім'ям `my_list_2` та покласти в неї список із коробочки `my_list_1`, Python просто запам'ятав, що тепер на вихідну коробочку посилаються дві змінні. Коли змінюємо список `my_list_1`, змінюється і `my_list_2`. І навпаки, при зміні `my_list_2` зміниться і `my_list_1`.

Саме тому список має метод `copy()`. Він дозволяє створити копію першого списку у новій змінній. У такому разі зміни першого списку вже не вплинуть на копію цього списку.

```{python}
# збережемо список у змінну my_list_1
my_list_1 = [3, 1, 2]

# у змінну my_list_2 збережемо список my_list_1 з методом copy()
my_list_2 = my_list_1.copy()

# змінимо список my_list_1
my_list_1.append(4)
my_list_1.sort()
my_list_1[0] = 100

# подивимося на обидва списки
print("Результат списку my_list_1:", my_list_1)
print("Результат списку my_list_2:", my_list_2)
```

Тому при роботі з об'єктами в Python важливо розуміти, чи змінюємо ми вихідний об'єкт чи створюємо новий. Уважно читайте документацію функцій та методів. Припустимо, ми маємо список `my_list`, ми хочемо завести новий список `my_list_ordered` з відсортованими елементами зі списку `my_list`:

```{python}
my_list = [1, 2, 3, -2]

# так правильно
my_list_ordered = sorted(my_list) # функція sorted повертає новий список, не змінює список my_list
print("Результат списку my_list_ordered:", my_list_ordered)
print("Результат списку my_list:", my_list)
```

```{python}
#| include: false

del my_list_ordered
```

```{python}
# так неправильно
my_list_ordered = my_list.sort() # метод sort нічого не повертає, а лише змінює список my_list
print("Результат списку my_list_ordered:", my_list_ordered)
print("Результат списку my_list:", my_list)
```

А ось вже знайомі нам числа `int` і `float`, рядки та логічні значення - це незмінні об'єкти. Тобто після створення об'єкта не можна змінити його значення, лише створити новий об'єкт із зміненим значенням.

## Кортежі

Незважаючи на деякі підводні камені, можливість змінювати списки та множини робить їх дуже зручними структурами для роботи. У процесі виконання програми ми можемо додавати, змінювати чи видаляти елементи.

Іноді можуть виникнути ситуації, коли хочемо зберігати набір елементів без можливості змінювати його. Тому у списків існує їхній незмінний аналог - **кортежі** (`tuple`). Кортежі створюються за допомогою круглих дужок `()`, а елементи розділені комами. Кортежі не можна змінювати після створення, тобто не можна додавати, видаляти чи змінювати елементи в кортежі. Тому кортежі краще використовувати, коли треба зберігати значення, які не змінюватимуться. Наприклад, назви місяців:

```{python}
#| error: true

# створимо кортеж
months = ('January', 'February', 'March', 'April', 'May',
           'June', 'July', 'August', 'September', 'October', 'November', 'December')

# спробуємо додати тринадцятий місяць
months[12] = 'Undecimber'

# або змінити другий місяць
months[1] = 'Лютий'
```

При виконанні коду отримаємо помилку `TypeError: 'tuple' object does no support item assignment`. Помилка говорить про те, що кортеж не підтримує зміну чи додавання елементів, тому спроба привласнення нового значення елементу викликає помилку `TypeError`.

Кортежі в основному використовуються в тих місцях, де потрібна ефективність та продуктивність. Кортежі займають менше місця, ніж списки, та обробляються швидше. При цьому кортежі, як і списки, підтримують індексацію. Наприклад, якщо ми хочемо отримати назву першого місяця, можемо використовувати вже звичний запис:

```{python}
month_index = 0
month_name = months[month_index] 
print(month_name)
```

:::: {.callout-note icon=false}
## Завдання
::: {#exr-py-list-set-06}
<br>
Створіть кортеж із назвами днів тижня та збережіть його у змінну `days_of_the_week`.

```
'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

days_of_the_week = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')
```

:::
::::

## Функція `zip()` для об'єднання послідовностей {#sec-list-zip}

Дуже часто нам доводиться працювати одразу з двома наборами даних, наприклад, з двома списками або множинами. Функція `zip()` у Python об'єднує елементи з декількох послідовностей. Давайте розглянемо приклад:

```{python}
x = [1, 2, 3]
y = ['a', 'b', 'c']

# Використовуємо функцію zip() для об'єднання елементів із двох списків
result = zip(x, y)

# Перетворюємо результат на список
result_list = list(result)

print(result_list)
```

У цьому прикладі ми створюємо два списки `x` і `y`, що містять числа і букви відповідно. Потім ми використовуємо функцію `zip()` для об'єднання елементів із цих двох списків. Результатом є складніший тип даних, але ми легко можемо перейти до вже знайомого нам формату за допомогою функції `list()`. 

Зараз важливо запам'ятати, що за допомогою зв'язки `list(zip(x, y))` ми можемо швидко й ефективно об'єднувати кілька списків.

Важливо зазначити, що результат `zip()` матиме довжину, що дорівнює довжині найкоротшої з вихідних послідовностей. Якщо довжини послідовностей відрізняються, то зайві елементи будуть проігноровані. Функція `zip()` може використовуватися в таких ситуаціях, як ітерація за кількома послідовностями одночасно або поєднання елементів з декількох списків.