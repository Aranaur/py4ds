# Додаткові матеріали

## Множини

Поміж різних типів даних у Python є ще один, який ми ще не мали нагоди використати, а саме множина. У математиці множина - це набір значень, в якому немає повторень. В Python **множина** (англ. *set*) - це структура даних, що містить унікальні елементи. Множини створюються за допомогою фігурних дужок `{}`.

Повернемося до прикладу `houses.py`, де ми створили список словників з даними про студентів Гоґвортсу:

```{python}
#| label: houses-py

students = [
        {'name': 'Гаррі Поттер', 'house': 'Ґрифіндор'},
        {'name': 'Герміона Грейнджер', 'house': 'Ґрифіндор'},
        {'name': 'Рон Уізлі', 'house': 'Ґрифіндор'},
        {'name': 'Драко Малфой', 'house': 'Слизерин'},
        {'name': 'Том Реддл', 'house': 'Слизерин'},
        {'name': 'Седрик Діггорі', 'house': 'Гафелпаф'},
        {'name': 'Луна Лавґуд', 'house': 'Рейвенклов'}
]
```

Припустимо, що наша мета --- з'ясувати унікальні гуртожитки в Гоґвортсі у світі Гаррі Поттера?

Перший підхід, який приходить на думку, це створити список унікальних гуртожитків, переглянути всіх студентів та додати гуртожиток до списку, якщо його там ще немає:

```{python}
#| label: houses-py-unique-houses

unique_houses = []
for student in students:
    if student['house'] not in unique_houses:
        unique_houses.append(student['house'])

print(unique_houses)
```

Другий підхід - використати множину за допомогою функції `set()`. Множина автоматично видаляє усі повторення, тому ми можемо просто створити множину з усіх гуртожитків:

```{python}
#| label: houses-py-unique-houses-set

unique_houses = set()
for student in students:
    unique_houses.add(student['house'])

print(unique_houses)
```

::: callout-note
Документацію по різним типам даних Python можна знайти за посиланням <https://docs.python.org/3/library/stdtypes.html>.
:::

### Методи множин

Множини мають ряд методів, які дозволяють виконувати різні операції з множинами. Розглянемо декілька з них

- `add(element)` - додає елемент до множини:

```{python}
#| label: set-add

students = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students.add('Драко Малфой')

print(students)
```

- `union(set)` - повертає об'єднання двох множин:

```{python}
#| label: set-union

students1 = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students2 = {'Драко Малфой', 'Том Реддл'}
all_students = students1.union(students2)

print(all_students)
```

- `clear()` - видаляє всі елементи множини:

```{python}
#| label: set-clear

students = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students.clear()

print(students)
```

- `copy()` - повертає копію множини:

```{python}
#| label: set-copy

students = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students2 = students.copy()

print(students2)
```

- `difference(set)` - повертає різницю двох множин:

```{python}
#| label: set-difference

students1 = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students2 = {'Гаррі Поттер', 'Рон Уізлі'}
students3 = students1.difference(students2)

print(students3)
```

- `discard(element)` - видаляє елемент із множини, якщо він там є. Якщо елементу немає у множині, то нічого не відбувається:

```{python}
#| label: set-discard

students = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students.discard('Гаррі Поттер')

print(students)
```

```{python}
#| label: set-discard-2

students = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students.discard('Драко Малфой')

print(students)
```

- `remove(element)` - видаляє елемент із множини, якщо він там є. Якщо елементу немає у множині, то видає помилку `KeyError`:

```{python}
#| label: set-remove

students = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students.remove('Гаррі Поттер')

print(students)
```

```{python}
#| label: set-remove-2
#| error: true

students = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students.remove('Драко Малфой')

print(students)
```

- `intersection(set)` - повертає перетин двох множин:

```{python}
#| label: set-intersection

students1 = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students2 = {'Гаррі Поттер', 'Рон Уізлі'}
students3 = students1.intersection(students2)

print(students3)
```

- `isdisjoint(set)` - повертає `True`, якщо дві множини не мають спільних елементів. Наприклад:

```{python}
#| label: set-isdisjoint

students1 = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}
students2 = {'Драко Малфой', 'Том Реддл'}

print(students1.isdisjoint(students2))
```

- `issubset(set)` - повертає `True`, якщо множина є підмножиною іншої множини. Наприклад:

```{python}
#| label: set-issubset

students1 = {'Гаррі Поттер', 'Герміона Грейнджер'}
students2 = {'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'}

print(students1.issubset(students2))
```

### Frozenset {#sec-frozenset}

У множини теж є незмінний аналог. **Frozenset** - це незмінний набір об'єктів, він має ту ж функціональність, що і `set`, але його елементи не можуть бути змінені після створення.

```{python}
#| label: frozenset

students = frozenset({'Гаррі Поттер', 'Герміона Грейнджер', 'Рон Уізлі'})
print(students)
```

На старті ви не так часто зіштовхуватиметеся з `frozenset`, але чим глибше ви занурюватиметеся в розробку, тим вище ймовірність, що ви зустрінетеся з `frozenset` при роботі з множинами.

::: callout-note
Документацію по `frozenset` Python можна знайти за посиланням <https://docs.python.org/3/library/stdtypes.html#frozenset>.
:::

## Глобальні змінні

У Python є можливість створювати змінні, які будуть доступні в усій програмі. Такі змінні називаються **глобальними**. Глобальні змінні можна створити за межами будь-якої функції, але вони будуть доступні в усій програмі. Для створення глобальної змінної потрібно використати ключове слово `global`.

Для прикладу створимо програму `bank.py`, яка буде відслідковувати баланс рахунку. Спочатку баланс рахунку буде дорівнювати 0:

```{python}
#| label: bank-py

balance = 0

def main():
    print("Баланс рахунку:", balance)

if __name__ == "__main__":
    main()
```

Навіть якщо ви оголосите змінну в Python поза межами ваших функцій ви можете отримати до неї доступ. 

Тепер давайте додамо функції, які дозволить збільшувати та зменшувати баланс рахунку:

```{python}
#| label: bank-py-2

balance = 0

def increase_balance(amount):
    global balance
    balance += amount

def decrease_balance(amount):
    global balance
    balance -= amount

def main():
    increase_balance(100)
    decrease_balance(50)
    print("Баланс рахунку:", balance)

if __name__ == "__main__":
    main()
```



## Корисні функції

Також давайте подивимося на різні функції, які допомагають нам працювати зі списками та множинами:

- `len()` - повертає кількість елементів у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(len(fruits))
```

```{python}
fruits = {'apple', 'banana', 'banana', 'apple'}
print(len(fruits))
```

- `max()` - повертає найбільший елемент у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(max(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(max(numbers))
```

```{python}
my_set = {5, 2, 8, 1, 8}
print(max(my_set))
```

- `min()` - повертає найменший елемент у списку або множині. Наприклад:

```{python}
fruits = ['apple', 'banana', 'orange']
print(min(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(min(numbers))
```

- `sorted()` - повертає відсортований список або множину. Вона може приймати параметр `reverse=True`, щоб відсортувати послідовність у зворотному порядку (за спаданням). Наприклад:

```{python}
fruits = ['banana', 'orange', 'apple']
print(sorted(fruits))
```

```{python}
numbers = [5, 2, 8, 1, 9]
print(sorted(numbers, reverse=True))
```

А от якщо відсортувати множину, то вийде список!

```{python}
my_set = {1, 1, 2, 2}
print(sorted(my_set))
```

### range()

Функція `range()` дозволяє створити послідовність чисел.

```
range(start, stop, step)
# start - з цього числа починаємо за замовчуванням 0
# stop - кінець послідовності, але саме число stop не включено до результату.
# step - крок переходу між числами за замовчуванням 1
```

Функція дозволяє нам генерувати послідовність цілих чисел із заданим початком, кінцем та кроком. Після виконання функція повертає спеціальний тип даних – `range`. Для зручнішої роботи з послідовністю можна перевести `range` до списку. Обов'язково потрібно вказати лише аргумент `stop`, початок та крок за умовчанням дорівнюють `0` і `1` відповідно. Розглянемо приклади:

```{python}
# від 0 до 4 з кроком 1
list(range(5))
```

```{python}
# від 2 до 9 з кроком 2
list(range(2, 10, 2))
```

```{python}
# від 10 до 2 з кроком 1
list(range(10, 1, -1))
```

:::: question
::: {#exr-py-list-set-02}
<br>
У змінну `var_1` збережіть список з числами **від -100 до 100 включно з кроком 1**.

У змінну var_2 збережіть список з числами **від 250 до 0 включно з кроком 2**.

У змінну var_3 збережіть список з усіма **непарними числами від 100 до 200**.


```{python}
#| code-fold: true
#| code-summary: "Рішення"

var_1 = list(range(-100, 101, 1))
var_2 = list(range(250, -1, -2))
var_3 = list(range(101, 200, 2))
```

:::
::::

:::: question
::: {#exr-py-list-set-03}
<br>
У змінних `a` та `b` зберігаються числа - початок і кінець діапазону. Напишіть програму, яка поверне суму всіх чисел із цього діапазону. Збережіть значення змінної `result`.

**Приклад:**

```{{python}}
a = 1
b = 3 

result = 6
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

a = 1
b = 3
result = sum(range(a, b + 1))
```

:::
::::

## Змінювані та незмінювані об'єкти {#sec-mutable-immutable}

Настав час розібратися з досить складною для початківців концепцією змінних і незмінних об'єктів у Python. Ми вже знаємо, що можемо змінювати створені списки, наприклад, замінити або видалити один із елементів у списку. Однак ця особливість списку, його змінність призводить до несподіваних на перший погляд наслідків:

```{python}
# збережемо список у змінну my_list_1
my_list_1 = [3, 1, 2]

# у змінну my_list_2 збережемо список my_list_1
my_list_2 = my_list_1

# змінимо список my_list_1
my_list_1.append(4)
my_list_1.sort()
my_list_1[0] = 100

# подивимося на обидва списки
print("Результат списку my_list_1:", my_list_1)
print("Результат списку my_list_2:", my_list_2)
```

Дивно, адже ми відсортували лише перший список, але другий також змінився! Вся справа в тому, що списки, масиви та словники — це об'єкти, що змінюються. Замість того, щоб створити ще одну коробочку в пам'яті з ім'ям `my_list_2` та покласти в неї список із коробочки `my_list_1`, Python просто запам'ятав, що тепер на вихідну коробочку посилаються дві змінні. Коли змінюємо список `my_list_1`, змінюється і `my_list_2`. І навпаки, при зміні `my_list_2` зміниться і `my_list_1`.

Саме тому список має метод `copy()`. Він дозволяє створити копію першого списку у новій змінній. У такому разі зміни першого списку вже не вплинуть на копію цього списку.

```{python}
# збережемо список у змінну my_list_1
my_list_1 = [3, 1, 2]

# у змінну my_list_2 збережемо список my_list_1 з методом copy()
my_list_2 = my_list_1.copy()

# змінимо список my_list_1
my_list_1.append(4)
my_list_1.sort()
my_list_1[0] = 100

# подивимося на обидва списки
print("Результат списку my_list_1:", my_list_1)
print("Результат списку my_list_2:", my_list_2)
```

Тому при роботі з об'єктами в Python важливо розуміти, чи змінюємо ми вихідний об'єкт чи створюємо новий. Уважно читайте документацію функцій та методів. Припустимо, ми маємо список `my_list`, ми хочемо завести новий список `my_list_ordered` з відсортованими елементами зі списку `my_list`:

```{python}
my_list = [1, 2, 3, -2]

# так правильно
my_list_ordered = sorted(my_list) # функція sorted повертає новий список, не змінює список my_list
print("Результат списку my_list_ordered:", my_list_ordered)
print("Результат списку my_list:", my_list)
```

```{python}
#| include: false

del my_list_ordered
```

```{python}
# так неправильно
my_list_ordered = my_list.sort() # метод sort нічого не повертає, а лише змінює список my_list
print("Результат списку my_list_ordered:", my_list_ordered)
print("Результат списку my_list:", my_list)
```

А ось вже знайомі нам числа `int` і `float`, рядки та логічні значення - це незмінні об'єкти. Тобто після створення об'єкта не можна змінити його значення, лише створити новий об'єкт із зміненим значенням.

## Кортежі

Незважаючи на деякі підводні камені, можливість змінювати списки та множини робить їх дуже зручними структурами для роботи. У процесі виконання програми ми можемо додавати, змінювати чи видаляти елементи.

Іноді можуть виникнути ситуації, коли хочемо зберігати набір елементів без можливості змінювати його. Тому у списків існує їхній незмінний аналог - **кортежі** (`tuple`). Кортежі створюються за допомогою круглих дужок `()`, а елементи розділені комами. Кортежі не можна змінювати після створення, тобто не можна додавати, видаляти чи змінювати елементи в кортежі. Тому кортежі краще використовувати, коли треба зберігати значення, які не змінюватимуться. Наприклад, назви місяців:

```{python}
#| error: true

# створимо кортеж
months = ('January', 'February', 'March', 'April', 'May',
           'June', 'July', 'August', 'September', 'October', 'November', 'December')

# спробуємо додати тринадцятий місяць
months[12] = 'Undecimber'

# або змінити другий місяць
months[1] = 'Лютий'
```

При виконанні коду отримаємо помилку `TypeError: 'tuple' object does no support item assignment`. Помилка говорить про те, що кортеж не підтримує зміну чи додавання елементів, тому спроба привласнення нового значення елементу викликає помилку `TypeError`.

Кортежі в основному використовуються в тих місцях, де потрібна ефективність та продуктивність. Кортежі займають менше місця, ніж списки, та обробляються швидше. При цьому кортежі, як і списки, підтримують індексацію. Наприклад, якщо ми хочемо отримати назву першого місяця, можемо використовувати вже звичний запис:

```{python}
month_index = 0
month_name = months[month_index] 
print(month_name)
```

:::: question
::: {#exr-py-list-set-06}
<br>
Створіть кортеж із назвами днів тижня та збережіть його у змінну `days_of_the_week`.

```
'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

days_of_the_week = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')
```

:::
::::

## Функція `zip()` для об'єднання послідовностей {#sec-list-zip}

Дуже часто нам доводиться працювати одразу з двома наборами даних, наприклад, з двома списками або множинами. Функція `zip()` у Python об'єднує елементи з декількох послідовностей. Давайте розглянемо приклад:

```{python}
x = [1, 2, 3]
y = ['a', 'b', 'c']

# Використовуємо функцію zip() для об'єднання елементів із двох списків
result = zip(x, y)

# Перетворюємо результат на список
result_list = list(result)

print(result_list)
```

У цьому прикладі ми створюємо два списки `x` і `y`, що містять числа і букви відповідно. Потім ми використовуємо функцію `zip()` для об'єднання елементів із цих двох списків. Результатом є складніший тип даних, але ми легко можемо перейти до вже знайомого нам формату за допомогою функції `list()`. 

Зараз важливо запам'ятати, що за допомогою зв'язки `list(zip(x, y))` ми можемо швидко й ефективно об'єднувати кілька списків.

Важливо зазначити, що результат `zip()` матиме довжину, що дорівнює довжині найкоротшої з вихідних послідовностей. Якщо довжини послідовностей відрізняються, то зайві елементи будуть проігноровані. Функція `zip()` може використовуватися в таких ситуаціях, як ітерація за кількома послідовностями одночасно або поєднання елементів з декількох списків.

## Завдання

:::: question
::: {#exr-py-list-set-08}
<br>
Дано два списки `list_1` і `list_2`. Відсортуйте `list_1` за зростанням, а `list_2` за спаданням.
Поєднайте `list_1` та `list_2` в один відсортований за зростанням список `list_3`.
У змінну `list_3_len` збережіть довжину `list_3`.

**Приклад:**

```{{python}}
list_1 = [1, 5, 3]
list_2 = [2, 8]
# -> 
list_1 = [1, 3, 5]
list_2 = [8, 2]
list_3 = [1, 2, 3, 5, 8]
list_3_len = 5
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

list_1 = [1, 5, 3]
list_2 = [2, 8]

```

:::
::::

:::: question
::: {#exr-py-list-set-10}
<br>
У змінній `menu` зберігається множина усіх позицій меню кав'ярні, а в змінній `stop` - множина позицій меню кав'ярні, недоступних для замовлення сьогодні. Збережіть у змінну `menu_today` позиції меню, доступні для замовлення сьогодні.

**Приклад:**

```{{python}}
menu = {'White Chocolate Mocha', 'Americano', 'Flat White', 'Latte', 
        'Blueberry Muffin', 'Chocolate Chip Cookie'}
stop = {'White Chocolate Mocha', 'Blueberry Muffin'}

menu_today = {'Americano', 'Flat White', 'Latte', 'Chocolate Chip Cookie'}
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

menu = {'White Chocolate Mocha', 'Americano', 'Flat White', 'Latte', 
        'Blueberry Muffin', 'Chocolate Chip Cookie'}
stop = {'White Chocolate Mocha', 'Blueberry Muffin'}

menu_today = menu - stop
# або
menu_today = menu.difference(stop)
```

:::
::::

:::: question
::: {#exr-py-list-set-11}
<br>
У змінній `my_set` множина (`set`) із чисел. У змінній `to_delete` число, яке потрібно видалити з `my_set`, якщо воно там є. Якщо такого числа немає в `my_set` нічого робити не треба.

**Приклад:**

```{{python}}
my_set = {0, 10, 100}
to_delete = 0
# ====>
my_set = {10, 100} # видалили 0

my_set = {0, 10, 100}
to_delete = -2
# ====>
my_set = {0, 10, 100} # нічого не робили

```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

my_set = {0, 10, 100}
to_delete = 0
my_set.discard(to_delete)
```

:::
::::

:::: question
::: {#exr-py-list-set-12}
<br>
У `students` зберігається множина студентів. Студент, ім'я якого записано в `new_student`, з іншого інституту, його ім'я потрібно додати в `students`. У змінній `churn_student` - студент, який хоче перевестися до іншого інституту, його ім'я потрібно прибрати зі `students`. 

**Приклад:**

```{{python}}
students = {'Крупін Владислав', 'Крашеніннікова Олександра', "Михолап Мар'яна", 'Дробина Юлія', 'Алексєєва Віталіна'}
new_student = 'Піщікова Катерина'
churn_student = "Михолап Мар'яна"
# ->
students = {'Крупін Владислав', 'Крашеніннікова Олександра', 'Дробина Юлія', 'Алексєєва Віталіна', 'Піщікова Катерина'}
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

students = {'Крупін Владислав', 'Крашеніннікова Олександра', 'Михолап Мар\'яна', 'Дробина Юлія', 'Алексєєва Віталіна'}
new_student = 'Піщікова Катерина'
churn_student = 'Михолап Мар\'яна'
students.add(new_student)
students.discard(churn_student)
# або
# students.remove(churn_student)
```

:::
::::

:::: question
::: {#exr-py-list-set-13}
<br>
У змінній `da_students` зберігаються імена студентів курсу "Аналітик даних", а у змінній `dv_students` - імена студентів курсу "Візуалізація даних". Збережіть у змінну `students` студентів, які навчаються на обох курсах.

Порядок елементів у `students` не має значення.

**Приклад:**

```{{python}}
# студенти курсу "Аналітик даних"
da_students = {'Крупін Владислав', 'Крашеніннікова Олександра', "Михолап Мар'яна", 'Дробина Юлія'}
# студенти курсу "Візуалізація даних"
dv_students = {"Михолап Мар'яна", 'Дробина Юлія', 'Алексєєва Віталіна'}

# результат
students = {"Михолап Мар'яна", 'Дробина Юлія'}
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

da_students = {'Крупін Владислав', 'Крашеніннікова Олександра', "Михолап Мар'яна", 'Дробина Юлія'}
dv_students = {"Михолап Мар'яна", 'Дробина Юлія', 'Алексєєва Віталіна'}
students = da_students & dv_students
# або
students = da_students.intersection(dv_students)
# або
students = da_students - dv_students
```

:::
::::

:::: question
::: {#exr-py-list-set-07}
<br>
- У змінній `numbers_list` збережено список із цілими числами. У списку щонайменше два різних цілих числа.
- У змінну `numbers_list_ordered` збережіть усі числа зі списку `numbers_list`, відсортовані за спаданням. При цьому список `numbers_list` не повинен змінюватися.
- У змінну `numbers_set` збережіть множину унікальних чисел зі списку `numbers_list`. Доповніть цю множину наступним цілим числом після максимального числа з `numbers_list`.
- У змінну `numbers_frozenset` збережіть незмінну множину з усіх унікальних чисел зі списку `numbers_list`, крім мінімального числа.

**Приклад:**

```{{python}}
# Приклад 1
numbers_list = [1, 5, 3, 3, 5]

numbers_list_ordered = [5, 5, 3, 3, 1]
numbers_set = set([1, 3, 5, 6])
numbers_frozenset = frozenset([3, 5])
```

```{{python}}
# Приклад 2
numbers_list = [-1, 0, 1]

numbers_list_ordered = [1, 0, -1]
numbers_set = set([-1, 0, 1, 2])
numbers_frozenset = frozenset([0, 1])
```

```{{python}}
# Приклад 3
numbers_list [-1, -5, -1]

numbers_list_ordered = [-1, -1, -5]
numbers_set = set([-5, -1, 0])
numbers_frozenset = frozenset([-1])
```

```{python}
#| code-fold: true
#| code-summary: "Рішення"

numbers_list = [1, 1, 5, 3, 3, 5]
numbers_list_ordered = sorted(numbers_list, reverse=True)
numbers_set = set(numbers_list)
numbers_set.add(max(numbers_list) + 1)
numbers_frozenset = frozenset(sorted(set(numbers_list))[1:]) 
```

:::
::::