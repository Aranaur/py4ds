---
engine: knitr
---

# Об'єктно-орієнтоване програмування

У світі програмування існують різні парадигми мов програмування - різні способи вирішення проблем за допомогою коду. Це трохи важко побачити спочатку, якщо ви вивчили лише одну мову. Але з часом, якщо і коли ви вивчите інші мови, окрім Python, ви почнете помічати певні закономірності і певні можливості одних мов, але не інших. Досі у світі Python ми з вами здебільшого писали процедурний код, тобто писали процедури, писали функції і робили все зверху донизу. Все відбувається крок за кроком, як і можна було б очікувати від алгоритму. Але на цьому шляху ми спробували ще одну парадигму, відому як *функціональне програмування* за допомогою Python, завдяки якій ми змогли передавати функції по колу.

Цього разу ми зосередимося на іншій парадигмі, і розглянемо її більш детально, а саме на **об'єктно-орієнтованому програмуванні (ООП)**. Можливо дехто з вас вже мали досвід програмування і вивчали такі мови, як Java, які за своєю суттю є об'єктно-орієнтованими, Python дійсно дозволяє вам бути більш гнучкими, коли мова йде про те, як ви вирішуєте проблеми за допомогою коду. Але виявляється, що ООП, об'єктно-орієнтоване програмування, є досить переконливим рішенням проблем, з якими ви незмінно стикаєтесь, коли ваші програми стають довшими, більшими та складнішими. 

## Використання структур даних

### Кортежі

Почнемо з простого прикладу і потрошку будемо додавати все нові і нові функції. Подивимось, чи не призведе це до труднощів. 

Для початку створимо програму `student.py`, яка буде приймати ім'я та гуртожиток студента у світі Гарі Поттера:

```{.bash filename="Terminal"}
code student.py
```

```{python}
#| label: student-py
#| eval: false

name = input("Ім'я: ")
house = input("Гуртожиток: ")

print(f"{name} з {house}")
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Грифіндор

Гаррі з Грифіндор
```

Раніше ми навчилися використовувати власні функції. Використаємо функціональний підхід і створимо функції `get_name()` та `get_house()`, які будуть повертати ім'я та гуртожиток студента відповідно:

```{python}
#| label: student-py-2
#| eval: false

def main():
    name = get_name()
    house = get_house()
    print(f"{name} з {house}")

def get_name():
    return input("Ім'я: ")

def get_house():
    return input("Гуртожиток: ")

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Грифіндор

Гаррі з Грифіндор
```

Розвиваючи та узагальнюючи цей код, мо можемо створити функцію `get_student()`, яка буде повертати ім'я та гуртожиток студента:

```{python}
#| label: student-py-3
#| eval: false

def main():
    name, house = get_student() #<<
    print(f"{name} з {house}")

def get_student(): #<<
    name = input("Ім'я: ") #<<
    house = input("Гуртожиток: ") #<<
    return name, house # це одне значення, якє є кортежем #<<

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Грифіндор

Гаррі з Грифіндор
```

Насправді, коли ми повертаємо значення з функції, ми повертаємо кортеж (англ. *tuple*) - один з типів даних Python, який дуже схожий на список, але він **не може бути змінений**. Це означає, що ми можемо використовувати кортежі, якщо ми хочемо повернути кілька значень з функції. І навіть записати їх у дужках, що інтуїтивно буде вказувати на використання кортежу: `return (name, house)`.

Ми можемо не розпаковувати кортеж в окремі змінні, а замість цього використовувати індексацію, щоб отримати доступ до значень у кортежі:

```{python}
#| label: student-py-4
#| eval: false

def main():
    student = get_student() #<<
    print(f"{student[0]} з {student[1]}") #<<

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return name, house

if __name__ == "__main__":
    main()
```

Для демонстрації незмінності кортежів, спробуємо змінити значення у кортежі через умовні оператори, для цього введемо умову, що якщо ім'я студента - Падма, то змінимо її гуртожиток на Рейвенкло:

```{python}
#| label: student-py-5
#| eval: false

def main():
    student = get_student()
    if student[0] == "Падма": #<<
        student[1] = "Рейвенклов" #<<
    print(f"{student[0]} з {student[1]}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return (name, house)

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Падма
Гуртожиток: Грифіндор

TypeError: 'tuple' object does not support item assignment
```

Якщо ми передбачаємо можливість змінити значення у кортежі, то ми можемо використати список замість кортежу: 

```{python}
#| label: student-py-6
#| eval: false

def main():
    student = get_student()
    if student[0] == "Падма":
        student[1] = "Рейвенклов"
    print(f"{student[0]} з {student[1]}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return [name, house] #<<

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Падма
Гуртожиток: Грифіндор

Падма з Рейвенклов
```

### Словники

Задачу з введенням ім'я та гуртожитку можна вирішити через словник:

```{python}
#| label: student-py-7
#| eval: false

def main():
    student = get_student()
    print(f"{student['name']} з {student['house']}")

def get_student():
    student = {} #<<
    student['name'] = input("Ім'я: ") #<<
    student['house'] = input("Гуртожиток: ") #<<
    return student

if __name__ == "__main__":
    main()
```

Нам не обов'язково створювати пустий словник, ми можемо одразу повертати словник з ім'ям та гуртожитком:

```{python}
#| label: student-py-8
#| eval: false

def main():
    student = get_student()
    print(f"{student['name']} з {student['house']}")

def get_student():
    return { #<<
        'name': input("Ім'я: "), #<<
        'house': input("Гуртожиток: ") #<<
    } #<<

if __name__ == "__main__":
    main()
```

Якщо ми захочемо враховувати можливість змінити гуртожиток, якщо ім'я студента - Падма, то ми можемо використати умовний оператор:

```{python}
#| label: student-py-9
#| eval: false

def main():
    student = get_student()
    if student['name'] == "Падма": #<<
        student['house'] = "Рейвенклов" #<<
    print(f"{student['name']} з {student['house']}")

def get_student():
    return {
        'name': input("Ім'я: "),
        'house': input("Гуртожиток: ")
    }

if __name__ == "__main__":
    main()
```

На невеликих прикладах все виглядає досить просто. Уявіть, що в перспективі з'явиться необхідність додати більше інформації про студента: патронус, магічні здібності, тощо. Було б значно зручніше, якби Python дозволяв нам створювати власні типи даних, які могли б містити інформацію про студента. І це можливо завдяки об'єктно-орієнтованому програмуванню.

## Класи

**Класи** (англ. *classes*) - це щось на зразок шаблону, який дозволяє створювати власні типи даних, давати їм імена.

Для створення класу використовується ключове слово `class`, за яким слідує ім'я класу, а потім двокрапка. Ім'я класу повинно починатися з великої літери, а якщо ім'я складається з декількох слів, то кожне слово повинно починатися з великої літери. Наприклад, `Student`: 

```{python}
#| label: student-class-1
#| eval: false

class Student:
    ...
```

::: {.callout-note}
Документація до класів Python: <https://docs.python.org/3/tutorial/classes.html>
:::

Для того, щоб наша програма почала використовувати клас, ми повинні створити екземпляр класу, тобто об'єкт. Це можна зробити, використовуючи ім'я класу, за яким слідує дужка. Наприклад, `Student()`.

Класи мають **атрибути** (англ. *attributes*), свого роду властивості, які дозволяють вам вказувати значення всередині них. Для того, щоб вказати атрибут, використовується крапка, за якою слідує ім'я атрибуту. Наприклад, `student.name`:

```{python}
#| label: student-class-2
#| eval: false

class Student:
    ...
    
def main():
    student = get_student()
    print(f"{student.name} з {student.house}")

def get_student():
    student = Student()
    student.name = input("Ім'я: ")
    student.house = input("Гуртожиток: ")
    return student

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Грифіндор

Гаррі з Грифіндор
```

Введемо ще одну термінологію. Ми створили клас за допомогою ключового слова `class`, але коли ми створюємо екземпляр класу, ми створюємо **об'єкт** (англ. *object*). Таким чином, об'єкт - це екземпляр класу. Якщо говорити метафорично, то клас - це план будинку, а об'єкт - це будинок, побудований за цим планом.

Давайте додамо більше функціональності нашому класу. Досить нерозважливо просто вставляти все що завгодно всередину класу. Класи можна стандартизувати - вказувати якими можуть бути атрибути і які значення вони можуть приймати. Давайте всередині функції `get_student()` створимо локальні змінні `name` та `house`, а потім використаємо їх для створення екземпляру класу `Student`:

```{python}
#| label: student-class-3
#| eval: false

class Student:
    ...

def main():
    student = get_student()
    print(f"{student.name} з {student.house}")

def get_student():
    name = input("Ім'я: ") #<<
    house = input("Гуртожиток: ") #<<
    student = Student(name, house) #<<
    return student

if __name__ == "__main__":
    main()
```

Зараз, коли ми готуємось до більш потужних можливостей класів та об'єктно-орієнтованого програмування в цілому. Зверніть увагу, що ми передаємо локальні змінні `name` та `house` класу `Student`, як аргументи функції, але він поки не знає, що з ними робити. Зараз ми стандартизуємо цей клас, щоб він знав, що робити з цими аргументами. Це дасть можливість перевіряти ці дані на помилки, які можуть виникнути, коли користувач вводить неправильні дані.

Тепер перейдемо до класу `Student`, який до цього часу мав три крапки. У контексті класів є ряд не тільки атрибутів або змінних екземпляра, які ви можете помістити всередину, але і методи (анг. *methods*). Класи поставляються з певними методами або функціями всередині, які ви можете визначити, і вони просто поводяться особливим чином за природою того, як працює Python. Ці функції дозволяють вам визначати поведінку у стандартний спосіб. Для цього використовується ключове слово `def`, за яким слідує ім'я методу, а потім дужки. Наприклад, `__init__()`:

```{python}
#| label: student-class-4
#| eval: false

class Student:
    def __init__(self, name, house): #<<
        self.name = name #<<
        self.house = house #<<

def main():
    student = get_student()
    print(f"{student.name} з {student.house}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    student = Student(name, house)
    return student

if __name__ == "__main__":
    main()
```

В такому випадку ми визначаємо метод `__init__()`, який викликається, коли ми створюємо екземпляр класу. Це називається **конструктором** (англ. *constructor*). Він викликається автоматично, коли ми створюємо екземпляр класу. Він приймає аргумент `self`, який вказує на екземпляр класу, а також інші аргументи, які ми передаємо, коли створюємо екземпляр класу. В нашому випадку це `name` та `house`. Ми використовуємо `self.name` та `self.house`, щоб вказати, що ці атрибути належать екземпляру класу. Це дозволяє нам використовувати ці атрибути всередині класу.

Насправді, нам не потрібна змінна `student` у функції `get_student()`, оскільки ми можемо повернути екземпляр класу `Student`:

```{python}
#| label: student-class-5
#| eval: false

class Student:
    def __init__(self, name, house):
        self.name = name
        self.house = house

def main():
    student = get_student()
    print(f"{student.name} з {student.house}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return Student(name, house) #<<

if __name__ == "__main__":
    main()
```

А що, якщо щось піде не так при створенні студента? Наприклад, якщо користувач не дасть нам ім'я і просто натисне клавішу Enter, коли з'явиться запит на введення імені? Або введе некоректну назву гуртожитку. Для цього ми можемо змінити метод `__init__()` так, щоб він перевіряв правильність введення даних. Для цього ми можемо використати ключове слово `raise`, яке дозволяє викидати помилки. Наприклад, `raise ValueError()`:

```{python}
#| label: student-class-6
#| eval: false

class Student:
    def __init__(self, name, house):
        if not name: #<<
            raise ValueError("Ім'я не може бути порожнім") #<<
        if house not in ["Ґрифіндор", "Гафелпаф", "Рейвенклов", "Слизерин"]: #<<
            raise ValueError("Неправильний гуртожиток") #<<
        self.name = name
        self.house = house

def main():
    student = get_student()
    print(f"{student.name} з {student.house}")

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return Student(name, house)

if __name__ == "__main__":
    main()
```

Перевіримо роботу програми:

```{.bash filename="Terminal"}

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Ґрифіндор

Гаррі з Ґрифіндор
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: вул. Тисова, 4

ValueError: Неправильний гуртожиток
```

## Метод `__str__`

Повернемось до функції `main()`, де ми друкуємо ім'я студента та його гуртожиток вручну через звернення до об'єкту `student.name` та `student.house`. Було б чудово, якби ми могли просто викликати метод `print()` і передати об'єкт `student` як аргумент, і він сам вивів би ім'я та гуртожиток:

```{python}
#| label: student-class-7
#| eval: false

class Student:
    def __init__(self, name, house):
        if not name:
            raise ValueError("Ім'я не може бути порожнім")
        if house not in ["Ґрифіндор", "Гафелпаф", "Рейвенклов", "Слизерин"]:
            raise ValueError("Неправильний гуртожиток")
        self.name = name
        self.house = house

def main():
    student = get_student()
    print(student) #<<

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return Student(name, house)

if __name__ == "__main__":
    main()
```

Але в такому випадку ми отримаємо адресу об'єкту у пам'яті комп'ютера, а не ім'я та гуртожиток:

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Ґрифіндор

<__main__.Student object at 0x7f9b1c0b5d30>
```

Але ми можемо змінити це, якщо визначимо метод `__str__()` у класі `Student`:

```{python}
#| label: student-class-8
#| eval: false

class Student:
    def __init__(self, name, house):
        if not name:
            raise ValueError("Ім'я не може бути порожнім")
        if house not in ["Ґрифіндор", "Гафелпаф", "Рейвенклов", "Слизерин"]:
            raise ValueError("Неправильний гуртожиток")
        self.name = name
        self.house = house

    def __str__(self): #<<
        return f"{self.name} з {self.house}" #<<

def main():
    student = get_student()
    print(student)

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return Student(name, house)

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Ґрифіндор

Гаррі з Ґрифіндор
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Драко
Гуртожиток: Слизерин

Драко з Слизерин
```

## Власні методи

Давайте подивимося, чи можемо ми зберігати не лише ім'я студента та його гуртожиток, але й його Патронус[^patronus], тобто те, що насправді він викликає, коли використовує це закляття.

[^patronus]: Патронус (англ. Patronus, від лат. Patronus - захисник) - магічна сутність, яка викликається заклинанням.

Додамо до аргументів методу `__init__()` ще один аргумент `patronus`. Поки не будемо перейматися правильністю введення даних і просто присвоїмо значення атрибуту `self.patronus` та запросимо його у функції `main()`:

```{python}
#| label: student-class-9
#| eval: false

class Student:
    def __init__(self, name, house, patronus): #<<
        if not name:
            raise ValueError("Ім'я не може бути порожнім")
        if house not in ["Ґрифіндор", "Гафелпаф", "Рейвенклов", "Слизерин"]:
            raise ValueError("Неправильний гуртожиток")
        self.name = name
        self.house = house
        self.patronus = patronus #<<

    def __str__(self):
        return f"{self.name} з {self.house}"

def main():
    student = get_student()
    print(student)

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    patronus = input("Патронус: ") #<<
    return Student(name, house, patronus) #<<

if __name__ == "__main__":
    main()
```

Припустимо, що тепер ми хочемо мати функціональність, а не тільки для ініціалізації студента і роздруківки студента. Якщо наш клас дійсно призначений для роботи зі студентами, ми можемо не просто запам'ятовувати інформацію про студентів. На відміну від словників, класи можуть мати не лише змінні або змінні екземплярів, так би мовити, атрибути, які ми постійно створюємо, а й вбудовані функції. Вони також можуть мати вбудовані функції, так звані методи. Коли функція знаходиться всередині класу, вона називається методом. Але це все ще просто функція.

На даний момент ми вже бачили два методи, які називаються `__init__` і `__str__`. Але це особливі методи, тому що вони працюють, тільки якщо ви їх визначите. Python викликає їх автоматично за вас. Але якщо ви хочете створити більше функціональності для студента, наприклад, використовувати магічні здібності, то ви можете визначити власні методи. Для цього використовується ключове слово `def`, за яким слідує ім'я методу, а потім дужки. Наприклад, `charm()`. Давайте одразу реалізуємо цей метод так, щоб він повертав емодзі зображення Патронуса:

```{python}
#| label: student-class-10
#| eval: false

class Student:
    def __init__(self, name, house, patronus):
        if not name:
            raise ValueError("Ім'я не може бути порожнім")
        if house not in ["Ґрифіндор", "Гафелпаф", "Рейвенклов", "Слизерин"]:
            raise ValueError("Неправильний гуртожиток")
        self.name = name
        self.house = house
        self.patronus = patronus

    def __str__(self):
        return f"{self.name} з {self.house}"

    def charm(self): #<<
        match self.patronus: #<<
            case "Олень": #<<
                return "🦌" #<<
            case "Видра": #<<
                return "🦦" #<<
            case "Тер'єр": #<<
                return "🐕" #<<
            case _: #<<
                return "🪄" #<<

def main():
    student = get_student()
    print("Expecto Patronum!") #<<
    print(student.charm()) #<<

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    patronus = input("Патронус: ")
    return Student(name, house, patronus)

if __name__ == "__main__":
    main()
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Гаррі
Гуртожиток: Ґрифіндор
Патронус: Олень

Expecto Patronum!
🦌
```

```{.bash filename="Terminal"}
python student.py
Ім'я: Драко
Гуртожиток: Слизерин
Патронус: 

Expecto Patronum!
🪄
```

## Наслідування

Для спрощення подальшого викладення матеріалу, я видалю все що пов'язане з Патронусами:

```{python}
#| label: student-class-11
#| eval: false

class Student:
    def __init__(self, name, house):
        if not name:
            raise ValueError("Ім'я не може бути порожнім")
        if house not in ["Ґрифіндор", "Гафелпаф", "Рейвенклов", "Слизерин"]:
            raise ValueError("Неправильний гуртожиток")
        self.name = name
        self.house = house

    def __str__(self):
        return f"{self.name} з {self.house}"

def main():
    student = get_student()
    print(student)

def get_student():
    name = input("Ім'я: ")
    house = input("Гуртожиток: ")
    return Student(name, house)

if __name__ == "__main__":
    main()
```


            


