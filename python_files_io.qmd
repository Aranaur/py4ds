# Введення/виведення файлів

До цього часу більшість програм, які ми писали, просто зберігали всю інформацію в пам'яті, тобто в змінних або всередині самої програми. Недоліком цього є те, що як тільки програма завершує роботу, все, що ви ввели, все, що ви робили з цією програмою, втрачається.

Використовуючи файли, ви можете зберігати інформацію довгостроково, і введення/виведення файлів (англ. *file I/O*) в контексті програмування - це написання коду, який може читати з файлів, тобто завантажувати інформацію з них, або записувати до них, тобто зберігати інформацію у самих файлах.

## Запис даних

Для початку пропоную розглянути знайому структуру даних, яку ми бачили раніше - `list`.

Створимо програму `names.py`, яка буде зберігати імена у списку, а потім виводити їх на екран:

```{.bash filename="Terminal"}
code names.py
```

```{python}
#| label: io-names-eval
#| eval: false

name = input("Як Вас звати? ")
print(f'Привіт, {name}!')
```

Припустімо, що ми хочемо додати підтримку збереження декількох імен, наприклад трьох. Для цього ми можемо використати список. Для цього необхідно створити пустий список `names` і додавати (`append`) до нього імена, які вводить користувач. Вивід імен відсортуємо за алфавітом:

```{python}
#| label: io-names-list-eval
#| eval: false

names = []

for _ in range(3):
    names.append(input("Як Вас звати? "))

for name in sorted(names):
    print(f'Привіт, {name}!')
```

```{.output}
Як Вас звати? Гаррі
Як Вас звати? Рон
Як Вас звати? Герміона
Привіт, Гаррі!
Привіт, Герміона!
Привіт, Рон!
```

Звичайно, якщо я запущу цю програму ще раз, всі імена пропадуть. Було б непогано мати можливість якось зберігати цю інформацію. І саме тут з'являється ввід-вивід файлів, і саме тут з'являються файли.

Давайте перепишемо нашу програму так, щоб вона зберігала імена у файлі `names.txt`. Для цього нам необхідно відкрити файл, використовуючи функцію `open` - ця функція приймає два аргументи: ім'я файлу і режим відкриття.

Режим відкриття може бути:

- `r` (англ. *read*) - читання, це режим за замовчуванням.
- `w` (англ. *write*) - запис, цей режим перезаписує файл.
- `a` (англ. *append*) - дописування, цей режим додає дані до файлу.

 Якщо файл не існує, то він буде створений. Давайте перепишемо нашу програму з використанням функції `open`:

```{python}
#| label: io-names-list-file-eval
#| eval: false

name = input("Як Вас звати? ")

file = open('names.txt', 'w')
file.write(name)
file.close()
```

Запустимо цю програму і перевіримо, чи вона працює:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Гаррі
code names.txt
```

Відкриємо створений файл:

```{.bash filename="names.txt"}
Гаррі
```

Все працює! Тепер давайте виконаємо цю програму ще раз, але цього разу введемо ім'я `Рон`:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Рон
code names.txt
```

Відкриємо створений файл:

```{.bash filename="names.txt"}
Рон
```

Як бачимо, файл перезаписався, і тепер в ньому знаходиться тільки ім'я `Рон`. Якщо ми хочемо додати ім'я до файлу, а не перезаписати його, то використовуйте режим `a`.

Видаліть файл `names.txt` і давайте перепишемо нашу програму так, щоб вона дописувала імена до файлу `names.txt`:

```{.bash filename="Terminal"}
rm names.txt
remove names.txt? y
```

```{python}
#| label: io-names-list-file-append-eval
#| eval: false

name = input("Як Вас звати? ")

file = open('names.txt', 'a')
file.write(name)
file.close()
```

Запустимо цю програму і перевіримо, чи вона працює:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Герміона
code names.txt
```

```{.bash filename="names.txt"}
Герміона
```

Запустимо програму ще раз і спробуємо додати ім'я `Гаррі` та `Рон`:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Гаррі
python names.py
Як Вас звати? Рон
code names.txt
```

```{.bash filename="names.txt"}
ГерміонаГарріРон
```

Зовсім не той результат, який ми очікували. Імена записалися в один рядок. Це тому, що функція `write` не додає символ переносу рядка (`\n`) після запису імені. Щоб це виправити, ми можемо додати символ переносу рядка після запису імені:

```{.bash filename="Terminal"}
rm names.txt
remove names.txt? y
```

```{python}
#| label: io-names-append-newline-eval
#| eval: false

name = input("Як Вас звати? ")

file = open('names.txt', 'a')
file.write(name + '\n')
file.close()
```

Запустимо цю програму:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Герміона
python names.py
Як Вас звати? Гаррі
python names.py
Як Вас звати? Рон
code names.txt
```

```{.bash filename="names.txt"}
Герміона
Гаррі
Рон

```

::: {.callout-note}
Документація до функції `open`: <https://docs.python.org/3/library/functions.html#open>
:::

## Контекстний менеджер

Під час написання коду дуже легко забути закрити файли і це може стати проблемою. Тому ми можемо піти більш безпечним шляхом і використовувати контекстний менеджер. 

**Контекстний менеджер** - це спеціальна конструкція мови Python, яка дозволяє виконувати певні дії до входу в блок коду і після виходу з блоку коду. Для використання контекстного менеджера використовується ключове слово `with`. Давайте перепишемо нашу програму з використанням контекстного менеджера:

```{python}
#| label: io-names-list-file-with-eval
#| eval: false

name = input("Як Вас звати? ")

with open('names.txt', 'a') as file:
    file.write(name + '\n')
```

Такий підхід не змінює функціональність програми, але є більш пітоничним.

## Читання даних

Для читання у функції `open` використовується режим `r`. Давайте створимо програму `names_read.py`, яка буде читати імена з файлу `names.txt` і виводити їх на екран:

```{.bash filename="Terminal"}
code names_read.py
```

Для читання використаємо метод `readlines`, яка повертає список рядків, які містяться у файлі. Цей метод повертає список, тому ми можемо використати цикл `for` для виведення імен на екран. Також слід врахувати, що метод `readlines` повертає список, в якому кожен рядок містить символ переносу рядка (`\n`). Щоб цього уникнути, ми можемо використати метод `rstrip`, який видаляє символ переносу рядка з кінця рядка:

```{python}
#| label: io-names-list-file-read-eval
#| eval: false

with open('names.txt', 'r') as file:
    lines = file.readlines()

for line in lines:
    print(f'Привіт, {line.rstrip()}!')
```

```{.output}
Привіт, Герміона!
Привіт, Гаррі!
Привіт, Рон!
```

Але у попередньому прикладі ми двічі проходимось по всьому файлу: спочатку ми читаємо його у список, а потім виводимо список на екран. Це не є найкращим рішенням, оскільки ми можемо витратити багато пам'яті, якщо файл дуже великий. Тому ми можемо використати цикл `for` безпосередньо для читання файлу:

```{python}
#| label: io-names-list-file-read-eval-2
#| eval: false

with open('names.txt', 'r') as file:
    for line in file:
        print(f'Привіт, {line.rstrip()}!')
```

```{.output}
Привіт, Герміона!
Привіт, Гаррі!
Привіт, Рон!
```

Тепер трошки ускладнимо задачу. Припустимо, що ми хочемо виводити привітання у алфавітному порядку. Для цього нам необхідно відсортувати список імен. Для цього ми можемо використати функцію `sorted`, яка повертає відсортований список. Давайте перепишемо нашу програму з використанням функції:

```{python}
#| label: io-names-list-file-read-sort-eval
#| eval: false

names = []

with open('names.txt', 'r') as file:
    for line in file:
        names.append(line.rstrip())

for name in sorted(names):
    print(f'Привіт, {name}!')
```

```{.output}
Привіт, Гаррі!
Привіт, Герміона!
Привіт, Рон!
```

Ми можемо зробити цю програму більш компактною. Для цього ми можемо відсортувати сам файл:

```{python}
#| label: io-names-list-file-read-sort-eval-2
#| eval: false

with open('names.txt', 'r') as file:
    for line in sorted(file):
        print(f'Привіт, {line.rstrip()}!')
```

```{.output}
Привіт, Гаррі!
Привіт, Герміона!
Привіт, Рон!
```

Для зворотного сортування ми можемо використати параметр `reverse` функції `sorted`:

```{python}
#| label: io-names-list-file-read-sort-reverse-eval
#| eval: false

with open('names.txt', 'r') as file:
    for line in sorted(file, reverse=True):
        print(f'Привіт, {line.rstrip()}!')
```

```{.output}
Привіт, Рон!
Привіт, Герміона!
Привіт, Гаррі!
```

::: {.callout-note}
Документація до функції `sorted`: <https://docs.python.org/3/library/functions.html#sorted>
:::

## Файли csv

Файли csv (англ. *comma-separated values*, значення, розділені комами) - це файли, які містять дані у вигляді таблиці, де значення розділені комами. Давайте створимо файл `students.csv`:

```{.bash filename="Terminal"}
code students.csv
```

Запишемо у нього імена і додамо гуртожиток:

```{.csv}
Гаррі,Гріфіндор
Герміона,Гріфіндор
Рон,Гріфіндор
Драко,Слизерин
```

Тепер давайте створимо програму `students.py`, яка буде читати цей файл.

```{.bash filename="Terminal"}
code students.py
```

Отже, в нас є імені і гуртожитки, які розділені комами. Це означає, що ми можемо використати метод `split` для розділення рядка на частини. Давайте перепишемо нашу програму з використанням методу `split`:

```{python}
#| label: io-csv-eval
#| eval: false

with open('students.csv', 'r') as file:
    for line in file:
        row = line.rstrip().split(',')
        print(f'{row[0]} живе в гуртожитку {row[1]}')
```

```{.output}
Гаррі живе в гуртожитку Гріфіндор
Герміона живе в гуртожитку Гріфіндор
Рон живе в гуртожитку Гріфіндор
Драко живе в гуртожитку Слизерин
```

Коли у вас є змінна, яка є списком, наприклад `row`, вам не обов'язково переносити всі ці змінні у окремий список. Ви можете розпакувати всю послідовність одразу. Іншими словами, якщо ви знаєте, що функція типу `split` повертає список, який містить два елементи, ви можете розпакувати цей список у дві змінні:

```{python}
#| label: io-csv-unpack-eval
#| eval: false

with open('students.csv', 'r') as file:
    for line in file:
        name, house = line.rstrip().split(',')
        print(f'{name} живе в гуртожитку {house}')
```

```{.output}
Гаррі живе в гуртожитку Гріфіндор
Герміона живе в гуртожитку Гріфіндор
Рон живе в гуртожитку Гріфіндор
Драко живе в гуртожитку Слизерин
```

Уявімо, що я хочу відсортувати цей список даних. Для цього я можу використати функцію `sorted` і вказати, що я хочу сортувати за другим елементом списку:

```{python}
#| label: io-csv-sorted-eval
#| eval: false

students_lst = []

with open('students.csv', 'r') as file:
    for line in file:
        name, house = line.rstrip().split(',')
        students_lst.append(f'{name} живе в гуртожитку {house}')

for student in sorted(students_lst):
    print(student)
```

```{.output}
Драко живе в гуртожитку Слизерин
Гаррі живе в гуртожитку Гріфіндор
Герміона живе в гуртожитку Гріфіндор
Рон живе в гуртожитку Гріфіндор
```

З технічної точки зору, це працює, але це не є найкращим рішенням, оскільки дані сортуються по цілому реченню. Ми можемо вирішити таку задачу за допомогою словників. Для цього нам необхідно створити пустий словник `student_dict` і додавати до нього інформацію про студентів. Давайте перепишемо нашу програму з використанням словників:

```{python}
#| label: io-csv-dict-eval
#| eval: false

students_lst = []

with open('students.csv', 'r') as file:
    for line in file:
        name, house = line.rstrip().split(',')
        student_dict = {}
        student_dict['name'] = name
        student_dict['house'] = house
        students_lst.append(student_dict)

for student in students_lst:
    print(f'{student["name"]} живе в гуртожитку {student["house"]}')
```

Ми можемо скоротити код шляхом присвоєння значень словнику одразу:

```{python}
#| label: io-csv-dict-eval-2
#| eval: false

students_lst = []

with open('students.csv', 'r') as file:
    for line in file:
        name, house = line.rstrip().split(',')
        student_dict = {'name': name, 'house': house}
        students_lst.append(student_dict)

for student in students_lst:
    print(f'{student["name"]} живе в гуртожитку {student["house"]}')
```

Але результат все ще не відсортований. Функція `sorted` приймає параметр `key`, який вказує, за яким ключем сортувати. Для цього ми можемо використати функцію `get_name`, яка повертає ім'я студента і використаємо її як параметр `key`:

```{python}
#| label: io-csv-dict-sorted-eval
#| eval: false

students_lst = []

with open('students.csv', 'r') as file:
    for line in file:
        name, house = line.rstrip().split(',')
        student_dict = {'name': name, 'house': house}
        students_lst.append(student_dict)

def get_name(student):
    return student['name']

for student in sorted(students_lst, key=get_name):
    print(f'{student["name"]} живе в гуртожитку {student["house"]}')
```

```{.output}
Драко живе в гуртожитку Слизерин
Гаррі живе в гуртожитку Гріфіндор
Герміона живе в гуртожитку Гріфіндор
Рон живе в гуртожитку Гріфіндор
```

Якщо ж я захочу відсортувати за гуртожитком у зворотному порядку, то я можу використати функцію `get_house` і додати параметр `reverse=True` у функцію `sorted`:

```{python}
#| label: io-csv-dict-sorted-eval-2
#| eval: false

students_lst = []

with open('students.csv', 'r') as file:
    for line in file:
        name, house = line.rstrip().split(',')
        student_dict = {'name': name, 'house': house}
        students_lst.append(student_dict)

def get_house(student):
    return student['house']

for student in sorted(students_lst, key=get_house, reverse=True):
    print(f'{student["name"]} живе в гуртожитку {student["house"]}')
```

```{.output}
Драко живе в гуртожитку Слизерин
Гаррі живе в гуртожитку Гріфіндор
Герміона живе в гуртожитку Гріфіндор
Рон живе в гуртожитку Гріфіндор
```

::: {.callout-warning}
Зверніть увагу, що в якості аргументу `key` функції `sorted` ми передаємо функцію `get_house`, **без дужок**. Ми хочемо передати функцію, а не викликати її.
:::








