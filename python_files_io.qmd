# Введення/виведення файлів

До цього часу більшість програм, які ми писали, просто зберігали всю інформацію в пам'яті, тобто в змінних або всередині самої програми. Недоліком цього є те, що як тільки програма завершує роботу, все, що ви ввели, все, що ви робили з цією програмою, втрачається.

Використовуючи файли, ви можете зберігати інформацію довгостроково, і введення/виведення файлів (англ. *file I/O*) в контексті програмування - це написання коду, який може читати з файлів, тобто завантажувати інформацію з них, або записувати до них, тобто зберігати інформацію у самих файлах.

## Запис даних

Для початку пропоную розглянути знайому структуру даних, яку ми бачили раніше - `list`.

Створимо програму `names.py`, яка буде зберігати імена у списку, а потім виводити їх на екран:

```{.bash filename="Terminal"}
code names.py
```

```{python}
#| label: io-names-eval
#| eval: false

name = input("Як Вас звати? ")
print(f'Привіт, {name}!')
```

Припустімо, що ми хочемо додати підтримку збереження декількох імен, наприклад трьох. Для цього ми можемо використати список. Для цього необхідно створити пустий список `names` і додавати (`append`) до нього імена, які вводить користувач. Вивід імен відсортуємо за алфавітом:

```{python}
#| label: io-names-list-eval
#| eval: false

names = []

for _ in range(3):
    names.append(input("Як Вас звати? "))

for name in sorted(names):
    print(f'Привіт, {name}!')
```

```{.output}
Як Вас звати? Гаррі
Як Вас звати? Рон
Як Вас звати? Герміона
Привіт, Гаррі!
Привіт, Герміона!
Привіт, Рон!
```

Звичайно, якщо я запущу цю програму ще раз, всі імена пропадуть. Було б непогано мати можливість якось зберігати цю інформацію. І саме тут з'являється ввід-вивід файлів, і саме тут з'являються файли.

Давайте перепишемо нашу програму так, щоб вона зберігала імена у файлі `names.txt`. Для цього нам необхідно відкрити файл, використовуючи функцію `open` - ця функція приймає два аргументи: ім'я файлу і режим відкриття. Режим відкриття може бути `r` (англ. *read*, читання), `w` (англ. *write*, запис) або `a` (англ. *append*, дописування). Якщо файл не існує, то він буде створений. Якщо файл існує, то він буде перезаписаний. Якщо ви хочете дописати щось до файлу, то використовуйте режим `a`:

```{python}
#| label: io-names-list-file-eval
#| eval: false

name = input("Як Вас звати? ")

file = open('names.txt', 'w')
file.write(name)
file.close()
```

Запустимо цю програму і перевіримо, чи вона працює:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Гаррі
code names.txt
```

Відкриємо створений файл:

```{.bash filename="names.txt"}
Гаррі
```

Все працює! Тепер давайте виконаємо цю програму ще раз, але цього разу введемо ім'я `Рон`:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Рон
code names.txt
```

Відкриємо створений файл:

```{.bash filename="names.txt"}
Рон
```

Як бачимо, файл перезаписався, і тепер в ньому знаходиться тільки ім'я `Рон`. Якщо ми хочемо додати ім'я до файлу, а не перезаписати його, то використовуйте режим `a`.

Видаліть файл `names.txt` і давайте перепишемо нашу програму так, щоб вона дописувала імена до файлу `names.txt`:

```{.bash filename="Terminal"}
rm names.txt
remove names.txt? y
```

```{python}
#| label: io-names-list-file-append-eval
#| eval: false

name = input("Як Вас звати? ")

file = open('names.txt', 'a')
file.write(name)
file.close()
```

Запустимо цю програму і перевіримо, чи вона працює:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Герміона
code names.txt
```

```{.bash filename="names.txt"}
Герміона
```

Запустимо програму ще раз і спробуємо додати ім'я `Гаррі` та `Рон`:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Гаррі
python names.py
Як Вас звати? Рон
code names.txt
```

```{.bash filename="names.txt"}
ГерміонаГарріРон
```

Зовсім не той результат, який ми очікували. Імена записалися в один рядок. Це тому, що функція `write` не додає символ переносу рядка (`\n`) після запису імені. Щоб це виправити, ми можемо додати символ переносу рядка після запису імені:

```{.bash filename="Terminal"}
rm names.txt
remove names.txt? y
```

```{python}
#| label: io-names-append-newline-eval
#| eval: false

name = input("Як Вас звати? ")

file = open('names.txt', 'a')
file.write(name + '\n')
file.close()
```

Запустимо цю програму:

```{.bash filename="Terminal"}
python names.py
Як Вас звати? Герміона
python names.py
Як Вас звати? Гаррі
python names.py
Як Вас звати? Рон
code names.txt
```

```{.bash filename="names.txt"}
Герміона
Гаррі
Рон

```

::: {.callout-note}
Документація до функції `open`: <https://docs.python.org/3/library/functions.html#open>
:::

## Контекстний менеджер

Під час написання коду дуже легко забути закрити файли і це може стати проблемою. Тому ми можемо піти більш безпечним шляхом і використовувати контекстний менеджер. 

**Контекстний менеджер** - це спеціальна конструкція мови Python, яка дозволяє виконувати певні дії до входу в блок коду і після виходу з блоку коду. Для використання контекстного менеджера використовується ключове слово `with`. Давайте перепишемо нашу програму з використанням контекстного менеджера:

```{python}
#| label: io-names-list-file-with-eval
#| eval: false

name = input("Як Вас звати? ")

with open('names.txt', 'a') as file:
    file.write(name + '\n')
```

Такий підхід не змінює функціональність програми, але є більш пітоничним.

## Читання даних







