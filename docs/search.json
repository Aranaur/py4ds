[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python та його друзі в науці про дані",
    "section": "",
    "text": "Вступне слово\n\n\n\n\n\n\nВажливо\n\n\n\nЦя книга знаходиться на стадії розробки.\n\n\nШановні читачі,\nЗапрошую до книги “Python та його друзі в науці про дані”! Сьогодні ми відкриваємо двері до захоплюючого світу аналізу даних та наукових досліджень, в якому Python стає вашим найкращим другом. Завдяки своїй простоті, гнучкості та потужності, Python виходить за межі звичайної мови програмування, перетворюючись на незамінного помічника для розв’язання складних задач і виявлення прихованих закономірностей.\nУ цій книзі ми збираємося подорожувати у світі науки про дані, де Python та інші дотичні інструменти стають невід’ємною частиною процесу відкриття знань та розуміння складних систем. Ви дізнаєтеся, як за допомогою Python можна ефективно обробляти, аналізувати та візуалізувати дані, виявляти закономірності та робити передбачення. Завдяки цим інструментам ви зможете розкрити потужний потенціал ваших даних та прийняти обґрунтовані рішення на основі наукових фактів.\nЯ запрошую вас на цю захоплюючу подорож, де ми разом з вами розкриємо секрети Python у науці про дані. Незалежно від вашого досвіду в програмуванні або знань про науку про дані, ця книга надасть вам необхідні знання та інструменти для успішного впровадження Python у ваші проекти. Будьте впевнені, що по закінченні цього шляху ви будете готові до викликів, які стоять перед вами у світі науки та досліджень.\nНехай ця книга стане вашим надійним провідником у справжньому дослідницькому пригоді, де Python та його друзі стають вашими найкращими союзниками. Розпочнемо нашу подорож разом!\nЗ найкращими побажаннями, Ігор Мірошниченко"
  },
  {
    "objectID": "sql.html#схема-бази-даних",
    "href": "sql.html#схема-бази-даних",
    "title": "SQL",
    "section": "Схема бази даних",
    "text": "Схема бази даних\nУ цьому розділі ми будемо використовувати набори даних, які представляють сервіс з доставки продуктів. Тут зберігається документація, котра допоможе розібратися з ними.\nДля запуску бази даних, я використовую DuckDB. Самі файли з даними можна знайти в репозиторії. Для локального запуску бази даних необхідно виконати наступний код:\n\n\nКод\n# Встановлення та імпорт необхідних пакетів\n!pip install --quiet duckdb\n!pip install --quiet jupysql \n!pip install --quiet duckdb-engine\n!pip install --quiet pandas\n!pip install --quiet matplotlib\n\nimport duckdb\nimport pandas as pd\n\n# Імпорт Jupyter-розширення jupysql для створення SQL комірок\n%load_ext sql\n\n# Налаштування jupysql, щоб дані поверталися у вигляді DataFrame Pandas з меншим виводом\n%config SqlMagic.autopandas = True\n%config SqlMagic.feedback = False\n%config SqlMagic.displaycon = False\n\n# Підключення до DuckDB в режимі \"in-memory\"\n%sql duckdb:///:memory:\n\n\n# Завантаження даних з файлів\n%sql CREATE OR REPLACE TABLE user_actions AS SELECT * FROM read_csv('00_data/sql/user_actions.csv', header=True, columns={'user_id': 'INT', 'order_id': 'INT', 'action': 'VARCHAR', 'time': 'TIMESTAMP'}, timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE courier_actions AS SELECT * FROM read_csv('00_data/sql/user_actions.csv', header=True, columns={'courier_id': 'INT', 'order_id': 'INT', 'action': 'VARCHAR', 'time': 'TIMESTAMP'}, timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE orders AS SELECT * FROM read_csv('00_data/sql/orders.csv', header=True, columns={'order_id': 'INT', 'creation_time': 'TIMESTAMP', 'product_ids': 'INT[]'}, timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE users AS SELECT * FROM read_csv('00_data/sql/users.csv', header=True, columns={'user_id': 'INT', 'birth_date': 'DATE', 'sex': 'VARCHAR'}, dateformat='%d/%m/%y');\n%sql CREATE OR REPLACE TABLE couriers AS SELECT * FROM read_csv('00_data/sql/couriers.csv', header=True, columns={'courier_id': 'INT', 'birth_date': 'DATE', 'sex': 'VARCHAR'}, dateformat='%d/%m/%y');\n%sql CREATE OR REPLACE TABLE products AS SELECT * FROM read_csv('00_data/sql/products.csv', header=True, columns={'product_id': 'INT', 'name': 'VARCHAR', 'price': 'DOUBLE'});\n\n\nНа схемі продемонстровані зв’язки між таблицями, а також опис даних:\n\n\n\n\nerDiagram\n    orders }|..|{ products : product_ids-product_id\n    orders }|..|{ courier_actions : order_id\n    users }|..|{ user_actions : user_id\n    user_actions }|..|{ orders : order_id\n    user_actions }|..|{ courier_actions : time\n    courier_actions }|..|{ courier : product\n    \n    users {\n        DATE birth_date\n        VARCHAR sex\n        INT user_id\n    }\n    user_actions {\n        INT user_id\n        VARCHAR actions\n        INT order_id\n        TIMESTAMP time\n    }\n    orders {\n        INT order_id\n        ARRAY product_ids\n        TIMESTAMP creation_time\n    }\n    products {\n        INT product_id\n        NUMERIC price\n        VARCHAR name\n    }\n    courier_actions {\n        INT courier_id\n        VARCHAR action\n        INT order_id\n        TIMESTAMP time\n    }\n    courier {\n        INT courier_id\n        VARCHAR sex\n        DATE birth_date\n    }"
  },
  {
    "objectID": "sql.html#типи-даних",
    "href": "sql.html#типи-даних",
    "title": "SQL",
    "section": "Типи даних",
    "text": "Типи даних\nВ таблицях можуть зберігатися різні типи даних: цілі і дробові числа, текст, дати, масиви чисел. У цих даних ви зустрінетесь з наступними типами:\n\n\n\n\n\n\n\n\n\nТипи даних\nОпис\nПриклад\n\n\n\n\n0\nINT\nЦіле число\nid користувача: 123\n\n\n1\nNUMERIC / DECIMAL\nДійсне число\nВартість товару: 120.55\n\n\n2\nVARCHAR\nТекст\nДія із замовленням: «create_order»\n\n\n3\nDATE\nДата з точністю до дня\nДата народження користувача: 25/03/91\n\n\n4\nTIMESTAMP\nДата з точністю до секунди\nЧас реєстрації у додатку: 24/08/22 01:52:24\n\n\n5\n[]\nМасив\nСписок id товаров у замовленні: [1, 13, 22]\n\n\n\n\n\n\n\nБільш детально почитати про типи даних можна за посиланням"
  },
  {
    "objectID": "sql.html#структура-та-наповнення-таблиць",
    "href": "sql.html#структура-та-наповнення-таблиць",
    "title": "SQL",
    "section": "Структура та наповнення таблиць",
    "text": "Структура та наповнення таблиць\nuser_actions – дії користувачів із замовленнями.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\nuser_id\nINT\nid користувача\n\n\n1\norder_id\nINT\nid замовлення\n\n\n2\naction\nVARCHAR(50)\nдія користувача із замовленням; \"create_order\"...\n\n\n3\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\n\ncourier_actions – дії кур’єрів із замовленнями.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\norder_id\nINT\nid замовлення\n\n\n2\naction\nVARCHAR(50)\nдія кур'єра із замовленням; 'accept order' - п...\n\n\n3\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\n\norders - інформація про замовлення.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\norder_id\nINT\nid замовлення\n\n\n1\ncreation_time\nTIMESTAMP\nчас створення замовлення\n\n\n2\nproduct_ids\ninteger[]\nсписок id товарів у замовленні\n\n\n\n\n\n\n\nusers - інформація про користувачів.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\nuser_id\nINT\nid користувача\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\ncouriers - інформація про кур’єрів.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\nproducts - інформація про товари, які доставляє сервіс.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ дужках типу VARCHAR вказано максимально допустиму кількість символів у тексті. У типу даних NUMERIC у дужках вказано загальну кількість символів."
  },
  {
    "objectID": "sql_basics.html#відбір-select",
    "href": "sql_basics.html#відбір-select",
    "title": "2  Базові запити",
    "section": "2.1 Відбір: SELECT",
    "text": "2.1 Відбір: SELECT\nДавайте спочатку напишемо найпростіший запит і подивимося, як виглядає таблиця products.\nЩоб вивести всі записи зі значеннями у всіх колонках, необхідно або перерахувати всі колонки в операторі SELECT або вказати після оператора спеціальний символ “*”:\nSELECT column_1, column_2, ...\nFROM table\n\n\nSELECT *\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nОператор FROM завжди вказується після оператора SELECT. У зворотному порядку їх записувати не можна – база даних поверне помилку.\n\n\n\nЗавдання 2.1 Виведіть усі записи з таблиці products.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n1\nsugar\n150.0\n\n\n1\n2\ngreen tea bags\n50.0\n\n\n2\n3\nstill water\n80.0\n\n\n3\n4\nlollipops\n46.0\n\n\n4\n5\ncoffee 3 in 1\n15.0\n\n\n...\n...\n...\n...\n\n\n82\n83\nwaffles\n55.0\n\n\n83\n84\ntangerines\n90.0\n\n\n84\n85\njam\n200.0\n\n\n85\n86\ncold coffee\n70.0\n\n\n86\n87\nveal\n398.0\n\n\n\n\n87 rows × 3 columns\n\n\n\nНа практиці таблиці можуть бути дуже великими, тому дуже бажано використовувати оператор LIMIT для того щоб не виводити всю таблицю, що може займати багато часу. Крім того, можливо такий запит навіть не буде виконано, оскільки розумні дата інженери заборонили виконувати такі запити."
  },
  {
    "objectID": "sql_basics.html#впорядкування-order-by",
    "href": "sql_basics.html#впорядкування-order-by",
    "title": "2  Базові запити",
    "section": "2.2 Впорядкування: ORDER BY",
    "text": "2.2 Впорядкування: ORDER BY\nДля сортування значень по будь-якій колонці SQL використовується оператор ORDER BY з ключовими словами ASC (за зростанням) або DESC (за спаданням).\nПри цьому за умовчанням сортування відбувається за зростанням, тобто ASC не обов’язково вказувати. Для сортування за спаданням після ORDER BY необхідно явно вказати DESC:\nSELECT column_1, column_2\nFROM table\nORDER BY column_1           -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 ASC       -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC      -- сортування за спаданням\n\nЗавдання 2.2 Виведіть всі записи з таблиці products, відсортувавши їх за найменуванням товарів у алфавітному порядку, тобто за зростанням. Для сортування використовуйте оператор ORDER BY.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\n\nПримітка\n\n\n\nСортування можна робити не тільки по полях зі значеннями, вираженими числами, але й по полях, значення яких представлені у вигляді тексту, як у нашому випадку.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nORDER BY name\nLIMIT 5\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n62\napple juice\n120.0\n\n\n1\n71\napples\n75.0\n\n\n2\n39\nbagels\n45.0\n\n\n3\n65\nbananas\n100.0\n\n\n4\n66\nbeef\n370.0\n\n\n\n\n\n\n\nСортувати результат SQL-запиту можна відразу за декількома колонками, вказуючи їх після ORDER BY через кому разом із напрямком сортування (ASC або DESC):\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2    -- спочатку сортування по першій колонці (за спаданням),\n                                    -- потім по другій (за зростанням)\n\n\n\n\n\n\nПримітка\n\n\n\nВажливо пам’ятати, що при роботі з великими таблицями потрібно по можливості обмежувати кількість виведених записів, щоб не створювати зайве навантаження на базу даних.\n\n\nОператори ORDER BY та LIMIT можна поєднувати в одному запиті, при цьому оператор LIMIT записується та виконується після оператора ORDER BY, обмежуючи кількість записів у вже відсортованому результаті:\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2\nLIMIT 5\n\nЗавдання 2.3 Відсортуйте таблицю courier_actions спочатку по колонці courier_id за зростанням id кур’єра, потім по колонці action (знову за зростанням), а потім по колонці time, але вже за спаданням — від останньої дії до першої. Не забудьте включити колонку order_id.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: courier_id, order_id, action, time.\n\n\n\n\n\n\nПримітка\n\n\n\nЯк ви вже здогадалися, сортувати таблиці можна навіть по полях з датами та часом.\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       order_id,\n       action,\n       time\nFROM   courier_actions\nORDER BY courier_id, action, time DESC limit 5\n\n\n\n\n\n\n\n\n\ncourier_id\norder_id\naction\ntime\n\n\n\n\n0\n1\n23149\ncreate_order\n2022-09-02 02:36:00\n\n\n1\n1\n22901\ncreate_order\n2022-09-02 00:58:00\n\n\n2\n1\n4683\ncreate_order\n2022-08-27 20:56:00\n\n\n3\n1\n1\ncreate_order\n2022-08-24 01:52:00\n\n\n4\n2\n7114\ncreate_order\n2022-08-28 18:11:00\n\n\n\n\n\n\n\nЗараз важливо запам’ятати порядок запису всіх відомих нам ключових слів:\n\nSELECT\nFROM\nORDER BY\nLIMIT\n\nТакож важливо зрозуміти, що порядок їх виконання дещо відрізняється від того, в якій послідовності вони вказуються в SQL-запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nПотім SELECT - відбираються вказані стовпці.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\n\nЗавдання 2.4 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, визначте 5 найдорожчих товарів у таблиці products, які доставляє наш сервіс. Виведіть їх найменування та ціну.\nПоля у результуючій таблиці: name, price.\nРішення:\n\n\n\nРішення\n%%sql\nSELECT name,\n       price\nFROM   products\nORDER BY price desc limit 5\n\n\n\n\n\n\n\n\n\nname\nprice\n\n\n\n\n0\ncaviar\n800.0\n\n\n1\nmutton\n559.0\n\n\n2\nolive oil\n450.0\n\n\n3\npork\n450.0\n\n\n4\ndecaffeinated coffee\n400.0"
  },
  {
    "objectID": "sql_basics.html#зміна-назви-as",
    "href": "sql_basics.html#зміна-назви-as",
    "title": "2  Базові запити",
    "section": "2.3 Зміна назви: AS",
    "text": "2.3 Зміна назви: AS\nПри складанні SQL-запитів колонкам у результуючій таблиці можна надавати будь-які інші імена (їх ще називають «аліасами»). Це можна робити за допомогою оператора AS:\nSELECT name AS new_name\nFROM table\nЯкщо раптом вам здасться, що на написання оператора AS йде занадто багато часу і сил, його можна опустити, вказавши нове ім’я колонки без нього. Наступний запис також спрацює:\nSELECT name new_name\nFROM table\n\nЗавдання 2.5 Повторіть запит із з попереднього прикладу (Завдання 2.3), але тепер колонки name і price перейменуйте відповідно на product_name і product_price.\nПоля у результуючій таблиці: product_name, product_price\nРішення:\n\n\n\nРішення\n%%sql\n\nSELECT name AS product_name,\n       price AS product_price\nFROM   products\nORDER BY price desc limit 5\n\n\n\n\n\n\n\n\n\nproduct_name\nproduct_price\n\n\n\n\n0\ncaviar\n800.0\n\n\n1\nmutton\n559.0\n\n\n2\nolive oil\n450.0\n\n\n3\npork\n450.0\n\n\n4\ndecaffeinated coffee\n400.0"
  },
  {
    "objectID": "sql_basics.html#кількість-символів-length",
    "href": "sql_basics.html#кількість-символів-length",
    "title": "2  Базові запити",
    "section": "2.4 Кількість символів: LENGTH",
    "text": "2.4 Кількість символів: LENGTH\nУ SQL-запитах до колонок таблиць можна використовувати різні функції, наприклад, як в Excel.\nУ загальному вигляді синтаксис функцій виглядає приблизно так:\nSELECT function(a, b, c, ...)\nFROM table\nЗамість function вказується назва функції, а дужках — її аргументи. Як аргументи можуть виступати як колонки зі значеннями, так і окремі значення. Залежно від функції кількість аргументів може відрізнятися.\nЯкщо ви коли-небудь працювали в Excel, то вам, напевно, знайомі різні функції на кшталт SUM, MIN, MAX тощо, які роблять деякі обчислення по стовпцях. У SQL вони називаються агрегуючими функціями.\nЗараз як приклад розглянемо функцію LENGTH. Вона виконує досить просте завдання — підраховує кількість символів у поданому їй на вхід значенні текстового типу (текстовий тип даних часто називають рядком — від англ. «string»). Іншими словами, функція LENGTH вимірює довжину деякого рядка у символах:\n\n%%sql\nSELECT LENGTH('I.love.Python') as py_love\n\n\n\n\n\n\n\n\npy_love\n\n\n\n\n0\n13\n\n\n\n\n\n\n\nФункція LENGTH також може застосовуватись до всього стовпця. У такому випадку довжина символів буде порахована для кожного значення в стовпці. Відповідний запит виглядатиме так:\nSELECT LENGTH(column) AS column_length\nFROM table\n\nЗавдання 2.6 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, а також функцію LENGTH, визначте товар із найдовшою назвою у таблиці products. Виведіть його найменування, довжину найменування у символах, а також ціну цього товару. Назвіть колонку з довжиною найменування в символах name_length.\nПоля у результуючій таблиці: name, name_length, price.\n\n\n\nРішення\n%%sql\nSELECT name,\n       length(name) as name_length,\n       price\nFROM   products\nORDER BY name_length desc limit 1\n\n\n\n\n\n\n\n\n\nname\nname_length\nprice\n\n\n\n\n0\nfruit drink blueberry\n21\n170.0\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що в цьому прикладі ви сортуєте результуючу таблицю по розрахунковій колонці name_length, якої спочатку не було таблиці products.\nТаке сортування за новими колонками можливе, оскільки це узгоджується з порядком виконання операторів у запиті: спочатку виконується вибір колонок і всі перетворення над ними в операторі SELECT — і тільки потім проводиться сортування за вказаними в ORDER BY стовпчиками. Тобто на момент сортування всі розрахункові поля вже існують, а значить, їх можна вказувати в ORDER BY.\nТакож зверніть увагу, що ми двічі вказуємо колонку name в операторі SELECT: вперше просто звертаємося до неї за ім’ям, а вдруге - використовуємо її як аргумент функції LENGTH. У цьому випадку теж немає жодних протиріч - ми можемо вибирати колонку стільки разів, скільки необхідно, причому для цього навіть необов’язково надавати цим колонкам різні аліаси (база даних сама перейменує дублікат колонки).\n\n\n:::\nУ SQL, як й у багатьох інших мовах, функції можна застосовувати до інших функцій, тобто. послідовно:\nSELECT function_one(function_two(a, b), c)\nУ наведеній вище конструкції a, b, c аргументи функцій. При цьому одним із аргументів функції function_one є результат виконання функції function_two.\nТаким чином, спочатку буде виконана функція function_two, а потім її результат буде поданий на вхід функції function_one як один з аргументів.\nРозглянемо такий випадок на прикладі функцій UPPER та LEFT. Функція UPPER наводить подане їй на вхід текстове значення до верхнього регістру:\nSELECT \n    UPPER('I.love.Python') AS upper_all\n\nРезультат:\nI.LOVE.PYTHON\nФункція LEFT повертає перші n символів у рядку:\nSELECT \n    LEFT('I.love.Python', 6) AS first_n\n\nРезультат:\nI.love\nМи можемо застосувати ці функції послідовно і в результаті отримаємо перші три символів верхнього регістру:\nSELECT \n    UPPER(LEFT('I.love.Python', 6))\n\nРезультат:\nI.LOVE\n\n\n\n\n\n\nОбережно\n\n\n\nВажливо: зверніть увагу, що у блоці SELECT не можна виконати дві операції окремо, тобто. ми не можемо спочатку створити розрахункову колонку з першими шістьма символами, а потім відразу ж звернутися до цієї нової колонки, застосувавши до неї функцію UPPER.\n\n\nНаступний запит не буде виконано, база даних поверне помилку:\nSELECT \n    LEFT('I.love.Python', 3) AS first_n,\n    UPPER(first_n) AS upper_first_n\n\nРезультат:\nError running query: column \"new_name\" does not exist\nВ межах одного запиту колонки створюються не по черзі, а разом, тому в межах одного запиту колонки upper_first_n не існує, поки блок SELECT не буде повністю виконаний. Дуже важливо враховувати цю особливість мови.\nОднак на практиці до нових колонок доводиться звертатися досить часто — саме для цього є підзапити (запити до інших запитів). А поки що нам достатньо розуміти, що застосовувати функції до розрахункових колонок у тому ж запиті не можна."
  },
  {
    "objectID": "sql_basics.html#поділ-та-повернення-split_part",
    "href": "sql_basics.html#поділ-та-повернення-split_part",
    "title": "2  Базові запити",
    "section": "2.5 Поділ та повернення: SPLIT_PART",
    "text": "2.5 Поділ та повернення: SPLIT_PART\nФункція SPLIT_PART розбиває поданий їй на вхід рядок на кілька частин відповідно до зазначеного роздільника та повертає одну з частин.\nКрім самого рядка (або колонки зі значеннями рядкового типу), функція приймає ще два аргументи — роздільник і порядковий номер частини, яку необхідно повернути. Подивіться наступний приклад:\nSELECT SPLIT_PART('I.love.Python', '.', 3)\n\nРезультат:\nPython\nУ прикладі вище рядок ‘I.love.Python’ було розбито на три частини (‘I’, ‘love’ та ‘Python’) по роздільнику “.”. Функція повернула ‘Python’, оскільки третім аргументом ми вказали частину із порядковим номером 3.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з іншими функціями для роботи з рядками можна ознайомитись за посиланням.\n\n\n\nЗавдання 2.7 Застосуйте послідовно функції UPPER та SPLIT_PART до колонки name та перетворіть найменування товарів у таблиці products так, щоб від назв залишилося тільки перше слово, записане у верхньому регістрі. Колонку з новою назвою, що складається із першого слова, назвіть first_word.\nУ результаті виведіть вихідні найменування товарів, нові найменування з першого слова, а також ціну товарів. Результат відсортуйте за зростанням початкового найменування товару в колонці name.\nПоля у результуючій таблиці: name, first_word, price\n\n\n\nРішення\n%%sql\nSELECT\n    name,\n    UPPER(SPLIT_PART(name, ' ', 1)) AS first_word,\n    price\nFROM\n    products\nORDER BY\n    name\n\n\n\n\n\n\n\n\n\nname\nfirst_word\nprice\n\n\n\n\n0\napple juice\nAPPLE\n120.0\n\n\n1\napples\nAPPLES\n75.0\n\n\n2\nbagels\nBAGELS\n45.0\n\n\n3\nbananas\nBANANAS\n100.0\n\n\n4\nbeef\nBEEF\n370.0\n\n\n...\n...\n...\n...\n\n\n82\nwaffles\nWAFFLES\n55.0\n\n\n83\nwatermelon\nWATERMELON\n120.0\n\n\n84\nwhite chocolate\nWHITE\n60.0\n\n\n85\nyogurt\nYOGURT\n45.0\n\n\n86\nсowberry juice\nСOWBERRY\n190.0\n\n\n\n\n87 rows × 3 columns"
  },
  {
    "objectID": "sql_basics.html#зміна-типу-cast",
    "href": "sql_basics.html#зміна-типу-cast",
    "title": "2  Базові запити",
    "section": "2.6 Зміна типу: CAST",
    "text": "2.6 Зміна типу: CAST\nІноді виникає необхідність змінити тип даних у якійсь колонці результуючої таблиці, не змінюючи при цьому властивості вихідної таблиці, наприклад, перетворити число на текст (тип даних VARCHAR). І тому існує функція CAST.\nНа вхід функції CAST необхідно подати ім’я колонки, вказавши через AS тип даних, до якого потрібно привести всі значення:\nSELECT CAST(column AS VARCHAR)\nFROM table\nТакож можна змінити тип даних за допомогою спеціального синтаксису з двома двокрапками («::»):\nSELECT column::VARCHAR\nFROM table\nНаприклад, переведемо текст ‘100’ у число 100:\nSELECT CAST('100' AS INTEGER)\n\nРезультат:\n100\nЗверніть увагу, що для успішної конвертації значення повинні бути конвертованими у вказаний тип. Наприклад, текст, який не виглядає як число, перевести до числового типу даних не вийде:\nSELECT CAST('text' AS INTEGER)\n\nРезультат:\nError running query: invalid input syntax for type integer: \"text\"\nАналогічним чином можна, наприклад, перетворити текст на дату (якщо він виглядає як дата):\nSELECT '2022-12-31'::DATE as date\n\nРезультат:\n2022-12-31\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з функцією CAST та перетворенням типів даних можна ознайомитись за цим посиланням.\nПро самі типи даних можна почитати тут.\n\n\n\nЗавдання 2.8 Змініть тип колонки price з таблиці products на VARCHAR. Виведіть колонки з найменуванням товарів, ціною у вихідному форматі та ціною у форматі VARCHAR. Нову колонку з ціною у новому форматі назвіть price_char.\nРезультат відсортуйте за зростанням початкового найменування товару в колонці name. Кількість записів, що виводяться, не обмежуйте.\nПоля в результуючій таблиці: name, price, price_char\n\n\n\nРішення\n%%sql\nSELECT \n    name,\n    price,\n    CAST(price as VARCHAR) as price_char\nFROM\n    products\nORDER BY\n    name\n\n\n\n\n\n\n\n\n\nname\nprice\nprice_char\n\n\n\n\n0\napple juice\n120.0\n120.0\n\n\n1\napples\n75.0\n75.0\n\n\n2\nbagels\n45.0\n45.0\n\n\n3\nbananas\n100.0\n100.0\n\n\n4\nbeef\n370.0\n370.0\n\n\n...\n...\n...\n...\n\n\n82\nwaffles\n55.0\n55.0\n\n\n83\nwatermelon\n120.0\n120.0\n\n\n84\nwhite chocolate\n60.0\n60.0\n\n\n85\nyogurt\n45.0\n45.0\n\n\n86\nсowberry juice\n190.0\n190.0\n\n\n\n\n87 rows × 3 columns"
  },
  {
    "objectID": "sql_basics.html#обєднання-concat",
    "href": "sql_basics.html#обєднання-concat",
    "title": "2  Базові запити",
    "section": "2.7 Об’єднання: CONCAT",
    "text": "2.7 Об’єднання: CONCAT\nУ цьому підрозділі ми ще трохи попрацюємо з текстовими даними та розглянемо функцію CONCAT, за допомогою якої можна з’єднувати в один рядок значення кількох стовпців.\nФункція CONCAT приймає на вхід кілька аргументів і повертає результат їхньої послідовної складання один з одним. Хороша аналогія - складання речень з різних карток зі словами:\nSELECT CONCAT('SQL', ' ', 'Python ', 2023)\n\nРезультат:\nSQL Python 2023\nПри цьому аргументи не обов’язково мають бути виражені текстовими значеннями — головне, вони мають бути конвертованими в текст. У прикладі вище число 2023 можна конвертувати в текст ‘2023’, тому запит працює без помилок.\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції CONCAT можна за посиланням.\n\n\n\nЗавдання 2.9 Для перших 200 записів з таблиці orders виведіть інформацію у такому вигляді (зверніть увагу на пробіли):\nЗамовлення № [id_замовлення] створено [дата]\nОтриману колонку назвіть order_info.\nПриклад результату:\nЗамовлення № 65 створено 2022-09-01\n\n\n\nРішення\n%%sql\nSELECT \n    CONCAT(\n        'Замовлення № ',\n        order_id,\n        ' створено ',\n        creation_time::DATE\n        ) as order_info\nFROM   \n    orders\nLIMIT 200\n\n\n\n\n\n\n\n\n\norder_info\n\n\n\n\n0\nЗамовлення № 1 створено 2022-08-24\n\n\n1\nЗамовлення № 2 створено 2022-08-24\n\n\n2\nЗамовлення № 3 створено 2022-08-24\n\n\n3\nЗамовлення № 4 створено 2022-08-24\n\n\n4\nЗамовлення № 5 створено 2022-08-24\n\n\n...\n...\n\n\n195\nЗамовлення № 196 створено 2022-08-25\n\n\n196\nЗамовлення № 197 створено 2022-08-25\n\n\n197\nЗамовлення № 198 створено 2022-08-25\n\n\n198\nЗамовлення № 199 створено 2022-08-25\n\n\n199\nЗамовлення № 200 створено 2022-08-25\n\n\n\n\n200 rows × 1 columns"
  },
  {
    "objectID": "sql_basics.html#частина-дати-date_part",
    "href": "sql_basics.html#частина-дати-date_part",
    "title": "2  Базові запити",
    "section": "2.8 Частина дати: DATE_PART",
    "text": "2.8 Частина дати: DATE_PART\nЯк ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (DATE) і часу (TIMESTAMP). Давайте трохи попрацюємо з такими даними.\nНасправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція DATE_PART. Її синтаксис наступний:\nSELECT DATE_PART(part, column)\nНа місці part необхідно в лапках вказати ту частину, яку потрібно витягти: 'year', 'month', 'day', 'hour' тощо. На місці column слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:\nSELECT DATE_PART('day', DATE '2022-01-12')\n\nРезультат:\n12.00\n\n\nSELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')\n\nРезультат:\n31.00\nВище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами dates. Тоді запит виглядав би так:\nSELECT DATE_PART('day', dates)\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції DATE_PART можна за посиланням.\n\n\n\nЗавдання 2.10 Виведіть id всіх кур’єрів та їхні роки народження з таблиці couriers.\nРік народження необхідно одержати з колонки birth_date. Нову колонку з роком назвіть birth_year. Результат відсортуйте спочатку за спаданням року народження кур’єра (тобто від наймолодших до найстарших), потім за зростанням id кур’єра.\nПоля у результуючій таблиці: courier_id, birth_year\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       date_part('year', birth_date) as birth_year\nFROM   couriers\nORDER BY birth_year desc, courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_year\n\n\n\n\n0\n83\nNaN\n\n\n1\n187\nNaN\n\n\n2\n200\nNaN\n\n\n3\n232\nNaN\n\n\n4\n411\nNaN\n\n\n...\n...\n...\n\n\n2818\n2200\n1981.0\n\n\n2819\n2432\n1979.0\n\n\n2820\n616\n1978.0\n\n\n2821\n1443\n1978.0\n\n\n2822\n493\n1973.0\n\n\n\n\n2823 rows × 2 columns"
  },
  {
    "objectID": "sql_basics.html#перше-ненульове-значення-coalesce",
    "href": "sql_basics.html#перше-ненульове-значення-coalesce",
    "title": "2  Базові запити",
    "section": "2.9 Перше ненульове значення: COALESCE",
    "text": "2.9 Перше ненульове значення: COALESCE\nВи могли помітити, що в минулому прикладі (Завдання 2.10) для окремих рядків функція DATE_PART не повернула рік народження кур’єра, а замість них утворилися порожні значення. Якщо не помітили, уважно подивіться на результат запиту.\nНасправді це сталося тому, що в наших даних у колонці birth_date є перепустки — так звані значення NULL (у виводі результату це NA). Іншими словами, для окремих кур’єрів просто не вказано їхні дні народження. Є безліч варіантів, чому так могло статися, але ми зараз не маємо часу все це з’ясовувати — нам просто потрібно навчитися якось обробляти такі випадки.\nДавайте зробимо так, щоб замість порожніх значень функція DATE_PART повертала якесь інше значення. У цьому нам допоможе функція COALESCE, яка повертає перше не NULL значення зі списку поданих на вхід аргументів.\nРоботу COALESCE можна описати так: вона буквально читає список значень зліва направо і, як тільки бачить значення, яке не є NULL, відразу ж повертає його та припиняє читання списку. Подивіться уважно на такі приклади:\nSELECT COALESCE(NULL, 'I am not NULL' , 'I.love.Python')\n\nРезультат:\nI am not NULL\n\n\nSELECT COALESCE(NULL, 25, 100, 150)\n\nРезультат:\n25\n\n\nSELECT COALESCE('NULL', 'I am not NULL', 'I.love.Python')\n\nРезультат:\nNULL\nОдним із аргументів функції COALESCE може бути результат виконання іншої функції:\nSELECT COALESCE(NULL, LOWER('I am not NULL'), 'I.love.Python')\n\nРезультат:\ni am not null\nЩоб заповнити пропуски в колонці, достатньо застосувати функцію COALESCE до колонки з пропусками та вказати як другий аргумент те значення, яке ми хочемо бачити замість NULL:\nSELECT COALESCE(column, 'filler value')\nFROM table\nФункція COALESCE застосовується до кожного значення колонки. Якщо це значення виявиться NULL, вона замінить його значення, вказане другим аргументом. Якщо значення колонці, навпаки, виявиться не NULL, то функція просто поверне це значення.\nПри цьому до колонки з перепустками можна заздалегідь застосовувати різні інші функції:\nSELECT COALESCE(LEFT(column, 5), 'filler value')\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nЗ іншими прикладами використання функції COALESCE можна за посиланням.\n\n\n\nЗавдання 2.11 Як і в попередньому прикладі (Завдання 2.10), знову виведіть id десяти відсотків кур’єрів та їх роки народження, тільки тепер до вилученого року застосуйте функцію COALESCE. Вкажіть параметри функції так, щоб замість значення NULL в результат потрапляло текстове значення unknown. Назви полів залиште колишніми.\nПоля у результуючій таблиці: courier_id, birth_year\n\n\n\nРішення\n%%sql\nSELECT\n    courier_id,\n    COALESCE(date_part('year', birth_date)::VARCHAR, 'unknown') birth_year\nFROM\n    couriers\nUSING SAMPLE 10 PERCENT (bernoulli, 123)\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_year\n\n\n\n\n0\n17\n1997\n\n\n1\n24\n1986\n\n\n2\n40\n1993\n\n\n3\n49\n1996\n\n\n4\n52\n1995\n\n\n...\n...\n...\n\n\n278\n3103\n1991\n\n\n279\n3124\n1992\n\n\n280\n3128\n1997\n\n\n281\n3162\n1996\n\n\n282\n3166\n1994\n\n\n\n\n283 rows × 2 columns"
  },
  {
    "objectID": "sql_basics.html#арифметичні-оператори",
    "href": "sql_basics.html#арифметичні-оператори",
    "title": "2  Базові запити",
    "section": "2.10 Арифметичні оператори",
    "text": "2.10 Арифметичні оператори\nДля роботи з числовими значеннями в DuckDB доступны різні арифметичні оператори. Нижче наведена таблиця з найбільш вживаними операторами:\n\n\n\nОператор\nОпис\nПриклад\nРезультат\n\n\n\n\n+\nДодавання\n2 + 3\n5\n\n\n-\nВіднімання\n2 - 3\n-1\n\n\n*\nМноження\n2 * 3\n6\n\n\n/\nДілення\n4 / 2\n2\n\n\n%\nЗалишок від ділення\n5 % 4\n1\n\n\n^\nПіднесення до степеня\n2 ^ 3\n8\n\n\n\nЯкби ми захотіли перевести 7600 гривен у долари за курсом 1 долар = 40 гривень, то операція виглядала б так:\nSELECT 7500 / 40\n\nРезультат:\n190\nЯкби нам потрібно було відняти з кожного значення в одній із колонок нашої таблиці якесь число (наприклад, 100), то запит виглядав би так:\nSELECT column - 100\nFROM table\nКрім того, в арифметичних операціях можуть брати участь одразу кілька колонок. Наприклад, для кожного рядка таблиці можна обчислити середнє арифметичне двох чисел, які містяться у двох різних колонках:\nSELECT (column_1 + column_2) / 2 AS average\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з усіма арифметичними операторами можна за посиланням.\n\n\n\nЗавдання 2.12 Давайте уявимо, що з якоїсь незрозумілої причини ми раптом вирішили відразу підвищити ціну всіх товарів у таблиці products на 5%.\nВиведіть id та найменування всіх товарів, їх стару та нову ціну. Колонку зі старою ціною назвіть old_price, а колонку з новою – new_price.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price.\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       price*1.05 as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n840.00\n\n\n1\n37\nmutton\n559.0\n586.95\n\n\n2\n15\nolive oil\n450.0\n472.50\n\n\n3\n57\npork\n450.0\n472.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n26.25\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.75\n\n\n84\n73\ncake\n15.0\n15.75\n\n\n85\n10\nseeds\n12.0\n12.60\n\n\n86\n54\npaper bag\n1.0\n1.05\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_basics.html#математичні-функції",
    "href": "sql_basics.html#математичні-функції",
    "title": "2  Базові запити",
    "section": "2.11 Математичні функції",
    "text": "2.11 Математичні функції\nПоряд з арифметичними операторами DuckDB також доступні різні математичні функції. Наприклад, для округлення чисел можна використовувати функцію ROUND:\nSELECT ROUND(100.5454, 2)\n\nРезультат:\n100.55\n\n\nSELECT ROUND(100.551, 1)\n\nРезультат:\n100.6\n\n\nSELECT ROUND(100.5511)\n\nРезультат:\n101.0\nПершим аргументом вказується саме значення, яке хочемо округлити. Другим число знаків після точки, до якої хочемо округлити. Другий аргумент вказувати не обов’язково: якщо його не вказати, відбудеться округлення до цілого числа (проте тип даних при цьому не зміниться).\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з усіма арифметичними операторами можна за посиланням.\n\n\n\nЗавдання 2.13 Знову, як і в минулому завданні (Завдання 2.12), підвищите ціну всіх товарів на 5%, тільки тепер до колонки з новою ціною застосуйте функцію ROUND. Виведіть id та найменування товарів, їх стару ціну, а також нову ціну із округленням. Нову ціну округліть до десятих, але тип даних не змінюйте.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price.\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       round(price * 1.05, 1) as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n840.0\n\n\n1\n37\nmutton\n559.0\n587.0\n\n\n2\n15\nolive oil\n450.0\n472.5\n\n\n3\n57\npork\n450.0\n472.5\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.0\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n26.3\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.8\n\n\n84\n73\ncake\n15.0\n15.8\n\n\n85\n10\nseeds\n12.0\n12.6\n\n\n86\n54\npaper bag\n1.0\n1.1\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_basics.html#умовна-конструкція-case-when",
    "href": "sql_basics.html#умовна-конструкція-case-when",
    "title": "2  Базові запити",
    "section": "2.12 Умовна конструкція: CASE WHEN",
    "text": "2.12 Умовна конструкція: CASE WHEN\nА якби ми захотіли підвищити ціну не на всі товари, а, скажімо, тільки на дорогі?\nДля цього нам потрібно було б створити деяку функцію, яка перевіряла б кожне значення в колонці price і порівнювала б його з якимось пороговим значенням. Якби ціна виявлялася вищою за цей поріг, то функція підвищувала б ціну, а якщо ні — залишала б без змін.\nІ таку функцію можна задати за допомогою умовної конструкції CASE. Вона має наступний синтаксис:\nCASE  \nWHEN logical_expression_1 THEN expression_1\nWHEN logical_expression_2 THEN expression_2\n...\nELSE expression_else\nEND AS case_example\nЦя конструкція може бути громіздкою, але насправді в ній немає нічого складного. Логіка роботи оператора CASE досить проста:\n\nНа кожному етапі WHEN - THEN обчислюється деякий логічний вираз logical_expression, що стоїть після WHEN. Якщо воно виявляється істинним (TRUE), то в якості результату оператор повертає вираз expression, що стоїть після THEN, і закінчує свою роботу.\nЯкщо вираз виявляється помилковим (FALSE), то оператор продовжує роботу та перевіряє наступну умову.\nЯкщо жодна з умов не проходить перевірку на істинність, повертається вираз, вказаний після ELSE. При цьому ELSE вказувати не обов’язково - якщо його не вказати, то повернеться порожнє значення NULL (у разі, якщо всі перевірки після WHEN виявилися помилковими).\nНасамкінець обов’язково вказується ключове слово END, яке говорить про закінчення конструкції CASE. Також після END новому розрахунковому полю за допомогою AS можна надати деяке ім’я, але це робити не обов’язково. Обов’язковими є лише ключові слова CASE, WHEN, THEN та END.\n\nНаступна конструкція розіб’є весь список найменувань на три категорії: «м’ясо», «риба» та «інше». Відповідно, якщо у перших двох умовах ми не врахуємо якісь назви з колонки name (наприклад, «телятину»), то вони потраплять до категорії «інше».\nSELECT name,\n       CASE \n       WHEN name='свинина' OR name='баранина' OR name='курка' THEN \"м'ясо\"\n       WHEN name='тріска' OR name='форель' OR name='окунь' THEN 'риба'\n       ELSE 'інше'\n       END AS сategory\nFROM table\nТепер трохи про логічні вирази: SQL можуть включати оператори порівняння і логічні операції.\nДо операторів порівняння належать:\n\n= («рівно»)\n&lt;&gt; або != («не дорівнює»)\n&lt; («менше»)\n&gt; («більше»)\n&lt;= («менше або дорівнює»)\n&gt;= («більше чи дорівнює»)\n\nРезультатом роботи операторів порівняння можуть бути три стани:\n\nTRUE («істина»)\nFALSE (помилка)\nNULL («невизначений стан» - коли одне з порівнюваних значень NULL)\n\nЗ цими трьома станами можна проводити такі логічні операції:\n\nAND («І»)\nOR («АБО»)\nNOT («НЕ»)\n\nРезультатом цих логічних операцій також можуть бути три вищевказані логічні стани (TRUE, FALSE або NULL):\n\n\n\na\nb\na AND b\na OR b\n\n\n\n\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nNULL\nNULL\nTRUE\n\n\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nNULL\nFALSE\nNULL\n\n\nNULL\nNULL\nNULL\nNULL\n\n\n\n\n\n\na\nNOT a\n\n\n\n\nTRUE\nFALSE\n\n\nFALSE\nTRUE\n\n\nNULL\nNULL\n\n\n\nТаким чином, оператори порівняння та логічні операції дозволяють писати комплексні логічні вирази.\nЗапам’ятати всі ці таблиці та комбінації не обов’язково. Головне, завжди тримайте цю пам’ятку під рукою.\nПрипустимо, відомо, що \\(a=10\\) і \\(b=5\\). Тоді наступний логічний вираз поверне TRUE:\na &gt;= 10 OR b &gt; 10\nТакож важливо розуміти, що є пріоритети виконання операцій:\n\nмноження та поділ (* та /)\nдодавання та віднімання (+ та -)\nоператори порівняння (=, !=, &gt;, &lt;, &gt;=, &lt;=)\nNOT\nAND\nOR\n\nНа порядок виконання операторів можна також впливати за допомогою дужок. Вирази, поміщені в дужки, матимуть найвищий пріоритет — як у математиці.\n\nЗавдання 2.14 Підвищіть ціну на 5% тільки на товари, вартість яких перевищує 100 одиниць. Ціну решти товарів залиште без змін. Також не підвищуйте ціну на ікру (caviar), яка й так коштує 800 одиниць. Виведіть id та найменування всіх товарів, їх стару та нову ціну. Ціну округляти не потрібно.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       case when price &lt;= 100 or\n                 name = 'caviar' then price\n            else price * 1.05 end as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n800.00\n\n\n1\n37\nmutton\n559.0\n586.95\n\n\n2\n15\nolive oil\n450.0\n472.50\n\n\n3\n57\npork\n450.0\n472.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n25.00\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.00\n\n\n84\n73\ncake\n15.0\n15.00\n\n\n85\n10\nseeds\n12.0\n12.00\n\n\n86\n54\npaper bag\n1.0\n1.00\n\n\n\n\n87 rows × 4 columns\n\n\n\nУявіть, що до вас звернувся менеджер із сусіднього відділу із проханням порахувати ПДВ кожного товару. Жодних додаткових даних він вам не надав, тому ви вирішили виконати завдання на власний розсуд, вважаючи, що ПДВ єдиний для всіх товарів і становить 20%.\n\nЗавдання 2.15 Обчисліть ПДВ кожного товару у таблиці products та розрахуйте ціну без урахування ПДВ. Виведіть всю інформацію про товари, включаючи суму податку та ціну без його врахування. Колонки із сумою податку та ціною без ПДВ назвіть відповідно tax та price_before_tax. Округліть значення у цих колонках до двох знаків після коми.\nРезультат відсортуйте спочатку за спаданням ціни товару без урахування ПДВ, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, tax, price_before_tax.\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       round((price * 0.2) / 1.2, 2) as tax,\n       round(price / 1.2, 2) as price_before_tax\nFROM   products\nORDER BY price_before_tax desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ntax\nprice_before_tax\n\n\n\n\n0\n13\ncaviar\n800.0\n133.33\n666.67\n\n\n1\n37\nmutton\n559.0\n93.17\n465.83\n\n\n2\n15\nolive oil\n450.0\n75.00\n375.00\n\n\n3\n57\npork\n450.0\n75.00\n375.00\n\n\n4\n43\ndecaffeinated coffee\n400.0\n66.67\n333.33\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n4.17\n20.83\n\n\n83\n5\ncoffee 3 in 1\n15.0\n2.50\n12.50\n\n\n84\n73\ncake\n15.0\n2.50\n12.50\n\n\n85\n10\nseeds\n12.0\n2.00\n10.00\n\n\n86\n54\npaper bag\n1.0\n0.17\n0.83\n\n\n\n\n87 rows × 5 columns"
  },
  {
    "objectID": "sql_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "href": "sql_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "title": "2  Базові запити",
    "section": "2.13 Типові помилки при написанні SQL-запитів.",
    "text": "2.13 Типові помилки при написанні SQL-запитів.\n\nНеправильний порядок або помилки у ключових словах. Правильний порядок операторів у запиті виглядає так:\n\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- угруповання даних\nHAVING      -- фільтрація даних після угруповання\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\nНеправильно названі функції та оператори, що використовуються в запиті (наприклад, DATEPART, а не DATE_PART).\nНеправильно вказано імена стовпців.\nНеправильно виконано сортування записів.\nНеправильно проведено розрахунки.\nПропущена кома при перерахуванні стовпців у SELECT\nЗайва кома після імені останнього стовпця в SELECT\nНе закриті дужки (перевірте, що кількість дужок дорівнює кількості закривають).\nДопущено помилку в підзапиті (перед виконанням всього запиту перевірте, чи працюють окремі підзапити).\nЗапущено відразу кілька запитів, не розділених крапкою з комою."
  },
  {
    "objectID": "sql_filtering.html#базова-фільтрація-where",
    "href": "sql_filtering.html#базова-фільтрація-where",
    "title": "3  Фільтрація даних",
    "section": "3.1 Базова фільтрація: WHERE",
    "text": "3.1 Базова фільтрація: WHERE\nВ SQL для фільтрації даних використовується оператор WHERE. Після оператора WHERE вказується логічний вираз, результат якого визначає, чи буде рядок включений до результуючої таблиці. Якщо умова виявляється істинною (TRUE), то рядок включається до результату, якщо хибним (FALSE) — рядок виключається.\nТаким чином, кожен рядок у таблиці проходить перевірку на відповідність певній умові, і в результаті цих перевірок формується таблиця, над якою проводяться операції, зазначені в блоці SELECT.\nОператор WHERE та логічний вираз вказуються після блоку FROM:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 0\nНаприклад, у результаті зазначеного вище запиту у вибірці попадуть лише записи з невід’ємними значеннями в колонці column_2.\nУ свою чергу оператори ORDER BY і LIMIT записуються вже після оператора WHERE. Якщо додати їх у приклад вище, запит виглядатиме так:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 0\nORDER BY column_1\nLIMIT 100\nУ результаті ми спочатку відфільтруємо необхідні нам рядки, потім виберемо стовпчики, виділені в SELECT, а потім сортуємо результуючу таблицю, обмеживши число виведених записів.\nТаким чином порядок запису відомих нам на поточний момент ключових слів виглядає так:\n\nSELECT\nFROM\nWHERE\nORDER BY\nLIMIT\n\nЗнову звернемо увагу, що порядок виконання відрізняється від того, в якій послідовності вони вказуються в запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nДалі WHERE - відфільтровуються рядки, що відповідають умові.\nПотім SELECT - відбираються зазначені стовпці та застосовуються функції.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\nІншими словами, в результаті виконання запиту спочатку відбувається підготовка таблиці до роботи, а потім над нею виконуються різні операції.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про оператор WHERE можна за посиланням.\n\n\n\nЗавдання 3.1 Напишіть SQL-запит до таблиці products та виведіть всю інформацію про товари, ціна яких не перевищує 100 одиниць. Результат відсортуйте за зростанням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\nРішення\n%%sql\nSELECT \n    product_id,\n    name,\n    price\nFROM   products\nWHERE  price &lt;= 100\nORDER BY product_id\nLIMIT  10;\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n2\ngreen tea bags\n50.0\n\n\n1\n3\nstill water\n80.0\n\n\n2\n4\nlollipops\n46.0\n\n\n3\n5\ncoffee 3 in 1\n15.0\n\n\n4\n6\ncrackers\n25.0\n\n\n5\n8\ndrying\n30.0\n\n\n6\n9\nblack leaf tea\n84.0\n\n\n7\n10\nseeds\n12.0\n\n\n8\n14\nmayonnaise\n60.0\n\n\n9\n18\nketchup\n58.0\n\n\n\n\n\n\n\nФільтрувати дані в таблицях можна не тільки по полях з числовими значеннями, але і по полях зі значеннями, представленими у вигляді тексту:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 = 'text'\nУ прикладі вище в результуючу таблицю потраплять лише рядки, значення в яких повністю збігаються із зазначеним у WHERE рядком 'text'.\nПри порівнянні рядків також допускається використовувати нерівності:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt; 'text'\nВтім, така операція використовується рідше, оскільки не цілком очевидно, що означає «один рядок більше за інший».\nНасправді порядок сортування даних рядкового типу зазвичай визначається заздалегідь встановленими правилами сортування, у яких значення мають довжина рядка в символах, порядок букв відповідно до алфавіту, наявність особливих символів, регістр тощо. Ми не будемо докладно зупинятись на цій темі — за бажання про це можна додатково прочитати у документації.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про правила сортування даних рядкового типу можна за посиланням.\n\n\n\nЗавдання 3.2 Виберіть користувачів жіночої статі з таблиці users. Виведіть лише id цих користувачів. Результат відсортуйте за зростанням id.\nДодайте в запит оператор LIMIT і виведіть лише 10 перших ID з відсортованого списку.\nПоле у результуючій таблиці: user_id\n\n\n\nРішення\n%%sql\nSELECT \n    user_id\nFROM   \n    users\nWHERE  \n    sex = 'female'\nORDER BY \n    user_id \nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n5\n7\n\n\n6\n8\n\n\n7\n11\n\n\n8\n12\n\n\n9\n13\n\n\n\n\n\n\n\nЯк значення для фільтрації можна також використовувати дати та час:\nSELECT column_1\nFROM table\nWHERE column_2 &lt;= '2022-12-31'\n\n\nSELECT column_1\nFROM table\nWHERE column_2 &lt;= '2022-12-31 00:00:00'\nОднак при цьому важливо заздалегідь переконатися, що в колонці, за якою фільтруватимуться дані, знаходяться саме дати або мітки часу, а не дані рядкового типу, зовні схожі на дати. Якщо в колонці виявляться рядки, то як такої помилки не відбудеться, проте результат сильно відрізнятиметься від очікуваного.\nТакож в операціях порівняння дат важливо враховувати, що дата завжди інтерпретується опівночі (початок дня), тобто '2022-12-31' насправді означає '2022-12-31 00:00:00'.\nДо речі, ніщо не забороняє нам комбінувати в блоці WHERE різні умови з різними типами даних і створювати складніші логічні вирази:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_1 &gt;= 0 \n      AND column_2 = 'some text' \n      AND column_3 = '2022-12-31'\nДавайте якраз вирішимо завдання одразу з кількома умовами!\n\nЗавдання 3.3 Виберіть з таблиці user_actions усі дії користувачів зі створення замовлень, які були зроблені ними після опівночі 6 вересня 2022 року. Виведіть колонки з id користувачів, id створених замовлень та часом їх створення.\nРезультат має бути відсортований за зростанням id замовлення.\nПоля в результуючій таблиці: user_id, order_id, time\nПояснення:\nЗверніть увагу, що в таблиці user_actions у кожного користувача можуть бути записи не тільки з часом створення замовлення, а й часом його скасування. Нам необхідно отримати лише записи із створенням замовлень.\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       time\nFROM   user_actions\nWHERE  action = 'create_order' and time &gt; '2022-09-06'\nORDER BY order_id\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\ntime\n\n\n\n\n0\n16721\n45201\n2022-09-06 00:01:00\n\n\n1\n17299\n45202\n2022-09-06 00:01:00\n\n\n2\n7957\n45203\n2022-09-06 00:01:00\n\n\n3\n17300\n45204\n2022-09-06 00:02:00\n\n\n4\n14723\n45205\n2022-09-06 00:03:00\n\n\n...\n...\n...\n...\n\n\n14390\n21402\n59591\n2022-09-08 23:58:00\n\n\n14391\n20859\n59592\n2022-09-08 23:58:00\n\n\n14392\n15131\n59593\n2022-09-08 23:59:00\n\n\n14393\n10881\n59594\n2022-09-08 23:59:00\n\n\n14394\n19774\n59595\n2022-09-08 23:59:00\n\n\n\n\n14395 rows × 3 columns\n\n\n\nВ операторі WHERE можна використовувати не тільки колонки, які вже є в таблиці, але й розрахункові колонки. При цьому вказувати їх у SELECT знову ж таки не обов’язково:\nSELECT column_1, column_2, (column_1 + column_2) * 0.5 AS average\nFROM table\nWHERE (column_1 + column_2) * 0.5 = 10\n\n\nSELECT column_1, column_2\nFROM table\nWHERE (column_1 + column_2) * 0.5 = 10 \nУ прикладі вище ми відфільтруємо тільки ті записи, для яких середнє арифметичне двох чисел, що містяться в колонках column_1 і column_2, дорівнюватиме 10.\nТакож важливо враховувати, що використовувати в блоці WHERE аліаси, які присвоєно новим розрахунковим колонкам, не можна. Зверніть увагу на приклади наступних запитів, які вважають частку значень колонки column_1 у відповідних їм значеннях колонки column_2. Перший запит спрацює, а другий поверне помилку:\n-- Цей запит спрацює:\n\nSELECT column_1, column_2, \n       column_1 / column_2 AS share\nFROM table\nWHERE column_1 / column_2 &gt; 50\n\n\n-- Цей запит поверне помилку:\n\nSELECT column_1, column_2, \n       column_1 / column_2 AS share\nFROM table\nWHERE share &gt; 50\nЦе пов’язано всі з тією ж послідовністю виконання операторів у запиті: на момент виконання оператора WHERE аліас колонці ще не присвоєно, і тому база даних поки не знає про існування колонки з новим ім’ям.\nМожна розглянути ще більш тривіальний приклад: навіть якщо ми просто зробимо дублікат колонки з іншим ім’ям і спробуємо використати це ім’я в WHERE, все одно отримаємо помилку:\n-- Цей запит поверне помилку:\n\nSELECT column, column AS same_column\nFROM table\nWHERE same_column &gt; 0\nПри вказівці фільтрів у блоці WHERE важливо враховувати розглянуті особливості. Можете керуватися наступним правилом: якщо збираєтеся фільтрувати дані по розрахунковій колонці, то дублюйте розрахунки WHERE і не використовуйте аліаси, присвоєні новим колонкам.\n\nЗавдання 3.4 Призначте знижку 20% на всі товари з таблиці products та відберіть ті, ціна на які з урахуванням знижки перевищує 100. Виведіть id товарів, їх найменування, колишню ціну та нову ціну з урахуванням знижки. Колонку зі старою ціною назвіть old_price, новою — new_price.\nРезультат має бути відсортований за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price\nПояснення:\nБудьте уважні, коли вказуватимете фільтр після оператора WHERE.\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       price * 0.8 as new_price\nFROM   products\nWHERE  price * 0.8 &gt; 100\nORDER BY product_id\nLIMIT 10 -- для скорочення виводу\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n1\nsugar\n150.0\n120.0\n\n\n1\n7\ngrain coffee\n351.0\n280.8\n\n\n2\n11\nlinseed oil\n200.0\n160.0\n\n\n3\n12\ngrape\n278.0\n222.4\n\n\n4\n13\ncaviar\n800.0\n640.0\n\n\n5\n15\nolive oil\n450.0\n360.0\n\n\n6\n17\nсowberry juice\n190.0\n152.0\n\n\n7\n19\nsalted fish\n180.0\n144.0\n\n\n8\n21\nground coffee\n283.0\n226.4\n\n\n9\n25\ninstant coffee\n150.0\n120.0\n\n\n\n\n\n\n\nПісля оператора WHERE до колонок можна також застосовувати різні функції:\nSELECT column_1, column_2\nFROM table \nWHERE LOWER(column_1) = 'i.love.python'\nУ прикладі вище кожне значення колонки column_1 спочатку буде приведено до нижнього регістру, а потім зіставлено зі значенням ‘i.love.python’. При цьому результат буде включено вихідні значення в колонці column_1. Таким чином, функція послужить тільки для фільтрації записів, але самі значення в колонках ніяк не вплине.\nЗверніть увагу, що використовувати аліаси, присвоєні колонкам в операторі SELECT, так само не можна. Наступний запит поверне помилку:\n-- Цей запит поверне помилку:\n\nSELECT column_1 AS new_column_1, column_2\nFROM table \nWHERE LOWER(new_column_1) = 'i.love.python'\n\nЗавдання 3.5 Відберіть із таблиці products всі товари, назви яких або починаються зі слова «tea», або складаються з п'яти символів. Виведіть дві колонки: id товарів та їх найменування.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\nПояснення:\nДля вирішення завдання вам знадобляться функції SPLIT_PART та LENGTH, які ми розглядали раніше.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля вирішення завдання в операторі WHERE до колонки з назвами товарів необхідно застосувати функцію SPLIT_PART, розділивши по пробілу на окремі слова і відібравши тільки ті, в яких перше слово - «tea». Також через OR необхідно додати другу умову з функцією LENGTH для перевірки, що найменування складається з 5 символів.\n\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name\nFROM   products\nWHERE  split_part(name, ' ', 1) = 'tea'\n    or length(name) = 5\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n1\nsugar\n\n\n1\n10\nseeds\n\n\n2\n12\ngrape\n\n\n3\n26\nchips\n\n\n4\n28\ncream\n\n\n5\n34\npasta\n\n\n6\n36\ntea mushroom\n\n\n7\n40\nbread\n\n\n8\n52\nkvass\n\n\n9\n53\nflour\n\n\n10\n61\nhoney\n\n\n11\n72\npears"
  },
  {
    "objectID": "sql_filtering.html#пошук-за-шаблоном-like",
    "href": "sql_filtering.html#пошук-за-шаблоном-like",
    "title": "3  Фільтрація даних",
    "section": "3.2 Пошук за шаблоном: LIKE",
    "text": "3.2 Пошук за шаблоном: LIKE\nУявіть, що із загального списку найменувань товарів нам раптом знадобилося відібрати певні позиції, які містять певні слова і навіть символи. Але при цьому ми точно не знаємо, в якій частині назви їх можна зустріти.\nНаприклад, нам потрібні всі “tea”, але вони необов’язково повинні починатися зі слова “tea”.\nАле як це зробити? Невже нам доведеться переглядати всю таблицю, вручну складати список товарів і писати довгий логічний вираз, що враховує всі можливі сценарії?\nЗрозуміло, що ні. Для фільтрації по колонках з текстовими значеннями в SQL передбачений оператор LIKE.\nОператор LIKE не просто порівнює рядки на повний збіг (або розбіжність), а перевіряє їх на відповідність заданому шаблону: якщо рядок йому відповідає, то повертається TRUE, інакше — FALSE. Як можна здогадатися, конструкція NOT LIKE працює з точністю навпаки.\nШаблони можуть містити як звичайні символи, так і символи-шаблони: знак відсотка (%) та підкреслення (_). Підкреслення підміняє будь-який одиночний символ, а знак відсотка - будь-яку (у тому числі порожню) послідовність символів:\nSELECT 'love.python' LIKE 'love%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE 'love_'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE '%love%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE '_love%'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE '%.%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE '_._'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE 'Love%'\n\nРезультат:\nfalse\nЗверніть увагу на останній приклад: оператор LIKE чутливий до регістру.\nЯкщо шаблон не містить знаків відсотка та підкреслень, тоді шаблон є рядком і LIKE працює як оператор порівняння, перевіряючи рядки на точний збіг.\nSELECT 'love.python' LIKE 'love.python'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE 'love'\n\nРезультат:\nfalse\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про оператор LIKE та шаблони можна почитати тут.\n\n\n\nЗавдання 3.6 Відберіть із таблиці products всі товари, що містять у своїй назві послідовність символів «tea» (без лапок). Виведіть дві колонки: id продукту та його назву.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\n\n\n\nРішення\n%%sql\nSELECT  product_id,\n        name\nFROM    products\nWHERE   name LIKE '%tea%'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n2\ngreen tea bags\n\n\n1\n9\nblack leaf tea\n\n\n2\n27\nherbal leaf tea\n\n\n3\n36\ntea mushroom\n\n\n4\n45\nleaf green tea\n\n\n5\n48\nivan-tea in bags\n\n\n6\n50\ncold tea\n\n\n7\n76\nblack tea bags\n\n\n8\n79\nherbal tea bags\n\n\n\n\n\n\n\nТепер зробимо наш фільтр трохи цікавішим.\n\nЗавдання 3.7 Виберіть із таблиці products id та найменування лише тих товарів, назви яких починаються на букву “c” і містять лише одне слово.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЯкщо з буквою «c» все зрозуміло, то з фільтром на одне слово ситуація трохи складніша: подумайте, яким символом принципово відрізняються рядки з одним і двома словами. Складіть шаблон для пошуку рядка, що складається з двох слів і виключіть такі рядки з результату.\nТакож будьте уважні мовою введення: латинська літера “c” та кирилична “с” виглядають однаково, але для бази даних це різні символи.\n\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name\nFROM   products\nWHERE  name like 'c%'\n   and name not like '% %'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n6\ncrackers\n\n\n1\n13\ncaviar\n\n\n2\n26\nchips\n\n\n3\n28\ncream\n\n\n4\n46\ncookie\n\n\n5\n73\ncake\n\n\n6\n77\nchicken\n\n\n7\n78\ncupcakes\n\n\n\n\n\n\n\nУявіть, що напередодні Нового року до вас звернувся менеджер, якому на думку спала ідея зробити знижку на найдорожчий чай. Він попросив вас надати йому вивантаження з бази даних з усіма чаями та новими цінами на них з урахуванням знижки.\nЩо він далі робитиме з цими даними, вам невідомо, але завдання є завдання, до того ж не таке вже й складне. Спробуймо його вирішити!\n\nЗавдання 3.8 Складіть SQL-запит, який вибирає з таблиці products всі чаї вартістю більше 60 і нараховує їм знижку 25%.\nЗнижку в % менеджер попросив вказати в окремому стовпці у форматі тексту, тобто так: «25%» (без лапок). Стовпці зі знижкою та новою ціною назвіть відповідно discount та new_price.\nТакож необхідно будь-яким відомим способом позбавитися «tea mushroom»: навряд чи менеджер мав на увазі і його, коли ставив нам завдання.\nРезультат має бути відсортований за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, discount, new_price\nПояснення:\nЩоб вказати стовпець з одним значенням для всіх записів (у нашому випадку це стовпець зі знижкою), достатньо просто ввести потрібне значення і дати стовпцю якусь назву - вказане значення автоматично проставиться у всіх рядках результуючої таблиці:\nSELECT column_1, 'text' AS column_2\nFROM table\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       '25%' as discount,\n       price * 0.75 as new_price\nFROM   products\nWHERE  price &gt; 60\n   and name != 'tea mushroom'\n   and name like '%tea%'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ndiscount\nnew_price\n\n\n\n\n0\n9\nblack leaf tea\n84.0\n25%\n63.00\n\n\n1\n27\nherbal leaf tea\n121.0\n25%\n90.75\n\n\n2\n45\nleaf green tea\n78.0\n25%\n58.50\n\n\n3\n79\nherbal tea bags\n65.0\n25%\n48.75"
  },
  {
    "objectID": "sql_filtering.html#in-та-between-для-фільтрації",
    "href": "sql_filtering.html#in-та-between-для-фільтрації",
    "title": "3  Фільтрація даних",
    "section": "3.3 IN та BETWEEN для фільтрації",
    "text": "3.3 IN та BETWEEN для фільтрації\nАле якщо ми все-таки не хочемо перевіряти наші дані на відповідність якомусь шаблону, а просто хочемо відібрати значення з деякого списку або навіть діапазону? У цьому випадку у логічному виразі після ключового слова WHERE можна використовувати оператори IN та BETWEEN.\nОператор IN перевіряє, чи відповідає значення в колонці одному із значень із заданого списку. Іншими словами, він перевіряє, чи входить значення до цього списку:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IN ('product_1', 'product_2', 'product_3')\nУ свою чергу, оператор BETWEEN дозволяє відібрати дані, що відносяться до деякого інтервалу. При цьому межі інтервалу включаються:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 BETWEEN 5 AND 10\nЗапит вище відповідає наступному запиту:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 5 AND column_2 &lt;= 10\nОператор BETWEEN можна використовувати і для фільтрації по колонках з датами та часом:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_3 BETWEEN '2022-11-20' AND '2022-12-31'\nОднак, в такому випадку, треба враховувати, що дата завжди інтерпретується опівночі (початок дня), тобто. ‘2022-12-31’ насправді означає ‘2022-12-31 00:00:00’. Тож заданий вище інтервал не потраплять записи пізніше опівночі ‘2022-12-31’, тобто цей день практично не буде враховано в інтервалі.\nПри цьому, запит вище буде рівносильний наступному запиту:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_3 &gt;= '2022-11-20' AND column_3 &lt;= '2022-12-31'\nДля отримання зворотного результату у поєднанні з операторами IN та BETWEEN можна використовувати оператор NOT:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 NOT IN ('product_1', 'product_2', 'product_3')\n\n\nSELECT column_1, column_2\nFROM table\nWHERE column_2 NOT BETWEEN 5 AND 10\n\n\n\n\n\n\nПримітка\n\n\n\nДетальніше про оператори IN та BETWEEN можна прочитати тут і тут.\n\n\n\nЗавдання 3.9 З таблиці user_actions виведіть всю інформацію про дії користувачів з id 170, 200 та 230 за період з 25 серпня до 4 вересня 2022 року включно. Результат відсортуйте за зменшенням id замовлення - тобто від останніх до найпізніших.\nПоля у результуючій таблиці: user_id, order_id, action, time\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       action,\n       time\nFROM   user_actions\nWHERE  user_id in (170, 200, 230)\n   and time &gt;= '2022-08-25'\n   and time &lt; '2022-09-05' -- уважно з датами!\nORDER BY order_id desc\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\naction\ntime\n\n\n\n\n0\n170\n34428\ncreate_order\n2022-09-04 01:43:00\n\n\n1\n170\n34424\ncreate_order\n2022-09-04 01:42:00\n\n\n2\n230\n24675\ncreate_order\n2022-09-02 12:21:00\n\n\n3\n200\n24538\ncreate_order\n2022-09-02 11:50:00\n\n\n4\n230\n22887\ncreate_order\n2022-09-02 00:54:00\n\n\n5\n230\n22878\ncreate_order\n2022-09-02 00:50:00\n\n\n6\n230\n19543\ncreate_order\n2022-09-01 07:21:00\n\n\n7\n170\n14894\ncreate_order\n2022-08-30 22:04:00\n\n\n8\n230\n14466\ncreate_order\n2022-08-30 19:51:00\n\n\n9\n170\n4194\ncreate_order\n2022-08-27 17:28:00\n\n\n10\n170\n4190\ncreate_order\n2022-08-27 17:27:00\n\n\n11\n200\n3416\ncreate_order\n2022-08-27 09:36:00\n\n\n12\n200\n3413\ncreate_order\n2022-08-27 09:34:00\n\n\n13\n170\n1234\ncreate_order\n2022-08-25 23:35:00\n\n\n14\n230\n263\ncreate_order\n2022-08-25 02:54:00\n\n\n15\n200\n229\ncreate_order\n2022-08-25 01:52:00\n\n\n16\n200\n226\ncreate_order\n2022-08-25 01:50:00\n\n\n17\n170\n188\ncreate_order\n2022-08-25 00:49:00"
  },
  {
    "objectID": "quarto.html#що-таке-quarto",
    "href": "quarto.html#що-таке-quarto",
    "title": "\n4  Quarto\n",
    "section": "\n4.1 Що таке Quarto",
    "text": "4.1 Що таке Quarto\nQuarto — це науково–технічна видавнича система з відкритим кодом, яка ґрунтується на універсальному конверторі документів Pandoc та використовує мову розмітки Markdown. Це універсальний інструмент для тих, хто пише на R, Python, Julia та Observable JavaScript.\nЗа допомогою Quarto можна поєднувати описовий текст і код для створення відформатованих документів, веб–сторінок, постів у блогах, книг тощо.\n\n4.1.1 Назва Quarto\nРозробники Quarto хотіли використати ім’я, яке мало деяке значення в історії видавничої справи. Вибір пав на Quarto (від латинського quārtō, скорочено Qto, 4to або 4º) — це формат книги або брошури в одну четвертину топографічного листа. На кожній стороні листа при цьому поміщається 4 сторінки книги (8 сторінок на один лист).\nНайраннішим відомим виданням такого формату була Книга Сивіл (англ. Sibyllenbuch), що була надрукована Йоганном Гутенбергом у 1452–1453 роках.\n\n\nРисунок 4.1: Quarto\n\n\n4.1.2 Можливості Quarto\nQuarto являє собою текстовий документ спеціального формату .qmd, який можна скомпілювати у різноманітні документи:\n\nДокументи у форматах:\n\nHTML\nPDF\nePub\nMS Word\nOpenOffice\n\n\nПрезентації у форматах:\n\n\nreveal.js (HTML)\n\nPowerPoint (MS Office)\n\nBeamer (LaTeX/PDF)\n\n\nВеб-сторінки:\n\n\nPractical Deep Learning від fast.ai\n\nnbdev від fast.ai\nКурс Julia Workshop for Data Science\n\n\n\nКниги, приклади яких можна переглянути за посиланнями:\n\nPython for Data Analysis\nR for Data Science\nVisualization Curriculum\n\n\nІнтерактивні документи:\n\n\nObservable reactive JavaScript\n\nShiny вебфреймворк\nІнтерактивні віджети Jupyter"
  },
  {
    "objectID": "quarto.html#початок-роботи-з-quarto",
    "href": "quarto.html#початок-роботи-з-quarto",
    "title": "\n4  Quarto\n",
    "section": "\n4.2 Початок роботи з Quarto",
    "text": "4.2 Початок роботи з Quarto\n\n4.2.1 Встановлення Quarto\nДля роботи з Quarto потрібно: 1. Встановити інтерфейс командного рядка Quarto (CLI) під актуальну операційну систему (Windows, Linux або Mac OS).\n\nВстановити плагін для інтегрованого середовища розробки (IDE). На даний момент підтримуються:\n\nVS Code\nRStudio\nJupyter\n\n\n\n4.2.2 Робота з проектами\nСтворити Quarto–проект можна декількома шляхами:\n\nЗа допомогою командного рядка:\n\n\n\nterminal\n\n# веб-сайт\nquarto create-project mysite --type website\n\n# блог\nquarto create-project myblog --type website:blog\n\n# книга\nquarto create-project mybook --type book\n\n\nЗасобами IDE:\n\n\n\nVS Code: File -&gt; New File -&gt; …\n\n\n\n\nРисунок 4.2: Меню створення Quarto–проекту у VS Code\n\n\n\nRStudio: File -&gt; New Project… -&gt; New Directory\n\n\n\n\nРисунок 4.3: Меню створення Quarto–проекту у RStudio\n\n\n4.2.3 Як працює Quarto\nСпочатку Knitr (для R) або Jupyter (для Python або Julia) виконує всі фрагменти коду .qmd-файлу і створює новий markdown (.md) документ, який включає в себе код і всі його результати. Далі .md–файл оброблюється Pandoc для перетворення у різноманітні формати файлів (HTML, PDF, Word тощо).\n\n\nРисунок 4.4: Процедура рендерінгу документів в Quarto\n\n\n4.2.4 Рендерінг\n\nДля рендерінгу документу можна використати кнопку Render в VS Code.\n\n\n\nРисунок 4.5: Клавіша рендерінгу документу в VS Code\n\n\nРендерінг за допомогою командного рядку:\n\n\n\nterminal\n\nquarto render &lt;input&gt; --to &lt;format&gt;\n\n# Наприклад:\nquarto render document.qmd --to docx"
  },
  {
    "objectID": "quarto.html#структура-документів-quatro",
    "href": "quarto.html#структура-документів-quatro",
    "title": "\n4  Quarto\n",
    "section": "\n4.3 Структура документів Quatro",
    "text": "4.3 Структура документів Quatro\nQuatro документи складаються з трьох базових складових:\n\nYAML–шапки1\n\nТекст з використанням розмітки Markdown\nЧанків (анг. chunks) з кодом\n\n\n4.3.1 YAML–шапка\nYAML–шапка знаходиться нагорі документу і відділена трьома дефісами (---) зверху та знизу. В ній зберігається мета–інформація документу: назва, дата створення, автор, інформація щодо роботи коду, контенту і процесу рендерінгу.\n---\ntitle: \"Dracula\"\nauthor: \"Bram Stoker\"\ndate: \"May 26, 1897\"\nformat: \n  html:\n    toc: true\n    code-fold: true\n---\n\n4.3.2 Текст з використанням розмітки Markdown\nЦя частина документу йде одраtextзу після YAML–шапки і складає основну частину документу.\nMarkdown — це популярна і зручна мова розмітки. Ви непевно зустрічали її в README.md–файлах репозиторіїв GitHub, а також у Telegram–повідомленнях.\n\n4.3.3 Чанки з кодом\nЧанки — це блоки, які відділяються від тексту потрійними зворотніми лапками ``` ( анг. backtick) на початку та в кінці. У фігурних дужках вказується мова програмування на якій необхідно виконати код.\n```{python}\nprint('Fly, you fools!')\n```\nРезультат чанку за замовчування виводиться одразу після нього, але все це можна налаштувати."
  },
  {
    "objectID": "quarto.html#yaml-шапка",
    "href": "quarto.html#yaml-шапка",
    "title": "\n4  Quarto\n",
    "section": "\n4.4 YAML-шапка",
    "text": "4.4 YAML-шапка\nМетадані документу можуть бути задані у шапці документу або окремим _quarto.yml-файлом.\nВ цій частині документу зберігається інформація щодо назви документу, дати, автора, налаштування рендерінгу, параметри чанків та інші додаткові налаштування. Всі параметри встановлюються у форматі key: value.\n\n4.4.1 Налаштування виводу\nКлюч format: відповідає за тип вихідного файлу.\n\n\n\n\n\n\n\nТип\nЗначення\nОпис\n\n\n\nДокументи\n\nhtml\npdf\ndocx\nodt\nepub\n\n\nHTML\nPDF\nMS Word\nOpenDocument\nePub\n\n\n\nПрезентації\n\nrevealjs\npptx\nbeamer\n\n\nRevealjs\nPowerPoint\nBeamer\n\n\n\nMarkdown\n\ngfm\ncommonmark\nmarkua\n\n\nGFM\nCommonMark\nMarkua\n\n\n\nWiki\n\nmediawiki\ndokuwiki\nzimwiki\njira\nxwiki\n\n\nMediaWiki\nDocuWiki\nZimWiki\nJira Wiki\nXWiki\n\n\n\n\nА також цілу низку інших форматів, документацію по котрим можна отримати в розділі Reference документації.\n\n4.4.2 Назва, дата та автор\nВ залежності від типу вихідного документу, ці ключі можуть відрізнятися, але наведу основні:\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\ntitle\nНазва документа\n\n\nsubtitle\nПідзаголовок документа\n\n\ndate\nДата документа\n\n\nauthor\nАвтор або автори документа\n\n\n\n4.4.3 Зміст\nДля генерації змісту (анг. table of contents, скорочено toc) необхідно ключу toc задати значення true. В залежності від типу вихідного документу зміст буде згенерований відповідно до заголовків (Розділ 4.5.2).\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\ntoc\nДодайте автоматично створений зміст у вихідний документ.\n\n\ntoc-depth\nКількість рівнів розділу, які потрібно включити у зміст. За замовчуванням 3\n\n\ntoc-title\nЗаголовок, використаний для змісту.\n\n\n\n4.4.4 Локалізація документу\nQuarto, Pandoc та LaTeX генерують текстові елементи документу, які потребують локалізації. Наприклад: “Рисунок” або “Таблиця” для перехресних посилань, назви виносок тощо.\n\n4.4.4.1 Налаштування lang\n\nПриклад використання польської локалізації документу:\n---\ntitle: \"Mój dokument\"\nlang: pl  \n---\nЦе призведе до використання польського перекладу компонентів документу, а також до застосування інших мовних правил обробки документів.\nНаразі доступні повні переклади такими мовами:\n\nанглійська (en, за замовчуванням)\nголландська (nl)\nіспанська (es)\nіталійська (it)\nкитайська (zh)\nкорейська (kr)\nнімецька (de)\nпольська (pl)\nпортугальська (pt)\nросійська (ru)\nфінська (fi)\nфранцузька (fr)\nчеська (cs)\nяпонська (ja)\n\n4.4.4.2 Власна локалізація\nЯкщо вас не влаштовує мова за умовчанням, яка використовується для певної частини документа, ви можете вказати альтернативну мову за допомогою ключа language. Наприклад, щоб замінити значення підписів «Author» і «Published», які використовуються в блоках заголовків, ви можете зробити це:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: \n  title-block-author-single: \"Автор\"\n  title-block-published: \"Опубліковано\"\n---\nВсі ці зміни можна зберегти в окремому .yml-файлі і використовувати власну локалізацію до документу:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: custom.yml\n---\nЯ зробив власну українську локалізацію Quarto-документів, яку Ви можете завантажити з мого GitHub-репозиторія: https://github.com/aranaur/quarto-ukrainian.\nОзнайомитися з усіма офіційними локалізаціями можна за посиланням: https://github.com/quarto-dev/quarto-cli/tree/main/src/resources/language."
  },
  {
    "objectID": "quarto.html#основи-markdown",
    "href": "quarto.html#основи-markdown",
    "title": "\n4  Quarto\n",
    "section": "\n4.5 Основи Markdown",
    "text": "4.5 Основи Markdown\nQuarto ґрунтується на Pandoc та використовує різновид markdown в якості базового синтаксису. Pandoc markdown — це розширена та злегка перероблена версія синтаксису markdown.\nMarkdown — це формат звичайного тексту, який розроблено таким чином, щоб його було легко писати та, що ще важливіше, легко читати.\n\n4.5.1 Форматування тексту\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n*курсив* та **жирний**\n\nкурсив та жирний\n\n\n\nнадрядковий^2^ / підрядковий~2~\nнадрядковий2 / підрядковий2\n\n\n\n~~перекреслення~~\nперекреслення\n\n\n`дослівний код`\nдослівний код\n\n\n\n4.5.2 Заголовки\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n# Заголовок 1\nЗаголовок 1\n\n\n## Заголовок 2\nЗаголовок 2\n\n\n### Заголовок 3\nЗаголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6\n\n\n\n4.5.3 Посилання та рисунки\n\n\nСинтаксис markdown\nРезультат\n\n\n\n[Python](https://python.org)\nPython\n\n\n![Підпис](img/python-logo.jpg)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org \"Python\")\n\n\n\n[![](img/python-logo.jpg){fig-alt=\"Alt text\"}](https://www.python.org)\n\n\n\n\n4.5.4 Списки\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n* невпорядкований список\n    + підпункт 1\n    + підпункт 2\n        - під--підпункт 1\n\n\nневпорядкований список\n\nпідпункт 1\n\nпідпункт 2\n\nпід–підпункт 1\n\n\n\n\n\n\n\n*   пункт 2\n\n    Продовження (відступ 4 інтервали)\n\n\nпункт 2\nПродовження (відступ 4 інтервали)\n\n\n\n\n1. впорядкований список\n2. пункт 2\n    i) підпункт 1\n         A.  під--підпункт 1\n\nвпорядкований список\n\nпункт 2\n\n\nпідпункт 1\n\nпід–підпункт 1\n\n\n\n\n\n\n\n(@)  Список, нумерація якого\n\nпродовжується після\n\n(@)  переривання\n\n\nСписок, нумерація якого\n\nпродовжується після\n\nпереривання\n\n\n\n\nтермін\n: визначення\n\nтермін\n\nвизначення\n\n\n\n\n\n4.5.5 Таблиці\n\n4.5.5.1 Таблиці markdown\nСинтаксис markdown\n| Зліва | Справа | За замовчуванням | По центру |\n|------:|:-------|------------------|:---------:|\n|   12  |  12    |    12            |    12     |\n|  123  |  123   |   123            |   123     |\n|    1  |    1   |     1            |     1     |\nРезультат\n\n\nЗліва\nСправа\nЗа замовчуванням\nПо центру\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\nФормувати такі таблиці вручну досить складно і незручно. В таких випадках на допомогу приходить Markdown Tables Generator.\n\n4.5.5.2 Таблиці з Python\n\nЗа допомогою комбінації функцій Markdown() та пакету tabulate:\n\n\n\nterminal\n\npip install tabulate\n\n\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\ntable = [[\"Bilbo Baggins\", \"Hobbits\", \"Male\"],\n         [\"Beren\", \"Men\", \"Male\"],\n         [\"Nimrodel\", \"Elves\", \"Female\"],\n         [\"Muzgash\", \"Orc\", \"Male\"]]\nMarkdown(tabulate(\n  table, \n  headers=[\"Name\", \"Race\", \"Sex\"]\n))\n\n\n\nТаблиця 4.1: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nPandas DataFrame у форматі консолі:\n\n\nчерез функцію print(), у форматі консолі:\n\n\nimport pandas as pd\n\ndf = pd.DataFrame(data = table,\n    columns = [\"Name\", \"Race\", \"Sex\"])\nprint(df)\n\n            Name     Race     Sex\n0  Bilbo Baggins  Hobbits    Male\n1          Beren      Men    Male\n2       Nimrodel    Elves  Female\n3        Muzgash      Orc    Male\n\n\n\nМожна викликати Python через R за допомогою пакету reticulate та використати функцію kable() з пакету knitr:\n\n\nlibrary(reticulate)\n\nWarning: package 'reticulate' was built under R version 4.2.2\n\nlibrary(knitr)\n\nkable(py$df)\n\n\n\nТаблиця 4.2: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nДодаткові можливості з’являються разом з пакетом kableExtra:\n\n\n# R chunk\nlibrary(kableExtra)\n\npy$df %&gt;% \n  kbl() %&gt;%\n  kable_classic_2(full_width = F)\n\n\n\nТаблиця 4.3: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\n\n\n4.5.6 Рівняння\nДля запису рівняння в середині тексту використовується одинарний символ $ та подвійний $$ для запису рівняння з нового рядка:\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\nу середині тексту: $E = mc^{2}$\nу середині тексту: \\(E=mc^{2}\\)\n\n\n\nз нового рядка:\n\n$$E = mc^{2}$$\nз нового рядка:\\[E = mc^{2}\\]\n\n\n\n\nВ якості допомоги формування рівнянь рекомендую ресурс Online LaTeX Equation Editor.\n\n4.5.7 Діаграми\nQuarto має вбудовану підтримку для створення діаграм Mermaid та Graphviz. Це дає змогу створювати блок–схеми, діаграми послідовності, діаграми станів тощо, використовуючи синтаксис простого тексту.\nПриклад створення блок–схеми за допомогою Mermaid:\n\n```{mermaid}\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n```\n\n\n\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n\n\n\n\n\nБільше інформації у розділі Diagrams.\n\n4.5.8 Відео\nВставляти відео у документи можна за допомогою запису {{&lt; video &gt;}}.\nПриклад використання відео з Youtube:\n{{&lt; video https://www.youtube.com/embed/qOhk7YyxXQ4 &gt;}}\nБільше інформації у розділі Videos.\n\n4.5.9 Виноски\n\n4.5.9.1 Типи виносок\nВиноски — чудовий спосіб привернути додаткову увагу до певних понять або чіткіше вказати, що певний вміст є додатковим або потребує додаткової уваги.\nУ Quarto є п’ять різноманітних виносок: - примітка (note) - застереження (warning) - важливо (important) - підказка (tip) - попередження (caution)\nКолір і значок відрізнятимуться залежно від обраного типу. Ось як виглядають різні виноски в HTML:\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що існує п’ять типів виносок, зокрема: note, tip, warning, caution та important.\n\n\n\n\n\n\n\n\nЗастереження\n\n\n\nВиноски — простий спосіб привернути увагу, наприклад, до цього застереження.\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nВиноски точно покращать Ваш текст.\n\n\n\n\n\n\n\n\nПідказка\n\n\n\nПриклад виноски з текстом\n\n\n\n\n\n\n\n\nРозгорніть, щоб дізнатися про згортання\n\n\n\n\n\nЦе приклад «згорнутої» виноски з попередженням. Використайте collapse=\"true\" щоб згорнути її за замовчуванням та collapse=\"false\" щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n\n\n\n\n4.5.9.2 Синтаксис markdown\nСтворіть виноски в розмітці за допомогою наступного синтаксису (зверніть увагу, що перший заголовок, використаний у виносці, використовується як заголовок виноски):\n::: {.callout-note}\n## Примітка\n\nЗауважте, що існує п’ять типів виносок, зокрема:\n`note`, `tip`, `warning`, `caution` та `important`.\n:::\n\n::: {.callout-tip}\n## Підказка\n\nПриклад виноски з текстом\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Розгорніть, щоб дізнатися про згортання\n\nЦе приклад «згорнутої» виноски з попередженням.\nВикористайте `collapse=\"true\"` щоб згорнути її за замовчуванням та `collapse=\"false\"` щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n:::\n\n4.5.10 Спеціальні символи\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\nтире: -\nтире: -\n\n\nкоротке (середнє) тире: --\nкоротке (середнє) тире: –\n\n\nдовге тире: ---\nдовге тире: —\n\n\n\n\n\n\n\n\n\nПриклади\n\n\n\n\nЖиття прожити — не поле перейти (довге тире)\n2020–2022 (коротке тире)\n25 - 5 (тире)"
  },
  {
    "objectID": "quarto.html#виконання-коду",
    "href": "quarto.html#виконання-коду",
    "title": "\n4  Quarto\n",
    "section": "\n4.6 Виконання коду",
    "text": "4.6 Виконання коду\n\n4.6.1 Налаштування виводу\nІснує широкий спектр доступних параметрів для налаштування виводу виконаного коду. Усі ці параметри можна вказати глобально (у YAML-шапці з ключем execute) або для кожного блоку коду.\n\nПриклад глобальних налаштувань:\n\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\nexecute:\n  echo: false\n---\n\nПриклад налаштування конкретного чанку:\n\n```{python}\n#| echo: true\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nx = np.arange(-4, 4, .012)\ny = np.arange(-4, 4, .012)\nX, Y = np.meshgrid(x, y)\nZ = 1 - np.abs(X) - np.sin(Y**2)\nW = 1 + Y - np.cos(X**2)\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(projection='polar')\nplt.scatter(Z, W, alpha=.03, s=0.2)\nplt.axis('off')\nplt.show()\n```\nПараметри налаштування знаходяться у верхній частині блоку під спеціальним коментарем #|.\n\n\n\n\n\n\nНалаштування\nОпис\n\n\n\neval\nОцініть фрагмент коду (якщо false, просто відтворіть код).\n\n\necho\nПоказувати код (якщо false, код не буде виведено на екран).\n\n\nwarning\nПоказувати попередження, які виникають під час виконання коду\n\n\nerror\nПоказувати помилки у документі (це означає, що помилки під час виконання коду не зупинять обробку документа).\n\n\ninclude\nЗапобігає виводу коду та його результатів.\n\n\n\n4.6.2 Вбудований код\nQuarto дозволяє виводити результат коду в середині тексту. Це особливо зручно, якщо необхідно щоб документ використовував найсвіжіші розрахунки. Проте синтаксис виводу залежить від рушія (анг. engine) Quarto: Jupyter, Knitr або OJS.\n\n4.6.2.1 Jupyter\nЩоб включити збережену змінну, використовуєте IPython.display.Markdown.\nНаприклад, виведемо площу кола за заданим радіусом (radius):\n```{python}\n#| echo: false\n\nfrom IPython.display import Markdown\nimport math\n\nradius = 10\ncircle_area = math.pi * pow(radius, 2)\n\nMarkdown((f\"\"\"\nПлоща кола з радіусом {radius} дорівнює {round(circle_area, 2)}.\n\"\"\"\n))\n```\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що ми використовуємо опцію echo: false, щоб не виводити код у фінальний документ, а тільки результат.\n\n\n\n4.6.2.2 Knitr\nАналогічно до роботи з таблицями (див. Розділ 4.5.5.2) можемо поєднати можливості R та Python для виводу результату коду в тексті документу.\nЩоб включити вирази в розмітку для Knitr, використовується вираз у `r `:\n```{r}\n#| include: false\n\nlibrary(reticulate)\n```\n```{python}\n#| echo: false\n\nimport math\n\nradius = 10\ncircle_area = round(math.pi * pow(radius, 2), 2)\n```\nПлоща кола з радіусом  `r⠀py$radius`  дорівнює `r⠀py$circle_area`.\n\n\n\n\n\n\nПримітка\n\n\n\nЗапис py$radius означає: взяти значення змінної Python з ім’ям radius."
  },
  {
    "objectID": "quarto.html#основи-публікації",
    "href": "quarto.html#основи-публікації",
    "title": "\n4  Quarto\n",
    "section": "\n4.7 Основи публікації",
    "text": "4.7 Основи публікації\nІснує низка способів публікації документів, презентацій і веб-документів, створених за допомогою Quarto. Оскільки вміст, відтворений за допомогою Quarto, використовує стандартні формати (HTML, PDF, MS Word тощо), його можна опублікувати будь-де. Крім того, доступна команда quarto publish для легкої публікації в різних популярних службах (GitHub, Netlify, RStudio Connect тощо), а також різні інструменти, які полегшують публікацію з системи Неперервної інтеграції (анг. Continuous integration).\nСервіси для публікації:\n\n\n\n\n\n\nСервіс\nОпис\n\n\n\nQuarto Pub\nПублікація документів, веб-сайтів і книг Quarto.\n\n\nGitHub Pages\nПублікація документів за допомогою репозиторію GitHub\n\n\nRStudio Connect\nПлатформа для безпечного обміну даними в межах організації.\n\n\nNetlify\nПрофесійна платформа веб-публікації.\n\n\nІнші сервіси\nСкористайтеся цими сервісами, якщо один із наведених вище методів не відповідає вашим вимогам."
  },
  {
    "objectID": "quarto.html#footnotes",
    "href": "quarto.html#footnotes",
    "title": "\n4  Quarto\n",
    "section": "",
    "text": "YAML це рекурсивний акронім YAML Ain’t Markup Language («YAML — не мова розмітки»). У назві відображена історія розвитку: на ранніх етапах мова називалася Yet Another Markup Language («Ще одна мова розмітки») і навіть розглядалася як конкурент XML, але пізніше була перейменована з метою акцентувати увагу на даних, а не на розбивці документів.↩︎"
  },
  {
    "objectID": "sql_filtering.html#додаткові-завдання",
    "href": "sql_filtering.html#додаткові-завдання",
    "title": "3  Фільтрація даних",
    "section": "3.5 Додаткові завдання",
    "text": "3.5 Додаткові завдання\nДавайте вирішимо ще кілька завдань, щоб переконатися, що ми розібралися з фільтрацією даних.\n\nЗавдання 3.11  Визначте id та дати народження 10 наймолодших користувачів чоловічої статі з таблиці users. Не враховуйте користувачів, у яких не вказано дату народження.\nПоле в результуючій таблиці: user_id, birth_date\nПояснення: будьте уважні і пам’ятайте про значення NULL.\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       birth_date\nFROM   users\nWHERE  birth_date IS NOT NULL\n   AND sex = 'male'\nORDER BY birth_date DESC\nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\nbirth_date\n\n\n\n\n0\n11419\n2003-09-02\n\n\n1\n11461\n2002-11-05\n\n\n2\n9257\n2002-07-11\n\n\n3\n20804\n2002-01-09\n\n\n4\n14956\n2001-08-09\n\n\n5\n7047\n2001-06-11\n\n\n6\n11725\n2001-05-27\n\n\n7\n4374\n2001-04-29\n\n\n8\n15102\n2001-04-21\n\n\n9\n14571\n2001-03-31\n\n\n\n\n\n\n\n\nЗавдання 3.12  Напишіть SQL-запит до таблиці courier_actions, щоб дізнатися ID та час доставки останніх 10 замовлень, доставлених кур’єром з ID 100.\nПоля у результуючій таблиці: order_id, time\nПояснення: Зверніть увагу, що у вихідній таблиці є записи не лише з часом доставки, а й з часом прийняття замовлення.\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       time\nFROM   courier_actions\nWHERE  courier_id = 100\n   AND action = 'deliver_order'\nORDER BY order_id desc limit 10\n\n\n\n\n\n\n\n\n\norder_id\ntime\n\n\n\n\n0\n57791\n2022-09-08 18:18:00\n\n\n1\n55095\n2022-09-08 07:51:00\n\n\n2\n53500\n2022-09-07 23:05:00\n\n\n3\n49779\n2022-09-07 07:34:00\n\n\n4\n48406\n2022-09-06 22:13:00\n\n\n5\n44546\n2022-09-05 21:13:00\n\n\n6\n42258\n2022-09-05 11:49:00\n\n\n7\n41606\n2022-09-05 09:00:00\n\n\n8\n41440\n2022-09-05 08:14:00\n\n\n9\n38536\n2022-09-04 18:57:00"
  },
  {
    "objectID": "sql_filtering.html#фільтрація-з-null",
    "href": "sql_filtering.html#фільтрація-з-null",
    "title": "3  Фільтрація даних",
    "section": "3.4 Фільтрація з NULL",
    "text": "3.4 Фільтрація з NULL\nРаніше Завдання 2.11 ми зіткнулися з пропущеними значеннями в таблиці couriers — у деяких кур’єрів не було зазначено їхні дні народження.\nДля перевірки на NULL значення SQL є оператор IS NULL. У поєднанні з WHERE записується він так:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IS NULL\nЯкщо ж, навпаки, необхідно відібрати значення не NULL, то додатково використовується оператор NOT:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IS NOT NULL\nЯк ми знаємо, у світі даних NULL означає відсутність інформації. NULL - це не якась величина і тому її не можна порівняти з чимось ще. Результатом порівняння NULL з будь-яким іншим значенням буде той самий NULL. Більше того, NULL не вдасться порівняти і з іншим NULL, тому що в такому випадку порівнюватимуться дві невизначеності і не можна напевно сказати, рівні вони чи ні.\nСпробуйте виконати наступні запити:\nSELECT NULL = NULL\n\nРезультат:\nNULL\n\nSELECT NULL IS NULL\n\nРезультат:\ntrue\n\nSELECT 100 = NULL\n\nРезультат:\nNULL\n\nSELECT 100 IS NULL\n\nРезультат:\nfalse\n\n\n\n\n\n\nПримітка\n\n\n\nДетальніше про значення NULL можна прочитати тут.\n\n\n\nЗавдання 3.10 Напишіть SQL-запит до таблиці couriers та виведіть всю інформацію про кур’єрів, у яких не вказано їх день народження.\nРезультат має бути відсортований за зростанням id кур’єра.\nПоля в результуючій таблиці: birth_date, courier_id, sex\n\n\n\nРішення\n%%sql\nSELECT birth_date,\n       courier_id,\n       sex\nFROM   couriers\nWHERE  birth_date is null\nORDER BY courier_id\nLIMIT 10 -- для скорочення виводу\n\n\n\n\n\n\n\n\n\nbirth_date\ncourier_id\nsex\n\n\n\n\n0\nNaT\n83\nmale\n\n\n1\nNaT\n187\nmale\n\n\n2\nNaT\n200\nmale\n\n\n3\nNaT\n232\nmale\n\n\n4\nNaT\n411\nmale\n\n\n5\nNaT\n450\nmale\n\n\n6\nNaT\n467\nmale\n\n\n7\nNaT\n481\nmale\n\n\n8\nNaT\n726\nmale\n\n\n9\nNaT\n790\nmale"
  },
  {
    "objectID": "sql_filtering.html#фільтрація-по-даті-та-часу",
    "href": "sql_filtering.html#фільтрація-по-даті-та-часу",
    "title": "3  Фільтрація даних",
    "section": "3.6 Фільтрація по даті та часу",
    "text": "3.6 Фільтрація по даті та часу\nІ ще кілька завдань на роботу з датами та часом.\n\nЗавдання 3.13  З таблиці user_actions отримаєте id всіх замовлень, зроблених користувачами сервісу у серпні 2022 року.\nРезультат відсортуйте за зростанням id замовлення.\nПоле у результуючій таблиці: order_id\nПояснення: зверніть увагу, що у вихідній таблиці є записи не лише з часом оформлення, а й часом скасування замовлення.У цій задачі може стати в нагоді функція DATE_PART. Ми розглядали її в Завдання 2.10.\n\n\n\nРішення\n%%sql\nSELECT order_id\nFROM   user_actions\nWHERE  action = 'create_order'\n   AND DATE_PART('month', time) = 8\n   AND DATE_PART('year', time) = 2022\nORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n18794\n18795\n\n\n18795\n18796\n\n\n18796\n18797\n\n\n18797\n18798\n\n\n18798\n18799\n\n\n\n\n18799 rows × 1 columns\n\n\n\n\nЗавдання 3.14  З таблиці couriers відберіть id всіх кур’єрів, що народилися в період з 1990 по 1995 включно.\nРезультат відсортуйте за зростанням id кур’єра.\nПоле у результуючій таблиці: courier_id\nПояснення: у цьому завдання знову може стати в нагоді функція DATE_PART.\n\n\n\nРішення\n%%sql\nSELECT courier_id\nFROM   couriers\nWHERE  date_part('year', birth_date) BETWEEN 1990\n   AND 1995\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\n\n\n\n\n0\n2\n\n\n1\n3\n\n\n2\n8\n\n\n3\n9\n\n\n4\n10\n\n\n...\n...\n\n\n1522\n3153\n\n\n1523\n3160\n\n\n1524\n3161\n\n\n1525\n3166\n\n\n1526\n3167\n\n\n\n\n1527 rows × 1 columns\n\n\n\n\nЗавдання 3.15  З таблиці user_actions отримайте інформацію про всі скасування замовлень, які користувачі здійснювали протягом серпня 2022 по середах з 12:00 до 15:59.\nРезультат відсортуйте за зменшенням id скасованих замовлень.\nПоля у результуючій таблиці: user_id, order_id, action, time\nПояснення: будьте уважні при роботі з датами та часом. Для вирішення задачі вам знадобиться функція DATE_PART. Для отримання дня тижня можна вказати аргумент 'dow' (“day of week”):\nSELECT DATE_PART('dow', DATE '2022-12-31')\n\nРезультат:\n6.00\nВ DuckDB дні тижня рахуються з неділі (0) до суботи (6).\n\n\n\nРішення\n%%sql\nSELECT  user_id,\n        order_id,\n        action,\n        time\nFROM   user_actions\nWHERE  action = 'cancel_order'\n    AND DATE_PART('dow', time) = 03\n    AND DATE_PART('month', time) = 08\n    AND DATE_PART('year', time) = 2022\n    AND DATE_PART('h', time) BETWEEN 12\n    AND 15\nORDER BY order_id DESC\nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\naction\ntime\n\n\n\n\n0\n8117\n17307\ncancel_order\n2022-08-31 15:59:00\n\n\n1\n8107\n17282\ncancel_order\n2022-08-31 15:50:00\n\n\n2\n1495\n17272\ncancel_order\n2022-08-31 15:46:00\n\n\n3\n7427\n17252\ncancel_order\n2022-08-31 15:38:00\n\n\n4\n3207\n17231\ncancel_order\n2022-08-31 15:33:00\n\n\n5\n8077\n17218\ncancel_order\n2022-08-31 15:30:00\n\n\n6\n3446\n17216\ncancel_order\n2022-08-31 15:28:00\n\n\n7\n8076\n17214\ncancel_order\n2022-08-31 15:26:00\n\n\n8\n6116\n17190\ncancel_order\n2022-08-31 15:17:00\n\n\n9\n8057\n17151\ncancel_order\n2022-08-31 15:02:00"
  },
  {
    "objectID": "sql_filtering.html#фільтрація-з-case-when",
    "href": "sql_filtering.html#фільтрація-з-case-when",
    "title": "3  Фільтрація даних",
    "section": "3.7 Фільтрація з CASE WHEN",
    "text": "3.7 Фільтрація з CASE WHEN\nІ насамкінець давайте повернемося до наших податків.\nМинулого разу ми вирішили завдання для одного з менеджерів та порахували ПДВ кожного товару. Ви довго дивилися на розрахунки, що вийшли, і вас все-таки замучила совість: адже ви точно знаєте, що на окремі групи товарів ПДВ становить не 20%, а 10%.\nОскільки менеджер раптово перестав відповідати на ваші повідомлення, ви вирішили написати безпосередньо бухгалтеру та запросили список товарів, на які поширюється ПДВ 10%.\nОсь який список ви отримали:\n'sugar', 'crackers', 'drying', 'seeds',\n'linseed oil', 'grapes', 'olive oil',\n'watermelon', 'baton', 'yogurt', 'cream', 'buckwheat',\n'oatmeal', 'pasta', 'mutton', 'oranges',\n'bagels', 'bread', 'peas', 'sour cream', 'smoked fish',\n'flour', 'sprats', 'sausages', 'pork', 'rice',\n'sesame oil', 'condensed milk', 'pineapple', 'beef',\n'salt', 'dried fish', 'sunflower oil', 'apples',\n'pears', 'flatbread', 'milk', 'chicken', 'lavash', 'waffles', 'tangerines'\n\nЗавдання 3.16  Як і у минулому завданні (Завдання 2.15), обчисліть ПДВ кожного товару в таблиці products і розрахуйте ціну без урахування ПДВ. Однак тепер врахуйте, що для товарів зі списку податок становить 10%. Для решти товарів ПДВ той самий — 20%.\nВиведіть всю інформацію про товари, включаючи суму податку та ціну без його врахування. Колонки із сумою податку та ціною без ПДВ назвіть відповідно tax та price_before_tax. Округліть значення у цих колонках до двох знаків після коми.\nРезультат відсортуйте спочатку за спаданням ціни товару без урахування ПДВ, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, tax, price_before_tax\nПояснення: порядок розрахунку податку той самий, що й у Завдання 2.15. Для вирішення завдання вам можуть стати в нагоді конструкція CASE та оператор IN. Конструкцію CASE ми розглядали у Завдання 2.14.\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       round(price * (case when name in ('sugar', 'crackers', 'drying', 'seeds',\n                                         'linseed oil', 'grapes', 'olive oil',\n                                         'watermelon', 'baton', 'yogurt', 'cream', 'buckwheat',\n                                         'oatmeal', 'pasta', 'mutton', 'oranges',\n                                         'bagels', 'bread', 'peas', 'sour cream', 'smoked fish',\n                                         'flour', 'sprats', 'sausages', 'pork', 'rice',\n                                         'sesame oil', 'condensed milk', 'pineapple', 'beef',\n                                         'salt', 'dried fish', 'sunflower oil', 'apples',\n                                         'pears', 'flatbread', 'milk', 'chicken', 'lavash', 'waffles', 'tangerines')\n                      then 0.1 / 1.1\n                      else 0.2 / 1.2 end), 2) as tax,\n       round(price / (case when name in ('sugar', 'crackers', 'drying', 'seeds',\n                                         'linseed oil', 'grapes', 'olive oil',\n                                         'watermelon', 'baton', 'yogurt', 'cream', 'buckwheat',\n                                         'oatmeal', 'pasta', 'mutton', 'oranges',\n                                         'bagels', 'bread', 'peas', 'sour cream', 'smoked fish',\n                                         'flour', 'sprats', 'sausages', 'pork', 'rice',\n                                         'sesame oil', 'condensed milk', 'pineapple', 'beef',\n                                         'salt', 'dried fish', 'sunflower oil', 'apples',\n                                         'pears', 'flatbread', 'milk', 'chicken', 'lavash', 'waffles', 'tangerines')\n                      then 1.1\n                      else 1.2 end), 2) as price_before_tax\nFROM   products\nORDER BY price_before_tax desc, product_id asc;\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ntax\nprice_before_tax\n\n\n\n\n0\n13\ncaviar\n800.0\n133.33\n666.67\n\n\n1\n37\nmutton\n559.0\n50.82\n508.18\n\n\n2\n15\nolive oil\n450.0\n40.91\n409.09\n\n\n3\n57\npork\n450.0\n40.91\n409.09\n\n\n4\n66\nbeef\n370.0\n33.64\n336.36\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n2.27\n22.73\n\n\n83\n5\ncoffee 3 in 1\n15.0\n2.50\n12.50\n\n\n84\n73\ncake\n15.0\n2.50\n12.50\n\n\n85\n10\nseeds\n12.0\n1.09\n10.91\n\n\n86\n54\npaper bag\n1.0\n0.17\n0.83\n\n\n\n\n87 rows × 5 columns"
  }
]