[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python та його друзі в науці про дані",
    "section": "",
    "text": "Вступне слово\n\n\n\n\n\n\nВажливо\n\n\n\nЦя книга знаходиться на стадії розробки.\n\n\nШановні читачі,\nЗапрошую до книги “Python та його друзі в науці про дані”! Сьогодні ми відкриваємо двері до захоплюючого світу аналізу даних та наукових досліджень, в якому Python стає вашим найкращим другом. Завдяки своїй простоті, гнучкості та потужності, Python виходить за межі звичайної мови програмування, перетворюючись на незамінного помічника для розв’язання складних задач і виявлення прихованих закономірностей.\nУ цій книзі ми збираємося подорожувати у світі науки про дані, де Python та інші дотичні інструменти стають невід’ємною частиною процесу відкриття знань та розуміння складних систем. Ви дізнаєтеся, як за допомогою Python можна ефективно обробляти, аналізувати та візуалізувати дані, виявляти закономірності та робити передбачення. Завдяки цим інструментам ви зможете розкрити потужний потенціал ваших даних та прийняти обґрунтовані рішення на основі наукових фактів.\nЯ запрошую вас на цю захоплюючу подорож, де ми разом з вами розкриємо секрети Python у науці про дані. Незалежно від вашого досвіду в програмуванні або знань про науку про дані, ця книга надасть вам необхідні знання та інструменти для успішного впровадження Python у ваші проекти. Будьте впевнені, що по закінченні цього шляху ви будете готові до викликів, які стоять перед вами у світі науки та досліджень.\nНехай ця книга стане вашим надійним провідником у справжньому дослідницькому пригоді, де Python та його друзі стають вашими найкращими союзниками. Розпочнемо нашу подорож разом!\nЗ найкращими побажаннями, Ігор Мірошниченко"
  },
  {
    "objectID": "sql.html#схема-бази-даних",
    "href": "sql.html#схема-бази-даних",
    "title": "SQL",
    "section": "Схема бази даних",
    "text": "Схема бази даних\nУ цьому розділі ми будемо використовувати набори даних, які представляють сервіс з доставки продуктів. Тут зберігається документація, котра допоможе розібратися з ними.\nДля запуску бази даних, я використовую DuckDB. Самі файли з даними можна знайти в репозиторії. Для локального запуску бази даних необхідно виконати наступний код:\n\n\nКод\n# Встановлення та імпорт необхідних пакетів\n!pip install --quiet duckdb\n!pip install --quiet jupysql \n!pip install --quiet duckdb-engine\n!pip install --quiet pandas\n!pip install --quiet matplotlib\n\nimport duckdb\nimport pandas as pd\n\n# Імпорт Jupyter-розширення jupysql для створення SQL комірок\n%load_ext sql\n\n# Налаштування jupysql, щоб дані поверталися у вигляді DataFrame Pandas з меншим виводом\n%config SqlMagic.autopandas = True\n%config SqlMagic.feedback = False\n%config SqlMagic.displaycon = False\n\n# Підключення до DuckDB в режимі \"in-memory\"\n%sql duckdb:///:memory:\n\n\n# Завантаження даних з файлів\n%sql CREATE OR REPLACE TABLE user_actions AS SELECT * FROM\n    read_csv('00_data/sql/user_actions.csv', header=True,\n             columns={'user_id': 'INT', 'order_id': 'INT',\n                      'action': 'VARCHAR', 'time': 'TIMESTAMP'},\n             timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE courier_actions AS SELECT * FROM \n    read_csv('00_data/sql/user_actions.csv', header=True,\n             columns={'courier_id': 'INT', 'order_id': 'INT',\n                      'action': 'VARCHAR', 'time': 'TIMESTAMP'},\n             timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE orders AS SELECT * FROM \n    read_csv('00_data/sql/orders.csv', header=True,\n             columns={'order_id': 'INT', 'creation_time': 'TIMESTAMP',\n                      'product_ids': 'INT[]'},\n             timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE users AS SELECT * FROM\n    read_csv('00_data/sql/users.csv', header=True,\n             columns={'user_id': 'INT', 'birth_date': 'DATE',\n                      'sex': 'VARCHAR'},\n             dateformat='%d/%m/%y');\n%sql CREATE OR REPLACE TABLE couriers AS SELECT * FROM\n    read_csv('00_data/sql/couriers.csv', header=True,\n             columns={'courier_id': 'INT', 'birth_date': 'DATE',\n                      'sex': 'VARCHAR'},\n             dateformat='%d/%m/%y');\n%sql CREATE OR REPLACE TABLE products AS SELECT * FROM\n    read_csv('00_data/sql/products.csv', header=True,\n             columns={'product_id': 'INT', 'name': 'VARCHAR',\n                      'price': 'DOUBLE'});\n\n\nНа схемі продемонстровані зв’язки між таблицями, а також опис даних:\n\n\n\n\nerDiagram\n    orders }|..|{ products : product_ids-product_id\n    orders }|..|{ courier_actions : order_id\n    users }|..|{ user_actions : user_id\n    user_actions }|..|{ orders : order_id\n    user_actions }|..|{ courier_actions : time\n    courier_actions }|..|{ courier : product\n    \n    users {\n        DATE birth_date\n        VARCHAR sex\n        INT user_id\n    }\n    user_actions {\n        INT user_id\n        VARCHAR actions\n        INT order_id\n        TIMESTAMP time\n    }\n    orders {\n        INT order_id\n        ARRAY product_ids\n        TIMESTAMP creation_time\n    }\n    products {\n        INT product_id\n        NUMERIC price\n        VARCHAR name\n    }\n    courier_actions {\n        INT courier_id\n        VARCHAR action\n        INT order_id\n        TIMESTAMP time\n    }\n    courier {\n        INT courier_id\n        VARCHAR sex\n        DATE birth_date\n    }"
  },
  {
    "objectID": "sql.html#типи-даних",
    "href": "sql.html#типи-даних",
    "title": "SQL",
    "section": "Типи даних",
    "text": "Типи даних\nВ таблицях можуть зберігатися різні типи даних: цілі і дробові числа, текст, дати, масиви чисел. У цих даних ви зустрінетесь з наступними типами:\n\n\n\n\n\n\n\n\n\nТипи даних\nОпис\nПриклад\n\n\n\n\n0\nINT\nЦіле число\nid користувача: 123\n\n\n1\nNUMERIC / DECIMAL\nДійсне число\nВартість товару: 120.55\n\n\n2\nVARCHAR\nТекст\nДія із замовленням: «create_order»\n\n\n3\nDATE\nДата з точністю до дня\nДата народження користувача: 25/03/91\n\n\n4\nTIMESTAMP\nДата з точністю до секунди\nЧас реєстрації у додатку: 24/08/22 01:52:24\n\n\n5\n[]\nМасив\nСписок id товаров у замовленні: [1, 13, 22]\n\n\n\n\n\n\n\nБільш детально почитати про типи даних можна за посиланням"
  },
  {
    "objectID": "sql.html#структура-та-наповнення-таблиць",
    "href": "sql.html#структура-та-наповнення-таблиць",
    "title": "SQL",
    "section": "Структура та наповнення таблиць",
    "text": "Структура та наповнення таблиць\nuser_actions – дії користувачів із замовленнями.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\nuser_id\nINT\nid користувача\n\n\n1\norder_id\nINT\nid замовлення\n\n\n2\naction\nVARCHAR(50)\nдія користувача із замовленням; \"create_order\"...\n\n\n3\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\n\ncourier_actions – дії кур’єрів із замовленнями.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\norder_id\nINT\nid замовлення\n\n\n2\naction\nVARCHAR(50)\nдія кур'єра із замовленням; 'accept order' - п...\n\n\n3\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\n\norders - інформація про замовлення.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\norder_id\nINT\nid замовлення\n\n\n1\ncreation_time\nTIMESTAMP\nчас створення замовлення\n\n\n2\nproduct_ids\ninteger[]\nсписок id товарів у замовленні\n\n\n\n\n\n\n\nusers - інформація про користувачів.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\nuser_id\nINT\nid користувача\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\ncouriers - інформація про кур’єрів.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\nproducts - інформація про товари, які доставляє сервіс.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ дужках типу VARCHAR вказано максимально допустиму кількість символів у тексті. У типу даних NUMERIC у дужках вказано загальну кількість символів."
  },
  {
    "objectID": "sql_basics.html#відбір-select",
    "href": "sql_basics.html#відбір-select",
    "title": "2  Базові запити",
    "section": "2.1 Відбір: SELECT",
    "text": "2.1 Відбір: SELECT\nДавайте спочатку напишемо найпростіший запит і подивимося, як виглядає таблиця products.\nЩоб вивести всі записи зі значеннями у всіх колонках, необхідно або перерахувати всі колонки в операторі SELECT або вказати після оператора спеціальний символ “*”:\nSELECT column_1, column_2, ...\nFROM table\n\n\nSELECT *\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nОператор FROM завжди вказується після оператора SELECT. У зворотному порядку їх записувати не можна – база даних поверне помилку.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.1 Виведіть усі записи з таблиці products.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n1\nsugar\n150.0\n\n\n1\n2\ngreen tea bags\n50.0\n\n\n2\n3\nstill water\n80.0\n\n\n3\n4\nlollipops\n46.0\n\n\n4\n5\ncoffee 3 in 1\n15.0\n\n\n...\n...\n...\n...\n\n\n82\n83\nwaffles\n55.0\n\n\n83\n84\ntangerines\n90.0\n\n\n84\n85\njam\n200.0\n\n\n85\n86\ncold coffee\n70.0\n\n\n86\n87\nveal\n398.0\n\n\n\n\n87 rows × 3 columns\n\n\n\nНа практиці таблиці можуть бути дуже великими, тому дуже бажано використовувати оператор LIMIT для того щоб не виводити всю таблицю, що може займати багато часу. Крім того, можливо такий запит навіть не буде виконано, оскільки розумні дата інженери заборонили виконувати такі запити."
  },
  {
    "objectID": "sql_basics.html#впорядкування-order-by",
    "href": "sql_basics.html#впорядкування-order-by",
    "title": "2  Базові запити",
    "section": "2.2 Впорядкування: ORDER BY",
    "text": "2.2 Впорядкування: ORDER BY\nДля сортування значень по будь-якій колонці SQL використовується оператор ORDER BY з ключовими словами ASC (за зростанням) або DESC (за спаданням).\nПри цьому за умовчанням сортування відбувається за зростанням, тобто ASC не обов’язково вказувати. Для сортування за спаданням після ORDER BY необхідно явно вказати DESC:\nSELECT column_1, column_2\nFROM table\nORDER BY column_1           -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 ASC       -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC      -- сортування за спаданням\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.2 Виведіть всі записи з таблиці products, відсортувавши їх за найменуванням товарів у алфавітному порядку, тобто за зростанням. Для сортування використовуйте оператор ORDER BY.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nСортування можна робити не тільки по полях зі значеннями, вираженими числами, але й по полях, значення яких представлені у вигляді тексту, як у нашому випадку.\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nORDER BY name\nLIMIT 5\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n62\napple juice\n120.0\n\n\n1\n71\napples\n75.0\n\n\n2\n39\nbagels\n45.0\n\n\n3\n65\nbananas\n100.0\n\n\n4\n66\nbeef\n370.0\n\n\n\n\n\n\n\nСортувати результат SQL-запиту можна відразу за декількома колонками, вказуючи їх після ORDER BY через кому разом із напрямком сортування (ASC або DESC):\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2    -- спочатку сортування по першій колонці (за спаданням),\n                                    -- потім по другій (за зростанням)\n\n\n\n\n\n\nПримітка\n\n\n\nВажливо пам’ятати, що при роботі з великими таблицями потрібно по можливості обмежувати кількість виведених записів, щоб не створювати зайве навантаження на базу даних.\n\n\nОператори ORDER BY та LIMIT можна поєднувати в одному запиті, при цьому оператор LIMIT записується та виконується після оператора ORDER BY, обмежуючи кількість записів у вже відсортованому результаті:\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2\nLIMIT 5\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.3 Відсортуйте таблицю courier_actions спочатку по колонці courier_id за зростанням id кур’єра, потім по колонці action (знову за зростанням), а потім по колонці time, але вже за спаданням — від останньої дії до першої. Не забудьте включити колонку order_id.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: courier_id, order_id, action, time.\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЯк ви вже здогадалися, сортувати таблиці можна навіть по полях з датами та часом.\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       order_id,\n       action,\n       time\nFROM   courier_actions\nORDER BY courier_id, action, time DESC limit 5\n\n\n\n\n\n\n\n\n\ncourier_id\norder_id\naction\ntime\n\n\n\n\n0\n1\n23149\ncreate_order\n2022-09-02 02:36:00\n\n\n1\n1\n22901\ncreate_order\n2022-09-02 00:58:00\n\n\n2\n1\n4683\ncreate_order\n2022-08-27 20:56:00\n\n\n3\n1\n1\ncreate_order\n2022-08-24 01:52:00\n\n\n4\n2\n7114\ncreate_order\n2022-08-28 18:11:00\n\n\n\n\n\n\n\nЗараз важливо запам’ятати порядок запису всіх відомих нам ключових слів:\n\nSELECT\nFROM\nORDER BY\nLIMIT\n\nТакож важливо зрозуміти, що порядок їх виконання дещо відрізняється від того, в якій послідовності вони вказуються в SQL-запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nПотім SELECT - відбираються вказані стовпці.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.4 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, визначте 5 найдорожчих товарів у таблиці products, які доставляє наш сервіс. Виведіть їх найменування та ціну.\nПоля у результуючій таблиці: name, price.\n\n\n\n\n\nРішення\n%%sql\nSELECT name,\n       price\nFROM   products\nORDER BY price desc limit 5\n\n\n\n\n\n\n\n\n\nname\nprice\n\n\n\n\n0\ncaviar\n800.0\n\n\n1\nmutton\n559.0\n\n\n2\nolive oil\n450.0\n\n\n3\npork\n450.0\n\n\n4\ndecaffeinated coffee\n400.0"
  },
  {
    "objectID": "sql_basics.html#зміна-назви-as",
    "href": "sql_basics.html#зміна-назви-as",
    "title": "2  Базові запити",
    "section": "2.3 Зміна назви: AS",
    "text": "2.3 Зміна назви: AS\nПри складанні SQL-запитів колонкам у результуючій таблиці можна надавати будь-які інші імена (їх ще називають «аліасами»). Це можна робити за допомогою оператора AS:\nSELECT name AS new_name\nFROM table\nЯкщо раптом вам здасться, що на написання оператора AS йде занадто багато часу і сил, його можна опустити, вказавши нове ім’я колонки без нього. Наступний запис також спрацює:\nSELECT name new_name\nFROM table\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.5 Повторіть запит із з попереднього прикладу (Завдання 2.3), але тепер колонки name і price перейменуйте відповідно на product_name і product_price.\nПоля у результуючій таблиці: product_name, product_price\n\n\n\n\n\nРішення\n%%sql\n\nSELECT name AS product_name,\n       price AS product_price\nFROM   products\nORDER BY price desc limit 5\n\n\n\n\n\n\n\n\n\nproduct_name\nproduct_price\n\n\n\n\n0\ncaviar\n800.0\n\n\n1\nmutton\n559.0\n\n\n2\nolive oil\n450.0\n\n\n3\npork\n450.0\n\n\n4\ndecaffeinated coffee\n400.0"
  },
  {
    "objectID": "sql_basics.html#кількість-символів-length",
    "href": "sql_basics.html#кількість-символів-length",
    "title": "2  Базові запити",
    "section": "2.4 Кількість символів: LENGTH",
    "text": "2.4 Кількість символів: LENGTH\nУ SQL-запитах до колонок таблиць можна використовувати різні функції, наприклад, як в Excel.\nУ загальному вигляді синтаксис функцій виглядає приблизно так:\nSELECT function(a, b, c, ...)\nFROM table\nЗамість function вказується назва функції, а дужках — її аргументи. Як аргументи можуть виступати як колонки зі значеннями, так і окремі значення. Залежно від функції кількість аргументів може відрізнятися.\nЯкщо ви коли-небудь працювали в Excel, то вам, напевно, знайомі різні функції на кшталт SUM, MIN, MAX тощо, які роблять деякі обчислення по стовпцях. У SQL вони називаються агрегуючими функціями.\nЗараз як приклад розглянемо функцію LENGTH. Вона виконує досить просте завдання — підраховує кількість символів у поданому їй на вхід значенні текстового типу (текстовий тип даних часто називають рядком — від англ. «string»). Іншими словами, функція LENGTH вимірює довжину деякого рядка у символах:\n\n%%sql\nSELECT LENGTH('I.love.Python') as py_love\n\n\n\n\n\n\n\n\npy_love\n\n\n\n\n0\n13\n\n\n\n\n\n\n\nФункція LENGTH також може застосовуватись до всього стовпця. У такому випадку довжина символів буде порахована для кожного значення в стовпці. Відповідний запит виглядатиме так:\nSELECT LENGTH(column) AS column_length\nFROM table\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.6 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, а також функцію LENGTH, визначте товар із найдовшою назвою у таблиці products. Виведіть його найменування, довжину найменування у символах, а також ціну цього товару. Назвіть колонку з довжиною найменування в символах name_length.\nПоля у результуючій таблиці: name, name_length, price.\n\n\n\n\n\nРішення\n%%sql\nSELECT name,\n       length(name) as name_length,\n       price\nFROM   products\nORDER BY name_length desc limit 1\n\n\n\n\n\n\n\n\n\nname\nname_length\nprice\n\n\n\n\n0\nfruit drink blueberry\n21\n170.0\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що в цьому прикладі ви сортуєте результуючу таблицю по розрахунковій колонці name_length, якої спочатку не було таблиці products.\nТаке сортування за новими колонками можливе, оскільки це узгоджується з порядком виконання операторів у запиті: спочатку виконується вибір колонок і всі перетворення над ними в операторі SELECT — і тільки потім проводиться сортування за вказаними в ORDER BY стовпчиками. Тобто на момент сортування всі розрахункові поля вже існують, а значить, їх можна вказувати в ORDER BY.\nТакож зверніть увагу, що ми двічі вказуємо колонку name в операторі SELECT: вперше просто звертаємося до неї за ім’ям, а вдруге - використовуємо її як аргумент функції LENGTH. У цьому випадку теж немає жодних протиріч - ми можемо вибирати колонку стільки разів, скільки необхідно, причому для цього навіть необов’язково надавати цим колонкам різні аліаси (база даних сама перейменує дублікат колонки).\n\n\nУ SQL, як й у багатьох інших мовах, функції можна застосовувати до інших функцій, тобто. послідовно:\nSELECT function_one(function_two(a, b), c)\nУ наведеній вище конструкції a, b, c аргументи функцій. При цьому одним із аргументів функції function_one є результат виконання функції function_two.\nТаким чином, спочатку буде виконана функція function_two, а потім її результат буде поданий на вхід функції function_one як один з аргументів.\nРозглянемо такий випадок на прикладі функцій UPPER та LEFT. Функція UPPER наводить подане їй на вхід текстове значення до верхнього регістру:\nSELECT \n    UPPER('I.love.Python') AS upper_all\n\nРезультат:\nI.LOVE.PYTHON\nФункція LEFT повертає перші n символів у рядку:\nSELECT \n    LEFT('I.love.Python', 6) AS first_n\n\nРезультат:\nI.love\nМи можемо застосувати ці функції послідовно і в результаті отримаємо перші три символів верхнього регістру:\nSELECT \n    UPPER(LEFT('I.love.Python', 6))\n\nРезультат:\nI.LOVE\n\n\n\n\n\n\nОбережно\n\n\n\nЗверніть увагу, що у блоці SELECT не можна виконати дві операції окремо, тобто. ми не можемо спочатку створити розрахункову колонку з першими шістьма символами, а потім відразу ж звернутися до цієї нової колонки, застосувавши до неї функцію UPPER.\n\n\nНаступний запит не буде виконано, база даних поверне помилку:\nSELECT \n    LEFT('I.love.Python', 3) AS first_n,\n    UPPER(first_n) AS upper_first_n\n\nРезультат:\nError running query: column \"new_name\" does not exist\nВ межах одного запиту колонки створюються не по черзі, а разом, тому в межах одного запиту колонки upper_first_n не існує, поки блок SELECT не буде повністю виконаний. Дуже важливо враховувати цю особливість мови.\nОднак на практиці до нових колонок доводиться звертатися досить часто — саме для цього є підзапити (запити до інших запитів). А поки що нам достатньо розуміти, що застосовувати функції до розрахункових колонок у тому ж запиті не можна."
  },
  {
    "objectID": "sql_basics.html#поділ-та-повернення-split_part",
    "href": "sql_basics.html#поділ-та-повернення-split_part",
    "title": "2  Базові запити",
    "section": "2.5 Поділ та повернення: SPLIT_PART",
    "text": "2.5 Поділ та повернення: SPLIT_PART\nФункція SPLIT_PART розбиває поданий їй на вхід рядок на кілька частин відповідно до зазначеного роздільника та повертає одну з частин.\nКрім самого рядка (або колонки зі значеннями рядкового типу), функція приймає ще два аргументи — роздільник і порядковий номер частини, яку необхідно повернути. Подивіться наступний приклад:\nSELECT SPLIT_PART('I.love.Python', '.', 3)\n\nРезультат:\nPython\nУ прикладі вище рядок 'I.love.Python' було розбито на три частини ('I', 'love' та 'Python') по роздільнику “.”. Функція повернула 'Python', оскільки третім аргументом ми вказали частину із порядковим номером 3.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з іншими функціями для роботи з рядками можна ознайомитись за посиланням.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.7 Застосуйте послідовно функції UPPER та SPLIT_PART до колонки name та перетворіть найменування товарів у таблиці products так, щоб від назв залишилося тільки перше слово, записане у верхньому регістрі. Колонку з новою назвою, що складається із першого слова, назвіть first_word.\nУ результаті виведіть вихідні найменування товарів, нові найменування з першого слова, а також ціну товарів. Результат відсортуйте за зростанням початкового найменування товару в колонці name.\nПоля у результуючій таблиці: name, first_word, price\n\n\n\n\n\nРішення\n%%sql\nSELECT\n    name,\n    UPPER(SPLIT_PART(name, ' ', 1)) AS first_word,\n    price\nFROM\n    products\nORDER BY\n    name\n\n\n\n\n\n\n\n\n\nname\nfirst_word\nprice\n\n\n\n\n0\napple juice\nAPPLE\n120.0\n\n\n1\napples\nAPPLES\n75.0\n\n\n2\nbagels\nBAGELS\n45.0\n\n\n3\nbananas\nBANANAS\n100.0\n\n\n4\nbeef\nBEEF\n370.0\n\n\n...\n...\n...\n...\n\n\n82\nwaffles\nWAFFLES\n55.0\n\n\n83\nwatermelon\nWATERMELON\n120.0\n\n\n84\nwhite chocolate\nWHITE\n60.0\n\n\n85\nyogurt\nYOGURT\n45.0\n\n\n86\nсowberry juice\nСOWBERRY\n190.0\n\n\n\n\n87 rows × 3 columns"
  },
  {
    "objectID": "sql_basics.html#зміна-типу-cast",
    "href": "sql_basics.html#зміна-типу-cast",
    "title": "2  Базові запити",
    "section": "2.6 Зміна типу: CAST",
    "text": "2.6 Зміна типу: CAST\nІноді виникає необхідність змінити тип даних у якійсь колонці результуючої таблиці, не змінюючи при цьому властивості вихідної таблиці, наприклад, перетворити число на текст (тип даних VARCHAR). І тому існує функція CAST.\nНа вхід функції CAST необхідно подати ім’я колонки, вказавши через AS тип даних, до якого потрібно привести всі значення:\nSELECT CAST(column AS VARCHAR)\nFROM table\nТакож можна змінити тип даних за допомогою спеціального синтаксису з двома двокрапками («::»):\nSELECT column::VARCHAR\nFROM table\nНаприклад, переведемо текст ‘100’ у число 100:\nSELECT CAST('100' AS INTEGER)\n\nРезультат:\n100\nЗверніть увагу, що для успішної конвертації значення повинні бути конвертованими у вказаний тип. Наприклад, текст, який не виглядає як число, перевести до числового типу даних не вийде:\nSELECT CAST('text' AS INTEGER)\n\nРезультат:\nError running query: invalid input syntax for type integer: \"text\"\nАналогічним чином можна, наприклад, перетворити текст на дату (якщо він виглядає як дата):\nSELECT '2022-12-31'::DATE as date\n\nРезультат:\n2022-12-31\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з функцією CAST та перетворенням типів даних можна ознайомитись за цим посиланням.\nПро самі типи даних можна почитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.8 Змініть тип колонки price з таблиці products на VARCHAR. Виведіть колонки з найменуванням товарів, ціною у вихідному форматі та ціною у форматі VARCHAR. Нову колонку з ціною у новому форматі назвіть price_char.\nРезультат відсортуйте за зростанням початкового найменування товару в колонці name. Кількість записів, що виводяться, не обмежуйте.\nПоля в результуючій таблиці: name, price, price_char\n\n\n\n\n\nРішення\n%%sql\nSELECT \n    name,\n    price,\n    CAST(price as VARCHAR) as price_char\nFROM\n    products\nORDER BY\n    name\n\n\n\n\n\n\n\n\n\nname\nprice\nprice_char\n\n\n\n\n0\napple juice\n120.0\n120.0\n\n\n1\napples\n75.0\n75.0\n\n\n2\nbagels\n45.0\n45.0\n\n\n3\nbananas\n100.0\n100.0\n\n\n4\nbeef\n370.0\n370.0\n\n\n...\n...\n...\n...\n\n\n82\nwaffles\n55.0\n55.0\n\n\n83\nwatermelon\n120.0\n120.0\n\n\n84\nwhite chocolate\n60.0\n60.0\n\n\n85\nyogurt\n45.0\n45.0\n\n\n86\nсowberry juice\n190.0\n190.0\n\n\n\n\n87 rows × 3 columns"
  },
  {
    "objectID": "sql_basics.html#обєднання-concat",
    "href": "sql_basics.html#обєднання-concat",
    "title": "2  Базові запити",
    "section": "2.7 Об’єднання: CONCAT",
    "text": "2.7 Об’єднання: CONCAT\nУ цьому підрозділі ми ще трохи попрацюємо з текстовими даними та розглянемо функцію CONCAT, за допомогою якої можна з’єднувати в один рядок значення кількох стовпців.\nФункція CONCAT приймає на вхід кілька аргументів і повертає результат їхньої послідовної складання один з одним. Хороша аналогія - складання речень з різних карток зі словами:\nSELECT CONCAT('SQL', ' ', 'Python ', 2023)\n\nРезультат:\nSQL Python 2023\nПри цьому аргументи не обов’язково мають бути виражені текстовими значеннями — головне, вони мають бути конвертованими в текст. У прикладі вище число 2023 можна конвертувати в текст ‘2023’, тому запит працює без помилок.\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції CONCAT можна за посиланням.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.9 Для перших 200 записів з таблиці orders виведіть інформацію у такому вигляді (зверніть увагу на пробіли):\nЗамовлення № [id_замовлення] створено [дата]\nОтриману колонку назвіть order_info.\nПриклад результату:\nЗамовлення № 65 створено 2022-09-01\n\n\n\n\n\nРішення\n%%sql\nSELECT \n    CONCAT(\n        'Замовлення № ',\n        order_id,\n        ' створено ',\n        creation_time::DATE\n        ) as order_info\nFROM   \n    orders\nLIMIT 200\n\n\n\n\n\n\n\n\n\norder_info\n\n\n\n\n0\nЗамовлення № 1 створено 2022-08-24\n\n\n1\nЗамовлення № 2 створено 2022-08-24\n\n\n2\nЗамовлення № 3 створено 2022-08-24\n\n\n3\nЗамовлення № 4 створено 2022-08-24\n\n\n4\nЗамовлення № 5 створено 2022-08-24\n\n\n...\n...\n\n\n195\nЗамовлення № 196 створено 2022-08-25\n\n\n196\nЗамовлення № 197 створено 2022-08-25\n\n\n197\nЗамовлення № 198 створено 2022-08-25\n\n\n198\nЗамовлення № 199 створено 2022-08-25\n\n\n199\nЗамовлення № 200 створено 2022-08-25\n\n\n\n\n200 rows × 1 columns"
  },
  {
    "objectID": "sql_basics.html#частина-дати-date_part",
    "href": "sql_basics.html#частина-дати-date_part",
    "title": "2  Базові запити",
    "section": "2.8 Частина дати: DATE_PART",
    "text": "2.8 Частина дати: DATE_PART\nЯк ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (DATE) і часу (TIMESTAMP). Давайте трохи попрацюємо з такими даними.\nНасправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція DATE_PART. Її синтаксис наступний:\nSELECT DATE_PART(part, column)\nНа місці part необхідно в лапках вказати ту частину, яку потрібно витягти: 'year', 'month', 'day', 'hour' тощо. На місці column слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:\nSELECT DATE_PART('day', DATE '2022-01-12')\n\nРезультат:\n12.00\n\n\nSELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')\n\nРезультат:\n31.00\nВище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами dates. Тоді запит виглядав би так:\nSELECT DATE_PART('day', dates)\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції DATE_PART можна за посиланням.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.10 Виведіть id всіх кур’єрів та їхні роки народження з таблиці couriers.\nРік народження необхідно одержати з колонки birth_date. Нову колонку з роком назвіть birth_year. Результат відсортуйте спочатку за спаданням року народження кур’єра (тобто від наймолодших до найстарших), потім за зростанням id кур’єра.\nПоля у результуючій таблиці: courier_id, birth_year\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       date_part('year', birth_date) as birth_year\nFROM   couriers\nORDER BY birth_year desc, courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_year\n\n\n\n\n0\n83\nNaN\n\n\n1\n187\nNaN\n\n\n2\n200\nNaN\n\n\n3\n232\nNaN\n\n\n4\n411\nNaN\n\n\n...\n...\n...\n\n\n2818\n2200\n1981.0\n\n\n2819\n2432\n1979.0\n\n\n2820\n616\n1978.0\n\n\n2821\n1443\n1978.0\n\n\n2822\n493\n1973.0\n\n\n\n\n2823 rows × 2 columns"
  },
  {
    "objectID": "sql_basics.html#перше-ненульове-значення-coalesce",
    "href": "sql_basics.html#перше-ненульове-значення-coalesce",
    "title": "2  Базові запити",
    "section": "2.9 Перше ненульове значення: COALESCE",
    "text": "2.9 Перше ненульове значення: COALESCE\nВи могли помітити, що в минулому прикладі (Завдання 2.10) для окремих рядків функція DATE_PART не повернула рік народження кур’єра, а замість них утворилися порожні значення. Якщо не помітили, уважно подивіться на результат запиту.\nНасправді це сталося тому, що в наших даних у колонці birth_date є перепустки — так звані значення NULL (у виводі результату це NA). Іншими словами, для окремих кур’єрів просто не вказано їхні дні народження. Є безліч варіантів, чому так могло статися, але ми зараз не маємо часу все це з’ясовувати — нам просто потрібно навчитися якось обробляти такі випадки.\nДавайте зробимо так, щоб замість порожніх значень функція DATE_PART повертала якесь інше значення. У цьому нам допоможе функція COALESCE, яка повертає перше не NULL значення зі списку поданих на вхід аргументів.\nРоботу COALESCE можна описати так: вона буквально читає список значень зліва направо і, як тільки бачить значення, яке не є NULL, відразу ж повертає його та припиняє читання списку. Подивіться уважно на такі приклади:\nSELECT COALESCE(NULL, 'I am not NULL' , 'I.love.Python')\n\nРезультат:\nI am not NULL\n\n\nSELECT COALESCE(NULL, 25, 100, 150)\n\nРезультат:\n25\n\n\nSELECT COALESCE('NULL', 'I am not NULL', 'I.love.Python')\n\nРезультат:\nNULL\nОдним із аргументів функції COALESCE може бути результат виконання іншої функції:\nSELECT COALESCE(NULL, LOWER('I am not NULL'), 'I.love.Python')\n\nРезультат:\ni am not null\nЩоб заповнити пропуски в колонці, достатньо застосувати функцію COALESCE до колонки з пропусками та вказати як другий аргумент те значення, яке ми хочемо бачити замість NULL:\nSELECT COALESCE(column, 'filler value')\nFROM table\nФункція COALESCE застосовується до кожного значення колонки. Якщо це значення виявиться NULL, вона замінить його значення, вказане другим аргументом. Якщо значення колонці, навпаки, виявиться не NULL, то функція просто поверне це значення.\nПри цьому до колонки з перепустками можна заздалегідь застосовувати різні інші функції:\nSELECT COALESCE(LEFT(column, 5), 'filler value')\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nЗ іншими прикладами використання функції COALESCE можна за посиланням.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.11 Як і в попередньому прикладі (Завдання 2.10), знову виведіть id десяти відсотків кур’єрів та їх роки народження, тільки тепер до вилученого року застосуйте функцію COALESCE. Вкажіть параметри функції так, щоб замість значення NULL в результат потрапляло текстове значення unknown. Назви полів залиште колишніми.\nПоля у результуючій таблиці: courier_id, birth_year\n\n\n\n\n\nРішення\n%%sql\nSELECT\n    courier_id,\n    COALESCE(date_part('year', birth_date)::VARCHAR, 'unknown') birth_year\nFROM\n    couriers\nUSING SAMPLE 10 PERCENT (bernoulli, 123)\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_year\n\n\n\n\n0\n17\n1997\n\n\n1\n24\n1986\n\n\n2\n40\n1993\n\n\n3\n49\n1996\n\n\n4\n52\n1995\n\n\n...\n...\n...\n\n\n278\n3103\n1991\n\n\n279\n3124\n1992\n\n\n280\n3128\n1997\n\n\n281\n3162\n1996\n\n\n282\n3166\n1994\n\n\n\n\n283 rows × 2 columns"
  },
  {
    "objectID": "sql_basics.html#арифметичні-оператори",
    "href": "sql_basics.html#арифметичні-оператори",
    "title": "2  Базові запити",
    "section": "2.10 Арифметичні оператори",
    "text": "2.10 Арифметичні оператори\nДля роботи з числовими значеннями в DuckDB доступны різні арифметичні оператори. Нижче наведена таблиця з найбільш вживаними операторами:\n\n\n\nОператор\nОпис\nПриклад\nРезультат\n\n\n\n\n+\nДодавання\n2 + 3\n5\n\n\n-\nВіднімання\n2 - 3\n-1\n\n\n*\nМноження\n2 * 3\n6\n\n\n/\nДілення\n4 / 2\n2\n\n\n%\nЗалишок від ділення\n5 % 4\n1\n\n\n^\nПіднесення до степеня\n2 ^ 3\n8\n\n\n\nЯкби ми захотіли перевести 7600 гривен у долари за курсом 1 долар = 40 гривень, то операція виглядала б так:\nSELECT 7500 / 40\n\nРезультат:\n190\nЯкби нам потрібно було відняти з кожного значення в одній із колонок нашої таблиці якесь число (наприклад, 100), то запит виглядав би так:\nSELECT column - 100\nFROM table\nКрім того, в арифметичних операціях можуть брати участь одразу кілька колонок. Наприклад, для кожного рядка таблиці можна обчислити середнє арифметичне двох чисел, які містяться у двох різних колонках:\nSELECT (column_1 + column_2) / 2 AS average\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з усіма арифметичними операторами можна за посиланням.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.12 Давайте уявимо, що з якоїсь незрозумілої причини ми раптом вирішили відразу підвищити ціну всіх товарів у таблиці products на 5%.\nВиведіть id та найменування всіх товарів, їх стару та нову ціну. Колонку зі старою ціною назвіть old_price, а колонку з новою – new_price.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       price*1.05 as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n840.00\n\n\n1\n37\nmutton\n559.0\n586.95\n\n\n2\n15\nolive oil\n450.0\n472.50\n\n\n3\n57\npork\n450.0\n472.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n26.25\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.75\n\n\n84\n73\ncake\n15.0\n15.75\n\n\n85\n10\nseeds\n12.0\n12.60\n\n\n86\n54\npaper bag\n1.0\n1.05\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_basics.html#математичні-функції",
    "href": "sql_basics.html#математичні-функції",
    "title": "2  Базові запити",
    "section": "2.11 Математичні функції",
    "text": "2.11 Математичні функції\nПоряд з арифметичними операторами DuckDB також доступні різні математичні функції. Наприклад, для округлення чисел можна використовувати функцію ROUND:\nSELECT ROUND(100.5454, 2)\n\nРезультат:\n100.55\n\n\nSELECT ROUND(100.551, 1)\n\nРезультат:\n100.6\n\n\nSELECT ROUND(100.5511)\n\nРезультат:\n101.0\nПершим аргументом вказується саме значення, яке хочемо округлити. Другим число знаків після точки, до якої хочемо округлити. Другий аргумент вказувати не обов’язково: якщо його не вказати, відбудеться округлення до цілого числа (проте тип даних при цьому не зміниться).\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з усіма арифметичними операторами можна за посиланням.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.13 Знову, як і в минулому завданні (Завдання 2.12), підвищите ціну всіх товарів на 5%, тільки тепер до колонки з новою ціною застосуйте функцію ROUND. Виведіть id та найменування товарів, їх стару ціну, а також нову ціну із округленням. Нову ціну округліть до десятих, але тип даних не змінюйте.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       round(price * 1.05, 1) as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n840.0\n\n\n1\n37\nmutton\n559.0\n587.0\n\n\n2\n15\nolive oil\n450.0\n472.5\n\n\n3\n57\npork\n450.0\n472.5\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.0\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n26.3\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.8\n\n\n84\n73\ncake\n15.0\n15.8\n\n\n85\n10\nseeds\n12.0\n12.6\n\n\n86\n54\npaper bag\n1.0\n1.1\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_basics.html#умовна-конструкція-case-when",
    "href": "sql_basics.html#умовна-конструкція-case-when",
    "title": "2  Базові запити",
    "section": "2.12 Умовна конструкція: CASE WHEN",
    "text": "2.12 Умовна конструкція: CASE WHEN\nА якби ми захотіли підвищити ціну не на всі товари, а, скажімо, тільки на дорогі?\nДля цього нам потрібно було б створити деяку функцію, яка перевіряла б кожне значення в колонці price і порівнювала б його з якимось пороговим значенням. Якби ціна виявлялася вищою за цей поріг, то функція підвищувала б ціну, а якщо ні — залишала б без змін.\nІ таку функцію можна задати за допомогою умовної конструкції CASE. Вона має наступний синтаксис:\nCASE  \nWHEN logical_expression_1 THEN expression_1\nWHEN logical_expression_2 THEN expression_2\n...\nELSE expression_else\nEND AS case_example\nЦя конструкція може бути громіздкою, але насправді в ній немає нічого складного. Логіка роботи оператора CASE досить проста:\n\nНа кожному етапі WHEN - THEN обчислюється деякий логічний вираз logical_expression, що стоїть після WHEN. Якщо воно виявляється істинним (TRUE), то в якості результату оператор повертає вираз expression, що стоїть після THEN, і закінчує свою роботу.\nЯкщо вираз виявляється помилковим (FALSE), то оператор продовжує роботу та перевіряє наступну умову.\nЯкщо жодна з умов не проходить перевірку на істинність, повертається вираз, вказаний після ELSE. При цьому ELSE вказувати не обов’язково - якщо його не вказати, то повернеться порожнє значення NULL (у разі, якщо всі перевірки після WHEN виявилися помилковими).\nНасамкінець обов’язково вказується ключове слово END, яке говорить про закінчення конструкції CASE. Також після END новому розрахунковому полю за допомогою AS можна надати деяке ім’я, але це робити не обов’язково. Обов’язковими є лише ключові слова CASE, WHEN, THEN та END.\n\nНаступна конструкція розіб’є весь список найменувань на три категорії: «м’ясо», «риба» та «інше». Відповідно, якщо у перших двох умовах ми не врахуємо якісь назви з колонки name (наприклад, «телятину»), то вони потраплять до категорії «інше».\nSELECT name,\n       CASE \n       WHEN name='свинина' OR name='баранина' OR name='курка' THEN \"м'ясо\"\n       WHEN name='тріска' OR name='форель' OR name='окунь' THEN 'риба'\n       ELSE 'інше'\n       END AS сategory\nFROM table\nТепер трохи про логічні вирази: SQL можуть включати оператори порівняння і логічні операції.\nДо операторів порівняння належать:\n\n= («рівно»)\n&lt;&gt; або != («не дорівнює»)\n&lt; («менше»)\n&gt; («більше»)\n&lt;= («менше або дорівнює»)\n&gt;= («більше чи дорівнює»)\n\nРезультатом роботи операторів порівняння можуть бути три стани:\n\nTRUE («істина»)\nFALSE (помилка)\nNULL («невизначений стан» - коли одне з порівнюваних значень NULL)\n\nЗ цими трьома станами можна проводити такі логічні операції:\n\nAND («І»)\nOR («АБО»)\nNOT («НЕ»)\n\nРезультатом цих логічних операцій також можуть бути три вищевказані логічні стани (TRUE, FALSE або NULL):\n\n\n\na\nb\na AND b\na OR b\n\n\n\n\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nNULL\nNULL\nTRUE\n\n\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nNULL\nFALSE\nNULL\n\n\nNULL\nNULL\nNULL\nNULL\n\n\n\n\n\n\na\nNOT a\n\n\n\n\nTRUE\nFALSE\n\n\nFALSE\nTRUE\n\n\nNULL\nNULL\n\n\n\nТаким чином, оператори порівняння та логічні операції дозволяють писати комплексні логічні вирази.\nЗапам’ятати всі ці таблиці та комбінації не обов’язково. Головне, завжди тримайте цю пам’ятку під рукою.\nПрипустимо, відомо, що \\(a=10\\) і \\(b=5\\). Тоді наступний логічний вираз поверне TRUE:\na &gt;= 10 OR b &gt; 10\nТакож важливо розуміти, що є пріоритети виконання операцій:\n\nмноження та ділення (* та /)\nдодавання та віднімання (+ та -)\nоператори порівняння (=, !=, &gt;, &lt;, &gt;=, &lt;=)\nNOT\nAND\nOR\n\nНа порядок виконання операторів можна також впливати за допомогою дужок. Вирази, поміщені в дужки, матимуть найвищий пріоритет — як у математиці.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.14 Підвищіть ціну на 5% тільки на товари, вартість яких перевищує 100 одиниць. Ціну решти товарів залиште без змін. Також не підвищуйте ціну на ікру (caviar), яка й так коштує 800 одиниць. Виведіть id та найменування всіх товарів, їх стару та нову ціну. Ціну округляти не потрібно.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       case when price &lt;= 100 or\n                 name = 'caviar' then price\n            else price * 1.05 end as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n800.00\n\n\n1\n37\nmutton\n559.0\n586.95\n\n\n2\n15\nolive oil\n450.0\n472.50\n\n\n3\n57\npork\n450.0\n472.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n25.00\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.00\n\n\n84\n73\ncake\n15.0\n15.00\n\n\n85\n10\nseeds\n12.0\n12.00\n\n\n86\n54\npaper bag\n1.0\n1.00\n\n\n\n\n87 rows × 4 columns\n\n\n\nУявіть, що до вас звернувся менеджер із сусіднього відділу із проханням порахувати ПДВ кожного товару. Жодних додаткових даних він вам не надав, тому ви вирішили виконати завдання на власний розсуд, вважаючи, що ПДВ єдиний для всіх товарів і становить 20%.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 2.15 Обчисліть ПДВ кожного товару у таблиці products та розрахуйте ціну без урахування ПДВ. Виведіть всю інформацію про товари, включаючи суму податку та ціну без його врахування. Колонки із сумою податку та ціною без ПДВ назвіть відповідно tax та price_before_tax. Округліть значення у цих колонках до двох знаків після коми.\nРезультат відсортуйте спочатку за спаданням ціни товару без урахування ПДВ, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, tax, price_before_tax.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       round((price * 0.2) / 1.2, 2) as tax,\n       round(price / 1.2, 2) as price_before_tax\nFROM   products\nORDER BY price_before_tax desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ntax\nprice_before_tax\n\n\n\n\n0\n13\ncaviar\n800.0\n133.33\n666.67\n\n\n1\n37\nmutton\n559.0\n93.17\n465.83\n\n\n2\n15\nolive oil\n450.0\n75.00\n375.00\n\n\n3\n57\npork\n450.0\n75.00\n375.00\n\n\n4\n43\ndecaffeinated coffee\n400.0\n66.67\n333.33\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n4.17\n20.83\n\n\n83\n5\ncoffee 3 in 1\n15.0\n2.50\n12.50\n\n\n84\n73\ncake\n15.0\n2.50\n12.50\n\n\n85\n10\nseeds\n12.0\n2.00\n10.00\n\n\n86\n54\npaper bag\n1.0\n0.17\n0.83\n\n\n\n\n87 rows × 5 columns"
  },
  {
    "objectID": "sql_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "href": "sql_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "title": "2  Базові запити",
    "section": "2.13 Типові помилки при написанні SQL-запитів.",
    "text": "2.13 Типові помилки при написанні SQL-запитів.\n\nНеправильний порядок або помилки у ключових словах. Правильний порядок операторів у запиті виглядає так:\n\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- угруповання даних\nHAVING      -- фільтрація даних після угруповання\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\nНеправильно названі функції та оператори, що використовуються в запиті (наприклад, DATEPART, а не DATE_PART).\nНеправильно вказано імена стовпців.\nНеправильно виконано сортування записів.\nНеправильно проведено розрахунки.\nПропущена кома при перерахуванні стовпців у SELECT\nЗайва кома після імені останнього стовпця в SELECT\nНе закриті дужки (перевірте, що кількість дужок дорівнює кількості закривають).\nДопущено помилку в підзапиті (перед виконанням всього запиту перевірте, чи працюють окремі підзапити).\nЗапущено відразу кілька запитів, не розділених крапкою з комою."
  },
  {
    "objectID": "sql_filter.html#базова-фільтрація-where",
    "href": "sql_filter.html#базова-фільтрація-where",
    "title": "3  Фільтрація даних",
    "section": "3.1 Базова фільтрація: WHERE",
    "text": "3.1 Базова фільтрація: WHERE\nВ SQL для фільтрації даних використовується оператор WHERE. Після оператора WHERE вказується логічний вираз, результат якого визначає, чи буде рядок включений до результуючої таблиці. Якщо умова виявляється істинною (TRUE), то рядок включається до результату, якщо хибним (FALSE) — рядок виключається.\nТаким чином, кожен рядок у таблиці проходить перевірку на відповідність певній умові, і в результаті цих перевірок формується таблиця, над якою проводяться операції, зазначені в блоці SELECT.\nОператор WHERE та логічний вираз вказуються після блоку FROM:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 0\nНаприклад, у результаті зазначеного вище запиту у вибірці попадуть лише записи з невід’ємними значеннями в колонці column_2.\nУ свою чергу оператори ORDER BY і LIMIT записуються вже після оператора WHERE. Якщо додати їх у приклад вище, запит виглядатиме так:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 0\nORDER BY column_1\nLIMIT 100\nУ результаті ми спочатку відфільтруємо необхідні нам рядки, потім виберемо стовпчики, виділені в SELECT, а потім сортуємо результуючу таблицю, обмеживши число виведених записів.\nТаким чином порядок запису відомих нам на поточний момент ключових слів виглядає так:\n\nSELECT\nFROM\nWHERE\nORDER BY\nLIMIT\n\nЗнову звернемо увагу, що порядок виконання відрізняється від того, в якій послідовності вони вказуються в запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nДалі WHERE - відфільтровуються рядки, що відповідають умові.\nПотім SELECT - відбираються зазначені стовпці та застосовуються функції.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\nІншими словами, в результаті виконання запиту спочатку відбувається підготовка таблиці до роботи, а потім над нею виконуються різні операції.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про оператор WHERE можна за посиланням.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.1 Напишіть SQL-запит до таблиці products та виведіть всю інформацію про товари, ціна яких не перевищує 100 одиниць. Результат відсортуйте за зростанням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT \n    product_id,\n    name,\n    price\nFROM   products\nWHERE  price &lt;= 100\nORDER BY product_id\nLIMIT  10;\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n2\ngreen tea bags\n50.0\n\n\n1\n3\nstill water\n80.0\n\n\n2\n4\nlollipops\n46.0\n\n\n3\n5\ncoffee 3 in 1\n15.0\n\n\n4\n6\ncrackers\n25.0\n\n\n5\n8\ndrying\n30.0\n\n\n6\n9\nblack leaf tea\n84.0\n\n\n7\n10\nseeds\n12.0\n\n\n8\n14\nmayonnaise\n60.0\n\n\n9\n18\nketchup\n58.0\n\n\n\n\n\n\n\nФільтрувати дані в таблицях можна не тільки по полях з числовими значеннями, але і по полях зі значеннями, представленими у вигляді тексту:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 = 'text'\nУ прикладі вище в результуючу таблицю потраплять лише рядки, значення в яких повністю збігаються із зазначеним у WHERE рядком 'text'.\nПри порівнянні рядків також допускається використовувати нерівності:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt; 'text'\nВтім, така операція використовується рідше, оскільки не цілком очевидно, що означає «один рядок більше за інший».\nНасправді порядок сортування даних рядкового типу зазвичай визначається заздалегідь встановленими правилами сортування, у яких значення мають довжина рядка в символах, порядок букв відповідно до алфавіту, наявність особливих символів, регістр тощо. Ми не будемо докладно зупинятись на цій темі — за бажання про це можна додатково прочитати у документації.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про правила сортування даних рядкового типу можна за посиланням.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.2 Виберіть користувачів жіночої статі з таблиці users. Виведіть лише id цих користувачів. Результат відсортуйте за зростанням id.\nДодайте в запит оператор LIMIT і виведіть лише 10 перших ID з відсортованого списку.\nПоле у результуючій таблиці: user_id\n\n\n\n\n\nРішення\n%%sql\nSELECT \n    user_id\nFROM   \n    users\nWHERE  \n    sex = 'female'\nORDER BY \n    user_id \nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n5\n7\n\n\n6\n8\n\n\n7\n11\n\n\n8\n12\n\n\n9\n13\n\n\n\n\n\n\n\nЯк значення для фільтрації можна також використовувати дати та час:\nSELECT column_1\nFROM table\nWHERE column_2 &lt;= '2022-12-31'\n\n\nSELECT column_1\nFROM table\nWHERE column_2 &lt;= '2022-12-31 00:00:00'\nОднак при цьому важливо заздалегідь переконатися, що в колонці, за якою фільтруватимуться дані, знаходяться саме дати або мітки часу, а не дані рядкового типу, зовні схожі на дати. Якщо в колонці виявляться рядки, то як такої помилки не відбудеться, проте результат сильно відрізнятиметься від очікуваного.\nТакож в операціях порівняння дат важливо враховувати, що дата завжди інтерпретується опівночі (початок дня), тобто '2022-12-31' насправді означає '2022-12-31 00:00:00'.\nДо речі, ніщо не забороняє нам комбінувати в блоці WHERE різні умови з різними типами даних і створювати складніші логічні вирази:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_1 &gt;= 0 \n      AND column_2 = 'some text' \n      AND column_3 = '2022-12-31'\nДавайте якраз вирішимо завдання одразу з кількома умовами!\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.3  Виберіть з таблиці user_actions усі дії користувачів зі створення замовлень, які були зроблені ними після опівночі 6 вересня 2022 року. Виведіть колонки з id користувачів, id створених замовлень та часом їх створення.\nРезультат має бути відсортований за зростанням id замовлення.\nПоля в результуючій таблиці: user_id, order_id, time\nПояснення: зверніть увагу, що в таблиці user_actions у кожного користувача можуть бути записи не тільки з часом створення замовлення, а й часом його скасування. Нам необхідно отримати лише записи із створенням замовлень.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       time\nFROM   user_actions\nWHERE  action = 'create_order' and time &gt; '2022-09-06'\nORDER BY order_id\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\ntime\n\n\n\n\n0\n16721\n45201\n2022-09-06 00:01:00\n\n\n1\n17299\n45202\n2022-09-06 00:01:00\n\n\n2\n7957\n45203\n2022-09-06 00:01:00\n\n\n3\n17300\n45204\n2022-09-06 00:02:00\n\n\n4\n14723\n45205\n2022-09-06 00:03:00\n\n\n...\n...\n...\n...\n\n\n14390\n21402\n59591\n2022-09-08 23:58:00\n\n\n14391\n20859\n59592\n2022-09-08 23:58:00\n\n\n14392\n15131\n59593\n2022-09-08 23:59:00\n\n\n14393\n10881\n59594\n2022-09-08 23:59:00\n\n\n14394\n19774\n59595\n2022-09-08 23:59:00\n\n\n\n\n14395 rows × 3 columns\n\n\n\nВ операторі WHERE можна використовувати не тільки колонки, які вже є в таблиці, але й розрахункові колонки. При цьому вказувати їх у SELECT знову ж таки не обов’язково:\nSELECT column_1, column_2, (column_1 + column_2) * 0.5 AS average\nFROM table\nWHERE (column_1 + column_2) * 0.5 = 10\n\n\nSELECT column_1, column_2\nFROM table\nWHERE (column_1 + column_2) * 0.5 = 10 \nУ прикладі вище ми відфільтруємо тільки ті записи, для яких середнє арифметичне двох чисел, що містяться в колонках column_1 і column_2, дорівнюватиме 10.\nТакож важливо враховувати, що використовувати в блоці WHERE аліаси, які присвоєно новим розрахунковим колонкам, не можна. Зверніть увагу на приклади наступних запитів, які вважають частку значень колонки column_1 у відповідних їм значеннях колонки column_2. Перший запит спрацює, а другий поверне помилку:\n-- Цей запит спрацює:\n\nSELECT column_1, column_2, \n       column_1 / column_2 AS share\nFROM table\nWHERE column_1 / column_2 &gt; 50\n\n\n-- Цей запит поверне помилку:\n\nSELECT column_1, column_2, \n       column_1 / column_2 AS share\nFROM table\nWHERE share &gt; 50\nЦе пов’язано всі з тією ж послідовністю виконання операторів у запиті: на момент виконання оператора WHERE аліас колонці ще не присвоєно, і тому база даних поки не знає про існування колонки з новим ім’ям.\nМожна розглянути ще більш тривіальний приклад: навіть якщо ми просто зробимо дублікат колонки з іншим ім’ям і спробуємо використати це ім’я в WHERE, все одно отримаємо помилку:\n-- Цей запит поверне помилку:\n\nSELECT column, column AS same_column\nFROM table\nWHERE same_column &gt; 0\nПри вказівці фільтрів у блоці WHERE важливо враховувати розглянуті особливості. Можете керуватися наступним правилом: якщо збираєтеся фільтрувати дані по розрахунковій колонці, то дублюйте розрахунки WHERE і не використовуйте аліаси, присвоєні новим колонкам.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.4 Призначте знижку 20% на всі товари з таблиці products та відберіть ті, ціна на які з урахуванням знижки перевищує 100. Виведіть id товарів, їх найменування, колишню ціну та нову ціну з урахуванням знижки. Колонку зі старою ціною назвіть old_price, новою — new_price.\nРезультат має бути відсортований за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price\nПояснення: будьте уважні, коли вказуватимете фільтр після оператора WHERE.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       price * 0.8 as new_price\nFROM   products\nWHERE  price * 0.8 &gt; 100\nORDER BY product_id\nLIMIT 10 -- для скорочення виводу\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n1\nsugar\n150.0\n120.0\n\n\n1\n7\ngrain coffee\n351.0\n280.8\n\n\n2\n11\nlinseed oil\n200.0\n160.0\n\n\n3\n12\ngrape\n278.0\n222.4\n\n\n4\n13\ncaviar\n800.0\n640.0\n\n\n5\n15\nolive oil\n450.0\n360.0\n\n\n6\n17\nсowberry juice\n190.0\n152.0\n\n\n7\n19\nsalted fish\n180.0\n144.0\n\n\n8\n21\nground coffee\n283.0\n226.4\n\n\n9\n25\ninstant coffee\n150.0\n120.0\n\n\n\n\n\n\n\nПісля оператора WHERE до колонок можна також застосовувати різні функції:\nSELECT column_1, column_2\nFROM table \nWHERE LOWER(column_1) = 'i.love.python'\nУ прикладі вище кожне значення колонки column_1 спочатку буде приведено до нижнього регістру, а потім зіставлено зі значенням ‘i.love.python’. При цьому результат буде включено вихідні значення в колонці column_1. Таким чином, функція послужить тільки для фільтрації записів, але самі значення в колонках ніяк не вплине.\nЗверніть увагу, що використовувати аліаси, присвоєні колонкам в операторі SELECT, так само не можна. Наступний запит поверне помилку:\n-- Цей запит поверне помилку:\n\nSELECT column_1 AS new_column_1, column_2\nFROM table \nWHERE LOWER(new_column_1) = 'i.love.python'\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.5 Відберіть із таблиці products всі товари, назви яких або починаються зі слова «tea», або складаються з п'яти символів. Виведіть дві колонки: id товарів та їх найменування.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\nПояснення: для вирішення завдання вам знадобляться функції SPLIT_PART та LENGTH, які ми розглядали раніше.\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля вирішення завдання в операторі WHERE до колонки з назвами товарів необхідно застосувати функцію SPLIT_PART, розділивши по пробілу на окремі слова і відібравши тільки ті, в яких перше слово - «tea». Також через OR необхідно додати другу умову з функцією LENGTH для перевірки, що найменування складається з 5 символів.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name\nFROM   products\nWHERE  split_part(name, ' ', 1) = 'tea'\n    or length(name) = 5\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n1\nsugar\n\n\n1\n10\nseeds\n\n\n2\n12\ngrape\n\n\n3\n26\nchips\n\n\n4\n28\ncream\n\n\n5\n34\npasta\n\n\n6\n36\ntea mushroom\n\n\n7\n40\nbread\n\n\n8\n52\nkvass\n\n\n9\n53\nflour\n\n\n10\n61\nhoney\n\n\n11\n72\npears"
  },
  {
    "objectID": "sql_filter.html#пошук-за-шаблоном-like",
    "href": "sql_filter.html#пошук-за-шаблоном-like",
    "title": "3  Фільтрація даних",
    "section": "3.2 Пошук за шаблоном: LIKE",
    "text": "3.2 Пошук за шаблоном: LIKE\nУявіть, що із загального списку найменувань товарів нам раптом знадобилося відібрати певні позиції, які містять певні слова і навіть символи. Але при цьому ми точно не знаємо, в якій частині назви їх можна зустріти.\nНаприклад, нам потрібні всі “tea”, але вони необов’язково повинні починатися зі слова “tea”.\nАле як це зробити? Невже нам доведеться переглядати всю таблицю, вручну складати список товарів і писати довгий логічний вираз, що враховує всі можливі сценарії?\nЗрозуміло, що ні. Для фільтрації по колонках з текстовими значеннями в SQL передбачений оператор LIKE.\nОператор LIKE не просто порівнює рядки на повний збіг (або розбіжність), а перевіряє їх на відповідність заданому шаблону: якщо рядок йому відповідає, то повертається TRUE, інакше — FALSE. Як можна здогадатися, конструкція NOT LIKE працює з точністю навпаки.\nШаблони можуть містити як звичайні символи, так і символи-шаблони: знак відсотка (%) та підкреслення (_). Підкреслення підміняє будь-який одиночний символ, а знак відсотка - будь-яку (у тому числі порожню) послідовність символів:\nSELECT 'love.python' LIKE 'love%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE 'love_'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE '%love%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE '_love%'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE '%.%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE '_._'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE 'Love%'\n\nРезультат:\nfalse\nЗверніть увагу на останній приклад: оператор LIKE чутливий до регістру.\nЯкщо шаблон не містить знаків відсотка та підкреслень, тоді шаблон є рядком і LIKE працює як оператор порівняння, перевіряючи рядки на точний збіг.\nSELECT 'love.python' LIKE 'love.python'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE 'love'\n\nРезультат:\nfalse\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про оператор LIKE та шаблони можна почитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.6 Відберіть із таблиці products всі товари, що містять у своїй назві послідовність символів «tea» (без лапок). Виведіть дві колонки: id продукту та його назву.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\n\n\n\n\n\nРішення\n%%sql\nSELECT  product_id,\n        name\nFROM    products\nWHERE   name LIKE '%tea%'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n2\ngreen tea bags\n\n\n1\n9\nblack leaf tea\n\n\n2\n27\nherbal leaf tea\n\n\n3\n36\ntea mushroom\n\n\n4\n45\nleaf green tea\n\n\n5\n48\nivan-tea in bags\n\n\n6\n50\ncold tea\n\n\n7\n76\nblack tea bags\n\n\n8\n79\nherbal tea bags\n\n\n\n\n\n\n\nТепер зробимо наш фільтр трохи цікавішим.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.7 Виберіть із таблиці products id та найменування лише тих товарів, назви яких починаються на букву “c” і містять лише одне слово.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЯкщо з буквою «c» все зрозуміло, то з фільтром на одне слово ситуація трохи складніша: подумайте, яким символом принципово відрізняються рядки з одним і двома словами. Складіть шаблон для пошуку рядка, що складається з двох слів і виключіть такі рядки з результату.\nТакож будьте уважні мовою введення: латинська літера “c” та кирилична “с” виглядають однаково, але для бази даних це різні символи.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name\nFROM   products\nWHERE  name like 'c%'\n   and name not like '% %'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n6\ncrackers\n\n\n1\n13\ncaviar\n\n\n2\n26\nchips\n\n\n3\n28\ncream\n\n\n4\n46\ncookie\n\n\n5\n73\ncake\n\n\n6\n77\nchicken\n\n\n7\n78\ncupcakes\n\n\n\n\n\n\n\nУявіть, що напередодні Нового року до вас звернувся менеджер, якому на думку спала ідея зробити знижку на найдорожчий чай. Він попросив вас надати йому вивантаження з бази даних з усіма чаями та новими цінами на них з урахуванням знижки.\nЩо він далі робитиме з цими даними, вам невідомо, але завдання є завдання, до того ж не таке вже й складне. Спробуймо його вирішити!\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.8 Складіть SQL-запит, який вибирає з таблиці products всі чаї вартістю більше 60 і нараховує їм знижку 25%.\nЗнижку в % менеджер попросив вказати в окремому стовпці у форматі тексту, тобто так: «25%» (без лапок). Стовпці зі знижкою та новою ціною назвіть відповідно discount та new_price.\nТакож необхідно будь-яким відомим способом позбавитися «tea mushroom»: навряд чи менеджер мав на увазі і його, коли ставив нам завдання.\nРезультат має бути відсортований за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, discount, new_price\nПояснення:\nЩоб вказати стовпець з одним значенням для всіх записів (у нашому випадку це стовпець зі знижкою), достатньо просто ввести потрібне значення і дати стовпцю якусь назву - вказане значення автоматично проставиться у всіх рядках результуючої таблиці:\nSELECT column_1, 'text' AS column_2\nFROM table\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       '25%' as discount,\n       price * 0.75 as new_price\nFROM   products\nWHERE  price &gt; 60\n   and name != 'tea mushroom'\n   and name like '%tea%'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ndiscount\nnew_price\n\n\n\n\n0\n9\nblack leaf tea\n84.0\n25%\n63.00\n\n\n1\n27\nherbal leaf tea\n121.0\n25%\n90.75\n\n\n2\n45\nleaf green tea\n78.0\n25%\n58.50\n\n\n3\n79\nherbal tea bags\n65.0\n25%\n48.75"
  },
  {
    "objectID": "sql_filter.html#in-та-between-для-фільтрації",
    "href": "sql_filter.html#in-та-between-для-фільтрації",
    "title": "3  Фільтрація даних",
    "section": "3.3 IN та BETWEEN для фільтрації",
    "text": "3.3 IN та BETWEEN для фільтрації\nАле якщо ми все-таки не хочемо перевіряти наші дані на відповідність якомусь шаблону, а просто хочемо відібрати значення з деякого списку або навіть діапазону? У цьому випадку у логічному виразі після ключового слова WHERE можна використовувати оператори IN та BETWEEN.\nОператор IN перевіряє, чи відповідає значення в колонці одному із значень із заданого списку. Іншими словами, він перевіряє, чи входить значення до цього списку:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IN ('product_1', 'product_2', 'product_3')\nУ свою чергу, оператор BETWEEN дозволяє відібрати дані, що відносяться до деякого інтервалу. При цьому межі інтервалу включаються:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 BETWEEN 5 AND 10\nЗапит вище відповідає наступному запиту:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 5 AND column_2 &lt;= 10\nОператор BETWEEN можна використовувати і для фільтрації по колонках з датами та часом:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_3 BETWEEN '2022-11-20' AND '2022-12-31'\nОднак, в такому випадку, треба враховувати, що дата завжди інтерпретується опівночі (початок дня), тобто. ‘2022-12-31’ насправді означає ‘2022-12-31 00:00:00’. Тож заданий вище інтервал не потраплять записи пізніше опівночі ‘2022-12-31’, тобто цей день практично не буде враховано в інтервалі.\nПри цьому, запит вище буде рівносильний наступному запиту:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_3 &gt;= '2022-11-20' AND column_3 &lt;= '2022-12-31'\nДля отримання зворотного результату у поєднанні з операторами IN та BETWEEN можна використовувати оператор NOT:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 NOT IN ('product_1', 'product_2', 'product_3')\n\n\nSELECT column_1, column_2\nFROM table\nWHERE column_2 NOT BETWEEN 5 AND 10\n\n\n\n\n\n\nПримітка\n\n\n\nДетальніше про оператори IN та BETWEEN можна прочитати тут і тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.9 З таблиці user_actions виведіть всю інформацію про дії користувачів з id 170, 200 та 230 за період з 25 серпня до 4 вересня 2022 року включно. Результат відсортуйте за зменшенням id замовлення - тобто від останніх до найпізніших.\nПоля у результуючій таблиці: user_id, order_id, action, time\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       action,\n       time\nFROM   user_actions\nWHERE  user_id in (170, 200, 230)\n   and time &gt;= '2022-08-25'\n   and time &lt; '2022-09-05' -- уважно з датами!\nORDER BY order_id desc\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\naction\ntime\n\n\n\n\n0\n170\n34428\ncreate_order\n2022-09-04 01:43:00\n\n\n1\n170\n34424\ncreate_order\n2022-09-04 01:42:00\n\n\n2\n230\n24675\ncreate_order\n2022-09-02 12:21:00\n\n\n3\n200\n24538\ncreate_order\n2022-09-02 11:50:00\n\n\n4\n230\n22887\ncreate_order\n2022-09-02 00:54:00\n\n\n5\n230\n22878\ncreate_order\n2022-09-02 00:50:00\n\n\n6\n230\n19543\ncreate_order\n2022-09-01 07:21:00\n\n\n7\n170\n14894\ncreate_order\n2022-08-30 22:04:00\n\n\n8\n230\n14466\ncreate_order\n2022-08-30 19:51:00\n\n\n9\n170\n4194\ncreate_order\n2022-08-27 17:28:00\n\n\n10\n170\n4190\ncreate_order\n2022-08-27 17:27:00\n\n\n11\n200\n3416\ncreate_order\n2022-08-27 09:36:00\n\n\n12\n200\n3413\ncreate_order\n2022-08-27 09:34:00\n\n\n13\n170\n1234\ncreate_order\n2022-08-25 23:35:00\n\n\n14\n230\n263\ncreate_order\n2022-08-25 02:54:00\n\n\n15\n200\n229\ncreate_order\n2022-08-25 01:52:00\n\n\n16\n200\n226\ncreate_order\n2022-08-25 01:50:00\n\n\n17\n170\n188\ncreate_order\n2022-08-25 00:49:00"
  },
  {
    "objectID": "sql_filter.html#фільтрація-з-null",
    "href": "sql_filter.html#фільтрація-з-null",
    "title": "3  Фільтрація даних",
    "section": "3.4 Фільтрація з NULL",
    "text": "3.4 Фільтрація з NULL\nРаніше Завдання 2.11 ми зіткнулися з пропущеними значеннями в таблиці couriers — у деяких кур’єрів не було зазначено їхні дні народження.\nДля перевірки на NULL значення SQL є оператор IS NULL. У поєднанні з WHERE записується він так:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IS NULL\nЯкщо ж, навпаки, необхідно відібрати значення не NULL, то додатково використовується оператор NOT:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IS NOT NULL\nЯк ми знаємо, у світі даних NULL означає відсутність інформації. NULL - це не якась величина і тому її не можна порівняти з чимось ще. Результатом порівняння NULL з будь-яким іншим значенням буде той самий NULL. Більше того, NULL не вдасться порівняти і з іншим NULL, тому що в такому випадку порівнюватимуться дві невизначеності і не можна напевно сказати, рівні вони чи ні.\nСпробуйте виконати наступні запити:\nSELECT NULL = NULL\n\nРезультат:\nNULL\n\nSELECT NULL IS NULL\n\nРезультат:\ntrue\n\nSELECT 100 = NULL\n\nРезультат:\nNULL\n\nSELECT 100 IS NULL\n\nРезультат:\nfalse\n\n\n\n\n\n\nПримітка\n\n\n\nДетальніше про значення NULL можна прочитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.10 Напишіть SQL-запит до таблиці couriers та виведіть всю інформацію про кур’єрів, у яких не вказано їх день народження.\nРезультат має бути відсортований за зростанням id кур’єра.\nПоля в результуючій таблиці: birth_date, courier_id, sex\n\n\n\n\n\nРішення\n%%sql\nSELECT birth_date,\n       courier_id,\n       sex\nFROM   couriers\nWHERE  birth_date is null\nORDER BY courier_id\nLIMIT 10 -- для скорочення виводу\n\n\n\n\n\n\n\n\n\nbirth_date\ncourier_id\nsex\n\n\n\n\n0\nNaT\n83\nmale\n\n\n1\nNaT\n187\nmale\n\n\n2\nNaT\n200\nmale\n\n\n3\nNaT\n232\nmale\n\n\n4\nNaT\n411\nmale\n\n\n5\nNaT\n450\nmale\n\n\n6\nNaT\n467\nmale\n\n\n7\nNaT\n481\nmale\n\n\n8\nNaT\n726\nmale\n\n\n9\nNaT\n790\nmale"
  },
  {
    "objectID": "sql_filter.html#додаткові-завдання",
    "href": "sql_filter.html#додаткові-завдання",
    "title": "3  Фільтрація даних",
    "section": "3.5 Додаткові завдання",
    "text": "3.5 Додаткові завдання\nДавайте вирішимо ще кілька завдань, щоб переконатися, що ми розібралися з фільтрацією даних.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.11  Визначте id та дати народження 10 наймолодших користувачів чоловічої статі з таблиці users. Не враховуйте користувачів, у яких не вказано дату народження.\nПоле в результуючій таблиці: user_id, birth_date\nПояснення: будьте уважні і пам’ятайте про значення NULL.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       birth_date\nFROM   users\nWHERE  birth_date IS NOT NULL\n   AND sex = 'male'\nORDER BY birth_date DESC\nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\nbirth_date\n\n\n\n\n0\n11419\n2003-09-02\n\n\n1\n11461\n2002-11-05\n\n\n2\n9257\n2002-07-11\n\n\n3\n20804\n2002-01-09\n\n\n4\n14956\n2001-08-09\n\n\n5\n7047\n2001-06-11\n\n\n6\n11725\n2001-05-27\n\n\n7\n4374\n2001-04-29\n\n\n8\n15102\n2001-04-21\n\n\n9\n14571\n2001-03-31\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.12  Напишіть SQL-запит до таблиці courier_actions, щоб дізнатися ID та час доставки останніх 10 замовлень, доставлених кур’єром з ID 100.\nПоля у результуючій таблиці: order_id, time\nПояснення: Зверніть увагу, що у вихідній таблиці є записи не лише з часом доставки, а й з часом прийняття замовлення.\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       time\nFROM   courier_actions\nWHERE  courier_id = 100\n   AND action = 'deliver_order'\nORDER BY order_id desc limit 10\n\n\n\n\n\n\n\n\n\norder_id\ntime\n\n\n\n\n0\n57791\n2022-09-08 18:18:00\n\n\n1\n55095\n2022-09-08 07:51:00\n\n\n2\n53500\n2022-09-07 23:05:00\n\n\n3\n49779\n2022-09-07 07:34:00\n\n\n4\n48406\n2022-09-06 22:13:00\n\n\n5\n44546\n2022-09-05 21:13:00\n\n\n6\n42258\n2022-09-05 11:49:00\n\n\n7\n41606\n2022-09-05 09:00:00\n\n\n8\n41440\n2022-09-05 08:14:00\n\n\n9\n38536\n2022-09-04 18:57:00"
  },
  {
    "objectID": "sql_filter.html#фільтрація-по-даті-та-часу",
    "href": "sql_filter.html#фільтрація-по-даті-та-часу",
    "title": "3  Фільтрація даних",
    "section": "3.6 Фільтрація по даті та часу",
    "text": "3.6 Фільтрація по даті та часу\nІ ще кілька завдань на роботу з датами та часом.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.13  З таблиці user_actions отримаєте id всіх замовлень, зроблених користувачами сервісу у серпні 2022 року.\nРезультат відсортуйте за зростанням id замовлення.\nПоле у результуючій таблиці: order_id\nПояснення: зверніть увагу, що у вихідній таблиці є записи не лише з часом оформлення, а й часом скасування замовлення.У цій задачі може стати в нагоді функція DATE_PART. Ми розглядали її в Завдання 2.10.\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id\nFROM   user_actions\nWHERE  action = 'create_order'\n   AND DATE_PART('month', time) = 8\n   AND DATE_PART('year', time) = 2022\nORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n18794\n18795\n\n\n18795\n18796\n\n\n18796\n18797\n\n\n18797\n18798\n\n\n18798\n18799\n\n\n\n\n18799 rows × 1 columns\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.14  З таблиці couriers відберіть id всіх кур’єрів, що народилися в період з 1990 по 1995 включно.\nРезультат відсортуйте за зростанням id кур’єра.\nПоле у результуючій таблиці: courier_id\nПояснення: у цьому завдання знову може стати в нагоді функція DATE_PART.\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id\nFROM   couriers\nWHERE  date_part('year', birth_date) BETWEEN 1990\n   AND 1995\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\n\n\n\n\n0\n2\n\n\n1\n3\n\n\n2\n8\n\n\n3\n9\n\n\n4\n10\n\n\n...\n...\n\n\n1522\n3153\n\n\n1523\n3160\n\n\n1524\n3161\n\n\n1525\n3166\n\n\n1526\n3167\n\n\n\n\n1527 rows × 1 columns\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.15  З таблиці user_actions отримайте інформацію про всі скасування замовлень, які користувачі здійснювали протягом серпня 2022 по середах з 12:00 до 15:59.\nРезультат відсортуйте за зменшенням id скасованих замовлень.\nПоля у результуючій таблиці: user_id, order_id, action, time\nПояснення: будьте уважні при роботі з датами та часом. Для вирішення задачі вам знадобиться функція DATE_PART. Для отримання дня тижня можна вказати аргумент 'dow' (“day of week”):\nSELECT DATE_PART('dow', DATE '2022-12-31')\n\nРезультат:\n6.00\nВ DuckDB дні тижня рахуються з неділі (0) до суботи (6).\n\n\n\n\n\nРішення\n%%sql\nSELECT  user_id,\n        order_id,\n        action,\n        time\nFROM   user_actions\nWHERE  action = 'cancel_order'\n    AND DATE_PART('dow', time) = 03\n    AND DATE_PART('month', time) = 08\n    AND DATE_PART('year', time) = 2022\n    AND DATE_PART('h', time) BETWEEN 12\n    AND 15\nORDER BY order_id DESC\nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\naction\ntime\n\n\n\n\n0\n8117\n17307\ncancel_order\n2022-08-31 15:59:00\n\n\n1\n8107\n17282\ncancel_order\n2022-08-31 15:50:00\n\n\n2\n1495\n17272\ncancel_order\n2022-08-31 15:46:00\n\n\n3\n7427\n17252\ncancel_order\n2022-08-31 15:38:00\n\n\n4\n3207\n17231\ncancel_order\n2022-08-31 15:33:00\n\n\n5\n8077\n17218\ncancel_order\n2022-08-31 15:30:00\n\n\n6\n3446\n17216\ncancel_order\n2022-08-31 15:28:00\n\n\n7\n8076\n17214\ncancel_order\n2022-08-31 15:26:00\n\n\n8\n6116\n17190\ncancel_order\n2022-08-31 15:17:00\n\n\n9\n8057\n17151\ncancel_order\n2022-08-31 15:02:00"
  },
  {
    "objectID": "sql_filter.html#фільтрація-з-case-when",
    "href": "sql_filter.html#фільтрація-з-case-when",
    "title": "3  Фільтрація даних",
    "section": "3.7 Фільтрація з CASE WHEN",
    "text": "3.7 Фільтрація з CASE WHEN\nІ насамкінець давайте повернемося до наших податків.\nМинулого разу ми вирішили завдання для одного з менеджерів та порахували ПДВ кожного товару. Ви довго дивилися на розрахунки, що вийшли, і вас все-таки замучила совість: адже ви точно знаєте, що на окремі групи товарів ПДВ становить не 20%, а 10%.\nОскільки менеджер раптово перестав відповідати на ваші повідомлення, ви вирішили написати безпосередньо бухгалтеру та запросили список товарів, на які поширюється ПДВ 10%.\nОсь який список ви отримали:\n'sugar', 'crackers', 'drying', 'seeds',\n'linseed oil', 'grapes', 'olive oil',\n'watermelon', 'baton', 'yogurt', 'cream', 'buckwheat',\n'oatmeal', 'pasta', 'mutton', 'oranges',\n'bagels', 'bread', 'peas', 'sour cream', 'smoked fish',\n'flour', 'sprats', 'sausages', 'pork', 'rice',\n'sesame oil', 'condensed milk', 'pineapple', 'beef',\n'salt', 'dried fish', 'sunflower oil', 'apples',\n'pears', 'flatbread', 'milk', 'chicken', 'lavash', 'waffles', 'tangerines'\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 3.16  Як і у минулому завданні (Завдання 2.15), обчисліть ПДВ кожного товару в таблиці products і розрахуйте ціну без урахування ПДВ. Однак тепер врахуйте, що для товарів зі списку податок становить 10%. Для решти товарів ПДВ той самий — 20%.\nВиведіть всю інформацію про товари, включаючи суму податку та ціну без його врахування. Колонки із сумою податку та ціною без ПДВ назвіть відповідно tax та price_before_tax. Округліть значення у цих колонках до двох знаків після коми.\nРезультат відсортуйте спочатку за спаданням ціни товару без урахування ПДВ, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, tax, price_before_tax\nПояснення: порядок розрахунку податку той самий, що й у Завдання 2.15. Для вирішення завдання вам можуть стати в нагоді конструкція CASE та оператор IN. Конструкцію CASE ми розглядали у Завдання 2.14.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       ROUND(price * (CASE WHEN name IN ('sugar', 'crackers', 'drying', 'seeds',\n                                         'linseed oil', 'grapes', 'olive oil',\n                                         'watermelon', 'baton', 'yogurt', 'cream',\n                                         'buckwheat', 'oatmeal', 'pasta', 'mutton',\n                                         'oranges', 'bagels', 'bread', 'peas',\n                                         'sour cream', 'smoked fish', 'flour', 'sprats',\n                                         'sausages', 'pork', 'rice', 'sesame oil',\n                                         'condensed milk', 'pineapple', 'beef', 'salt',\n                                         'dried fish', 'sunflower oil', 'apples',\n                                         'pears', 'flatbread', 'milk', 'chicken',\n                                         'lavash', 'waffles', 'tangerines')\n                      THEN 0.1 / 1.1\n                      ELSE 0.2 / 1.2 end), 2) AS tax,\n       ROUND(price / (CASE WHEN name IN ('sugar', 'crackers', 'drying', 'seeds',\n                                         'linseed oil', 'grapes', 'olive oil',\n                                         'watermelon', 'baton', 'yogurt', 'cream',\n                                         'buckwheat', 'oatmeal', 'pasta', 'mutton',\n                                         'oranges', 'bagels', 'bread', 'peas',\n                                         'sour cream', 'smoked fish', 'flour', 'sprats',\n                                         'sausages', 'pork', 'rice', 'sesame oil',\n                                         'condensed milk', 'pineapple', 'beef', 'salt',\n                                         'dried fish', 'sunflower oil', 'apples',\n                                         'pears', 'flatbread', 'milk', 'chicken',\n                                         'lavash', 'waffles', 'tangerines')\n                      THEN 1.1\n                      ELSE 1.2 END), 2) AS price_before_tax\nFROM   products\nORDER BY price_before_tax DESC, product_id asc;\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ntax\nprice_before_tax\n\n\n\n\n0\n13\ncaviar\n800.0\n133.33\n666.67\n\n\n1\n37\nmutton\n559.0\n50.82\n508.18\n\n\n2\n15\nolive oil\n450.0\n40.91\n409.09\n\n\n3\n57\npork\n450.0\n40.91\n409.09\n\n\n4\n66\nbeef\n370.0\n33.64\n336.36\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n2.27\n22.73\n\n\n83\n5\ncoffee 3 in 1\n15.0\n2.50\n12.50\n\n\n84\n73\ncake\n15.0\n2.50\n12.50\n\n\n85\n10\nseeds\n12.0\n1.09\n10.91\n\n\n86\n54\npaper bag\n1.0\n0.17\n0.83\n\n\n\n\n87 rows × 5 columns"
  },
  {
    "objectID": "sql_agg.html#унікальні-значення-distinct",
    "href": "sql_agg.html#унікальні-значення-distinct",
    "title": "4  Агрегація даних",
    "section": "4.1 Унікальні значення: DISTINCT",
    "text": "4.1 Унікальні значення: DISTINCT\nКлючове слово DISTINCT дає змогу відбирати унікальні записи, тобто позбавлятися всіх дублікатів у таблиці.\nВказується DISTINCT одразу після SELECT. Для виведення унікальних значень в одній колонці можна скласти наступний запит:\nSELECT DISTINCT column\nFROM table\nДавайте спершу вирішимо просте завдання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.1  Виведіть ID всіх унікальних користувачів з таблиці user_actions. Результат відсортуйте за зростанням id.\nПоле у результуючій таблиці: user_id\n\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT user_id\nFROM   user_actions\nORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n21396\n21398\n\n\n21397\n21399\n\n\n21398\n21400\n\n\n21399\n21401\n\n\n21400\n21402\n\n\n\n\n21401 rows × 1 columns\n\n\n\nКлючове слово DISTINCT можна застосовувати не тільки до однієї колонки, а й одразу до кількох.\nНаприклад, запит для двох колонок виглядатиме так:\nSELECT DISTINCT column_1, column_2\nFROM table\nУ такому випадку запит поверне унікальні комбінації значень в колонках.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.2  Застосуйте DISTINCT відразу до двох колонок таблиці courier_actions та відберіть унікальні пари значень courier_id та order_id.\nРезультат відсортуйте спочатку за зростанням id кур’єра, потім за зростанням id замовлення.\nПоля у результуючій таблиці: courier_id, order_id\n\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT courier_id,\n                order_id\nFROM   courier_actions\nORDER BY courier_id, order_id\n\n\n\n\n\n\n\n\n\ncourier_id\norder_id\n\n\n\n\n0\n1\n98\n\n\n1\n1\n194\n\n\n2\n1\n233\n\n\n3\n1\n522\n\n\n4\n1\n1251\n\n\n...\n...\n...\n\n\n59590\n3166\n56165\n\n\n59591\n3166\n56940\n\n\n59592\n3167\n56176\n\n\n59593\n3167\n58039\n\n\n59594\n3167\n58774\n\n\n\n\n59595 rows × 2 columns"
  },
  {
    "objectID": "sql_agg.html#базова-агрегація-count-sum-avg-min-max",
    "href": "sql_agg.html#базова-агрегація-count-sum-avg-min-max",
    "title": "4  Агрегація даних",
    "section": "4.2 Базова агрегація: COUNT, SUM, AVG, MIN, MAX",
    "text": "4.2 Базова агрегація: COUNT, SUM, AVG, MIN, MAX\nАгрегатними функціями називають функції, які обробляють певний набір спостережень і повертають одне узагальнююче значення. Якщо ви коли-небудь працювали в Excel, то, напевно, стикалися з підрахунком суми або максимального/мінімального значення по стовпцю — йдеться саме про це.\nОсь кілька прикладів таких функцій у SQL:\n\nCOUNT: повертає кількість значень у колонці;\nSUM: обчислює суму значень;\nAVG: обчислює середнє значення;\nMAX: обчислює максимальне значення;\nMIN: обчислює мінімальне значення.\n\nПриклад:\nSELECT COUNT(column) AS count\nFROM table\n\n\nSELECT SUM(column_1) AS sum,\n       AVG(column_2) AS average\nFROM table\nЗверніть увагу, що деякі з вищезгаданих функцій не можна застосовувати до колонок з текстом, датами та часом, оскільки не цілком зрозуміло, що, наприклад, означає знайти середнє значення або суму найменувань товарів.\nУ той самий час «максимальне» найменування товару обчислити можна — функція MAX шукатиме найбільше значення упорядкованої послідовності (відповідно до встановлених правил сортування значень рядкового типу).\nВтім, заучувати межі застосування цих функцій не потрібно — просто керуйтеся здоровим глуздом.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про агрегатні функції в DuckDB можна ознайомитися тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.3  Порахуйте максимальну та мінімальну ціни товарів у таблиці products. Поля назвіть відповідно max_price, min_price.\nПоля у результуючій таблиці: max_price, min_price\nПояснення: в одному запиті можна використовувати відразу кілька агрегаційних функцій — якщо необхідно, то навіть по кількох різних колонках.\n\n\n\n\n\nРішення\n%%sql\nSELECT max(price) as max_price,\n       min(price) as min_price\nFROM   products\n\n\n\n\n\n\n\n\n\nmax_price\nmin_price\n\n\n\n\n0\n800.0\n1.0"
  },
  {
    "objectID": "sql_agg.html#count-vs-countcolumn",
    "href": "sql_agg.html#count-vs-countcolumn",
    "title": "4  Агрегація даних",
    "section": "4.3 COUNT(*) vs COUNT(column)",
    "text": "4.3 COUNT(*) vs COUNT(column)\nТакож при підрахунку кількості записів іноді замість найменування колонки як атрибут функції COUNT використовують зірочку «*»:\nSELECT COUNT(*)\nFROM table\nОднак важливо враховувати один нюанс: запит із зірочкою повертає кількість взагалі всіх записів у таблиці, а запит із зазначенням стовпця — кількість тих записів, де в заданому стовпці значення не є NULL.\nТаким чином, якщо в деякій колонці column є перепустки, вирази COUNT(*) і COUNT(column) повернуть різні значення.\nДавайте перевіримо!\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.4  Як ви пам’ятаєте, у таблиці users в деяких користувачів не було зазначено їх дати народження.\nПорахуйте в одному запиті кількість усіх записів у таблиці та кількість лише тих записів, для яких у колонці birth_date вказана дата народження.\nКолонку із загальним числом записів назвіть dates, а колонку із записами без перепусток — dates_not_null.\nПоля у результуючій таблиці: dates, dates_not_null\n\n\n\n\n\nРішення\n%%sql\nSELECT count(*) as dates,\n       count(birth_date) as dates_not_null\nFROM   users\n\n\n\n\n\n\n\n\n\ndates\ndates_not_null\n\n\n\n\n0\n20331\n20281\n\n\n\n\n\n\n\nІ ще один важливий момент: агрегатні функції можна застосовувати в поєднанні з ключовим словом DISTINCT. У такому випадку розрахунки будуть проводитися лише за унікальними значеннями.\nЯкщо у випадку з MIN та MAX це не має особливого сенсу, то при розрахунку AVG, SUM та COUNT іноді це буває корисно:\nSELECT SUM(DISTINCT column) AS sum_distinct\nFROM table\nПри цьому досить часто DISTINCT використовується саме в поєднанні з COUNT для підрахунку числа унікальних користувачів, унікальних замовлень тощо.\nSELECT COUNT(DISTINCT column) AS count_distinct\nFROM table\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.5  Порахуйте кількість всіх значень у колонці user_id у таблиці user_actions, а також кількість унікальних значень у цій колонці (тобто кількість унікальних користувачів сервісу).\nКолонку з першим отриманим значенням назвіть users, а колонку з другим – unique_users.\nПоля у результуючій таблиці: users, unique_users\n\n\n\n\n\nРішення\n%%sql\nSELECT count(user_id) as users,\n       count(distinct user_id) as unique_users\nFROM   user_actions\n\n\n\n\n\n\n\n\n\nusers\nunique_users\n\n\n\n\n0\n62574\n21401"
  },
  {
    "objectID": "sql_agg.html#фільтрація-та-агрегація",
    "href": "sql_agg.html#фільтрація-та-агрегація",
    "title": "4  Агрегація даних",
    "section": "4.4 Фільтрація та агрегація",
    "text": "4.4 Фільтрація та агрегація\nА якщо для розрахунків нам потрібні не всі дані в стовпці, а тільки якась частина? Тоді в запит з агрегатними функціями можна включити оператор WHERE, вказавши умову для відбору записів:\nSELECT COUNT(column_1) AS count\nFROM table\nWHERE column_2 &gt; 100\nУ такому випадку спочатку буде виконана фільтрація таблиці і тільки потім буде проведена агрегація по записах, що залишилися.\nПро всяк випадок нагадаємо порядок виконання у запиті відомих нам ключових операторів:\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.6  Порахуйте кількість кур’єрів жіночої статі у таблиці couriers. Отриманий стовпець з одним значенням назвіть couriers.\nПоле в результуючій таблиці: couriers\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct courier_id) as couriers\nFROM   couriers\nWHERE  sex = 'female'\n\n\n\n\n\n\n\n\n\ncouriers\n\n\n\n\n0\n1149\n\n\n\n\n\n\n\nІ ще одне завдання на агрегацію із фільтрацією. На цей раз проведемо розрахунки по колонці з даними у форматі TIMESTAMP.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.7  Розрахуйте час, коли було здійснено першу та останню доставку замовлень у таблиці courier_actions.\nКолонку з часом першої доставки назвіть first_delivery, а колонку з часом останньої – last_delivery.\nПоля у результуючій таблиці: first_delivery, last_delivery\nПояснення: зауважте, що в таблиці з діями кур’єрів є не тільки записи з часом доставки замовлень, але й записи з часом їх прийняття.\n\n\n\n\n\nРішення\n%%sql\nSELECT min(time) as first_delivery,\n       max(time) as last_delivery\nFROM   courier_actions\nWHERE  action = 'deliver_order'\n\n\n\n\n\n\n\n\n\nfirst_delivery\nlast_delivery\n\n\n\n\n0\n2022-08-24 02:15:00\n2022-09-08 23:59:00\n\n\n\n\n\n\n\nУ поєднанні з агрегатними функціями можна використовувати ті ж умовні конструкції, які ми розглядали раніше.\nДавайте додамо до нашого запиту більш цікаву фільтрацію.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.8  Уявіть, що один із користувачів сервісу зробив замовлення, до якого увійшли одна пачка крекерів (crackers), одна пачка чіпсів (chips) та один енергетичний напій (energy drink). Порахуйте вартість такого замовлення.\nКолонку із розрахованою вартістю замовлення назвіть order_price.\nДля розрахунків використовуйте таблицю products.\nПоле в результуючій таблиці: order_price\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля вирішення завдання необхідно «сформувати» описане замовлення, відібравши з таблиці products зазначені товари та порахувавши їхню сумарну вартість.\n\n\n\n\n\nРішення\n%%sql\nSELECT sum(price) as order_price\nFROM   products\nWHERE  name in ('crackers', 'chips', 'energy drink')\n\n\n\n\n\n\n\n\n\norder_price\n\n\n\n\n0\n235.0"
  },
  {
    "objectID": "sql_agg.html#довжина-списку-array_length",
    "href": "sql_agg.html#довжина-списку-array_length",
    "title": "4  Агрегація даних",
    "section": "4.5 Довжина списку: ARRAY_LENGTH",
    "text": "4.5 Довжина списку: ARRAY_LENGTH\nЯк пам’ятаєте, у таблиці orders вміст замовлень представлено вигляді списків товарів (масивів). Щоб порахувати кількість товарів у кожному замовленні, можна скористатися функцією array_length.\nФункція array_length обчислює кількість елементів у масиві (довжину масиву) і записується так:\nSELECT array_length(ARRAY['first', 'second', 'third'], 1)\n\nРезультат:\n3\nСинтаксис може здатися вам трохи складним, але це лише на перший погляд! Давайте розбиратися.\nARRAY['first', 'second', 'third'] – це деякий список із трьох значень: 'first', 'second', 'third’.\nОдиниця як другий аргумент — це розмірність масиву, за якій рахується його довжина. Так як список у нас одновимірний (просто значення, записані в один рядок), то вибір у нас невеликий – можемо вказати лише першу розмірність.\nЯкби в нас була таблиця N x N, в якій були б і рядки, і стовпці, то розмірності було б дві: перша відповідала кількості рядків, а друга — числу стовпців. У такому випадку ми могли б вказати або першу, або другу розмірність.\nДавайте уявімо, що у нас є проста таблиця наступного виду:\n _______\n| 1 | 2 |\n| 3 | 4 |\n| 5 | 6 |\n ‾‾‾‾‾‾‾\nУ цій таблиці 3 рядки та 2 стовпці, тому її можна описати у вигляді наступного списку з трьох вкладених у нього списків:\nARRAY[[1,2], [3,4], [5,6]]\nУ прикладі вище кількість списків усередині основного списку — кількість рядків у таблиці, а кількість елементів усередині кожного внутрішнього списку — кількість стовпців.\nЗверніть увагу на результат обчислень функції array_length для першої та другої розмірності:\nSELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)\n\nРезультат:\n3\n\nSELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)\n\nРезультат:\n2\nУ це досить складно повірити, але значеннями в основній таблиці справді можуть бути інші таблиці (матриці). На щастя, у нас не такі дані, тому ми працюватимемо із простими однорозмірними списками значень.\nВ якості аргументу функції array_length на місці масиву можна вказувати ім’я колонки, яка містить масиви (у нашому випадку це колонка product_ids):\nSELECT array_length(column, 1)\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nДізнатися більше про функції для роботи з масивами можна у документації. З деякими з них ми познайомимося далі.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.9  Порахуйте кількість замовлень у таблиці orders із дев’ятьма і більше товарами. Для цього скористайтесь функцією array_length, відфільтруйте дані щодо кількості товарів у замовленні та проведіть агрегацію. Отриманий стовпець назвіть orders.\nПоле в результуючій таблиці: orders\nПояснення: у наших даних у колонці product_ids містяться звичайні списки товарів лише з однією розмірністю.\n\n\n\n\n\nРішення\n%%sql\nSELECT count(order_id) as orders\nFROM   orders\nWHERE  array_length(product_ids, 1) &gt;= 9\n\n\n\n\n\n\n\n\n\norders\n\n\n\n\n0\n5"
  },
  {
    "objectID": "sql_agg.html#різниця-часу-age",
    "href": "sql_agg.html#різниця-часу-age",
    "title": "4  Агрегація даних",
    "section": "4.6 Різниця часу: AGE",
    "text": "4.6 Різниця часу: AGE\nВ якості агрегатних функцій можуть виступати не тільки стовпці, але також розрахункові колонки або результат іншої функції:\nSELECT AVG(some_function(column))\nFROM table\n\n\nSELECT AVG(column_1 + column_2)\nFROM table\nСпробуємо розрахувати середній вік користувачів чоловічої статі. Для цього скористаємось новою для нас функцією AGE.\nФункція AGE повертає різницю між двома значеннями, наведеними у форматі TIMESTAMP. При цьому від першого значення віднімається друге, а сама різниця повертається у форматі INTERVAL:\nSELECT AGE('2022-12-12', '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nТаким чином, з '2021-11-10' до '2022-12-12' пройшло рівно 397 днів.\nЯкщо в якості першого аргументу нічого не вказати, то на місце першої дати автоматично підставиться поточна дата (опівніч поточного дня, тобто початок дня).\nЯкщо сьогодні '2022-12-12', то з '2021-11-10' пройшло рівно стільки ж днів, скільки у прикладі вище:\nSELECT AGE(TIMESTAMP '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nНасправді поточній даті відповідає значення current_date, яке можна вказувати як аргумент функції AGE:\nSELECT AGE(TIMESTAMP '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nМожете самостійно запустити два запити - з current_date і без - і порівняти отримані результати. У вашому випадку це будуть нові результати, але вони мають збігтися.\nА саме значення current_date можна викликати так:\nSELECT current_date\n\nРезультат:\n2023-06-01  \nДля того щоб результат відображався не у кількості днів, а в зручнішому форматі, можна переводити результат обчислень у тип VARCHAR:\nSELECT AGE(current_date, '2021-11-10')::VARCHAR\n\nРезультат:\n1 year 1 mon 2 days\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.10  За допомогою функції AGE і агрегатної функції розрахуйте вік наймолодшого кур’єра чоловічої статі в таблиці couriers.\nВік виведіть через кількість років, місяців і днів (як у прикладі вище), перевівши їх у тип VARCHAR.\nВ якості дати, відносно якої необхідно розрахувати вік кур’єрів, використовуйте свою поточну дату (або не вказуйте її на місці першого аргументу, як показано в прикладах).\nОтриману колонку зі значенням віку назвіть min_age.\nПоле у результуючій таблиці: min_age\nПояснення: оскільки в якості дати, щодо якої проводиться розрахунок віку, ми використовуємо поточну дату, кожен новий день ми отримуватимемо новий результат.\nЗрозуміло, що рахувати вік у такий спосіб не зовсім коректно. Ми навчимося робити це правильно в розділі «Підзапити».\n\n\n\n\n\nРішення\n%%sql\nSELECT age(max(birth_date))::varchar as min_age\nFROM   couriers\nWHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nmin_age\n\n\n\n\n0\n17 years 8 months 13 days 12:54:53.566"
  },
  {
    "objectID": "sql_agg.html#агрегація-з-case-when",
    "href": "sql_agg.html#агрегація-з-case-when",
    "title": "4  Агрегація даних",
    "section": "4.7 Агрегація з CASE WHEN",
    "text": "4.7 Агрегація з CASE WHEN\nАргументом агрегатної функції може бути і складніша розрахункова колонка - наприклад, отримана в результаті роботи конструкції CASE.\nУ такому випадку сама конструкція CASE поміщається всередину дужок агрегатної функції:\nAVG(\n    CASE  \n    WHEN logical_expression_1 THEN expression_1\n    WHEN logical_expression_2 THEN expression_2\n    ELSE expression_else\n    END\n)\nТак, якби в нашій таблиці всі товари були розбиті за категоріями і ми захотіли б порахувати середню ціну товарів з урахуванням підвищувальних чи знижувальних коефіцієнтів для кожної категорії, то ми могли б зробити це, наприклад, так:\nSELECT AVG(\n    CASE \n    WHEN category=\"м'ясо\" THEN price*0.95\n    WHEN category=\"риба\" THEN price*0.9\n    WHEN category=\"напої\" THEN price*1.05\n    ELSE price\n    END\n    ) AS avg_price\nFROM products\nДавайте ускладнимо одне з попередніх завдань і розрахуємо вартість ще одного замовлення.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.11  Порахуйте вартість замовлення, в якому будуть три пачки крекерів ('crackers'), дві пачки чіпсів ('chips') та один енергетичний напій ('energy drink'). Колонку із розрахованою вартістю замовлення назвіть order_price.\nДля розрахунків використовуйте таблицю products.\nПоле в результуючій таблиці: order_price\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розв’язання задачі необхідно за допомогою конструкції CASE створити розрахункову колонку, в якій навпроти кожного товару, який увійшов у замовлення, проставити ціну, помножену на кількість таких товарів у замовленні. Для товарів, які не увійшли у замовлення, необхідно вказати ціну, що дорівнює 0 або NULL. Потім за допомогою агрегатної функції достатньо порахувати суму значень у новій розрахунковій колонці.\n\n\n\n\n\nРішення\n%%sql\nSELECT sum(case when name = 'crackers' then price * 3\n                when name = 'chips' then price * 2\n                when name = 'energy drink' then price\n                else 0 end) as order_price\nFROM   products\n\n\n\n\n\n\n\n\n\norder_price\n\n\n\n\n0\n355.0"
  },
  {
    "objectID": "sql_agg.html#агрегатні-вирази-з-фільтрацією",
    "href": "sql_agg.html#агрегатні-вирази-з-фільтрацією",
    "title": "4  Агрегація даних",
    "section": "4.8 Агрегатні вирази з фільтрацією",
    "text": "4.8 Агрегатні вирази з фільтрацією\nМи розглянули кілька прикладів, коли в якості агрументу агрегатних функцій виступає результат виконання іншої функції.\nАле агрегатна функція може і сама опинитися на місці аргументу якоїсь функції:\nSELECT some_function(SUM(column)) AS result\nFROM table\nНаочний приклад — застосування функції ROUND до результату агрегації:\nSELECT ROUND(SUM(column)) AS rounded_sum\nFROM table\nДавайте вирішимо схоже завдання і заразом ненадовго повернемося до наших напоїв та оператора LIKE.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.12  Розрахуйте середню ціну товарів у таблиці products, у назвах яких є слова 'tea' чи 'coffee'. Виключіть з розрахунку товари, що містять «іван-чай» ('ivan-tea') або «чайний гриб» ('tea mushroom').\nСередню ціну округліть до двох знаків після коми. Стовпець із отриманим значенням назвіть avg_price.\nПоле у результуючій таблиці: avg_price\nПояснення: пам’ятайте, що виконання логічних виразів можна керувати за допомогою дужок. Це може стати в нагоді.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(price), 2) as avg_price\nFROM   products\nWHERE  (name like '%tea%'\n    or name like '%coffee%')\n   and name not like '%ivan-tea%'\n   and name not like '%mushroom%'\n\n\n\n\n\n\n\n\n\navg_price\n\n\n\n\n0\n135.23\n\n\n\n\n\n\n\nВтім, бувають і випадки, коли як аргументи деякої функції виступають відразу кілька агрегатних функцій:\nSELECT some_function(SUM(column_1), SUM(column_2)) AS result\nFROM table\nНаприклад, нам уже знайома функція AGE, яка може приймати одразу два аргументи - дату кінця та дату початку деякого періоду часу.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.13  Скористайтеся функцією AGE та розрахуйте різницю у віці між найстарішим та наймолодшим користувачами чоловічої статі у таблиці users.\nРізницю у віці висловіть кількістю років, місяців та днів, перевівши її у тип VARCHAR.\nНазвіть колонку з порахованим значенням age_diff.\nПоле у результуючій таблиці: age_diff\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЦе завдання можна вирішити різними способами: можна просто знайти різницю між датами народження наймолодшого і найстарішого користувачів, а можна порахувати різницю між їх віком. Можете піти будь-яким шляхом. Якщо рахуватимете вік, то в якості першої дати використовуйте свою поточну дату (current_date).\n\n\n\n\n\nРішення\n%%sql\nSELECT age(max(birth_date), min(birth_date))::varchar as age_diff\nFROM   users\nWHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nage_diff\n\n\n\n\n0\n21 years 9 months 27 days\n\n\n\n\n\n\n\nА тепер розглянемо приклад, коли агрегатна функція приймає в якості аргументу одну функцію і при цьому сама є аргументом іншої функції.\nВиглядати це може так:\nSELECT function_two(SUM(funtion_one(column))) AS result\nFROM table\nУ цьому прикладі спочатку до колонки column застосовується функція funtion_one, потім за допомогою функції SUM буде пораховано суму отриманих значень, і тільки потім до результату агрегації застосовується функція funtion_two.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.14  Розрахуйте середню кількість товарів у замовленнях з таблиці orders, які користувачі оформляли у вихідні дні (субота та неділя) протягом усього часу роботи сервісу.\nОтримане значення округліть до двох знаків після коми. Назвіть колонку з ним avg_order_size.\nПоле у результуючій таблиці: avg_order_size\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розрахунку кількості товарів у замовленнях скористайтесь функцією array_length. Для фільтрації таблиці у вихідні дні можна використовувати функцію DATE_PART з параметром 'dow'.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(array_length(product_ids, 1)), 2) as avg_order_size\nFROM   orders\nWHERE  date_part('dow', creation_time) in (6, 0)\n\n\n\n\n\n\n\n\n\navg_order_size\n\n\n\n\n0\n3.39\n\n\n\n\n\n\n\nРезультати декількох агрегатних функцій можна використовувати в одному запиті для проведення над ними арифметичних операцій:\nSELECT (SUM(column_1) + SUM(column_2)) / 2\nFROM table\nУ запиті вище буде пораховано середнє арифметичне двох сум — значень колонки column_1 і значень колонки column_2.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.15  На основі даних у таблиці user_actions порахуйте: - кількість унікальних користувачів сервісу; - кількість унікальних замовлень - скільки замовлень припадає на одного користувача.\nУ результуючій таблиці відобразіть усі три значення – поля назвіть відповідно unique_users, unique_orders, orders_per_user.\nПоказник числа замовлень користувача округліть до двох знаків після коми.\nПоля у результуючій таблиці: unique_users, unique_orders, orders_per_user\n\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nЩоб отримати коректний результат поділу, необхідно хоча б одне із значень попередньо привести до типу DECIMAL (або помножити на 1.0). Інакше результатом розподілу цілого числа інше ціле число буде теж ціле число.\nДо речі, з подібною проблемою можна ознайомитись на stackoverflow. Це дуже корисний ресурс для пошуку відповідей на свої запитання. Навіть досвідчені програмісти часто ним користуються. Можете вже зараз почати виробляти звичку звертатися до нього за необхідності.\nТакож пам’ятайте, що використовувати в розрахунках аліаси нових колонок не можна.\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct user_id) as unique_users,\n       count(distinct order_id) as unique_orders,\n       round(count(distinct order_id) * 1.0 / count(distinct user_id),\n             2) as orders_per_user\nFROM   user_actions\n\n-- Рішення через DECIMAL\n-- SELECT count(distinct user_id) as unique_users,\n--        count(distinct order_id) as unique_orders,\n--        round(count(distinct order_id)::DECIMAL / count(distinct user_id),\n--              2) as orders_per_user\n-- FROM   user_actions\n\n\n\n\n\n\n\n\n\nunique_users\nunique_orders\norders_per_user\n\n\n\n\n0\n21401\n59595\n2.78\n\n\n\n\n\n\n\nІ насамкінець познайомимося з більш просунутим функціоналом — агрегатними виразами з фільтрацією.\nЯкщо після агрегатної функції вказати ключове слово FILTER і помістити в дужках деяку умову condition після WHERE, то агрегатній функції на вхід будуть подані тільки ті рядки, для яких умова фільтра виявиться істинною.\nЗагалом ця конструкція виглядає так:\nSELECT agg_function(column) FILTER (WHERE condition)\nFROM table\nНаприклад, якби ми захотіли порахувати середню ціну тільки для товарів категорії 'fish', то запит виглядав би так:\nSELECT AVG(price) FILTER (WHERE category = 'fish') AS avg_fish_price\nFROM table\nЗверніть увагу: це дуже схоже на звичайну фільтрацію з агрегацією, яку ми розглядали в попередніх завданнях, тільки в даному випадку умова відбору записів вказується відразу в блоці SELECT.\nПеревага такого запису в тому, що він дозволяє проводити розрахунки без проміжних запитів з умовами у блоці WHERE.\nРозглянемо ще один приклад.\nУ нашому випадку досить зрозуміло, як порахувати загальну кількість користувачів. Також зрозуміло, як порахувати кількість користувачів, які хоча б раз скасовували замовлення — досить просто вказати потрібну умову в операторі WHERE. Але як у рамках одного запиту порахувати тих, хто ніколи не скасовував своє замовлення?\nОскільки об’єднувати кілька запитів разом ми поки що не вміємо, нам допоможе прийти агрегатний вираз.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.16  Порахуйте скільки користувачів ніколи не скасовували своє замовлення. Для цього із загальної кількості всіх унікальних користувачів відніміть кількість унікальних користувачів, які хоча б раз скасовували замовлення. Подумайте, яку умову необхідно вказати у FILTER, щоб отримати коректний результат.\nОтриманий стовпець назвіть users_count.\nПоле в результуючій таблиці: users_count\n\n\n\n\n\nРішення\n%%sql\n-- Рішення через різницю\nSELECT count(distinct user_id) - count(distinct user_id) filter (WHERE action = 'cancel_order') as users_count\nFROM   user_actions\n\n-- Рішення через вкладений запит\n-- SELECT count(distinct user_id) filter (WHERE user_id not in (SELECT DISTINCT user_id\n--                                                              FROM   user_actions\n--                                                              WHERE  action = 'cancel_order')) as users_count\n-- FROM   user_actions\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n18641\n\n\n\n\n\n\n\nДавайте вирішимо ще одне завдання на агрегатні вирази з фільтрацією - цього разу з більш складними розрахунками.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.17  Порахуйте:\n\nзагальну кількість замовлень у таблиці orders\nкількість замовлень із п’ятьма та більше товарами\nчастку замовлень із п’ятьма та більше товарами у загальній кількості замовлень.\n\nУ результуючій таблиці відобразіть усі три значення - поля назвіть відповідно orders, large_orders, large_orders_share.\nЧастку замовлень із п’ятьма та більше товарами у загальній кількості товарів округліть до двох знаків після коми.\nПоля в результуючій таблиці: orders, large_orders, large_orders_share\nПояснення: при розрахунку частки не забудьте хоча б одне із значень попередньо привести до типу DECIMAL (або домножити на 1.0). Також пам’ятайте, що використовувати в розрахунках аліаси нових колонок не можна.\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct order_id) as orders,\n       count(distinct order_id) filter (WHERE array_length(product_ids, 1) &gt;= 5) as large_orders,\n       round(count(distinct order_id) filter (WHERE array_length(product_ids, 1) &gt;= 5)::decimal / count(distinct order_id),\n             2) as large_orders_share\nFROM   orders\n\n\n\n\n\n\n\n\n\norders\nlarge_orders\nlarge_orders_share\n\n\n\n\n0\n59595\n11498\n0.19"
  },
  {
    "objectID": "sql_groupby.html#оператор-group-by",
    "href": "sql_groupby.html#оператор-group-by",
    "title": "5  Групування даних",
    "section": "5.1 Оператор GROUP BY",
    "text": "5.1 Оператор GROUP BY\nДля групування даних в SQL використовується оператор GROUP BY. Він дозволяє групувати дані по одному або декільком стовпцям таблиці. При цьому вибірка даних буде містити лише унікальні значення з вказаних стовпців:\n\nСпочатку в таблиці визначаються рядки, в яких у вказаному в GROUP BY стовпці є однакові значення.\nДалі за цими значеннями записи об’єднуються у групи, причому у групі може бути навіть один запис.\nПісля цього над елементами цих груп, як правило, проводяться якісь операції за допомогою агрегатних функцій: наприклад, за допомогою SUM() обчислюється сума значень в якому-небудь стовпці в кожній групі:\n\nSELECT column_1, SUM(column_2)\nFROM table\nGROUP BY column_1\n\nПотім у результуючий запит потрапляє по одному унікальному запису зі стовпця, по якому здійснювалося групування. При цьому навпроти кожного такого значення відображається результат агрегації по відповідній групі, якщо агрегація проводилася.\n\nТут важливо зробити кілька уточнень:\n\nПо-перше, групування виконується після фільтрації, тобто спочатку виконуються інструкції WHERE і лише потім дані групуються через GROUP BY.\nПо-друге, до груп, що утворилися в результаті застосування GROUP BY, можна застосовувати відразу кілька агрегатних функцій (у тому числі до різних колонок).\nПо-третє, групування можна робити відразу за новими полями, порахованими в SELECT: при цьому допускається використання в GROUP BY аліасу колонки, зазначеного в SELECT. Наступні два запити дадуть однаковий результат:\n\nSELECT DATE(column_1) AS date, SUM(column_2)\nFROM table\nGROUP BY DATE(column_1)\n\n\nSELECT DATE(column_1) AS date, SUM(column_2)\nFROM table\nGROUP BY date\n\nПо-четверте, робити агрегацію після групування необов’язково. Якщо не вказувати агрегатну функцію, то запит поверне унікальні значення в стовпці, тобто той самий результат, як і оператор DISTINCT. Можете самостійно запустити наступний запит та переконатися:\n\nSELECT user_id\nFROM user_actions\nGROUP BY user_id\n\nSELECT DISTINCT user_id\nFROM user_actions\nДо речі, питання про те, як можна відібрати унікальні значення, досвідчені аналітики люблять ставити на співбесідах своїм менш досвідченим колегам.\nІ нарешті, останнє важливе уточнення: під час використання групування колонки, вказаних у SELECT, повинні бути і GROUP BY, якщо вони використовуються у агрегатних функціях. Це обов’язкова умова, і якщо вона не буде виконана, база даних поверне помилку.\nНаступний запит не працюватиме, оскільки в GROUP BY вказані не всі неагреговані колонки з блоку SELECT:\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY column_1\nВодночас такий запит спрацює:\nSELECT SUM(column_2)\nFROM table\nGROUP BY column_1\nЗверніть увагу, що у цьому запиті у блоці SELECT немає колонки, вказаної у GROUP BY, тобто у зворотний бік правило не працює: якщо ми щось вказали в GROUP BY, це не обов’язково вказувати в SELECT. Інакше кажучи, виводити найменування груп необов’язково.\nІ ще: замість назв колонок у блоці GROUP BY можна використовувати номер колонки, вказаної у SELECT. Наприклад, наступні два запити еквівалентні:\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY column_1, column_2\n\n\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY 1, 2\nПри цьому номери колонок із SELECT також можна використовувати при сортуванні в операторі ORDER BY. Можете самі поекспериментувати із цим у наступних завданнях.\nЗ теорією начебто розібралися, тепер приступимо до практики. Минулого разу ми вже рахували кількість кур’єрів жіночої статі та використовували для цього фільтрацію. Групування дозволить нам провести розрахунки відразу для двох статей.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.1  За допомогою групування порахуйте кількість кур’єрів чоловічої та жіночої статі у таблиці couriers. Нову колонку з числом кур’єром назвіть couriers_count. Результат відсортуйте по цій колонці за зростанням.\nПоля у результуючій таблиці: sex, couriers_count\n\n\n\n\n\nРішення\n%%sql\nSELECT sex,\n       count(courier_id) as couriers_count\nFROM   couriers\nGROUP BY sex\nORDER BY couriers_count\n\n\n\n\n\n\n\n\n\nsex\ncouriers_count\n\n\n\n\n0\nfemale\n1149\n\n\n1\nmale\n1674\n\n\n\n\n\n\n\nТепер давайте аналогічним чином порахуємо максимальний вік користувачів чоловічої та жіночої статі. Тільки на цей раз виведемо не повний вік, а лише кількість повних років. Для цього до результату обчислень можна застосувати вже знайому нам функцію DATE_PART з аргументом 'year'.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.2  Порахуйте максимальний вік користувачів чоловічої та жіночої статі у таблиці users. Вік виміряйте кількістю повних років. Нову колонку з віком назвіть max_age. Результат відсортуйте за новою колонкою за зростанням віку.\nПоля у результуючій таблиці: sex, max_age\n\n\n\n\n\nРішення\n%%sql\nSELECT sex,\n       date_part('year', max(age(birth_date))) as max_age\nFROM   users\nGROUP BY sex\nORDER BY max_age\n\n\n\n\n\n\n\n\n\nsex\nmax_age\n\n\n\n\n0\nfemale\n40\n\n\n1\nmale\n41\n\n\n\n\n\n\n\nМаркетологи знову звернулися до нас із завданням: цього разу вони просять провести невеликий аналіз нашої аудиторії та порахувати, скільки клієнтів певного віку користуються нашим сервісом. Давайте допоможемо нашим колегам!\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.3  Розбийте користувачів з таблиці users на групи віком (вік вимірюємо кількістю повних років) і порахуйте кількість користувачів кожного віку. Колонку з віком назвіть age, а колонку з кількістю користувачів users_count. Відсортуйте отриманий результат за зростанням по віку. Не забудемо і про тих користувачів, у яких замість віку буде перепустки, для цієї групи також підрахуємо кількість користувачів.\nПоля у результуючій таблиці: age, users_count\nПояснення: зверніть увагу, що у цій задачі вам необхідно провести групування за новим розрахунковим полем з віком. У цій ситуації важливо пам’ятати, що колонки, вказані в SELECT, повинні знаходитись і в GROUP BY (якщо вони не використовуються в агрегатних функціях). При цьому GROUP BY допускається використання аліасу колонки, зазначеного в блоці SELECT, тобто повторно проводити обчислення у GROUP BY не обов’язково.\n\n\n\n\n\nРішення\n%%sql\nSELECT date_part('year', age(birth_date)) as age,\n       count(user_id) as users_count\nFROM   users\nGROUP BY age\nORDER BY age\nLIMIT 10\n\n\n\n\n\n\n\n\n\nage\nusers_count\n\n\n\n\n0\nNaN\n50\n\n\n1\n19.0\n1\n\n\n2\n20.0\n2\n\n\n3\n21.0\n6\n\n\n4\n22.0\n30\n\n\n5\n23.0\n76\n\n\n6\n24.0\n201\n\n\n7\n25.0\n437\n\n\n8\n26.0\n862\n\n\n9\n27.0\n1433\n\n\n\n\n\n\n\nВи могли помітити, що результат попереднього запиту для однієї з груп повернув пусте значення віку. Ми знову зіткнулися з значеннями NULL — цього разу в колонці birth_date. Давайте позбавимося їх перед групуванням і заодно зробимо наш аналіз ще більш детальним: додамо до групування стать користувачів.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.4  Знову розбийте користувачів із таблиці users на групи за віком (вік вимірюємо кількістю повних років), тільки тепер додайте до групування стать користувача. В результаті в кожній віковій групі має з’явитися ще по дві підгрупи зі статтю. У кожній такій підгрупі порахуйте кількість користувачів.\nУсі значення NULL у колонці birth_date заздалегідь відфільтруйте за допомогою WHERE. Колонку з віком назвіть age, а колонку з числом користувачів -users_count`, ім’я колонки зі статтю залиште без змін. Відсортуйте отриману таблицю спочатку по колонці з віком по зростанню, потім по колонці з підлогою теж по зростанню.\nПоля у результуючій таблиці: age, sex, users_count\n\n\n\n\n\nРішення\n%%sql\nSELECT date_part('year', age(birth_date)) as age,\n       sex,\n       count(user_id) as users_count\nFROM   users\nWHERE  birth_date is not null\nGROUP BY age, sex\nORDER BY age, sex\nLIMIT 10\n\n\n\n\n\n\n\n\n\nage\nsex\nusers_count\n\n\n\n\n0\n19\nmale\n1\n\n\n1\n20\nmale\n2\n\n\n2\n21\nfemale\n4\n\n\n3\n21\nmale\n2\n\n\n4\n22\nfemale\n13\n\n\n5\n22\nmale\n17\n\n\n6\n23\nfemale\n38\n\n\n7\n23\nmale\n38\n\n\n8\n24\nfemale\n108\n\n\n9\n24\nmale\n93\n\n\n\n\n\n\n\nА тепер, використовуючи наші знання про групування, давайте порахуємо скільки замовлень було зроблено і скільки скасовано в кожному окремому місяці. На цей раз для роботи з датами будемо використовувати не DATE_PART, а нову функцію DATE_TRUNC.\nФункція DATE_TRUNC використовується усічення дат і часу, тобто вона працює аналогічно округленню ROUND, тільки для типів даних TIMESTAMP та INTERVAL.\nСинтаксис у неї такий самий, як і у DATE_PART:\nSELECT DATE_TRUNC(part, column)\nНа місці part у лапках вказується, до якої точності слід обрізати передане значення часу: 'year', 'month', 'day', 'hour’ тощо.\nОтримані значення мають тип TIMESTAMP або INTERVAL, а всі «частини» вихідного значення, менш значущі, ніж задана «частина», прирівнюються до нуля (або одиниці, якщо це номер дня або місяця):\nSELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-01 00:00\n\nSELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-12 00:00    \n\nSELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-12 08:00\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з функцією DATE_TRUNC можна ознайомитись тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.5  Використовуючи функцію DATE_TRUNC, порахуйте, скільки замовлень було зроблено та скільки було скасовано кожного місяця. Розрахунки проводьте за таблицею user_actions. Колонку з усіченою датою назвіть month, колонку з кількістю замовлень - orders_count. Результат відсортуйте спочатку за місяцями – за зростанням, потім за типом дії – також за зростанням.\nПоля в результуючій таблиці: month, action, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT date_trunc('month', time) as month,\n       action,\n       count(order_id) as orders_count\nFROM   user_actions\nGROUP BY month, action\nORDER BY month, action\n\n\n\n\n\n\n\n\n\nmonth\naction\norders_count\n\n\n\n\n0\n2022-08-01\ncancel_order\n967\n\n\n1\n2022-08-01\ncreate_order\n18799\n\n\n2\n2022-09-01\ncancel_order\n2012\n\n\n3\n2022-09-01\ncreate_order\n40796\n\n\n\n\n\n\n\nУ Завдання 4.9 ми навчилися працювати з функцією array_length і навіть порахували з її допомогою кількість товарів у кожному замовленні. Давайте для кожного розміру замовлення, яке зустрічається у даних, порахуємо загальну кількість замовлень такого розміру.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.6  Порахуйте кількість товарів у кожному замовленні з таблиці orders, застосуйте до цих значень групування та порахуйте кількість замовлень у кожній групі. Виведіть дві колонки: кількість товарів у замовленні та кількість замовлень з такою кількістю. Колонки назвіть відповідно order_size та orders_count. Результат відсортуйте за зростанням кількості товарів у замовленні.\nПоля у результуючій таблиці: order_size, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT array_length(product_ids, 1) as order_size,\n       count(order_id) as orders_count\nFROM   orders\nGROUP BY order_size\nORDER BY order_size\n\n\n\n\n\n\n\n\n\norder_size\norders_count\n\n\n\n\n0\n1\n3333\n\n\n1\n2\n11851\n\n\n2\n3\n17856\n\n\n3\n4\n15057\n\n\n4\n5\n8065\n\n\n5\n6\n2774\n\n\n6\n7\n583\n\n\n7\n8\n71\n\n\n8\n9\n5"
  },
  {
    "objectID": "sql_groupby.html#фільтрація-після-групування-having",
    "href": "sql_groupby.html#фільтрація-після-групування-having",
    "title": "5  Групування даних",
    "section": "5.2 Фільтрація після групування: HAVING",
    "text": "5.2 Фільтрація після групування: HAVING\nHAVING використовується для фільтрації даних після групування. Він працює аналогічно WHERE, тільки використовується після GROUP BY і фільтрує вже групи, а не окремі записи.\nАле треба обговорити одну важливу особливість роботи з HAVING: у цьому блоці не можна вказувати аліаси розрахункових полів із блоку SELECT. Справа в тому, що відповідно до порядку виконання запиту оператор SELECT виконується після оператора HAVING. Тому агрегацію необхідно також вказувати і HAVING.\nНаприклад, такий запит не спрацює:\nSELECT column_1, SUM(column_2) AS new_column\nFROM table\nGROUP BY column_1\nHAVING new_column = 10\nА такий спрацює:\nSELECT column_1, SUM(column_2) AS new_column\nFROM table\nGROUP BY column_1\nHAVING SUM(column_2) = 10\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.7  Доповніть попередній запит оператором HAVING та відберіть лише ті розміри замовлень, загальна кількість яких перевищує 5000. Знову виведіть дві колонки: кількість товарів у замовленні та кількість замовлень з такою кількістю. Колонки назвіть відповідно order_size та orders_count. Результат відсортуйте за зростанням кількості товарів у замовленні.\nПоля у результуючій таблиці: order_size, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT array_length(product_ids, 1) as order_size,\n       count(order_id) as orders_count\nFROM   orders\nGROUP BY order_size\nHAVING count(order_id) &gt; 5000\nORDER BY order_size\n\n\n\n\n\n\n\n\n\norder_size\norders_count\n\n\n\n\n0\n2\n11851\n\n\n1\n3\n17856\n\n\n2\n4\n15057\n\n\n3\n5\n8065\n\n\n\n\n\n\n\nПеред тим, як рухатися далі, пропонуємо вам вирішити ще кілька завдань на групування.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.8  З таблиці courier_actions відберіть id трьох кур’єрів, які доставили найбільшу кількість замовлень у серпні 2022 року. Виведіть дві колонки – id кур’єра та кількість доставлених замовлень. Назвіть колонку з кількістю доставлених замовлень delivered_orders. Відсортуйте результат за спаданням delivered_orders.\nПоля у результуючій таблиці: courier_id, delivered_orders\nПояснення: пам’ятайте, що у таблиці courier_actions є інформація як про прийняті, так і про доставлені замовлення.\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       count(courier_id) as delivered_orders\nFROM   courier_actions\nWHERE  action = 'deliver_order'\n   and date_part('year', time) = 2022\n   and date_part('month', time) = 08\nGROUP BY courier_id\nORDER BY delivered_orders desc\nLIMIT 3\n\n\n\n\n\n\n\n\n\ncourier_id\ndelivered_orders\n\n\n\n\n0\n179\n36\n\n\n1\n329\n34\n\n\n2\n103\n31\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.9  А тепер відберіть лише тих кур’єрів, які у вересні 2022 року встигли доставити тільки за одне замовлення. Таблиця та сама - courier_actions. Знову виведіть дві колонки – id кур’єра та кількість доставлених замовлень. Назвіть колонку з числом замовлень delivered_orders. Результат відсортуйте за зростанням id кур’єра.\nПоля у результуючій таблиці: courier_id, delivered_orders\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       count(distinct courier_id) as delivered_orders\nFROM   courier_actions\nWHERE  action = 'deliver_order'\n   and date_part('year', time) = 2022\n   and date_part('month', time) = 09\nGROUP BY courier_id having count(distinct courier_id) = 1\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\ndelivered_orders\n\n\n\n\n0\n1\n1\n\n\n1\n2\n1\n\n\n2\n3\n1\n\n\n3\n4\n1\n\n\n4\n5\n1\n\n\n...\n...\n...\n\n\n2817\n3163\n1\n\n\n2818\n3164\n1\n\n\n2819\n3165\n1\n\n\n2820\n3166\n1\n\n\n2821\n3167\n1\n\n\n\n\n2822 rows × 2 columns\n\n\n\nОй, до нас у кабінет знову постукали! Це знову маркетологи: кажуть, що хочуть розіслати пуш-повідомлення зі спеціальною пропозицією. Аудиторія – користувачі, які давно не робили у нас замовлення.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.10  З таблиці user_actions відберіть користувачів, у яких останнє замовлення було створено до 8 вересня 2022 року. Виведіть тільки їх ID, дату створення замовлення виводити не потрібно. Результат відсортуйте за зростанням id користувача.\nПоле у результуючій таблиці: user_id\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЩоб розв’язати завдання, потрібно спочатку для кожного користувача знайти останній TIMESTAMP, коли він робив замовлення, а потім відібрати тих, хто робив це занадто давно. Враховуйте, що в таблиці є не лише час створення, а й час скасування замовлення.\n\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT user_id\nFROM   user_actions\nWHERE  action = 'create_order'\nGROUP BY user_id\nHAVING max(time) &lt; '2022-09-08'\nORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n17368\n19727\n\n\n17369\n19728\n\n\n17370\n19729\n\n\n17371\n19730\n\n\n17372\n19731\n\n\n\n\n17373 rows × 1 columns\n\n\n\nА тепер спробуємо вирішити складніше завдання. Для нього нам знову знадобиться агрегатний вираз із фільтрацією, який ми розглядали у Завдання 4.16. Цю конструкцію можна застосовувати не лише до всієї таблиці, а й окремо до кожної групи, сформованої внаслідок застосування оператора GROUP BY. Загалом вона виглядатиме так:\nSELECT column_1, agg_function(column_2) FILTER (WHERE [condition])\nFROM table\nGROUP BY column_1\nПриклад:\nSELECT column_1, AVG(column_2) FILTER (WHERE column_3 &gt; 100)\nFROM table\nGROUP BY column_1\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.11  Для кожного користувача в таблиці user_actions порахуйте частку скасованих замовлень. Виведіть дві колонки: ID користувача та розрахований показник. Нову колонку з показником округліть до двох знаків після коми та назвіть cancel_rate. Результат відсортуйте за зростанням id користувача.\nПоля у результуючій таблиці: user_id, cancel_rate\nПояснення: щоб порахувати частку скасованих замовлень, необхідно поділити кількість скасованих замовлень на загальну кількість унікальних замовлень користувача. Пам’ятайте, що для отримання коректного результату поділу потрібно хоча б одне із значень привести до типу DECIMAL.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       round(count(action) filter (WHERE action = 'cancel_order')::decimal / count(action) filter (WHERE action = 'create_order'),\n             2) as cancel_rate\nFROM   user_actions\nGROUP BY user_id\nORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\ncancel_rate\n\n\n\n\n0\n1\n0.0\n\n\n1\n2\n0.0\n\n\n2\n3\n0.0\n\n\n3\n4\n0.0\n\n\n4\n5\n0.0\n\n\n...\n...\n...\n\n\n21396\n21398\n0.0\n\n\n21397\n21399\n0.0\n\n\n21398\n21400\n0.0\n\n\n21399\n21401\n0.0\n\n\n21400\n21402\n0.0\n\n\n\n\n21401 rows × 2 columns\n\n\n\nПовернімося до запиту з групуванням користувачів за віком, який робили у завданні 4.3.\nМи порахували кількість користувачів кожного віку, але дивитися на дані саме в такому угрупованні не дуже цікаво. Давайте перейдемо від конкретних значень віку до вікових груп.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.12  Розбийте користувачів із таблиці users на 4 вікові групи:\n\nвід 19 до 24 років;\nвід 25 до 29 років;\nвід 30 до 35 років;\nвід 36 до 41 року.\n\nПорахуйте кількість користувачів, які потрапили до кожної вікової групи. Групи назвіть відповідно 19-24, 25-29, 30-35, 36-41. Виведіть найменування груп та кількість користувачів у них. Назвіть колонку з найменуванням груп group_age, а колонку з числом користувачів — users_count. Відсортуйте отриману таблицю по колонці з найменуванням груп за зростання.\nПоля у результуючій таблиці: group_age, users_count\nПояснення: для вирішення цього завдання підійде конструкція CASE. Як і минулого разу, вік розглядайте, як кількість повних років.\n\n\n\n\n\nРішення\n%%sql\nSELECT case when date_part('year', age(birth_date)) between 19 and\n                 24 then '19-24'\n            when date_part('year', age(birth_date)) between 25 and\n                 29 then '25-29'\n            when date_part('year', age(birth_date)) between 30 and\n                 35 then '30-35'\n            when date_part('year', age(birth_date)) between 36 and\n                 41 then '36-41' end as group_age,\n       count(user_id) as users_count\nFROM   users\nWHERE  birth_date is not null\nGROUP BY group_age\nORDER BY group_age\n\n\n\n\n\n\n\n\n\ngroup_age\nusers_count\n\n\n\n\n0\n19-24\n316\n\n\n1\n25-29\n7472\n\n\n2\n30-35\n11909\n\n\n3\n36-41\n584"
  },
  {
    "objectID": "sql_subquery.html#порядок-виконання-запитів",
    "href": "sql_subquery.html#порядок-виконання-запитів",
    "title": "6  Підзапити",
    "section": "6.1 Порядок виконання запитів",
    "text": "6.1 Порядок виконання запитів\nПерш ніж переходити до підзапитів, давайте трохи поговоримо про порядок виконання запитів у SQL.\nДо цього моменту ми вже встигли познайомитися з основними операторами, які складають “скелет” стандартного SQL-запиту: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY та LIMIT.\nМи вже знаємо, що порядок їх написання у запиті наступний:\nSELECT      -- перелік полів результуючої таблиці\nFROM        -- вказівник джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- групування даних\nHAVING      -- фільтрація даних після групування\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів у виводі\nПроте важливо розуміти, що порядок виконання операторів у базах даних дещо відрізняється від порядку їх написання у запиті. У спрощеному вигляді порядок виконання запиту такий:\nFROM       -- вказівник джерела даних\nWHERE      -- фільтрація даних\nGROUP BY   -- групування даних\nHAVING     -- фільтрація даних після групування\nSELECT     -- перелік полів результуючої таблиці\nORDER BY   -- сортування результуючої таблиці\nLIMIT      -- бмеження кількості записів у виводі\nТаким чином:\n\nСпочатку з допомогою FROM визначається таблиця.\nПотім відповідно до зазначеної у WHERE умові з цієї таблиці відбираються записи.\nПотім вибрані дані групуються та агрегуються за допомогою GROUP BY.\nДалі з агрегованих записів відбираються ті, які задовольняють умову HAVING.\nТільки після цього відповідно до зазначених у SELECT інструкціях формується результуюча таблиця — проводяться всі необхідні обчислення, надаються нові імена тощо.\nПотім результуюча таблиця сортується відповідно до ORDER BY.\nІ нарешті спрацьовує обмеження кількості рядків, вказане в LIMIT.\n\nНасправді це дуже важлива інформація, яку слід пам’ятати при складанні будь-яких SQL-запитів.\nМожливо, ви вже зіткнулися з помилками, коли намагалися в блоці WHERE використовувати фільтрацію по нових полях, розрахованих у SELECT. Така операція не відповідає порядку виконання операторів і тому так робити не можна. Також ви могли потрапити в ситуацію, коли при фільтрації у HAVING у вас не приймався аліас колонки, розрахованої в SELECT. Це відбувалося з тієї ж причини – база даних просто ще не знала про те, що ви надали колонці нове ім’я.\nІ ще одна важлива порада. Зверніть увагу, що фільтрацію даних за неагрегованими значеннями можна робити як у блоці WHERE, так і в блоці HAVING. Уважно подивіться на такі запити:\nSELECT sex, COUNT(user_id)\nFROM users\nWHERE sex != 'male'\nGROUP BY sex\n\n\nSELECT sex, COUNT(user_id)\nFROM users\nGROUP BY sex\nHAVING sex != 'male'\nЇх результат буде однаковим (можете переконатися в цьому самі).\nПроте робити фільтрацію за неагрегованими даними рекомендується саме у блоці WHERE, тобто заздалегідь. У такому разі ви ще до угруповання прибираєте з розрахунків непотрібні вам дані і таким чином не витрачаєте обчислювальні ресурси на підрахунок значень, які будуть відфільтровані вами пізніше.\nЦе важливий момент щодо оптимізації SQL-запитів, тому рекомендуємо вам взяти до уваги інформацію."
  },
  {
    "objectID": "sql_subquery.html#підзапити",
    "href": "sql_subquery.html#підзапити",
    "title": "6  Підзапити",
    "section": "6.2 Підзапити",
    "text": "6.2 Підзапити\nПідзапити це потужним інструментом в мові SQL, який дозволяє нам виконувати запити в середині інших запитів. Вони дають можливість створювати складніші і більш гнучкі запити, які вимагають доступу до даних з кількох таблиць або виконання додаткових обчислень.\nОдин із сценаріїв використання підзапитів - це пошук даних в одній таблиці на основі значень з іншої таблиці. Наприклад, ми можемо створити запит, що повертає всіх клієнтів, які зробили замовлення на товари з певної категорії, використовуючи підзапит для вибірки ідентифікаторів цих товарів з таблиці товарів.\nНаприклад у нас є дві таблиці: clients і orders. Нам потрібно отримати список клієнтів, які зробили замовлення після певної дати. Для цього ми можемо скористатися підзапитом:\nSELECT *\nFROM clients\nWHERE ID IN (SELECT client_id\n             FROM orders\n             WHERE data &gt; '2023-01-01');\n)\nІншими словами, підзапит — це лише запит усередині іншого запиту.\nПідзапити можуть застосовуватись у таких частинах основного запиту:\n\nв операторі FROM;\nв операторі SELECT (якщо запит повертає один стовпець з одним значенням);\nв операторах WHERE та HAVING (якщо запит повертає один стовпець з одним або декількома значеннями).\n\nАле давайте про все по порядку.\nНасамперед важливо зрозуміти, що з результату виконання підзапиту можна звертатися також як і до таблиць у базі даних, тобто використовувати їх у блоці FROM замість наявних таблиць:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM table\n) AS subquery_1\nВ межах даного запиту спочатку буде виконано підзапит, який відбере колонки column_1 і column_2 з таблиці table, а потім вже з таблиці, що утворилася, основний запит вибере колонку column_1.\nВажливий момент: при використанні підзапиту в блоці FROM сформованій на основі підзапиту таблиці необхідно привласнити якийсь аліас, інакше основний запит не спрацює. У прикладі вище ми позначили результат підзапиту subquery_1.\nКрім того, рівнів вкладеності може бути декілька:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM (\n        SELECT column_1, column_2, column_3\n        FROM table\n    ) AS subquery_1\n) AS subquery_2\nВ даному випадку послідовність роботи запиту така: спочатку буде виконано підзапит, що повертає результат subquery_1, потім підзапит, що повертає результат subquery_2, і тільки потім в результаті основного підзапиту потрапить колонка column_1. В результаті виходить щось схоже на матрьошку, при цьому до основної таблиці table звертається тільки перший підзапит subquery_1.\nНаведений приклад досить умовний і на практиці колонки в такий спосіб відбирати не варто, але загальну ідею він має передавати.\nРозуміння того, як працюють підзапити в блоці FROM, нам особливо стане в нагоді, коли ми вчитимемося об’єднувати різні таблиці.\nА зараз давайте вирішимо просте завдання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.1  Використовуючи дані з таблиці user_actions, розрахуйте середню кількість замовлень для всіх користувачів нашого сервісу. Для цього спочатку в підзапиті порахуйте скільки замовлень зробив кожен користувач, а потім зверніться до результату підзапиту в блоці FROM і вже в основному запиті усередніть кількість замовлень по всіх користувачах. Отриману середню кількість замовлень всіх користувачів округліть до двох знаків після коми. Назвіть колонку з цим значенням orders_avg.\nПоле у результуючій таблиці: orders_avg\nПояснення: до колонок з підзапиту можна застосовувати агрегатні функції — так само, як би ми зверталися до колонок вихідних таблиць.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(orders_count), 2) as orders_avg\nFROM   (SELECT count(order_id) as orders_count\n        FROM   user_actions\n        WHERE  action = 'create_order'\n        GROUP BY user_id) as t1\n\n\n\n\n\n\n\n\n\norders_avg\n\n\n\n\n0\n2.78"
  },
  {
    "objectID": "sql_subquery.html#табличні-вирази-with",
    "href": "sql_subquery.html#табличні-вирази-with",
    "title": "6  Підзапити",
    "section": "6.3 Табличні вирази: WITH",
    "text": "6.3 Табличні вирази: WITH\nВирішуючи попереднє завдання, ви могли запитати себе: а що якщо один і той же підзапит буде використовуватися в декількох частинах основного запиту? Невже щоразу доведеться дублювати той самий підзапит? А якщо рівнів вкладеності буде кілька? Чи не вийде тоді надто складний та громіздкий запит, який буде складно читати?\nДля таких випадків SQL передбачений оператор WITH, який дозволяє створювати так звані табличні вирази (CTE, анг. common table expressions) - тимчасові таблиці, які існують тільки для одного запиту. Їхнє основне призначення полягає в розбиття складних запитів на кілька частин.\nТабличні вирази створюються так:\nWITH subquery_1 AS (\n    SELECT column_1, column_2\n    FROM table\n)\nSELECT column_1\nFROM subquery_1\nПорівняйте запит вище з результатом запиту, який ми використовували раніше:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM table\n) AS subquery_1\nОператор WITH може містити кілька табличних виразів, причому до зазначених раніше виразів можна звертатися у подальших виразах:\nWITH subquery_1 AS (\n    SELECT column_1, column_2, column_3\n    FROM table\n    ),\n     subquery_2 AS (\n    SELECT column_1, column_2\n    FROM subquery_1\n    )\n\nSELECT column_1\nFROM subquery_2\nМожете знову порівняти запит вище із запитом, який ми використовували раніше:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM (\n        SELECT column_1, column_2, column_3\n        FROM table\n    ) AS subquery_1\n) AS subquery_2\nВикористовувати у своїх запитах оператор WITH чи ні вирішувати вам, але в деяких випадках він може спростити роботу з кодом запиту.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про WITH та табличні вирази можна почитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.2  Повторіть запит із завдання 6.1, але тепер замість підзапиту використовуйте оператор WITH та табличний вираз. Умови завдання ті самі.\nПоле у результуючій таблиці: orders_avg\n\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT user_id,\n                   count(order_id) as orders_count\n            FROM   user_actions\n            WHERE  action = 'create_order'\n            GROUP BY user_id)\nSELECT round(avg(orders_count), 2) as orders_avg\nFROM   t1\n\n\n\n\n\n\n\n\n\norders_avg\n\n\n\n\n0\n2.78\n\n\n\n\n\n\n\nЩе один важливий напрямок застосування підзапитів - створення більш просунутих умовних виразів в операторах WHERE та HAVING. Але оскільки і в тому, і в іншому випадку синтаксис і призначення підзапитів приблизно однакові, у цьому уроці ми розглядатимемо все на прикладі підзапитів у WHERE.\nНасамперед важливо зрозуміти, що підзапит, який повертає одне значення, може використовуватися як звичайне значення спільно з операторами порівняння.\nУявіть, що нам потрібно порівняти значення в якомусь стовпці з максимальним, мінімальним чи середнім значенням у цьому стовпці. Зробити це в рамках одного запиту не вийде, оскільки агрегатні функції не можна використовувати в блоці WHERE.\nНаприклад, наступний запит не працюватиме (база даних повідомить про помилку):\nSELECT column\nFROM table\nWHERE column = MAX(column) \nУ той же час такий запит спрацює, тому що підзапит виконається першим і поверне одне значення:\nSELECT column\nFROM table\nWHERE column = (SELECT MAX(column) FROM table) \nВ результаті виконання такого запиту ми отримаємо всі значення в колонці column, що дорівнює максимальному значенню в цій колонці.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.3  Виведіть з таблиці products інформацію про всі товари крім найдешевшого. Результат відсортуйте за зменшенням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nWHERE  price != (SELECT min(price)\n                 FROM   products)\nORDER BY product_id desc\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n87\nveal\n398.0\n\n\n1\n86\ncold coffee\n70.0\n\n\n2\n85\njam\n200.0\n\n\n3\n84\ntangerines\n90.0\n\n\n4\n83\nwaffles\n55.0\n\n\n...\n...\n...\n...\n\n\n81\n5\ncoffee 3 in 1\n15.0\n\n\n82\n4\nlollipops\n46.0\n\n\n83\n3\nstill water\n80.0\n\n\n84\n2\ngreen tea bags\n50.0\n\n\n85\n1\nsugar\n150.0\n\n\n\n\n86 rows × 3 columns\n\n\n\nУ блоці WHERE результати підзапитів, що повертають одне значення, також можна використовувати в арифметичних операціях:\nSELECT column\nFROM table\nWHERE column = (SELECT MAX(column) FROM table) - 100\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.4  Виведіть інформацію про товари в таблиці products, ціна на які перевищує середню ціну всіх товарів на 20 і більше одиниць. Результат відсортуйте за зменшенням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nWHERE  price &gt;= (SELECT avg(price)\n                 FROM   products) + 20\nORDER BY product_id desc\nLIMIT 10\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n87\nveal\n398.0\n\n\n1\n85\njam\n200.0\n\n\n2\n77\nchicken\n298.0\n\n\n3\n69\ncranberry juice\n175.0\n\n\n4\n66\nbeef\n370.0\n\n\n5\n64\npineapple\n200.0\n\n\n6\n61\nhoney\n380.0\n\n\n7\n59\nsesame oil\n250.0\n\n\n8\n57\npork\n450.0\n\n\n9\n51\nsmoked fish\n195.0"
  },
  {
    "objectID": "sql_subquery.html#підзапит-з-інтервалом-часу-interval",
    "href": "sql_subquery.html#підзапит-з-інтервалом-часу-interval",
    "title": "6  Підзапити",
    "section": "6.4 Підзапит з інтервалом часу: INTERVAL",
    "text": "6.4 Підзапит з інтервалом часу: INTERVAL\nУ яких випадках нам може стати в нагоді підзапит в операторі WHERE?\nУявімо, що нам потрібно провести якісь розрахунки за останні N днів — скажімо, за останній тиждень. Чи будемо ми вручну відраховувати 7 днів від останньої дати в нашій таблиці? Зрозуміло, що ні. Крім того, остання дата може згодом змінитись, коли до нас надійдуть нові дані. Щоразу писати новий запит і рахувати дату вручну — заняття не для нас.\nДля вирішення такого завдання ми можемо спочатку за допомогою підзапиту обчислити останню дату наших даних, а потім відкласти від неї тиждень.\nЩоб відкласти від дати або додати до неї певний проміжок часу, можна використовувати нескладні арифметичні операції з датами. Наприклад, від поточної дати можна відібрати якийсь проміжок INTERVAL:\nSELECT NOW() - INTERVAL '1 year 2 months 1 week'\n\nРезультат:\n2022-04-24 13:10\nДо речі, NOW() — корисна функція, яка дозволяє отримувати поточну дату та час (у вашому випадку вона буде іншою):\nSELECT NOW()\n\nРезультат:\n2022-07-10 16:11\n\n\n\n\n\n\nПримітка\n\n\n\nЗ іншими прикладами роботи з INTERVAL та арифметичними операціями з датами можна ознайомитись тут.\nПро функцію NOW() можна додатково прочитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.5  Порахуйте кількість унікальних клієнтів у таблиці user_actions, які зробили за останній тиждень хоча б одне замовлення. Отриману колонку зі значенням назвіть users_count. В якості поточної дати, від якої відкладати тиждень, використовуйте останню дату тієї ж таблиці user_actions.\nПоле у результуючій таблиці: users_count\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct user_id) as users_count\nFROM   user_actions\nWHERE  action = 'create_order'\n   and time &gt; (SELECT max(time)\n            FROM   user_actions) - interval '1 week'\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n17352\n\n\n\n\n\n\n\nВиходить, що в одному з минулих завдань (4.10) ми неправильно рахували вік кур’єрів. Дійсно, як перша дата у функції AGE() ми використовували поточну дату, а не останню дату в наших даних. Давайте виправимо це прикре непорозуміння, адже тепер у нас для цього є всі необхідні знання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.6  За допомогою функції AGE() і агрегатної функції знову розрахуйте вік наймолодшого кур’єра чоловічої статі в таблиці couriers, але цього разу в якості першої дати використовуйте останню дату з таблиці courier_actions. Щоб вийшла саме дата, перед застосуванням функції AGE() переведіть пораховану останню дату у формат DATE, як ми робили у 2.9. Вік кур’єра виміряйте кількістю років, місяців і днів і переведіть його до типу VARCHAR. Отриману колонку зі значенням віку назвіть min_age.\nПоле у результуючій таблиці: min_age\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цій задачі результат підзапиту виступає як аргумент функції. Щоб весь запит виглядав компактнішим, для приведення даних до іншого типу можна використовувати формат запису з двома двокрапками - ::.\nТакож зверніть увагу, що для отримання необхідного результату ми звертаємось до різних таблиць у рамках одного загального запиту – так можна робити теж.\n\n\n\n\nРішення\n%%sql\n-- варіант 1\nSELECT age((SELECT max(time)::date\n            FROM   courier_actions), max(birth_date))::varchar as min_age\nFROM   couriers\nWHERE  sex = 'male'\n\n-- варіант 2\n-- SELECT min(age((SELECT max(time)::date\n--                 FROM   courier_actions), birth_date))::varchar as min_age\n-- FROM   couriers\n-- WHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nmin_age\n\n\n\n\n0\n16 years 10 months 11 days\n\n\n\n\n\n\n\nПідзапит, який повертає кілька значень, може використовуватися в блоці WHERE спільно з оператором IN — наприклад, коли нам потрібно перевірити, чи збігається значення в стовпці з одним із значень із певної множини, отриманої в результаті виконання підзапиту:\nSELECT column_1\nFROM table_1\nWHERE column_1 IN (SELECT column_2 FROM table_2) \nПри цьому, запит вище буде рівносильний запиту з табличним виразом:\nWITH subquery AS (\n    SELECT column_2\n    FROM table_2\n    )\n\nSELECT column_1\nFROM table_1\nWHERE column_1 IN (SELECT * FROM subquery) \nЗверніть увагу, що при використанні в операторі табличного виразу WHERE звернутися просто до його імені не можна - необхідно попередньо вибрати всі його записи, тобто написати підзапит. При цьому в табличному вираженні має бути лише один стовпець, інакше база даних поверне помилку.\nКрім того, в табличному вираженні можна зберігати лише одне значення (наприклад, результат агрегації) і аналогічним чином викликати його в операторі WHERE як змінну:\nWITH subquery AS (\n    SELECT MAX(column_2)\n    FROM table_2\n    )\n\nSELECT column_1\nFROM table_1\nWHERE column_1 = (SELECT * FROM subquery) \nДавайте розглянемо такий приклад.\nЗ наших даних досить легко відібрати скасовані замовлення - достатньо вказати у WHERE потрібний фільтр. Але як відібрати створені, але не скасовані замовлення? Це якраз можна зробити за допомогою підзапиту або табличного виразу.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.7  З таблиці user_actions за допомогою підзапиту або табличного виразу відберіть усі замовлення, які не було скасовано користувачами. Виведіть стовпчик з id цих замовлень. Результат запиту відсортуйте за зростанням id замовлення. Додайте в запит оператор LIMIT та виведіть лише перші 10 рядків результуючої таблиці.\nПоле у результуючій таблиці: order_id\n\n\n\n\n\nРішення\n%%sql\n-- варіант 1\nSELECT order_id\nFROM   user_actions\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order')\nORDER BY order_id limit 10\n\n-- варіант 2\n-- SELECT order_id\n-- FROM   user_actions\n-- WHERE  order_id not in (SELECT order_id\n--                         FROM   user_actions\n--                         WHERE  action = 'cancel_order')\n-- ORDER BY order_id limit 10\n\n\n\n\n\n\n\n\n\norder_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n5\n6\n\n\n6\n8\n\n\n7\n9\n\n\n8\n10\n\n\n9\n11"
  },
  {
    "objectID": "sql_subquery.html#підзапити-в-блоці-select",
    "href": "sql_subquery.html#підзапити-в-блоці-select",
    "title": "6  Підзапити",
    "section": "6.5 Підзапити в блоці SELECT",
    "text": "6.5 Підзапити в блоці SELECT\nЯк було зазначено в першому кроці, вкладений запит може бути розміщений і після оператора SELECT. Однак результатом підзапиту в такому випадку може бути тільки одне значення — наприклад, результат застосування агрегатної функції до якоїсь колонки:\nSELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1\nFROM table\nВ такому випадку з таблиці table буде обрано колонка column_1, і навпаки кожного значення у цій колонці буде виведено результат виконання вкладеного запиту, тобто максимальне значення у цій колонці. При цьому давати аліасу результату підзапиту не обов’язково.\nТакож результати підзапитів у блоці SELECT можна використовувати у обчисленнях:\nSELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2\nFROM table\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.8  Використовуючи дані з таблиці user_actions, розрахуйте скільки замовлень зробив кожен користувач і відобразіть це в стовпці orders_count. В окремому стовпці orders_avg навпроти кожного користувача вкажіть середню кількість замовлень всіх користувачів, округливши до двох знаків після коми. Також для кожного користувача порахуйте відхилення замовлень від середнього значення. Відхилення рахуйте так: число замовлень «мінус» заокруглене середнє значення. Назвіть колонку з відхиленням orders_diff. Результат відсортуйте за зростанням id користувача. Додайте в запит оператор LIMIT та виведіть лише перші 10 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, orders_count, orders_avg, orders_diff\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цій задачі можна використовувати підзапит, написаний у перших завданнях цього уроку. Щоб не довелося двічі писати той самий підзапит, можна використовувати оператор WITH.\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT user_id,\n                   count(order_id) as orders_count\n            FROM   user_actions\n            WHERE  action = 'create_order'\n            GROUP BY user_id)\nSELECT user_id,\n       orders_count,\n       round((SELECT avg(orders_count) FROM   t1), 2) as orders_avg,\n       orders_count - round((SELECT avg(orders_count) FROM   t1), 2) as orders_diff\nFROM   t1\nORDER BY user_id limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\norders_count\norders_avg\norders_diff\n\n\n\n\n0\n1\n4\n2.78\n1.22\n\n\n1\n2\n2\n2.78\n-0.78\n\n\n2\n3\n4\n2.78\n1.22\n\n\n3\n4\n2\n2.78\n-0.78\n\n\n4\n5\n1\n2.78\n-1.78\n\n\n...\n...\n...\n...\n...\n\n\n995\n996\n4\n2.78\n1.22\n\n\n996\n997\n4\n2.78\n1.22\n\n\n997\n998\n2\n2.78\n-0.78\n\n\n998\n999\n3\n2.78\n0.22\n\n\n999\n1000\n5\n2.78\n2.22\n\n\n\n\n1000 rows × 4 columns\n\n\n\nПеред тим, як піти далі, пропонуємо вам вирішити ще кілька завдань на підзапити.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.9  Виведіть id та вміст 100 останніх доставлених замовлень із таблиці orders. Вмістом замовлень вважаються списки з id товарів, що входять у замовлення. Результат відсортуйте за зростанням id замовлення.\nПоля у результуючій таблиці: order_id, product_ids\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що вміст замовлень знаходиться у таблиці orders, а інформація про дії із замовленнями – у таблиці courier_actions.\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       product_ids\nFROM   orders\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order'\n                    ORDER BY time desc limit 100)\nORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\nproduct_ids\n\n\n\n\n0\n59466\n[71, 50, 45]\n\n\n1\n59481\n[26, 30, 84, 1]\n\n\n2\n59482\n[32, 42, 79, 56]\n\n\n3\n59487\n[9, 62, 77]\n\n\n4\n59489\n[67, 42]\n\n\n...\n...\n...\n\n\n95\n59591\n[74, 26, 69, 3]\n\n\n96\n59592\n[34, 58, 31]\n\n\n97\n59593\n[52, 46, 40]\n\n\n98\n59594\n[2, 62]\n\n\n99\n59595\n[18, 30, 67]\n\n\n\n\n100 rows × 2 columns\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.10  З таблиці couriers виведіть всю інформацію про кур’єрів, які у вересні 2022 року доставили 30 і більше замовлень. Результат відсортуйте за зростанням id кур’єра.\nПоля в результуючій таблиці: courier_id, birth_date, sex\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що інформація про кур’єрів знаходиться в таблиці couriers, а інформація про дії із замовленнями - у таблиці courier_actions.\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       birth_date,\n       sex\nFROM   couriers\nWHERE  courier_id in (SELECT courier_id\n                      FROM   courier_actions\n                      WHERE  date_part('month', time) = 9\n                         and date_part('year', time) = 2022\n                         and action = 'deliver_order'\n                      GROUP BY courier_id having count(distinct order_id) &gt;= 30)\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_date\nsex\n\n\n\n\n0\n23\n1990-03-26\nmale\n\n\n1\n869\n2001-08-25\nfemale\n\n\n2\n1466\n1994-04-07\nmale\n\n\n3\n1664\n1987-12-16\nmale\n\n\n\n\n\n\n\nУ цій задачі об’єднаємо знання про конструкцію CASE та підзапити.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.11  Призначте знижку 15% на товари, ціна яких перевищує середню ціну на всі товари на 50 і більше одиниць, а також знижку 10% на товари, ціна яких нижча за середню на 50 і більше одиниць. Ціну інших товарів усередині діапазону (середнє – 50; середнє + 50) залиште без змін. При розрахунку середньої ціни округліть її до двох знаків після коми.\nВиведіть інформацію про всі товари із зазначенням старої та нової ціни. Колонку із новою ціною назвіть new_price. Результат відсортуйте спочатку за спаданням колишньої ціни в колонці price, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, new_price\n\n\n\n\n\nРішення\n%%sql\nSELECT \n  product_id,\n  name,\n  price,\n  CASE\n    WHEN price &gt; (SELECT ROUND(AVG(price), 2) + 50 FROM products) THEN ROUND(price * 0.85, 2)\n    WHEN price &lt; (SELECT ROUND(AVG(price), 2) - 50 FROM products) THEN ROUND(price * 0.9, 2)\n    ELSE price\n  END AS new_price\nFROM products\nORDER BY price DESC, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n680.00\n\n\n1\n37\nmutton\n559.0\n475.15\n\n\n2\n15\nolive oil\n450.0\n382.50\n\n\n3\n57\npork\n450.0\n382.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n340.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n22.50\n\n\n83\n5\ncoffee 3 in 1\n15.0\n13.50\n\n\n84\n73\ncake\n15.0\n13.50\n\n\n85\n10\nseeds\n12.0\n10.80\n\n\n86\n54\npaper bag\n1.0\n0.90\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_subquery.html#розгортання-списків-unnest",
    "href": "sql_subquery.html#розгортання-списків-unnest",
    "title": "6  Підзапити",
    "section": "6.6 Розгортання списків: UNNEST()",
    "text": "6.6 Розгортання списків: UNNEST()\nДавайте знову попрацюємо з масивами і освоїмо нову функцію unnest, яка стане нам у нагоді в подальших завданнях. Функція unnest призначена для розгортання масивів та перетворення їх на набір рядків:\nSELECT unnest(ARRAY['one','two','three'])\n\nРезультат:\none\ntwo\nthree\nУ прикладі вище функція unnest перетворила вихідний список із трьох елементів на набір із трьох рядків.\nЯкби у вихідній таблиці крім списку був стовпець з будь-яким значенням, то це значення автоматично проставилося б навпроти значень у кожному рядку, що утворився:\nSELECT 'row', unnest(ARRAY['one','two','three'])\n\nРезультат:\nrow    one\nrow    two\nrow    three\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.12  Виберіть всі колонки з таблиці orders, але як останню колонку вкажіть функцію unnest, застосовану до колонки product_ids. Нову колонку назвіть product_id. Виведіть лише перші 100 записів результуючої таблиці. Подивіться результат роботи unnest і постарайтеся розібратися, що сталося з вихідною таблицею.\nПоля в результуючій таблиці: creation_time, order_id, product_ids, product_id\n\n\n\n\n\nРішення\n%%sql\nSELECT creation_time,\n       order_id,\n       product_ids,\n       unnest(product_ids) as product_id\nFROM   orders\nLIMIT 100\n\n\n\n\n\n\n\n\n\ncreation_time\norder_id\nproduct_ids\nproduct_id\n\n\n\n\n0\n2022-08-24 01:52:00\n1\n[65, 28]\n65\n\n\n1\n2022-08-24 01:52:00\n1\n[65, 28]\n28\n\n\n2\n2022-08-24 06:37:00\n2\n[35, 30, 42, 34]\n35\n\n\n3\n2022-08-24 06:37:00\n2\n[35, 30, 42, 34]\n30\n\n\n4\n2022-08-24 06:37:00\n2\n[35, 30, 42, 34]\n42\n\n\n...\n...\n...\n...\n...\n\n\n95\n2022-08-24 18:57:00\n30\n[9, 32, 42, 8]\n32\n\n\n96\n2022-08-24 18:57:00\n30\n[9, 32, 42, 8]\n42\n\n\n97\n2022-08-24 18:57:00\n30\n[9, 32, 42, 8]\n8\n\n\n98\n2022-08-24 18:58:00\n31\n[77, 67, 25, 23]\n77\n\n\n99\n2022-08-24 18:58:00\n31\n[77, 67, 25, 23]\n67\n\n\n\n\n100 rows × 4 columns\n\n\n\nА тепер застосуємо unnest для вирішення практичного завдання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.13  Використовуючи функцію unnest, визначте 10 найпопулярніших товарів у таблиці orders. Найпопулярнішими вважатимемо ті, які зустрічалися в замовленнях найчастіше. Якщо товар зустрічається в одному замовленні кілька разів (тобто було куплено кілька одиниць товару), це теж враховується при підрахунку.\nВиведіть id товарів та скільки разів вони зустрічалися в замовленнях. Нову колонку з кількістю покупок товару назвіть times_purchased.\nПоля у результуючій таблиці: product_id, times_purchased\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цьому завданні необхідно спочатку розгорнути списки з товарами в замовленнях, а потім для кожного товару порахувати, скільки разів він зустрівся в даних. Для визначення найпопулярніших товарів використовуйте оператор LIMIT.\n\n\n\n\nРішення\n%%sql\nSELECT unnest(product_ids) as product_id,\n       count(*) as times_purchased\nFROM   orders\nGROUP BY product_id\nORDER BY times_purchased desc\nLIMIT 10\n\n\nІ насамкінець ще пара завдань зі зірочкою, щоб точно переконатися, що ми розібралися з підзапитами.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.14  З таблиці orders виведіть id та вміст замовлень, які включають хоча б один із п’яти найдорожчих товарів, доступних у нашому сервісі. Результат відсортуйте за зростанням id замовлення.\nПоля у результуючій таблиці: order_id, product_ids\n\n\n\n\n\nРішення\n%%sql\nwith    top_products as (SELECT product_id\n                      FROM   products\n                      ORDER BY price desc limit 5),\n        unnest as (SELECT order_id,\n                   product_ids,\n                   unnest(product_ids) as product_id\n                   FROM   orders)\nSELECT DISTINCT order_id,\n                product_ids\nFROM   unnest\nWHERE  product_id in (SELECT *\n                      FROM   top_products)\nORDER BY order_id\n\n-- або з `exists`\n-- SELECT order_id,\n--        product_ids\n-- FROM   orders\n-- WHERE  exists (\n--  SELECT 1\n--  FROM   unnest(product_ids) as product_id\n--  WHERE  product_id in (\n--      SELECT product_id\n--      FROM   products\n--      ORDER BY price desc\n--      LIMIT 5\n--      )\n-- )\n-- ORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\nproduct_ids\n\n\n\n\n0\n7\n[35, 74, 15, 34, 80]\n\n\n1\n9\n[40, 27, 24, 39, 62, 15]\n\n\n2\n11\n[84, 14, 57]\n\n\n3\n14\n[65, 1, 26, 43, 6]\n\n\n4\n26\n[19, 37, 72, 9]\n\n\n...\n...\n...\n\n\n8176\n59573\n[2, 55, 37]\n\n\n8177\n59576\n[33, 5, 28, 37]\n\n\n8178\n59578\n[82, 25, 50, 37]\n\n\n8179\n59580\n[75, 40, 50, 57, 67]\n\n\n8180\n59586\n[18, 70, 15, 24]\n\n\n\n\n8181 rows × 2 columns\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.15  Порахуйте вік кожного користувача у таблиці users. Вік виміряйте числом повних років, як ми робили на минулих уроках. Вік рахуйте щодо останньої дати в таблиці user_actions. У результаті включіть колонки з id користувача та віком. Для тих користувачів, у яких у таблиці users не вказано дату народження, вкажіть середнє значення віку решти користувачів, округлене до цілого числа. Колонку з віком назвіть age. Результат відсортуйте за зростанням id користувача.\nПоля у результуючій таблиці: user_id, age\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цьому завдання вам доведеться написати кілька підзапитів і, можливо, використовувати табличні вирази. Придадуться функції DATE_PART, AGE та COALESCE. Основна складність полягає у заповненні перепусток середнім значенням — подумайте, як це можна зробити, та побудуйте запит навколо свого підходу.\n\n\n\n\nРішення\n%%sql\n\nwith users_age as (\n    SELECT  user_id,\n            date_part('year', age((SELECT max(time) FROM   user_actions), birth_date)) as age\n    FROM   users)\n\nSELECT user_id,\n       coalesce(age, (SELECT round(avg(age))\n               FROM   users_age)) as age\nFROM   users_age\nORDER BY user_id\n\n-- або без `coalesce`\n-- with max_time as (\n--     SELECT max(time) as max\n--     FROM user_actions \n--     ),\n--     user_age as (\n--     SELECT  user_id,\n--             DATE_PART('year', age((SELECT max FROM max_time), birth_date)) as age\n--     FROM users\n--     ),\n--     user_avg_age as (\n--     SELECT AVG(age)::integer as avg_age\n--     FROM user_age\n--     )\n--     \n-- SELECT  user_id,\n--         case when age IS NULL THEN (SELECT avg_age FROM user_avg_age)\n--     ELSE age\n--     end\n-- FROM user_age\n-- ORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\nage\n\n\n\n\n0\n1\n30.0\n\n\n1\n2\n29.0\n\n\n2\n3\n28.0\n\n\n3\n4\n30.0\n\n\n4\n5\n34.0\n\n\n...\n...\n...\n\n\n20326\n21398\n29.0\n\n\n20327\n21399\n35.0\n\n\n20328\n21400\n35.0\n\n\n20329\n21401\n29.0\n\n\n20330\n21402\n31.0\n\n\n\n\n20331 rows × 2 columns"
  },
  {
    "objectID": "sql_join.html#основні-типи-обєднань-join",
    "href": "sql_join.html#основні-типи-обєднань-join",
    "title": "7  Об’єднання таблиць",
    "section": "7.1 Основні типи об’єднань JOIN",
    "text": "7.1 Основні типи об’єднань JOIN\nОсь ми й підібралися до однієї з найважливіших тем у SQL – об’єднання таблиць.\nSQL-запити дозволяють вибирати та обробляти дані не тільки з однієї таблиці – у цьому ми вже переконалися, коли працювали з підзапитами. Але таблиці можна об’єднувати в один результуючий набір записів, пов’язуючи їх за певними умовами. Це дозволяє робити операція з’єднання JOIN.\nМи розглянемо такі типи з’єднань таблиць:\n\nINNER JOIN\nLEFT/RIGHT JOIN\nFULL JOIN\nCROSS JOIN\n\nОператори об’єднання включаються до розділу FROM запиту. Загалом, незалежно від того, який тип об’єднання використовується, запит на об’єднання таблиць виглядає наступним чином:\nSELECT ...\nFROM table_1 \n     JOIN table_2\n     ON [condition]\nЯк правило (але далеко не завжди), в якості умови [condition], за якою відбувається об’єднання, виступає рівність значень у певних стовпцях. Такі стовпці зазвичай використовуються як ключі із зазначенням id (товару, користувача тощо), тобто значень, за якими можна однозначно ідентифікувати певну сутність:\nSELECT table_1.column_1, table_2.column_2\nFROM table_1 \n     JOIN table_2\n     ON table_1.id = table_2.id\nПри цьому рекомендується до кожної колонка через точку вказувати ім’я таблиці, яка містить цю колонку. Більше того, це стає вже не рекомендацією, а необхідністю, коли імена стовпців у таблицях збігаються - без явного вказівки джерел, база даних не зможе сама визначити, які стовпці та з яких таблиць ви маєте на увазі, і в результаті поверне помилку.\nЯкщо імена таблиць надто довгі, таблицям можна присвоїти аліаси. За цими ж аліасами можна відразу зручно звертатися до колонок:\nSELECT a.column_1, b.column_2\nFROM table_1 a \n     JOIN table_2 b\n     ON a.id = b.id\nЯкщо ім’я поля, за котрим відбувається об’єднання, збігається в обох таблицях (як у прикладах вище), можна використовувати скорочений запис з оператором USING:\nSELECT a.column_1, b.column_2\nFROM table_1 a \n     JOIN table_2 b\n     USING (id)\nПри об’єднанні таблиць можна використовувати підзапити. Їх можна поєднувати з іншими таблицями або одину з одною:\nSELECT ...\nFROM table_1\n     JOIN (\n          SELECT ...\n          FROM table_2\n     ) AS subquery\n    ON table_1.id = subquery.id\n...\n\n\nSELECT ...\nFROM (\n     SELECT ...\n     FROM table_1\n) AS subquery_1\n     JOIN (\n          SELECT ...\n          FROM table_2\n     ) AS subquery_2\n    ON subquery_1.id = subquery_2.id\n..."
  },
  {
    "objectID": "sql_join.html#як-працює-обєднання-таблиць",
    "href": "sql_join.html#як-працює-обєднання-таблиць",
    "title": "7  Об’єднання таблиць",
    "section": "7.2 Як працює об’єднання таблиць",
    "text": "7.2 Як працює об’єднання таблиць\nДобре, із записом у загальному вигляді начебто зрозуміло. Але що насправді відбувається при об’єднанні таблиць? Давайте розбиратися.\nПроцес об’єднання можна подати у вигляді наступної послідовності операцій:\n\nСпочатку кожен рядок першої таблиці зіставляється з кожним рядком другої таблиці, тобто відбувається декартів добуток вдох множин, результатом якого є нове множина, що складається з різних пар вхідних рядків. Наприклад, якщо у одній таблиці було 50 записів, а інший 10, то результаті декартового добутку вийде 500 записів. На іграшковому прикладі це можна уявити так:\n\n\n\n\nРисунок 7.1: Декартів добуток\n\n\n\nПотім для кожного об’єднаного рядка, що складається з двох вхідних таблиць, перевіряється умова з’єднання, вказана після оператора ON.\nПісля цього відповідно до обраного типу об’єднання формується результуюча таблиця.\n\nПри з’єднанні yне двох, а кількох таблиць, операція об’єднання виконується послідовно кілька разів, тобто описаний вище алгоритм запускається стільки разів, скільки зазначено з’єднань. При цьому в цій послідовності при кожному об’єднанні можна використовувати будь-який тип з’єднання (INNER, LEFT тощо).\nДля двох об’єднань запит може виглядати приблизно так:\nSELECT a.column_1, b.column_2\nFROM table_1 a \n     LEFT JOIN table_2 b\n     ON a.user_id = b.user_id\n     JOIN table_3 c\n     ON b.order_id = c.order_id\n...\nПро те, як саме вибір типу JOIN впливає на результат, ми говоритимемо далі.\nЯкщо щось на цьому кроці залишилося незрозумілим, не переживайте. Далі все прояснимо на практичних прикладах!"
  },
  {
    "objectID": "sql_join.html#inner-join",
    "href": "sql_join.html#inner-join",
    "title": "7  Об’єднання таблиць",
    "section": "7.3 INNER JOIN",
    "text": "7.3 INNER JOIN\nПерший тип об’єднання, який ми розглянемо, має назву INNER JOIN. Це оператор внутрішнього об’єднання, якому абсолютно неважливий порядок зазначення таблиць, тобто у таких випадках результат об’єднання буде однаковим:\nSELECT ...\nFROM table_1 INNER JOIN table_2\n     ON [condition]\n...\n\n\nSELECT ...\nFROM table_2 INNER JOIN table_1 \n     ON [condition]\n...\nПри цьому в запиті замість INNER JOIN можна писати просто JOIN - це те саме.\nРезультат об’єднання INNER JOIN формується так:\n\nСпочатку кожен рядок першої таблиці зіставляється з кожним рядком другої таблиці (відбувається декартів добуток).\nПотім для кожного об’єднаного рядка перевіряється умова з’єднання, вказана після оператора ON.\nПісля цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.\n\nТаким чином, в результаті об’єднання INNER JOIN із двох таблиць відкидаються усі рядки, які не пройшли перевірку на відповідність зазначеній умові. От і все!\nРозглянемо наступний приклад:\nSELECT A.id as id,\n       A.city as city,\n       B.country as country\nFROM table_A as A\n     JOIN table_B as B\n     ON A.id = B.id\nВ результаті такого запиту таблиці table_A та table_B будуть об’єднані в таблицю table_С:\n\n\nТаблиця 7.1: Приклад роботи INNER JOIN\n\n\n\n\n(a) Таблиця A\n\n\nid\ncity\n\n\n\n\n01\nLondon\n\n\n02\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\nid\ncountry\n\n\n\n\n02\nUkraine\n\n\n03\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\nid\ncity\ncountry\n\n\n\n\n02\nKyiv\nUkraine\n\n\n\n\n\n\nОскільки таблиці збігаються лише за одним значенням у стовпці id, то в результат буде включено лише одне запис.\nСхематично результат роботи об’єднань прийнято зображувати за допомогою діаграм Венна. Для INNER JOIN наведено на рисунку 7.2.\n\n\n\n\n\nРисунок 7.2: Діаграма Венна: INNER JOIN\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про INNER JOIN можна почитати тут.\n\n\nА тепер давайте повернемося до нашої бази даних та вирішимо завдання.\nДля початку спробуйте виконати наступні два запити та порахувати кількість унікальних користувачів у таблицях users та user_actions:\n\n%%sql\nSELECT COUNT(DISTINCT user_id) AS users_count\nFROM users\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n20331\n\n\n\n\n\n\n\n\n%%sql\nSELECT COUNT(DISTINCT user_id) as users_count\nFROM user_actions\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n21401\n\n\n\n\n\n\n\nВи помітите, що у таблиці user_actions унікальних користувачів більше. Це означає, що про частину користувачів ми щось не знаємо — у нас просто немає інформації в таблиці users. Тому в результаті об’єднання цих двох таблиць за допомогою INNER JOIN цю частину користувачів буде виключено з результату.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.1  Об’єднайте таблиці user_actions та users за ключом user_id. У результаті включіть дві колонки з user_id з обох таблиць. Ці дві колонки назвіть відповідно user_id_left та user_id_right. Також у результат включіть колонки order_id, time, action, sex, birth_date. Відсортуйте таблицю за зростанням id користувача (у будь-якій з двох колонок з id).\nПоля в результуючій таблиці: user_id_left, user_id_right, order_id, time, action, sex, birth_date\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що в результаті об’єднання колонки з ключами (у нашому випадку це user_id) не перетворюються на одну загальну колонку, а разом додаються в результуючу таблицю. Тобто скільки було сумарно колонок у двох таблицях, стільки виявиться і в результуючій таблиці після об’єднання. А вже далі в операторі SELECT можна вибирати потрібні та проводити над ними операції.\nЩоб звернутися до колонок з однаковим ім’ям (user_id), що прийшли з різних таблиць, призначте таблицям аліаси та зверніться до колонок через них. Приклад, як це можна зробити:\nSELECT A.id as id_a, \n       B.id as id_b, \n       ...\nFROM table_A as A\n     JOIN table_B as B\n     ON A.id = B.id\n...\n\n\n\n\nРішення\n%%sql\nSELECT a.user_id as user_id_left,\n       b.user_id as user_id_right,\n       order_id,\n       time,\n       action,\n       sex,\n       birth_date\nFROM   user_actions a join users b using (user_id)\nORDER BY user_id_left\n\n\n\n\n\n\n\n\n\nuser_id_left\nuser_id_right\norder_id\ntime\naction\nsex\nbirth_date\n\n\n\n\n0\n1\n1\n1\n2022-08-24 01:52:00\ncreate_order\nfemale\n1991-10-23\n\n\n1\n1\n1\n4683\n2022-08-27 20:56:00\ncreate_order\nfemale\n1991-10-23\n\n\n2\n1\n1\n22901\n2022-09-02 00:58:00\ncreate_order\nfemale\n1991-10-23\n\n\n3\n1\n1\n23149\n2022-09-02 02:36:00\ncreate_order\nfemale\n1991-10-23\n\n\n4\n2\n2\n2\n2022-08-24 06:37:00\ncreate_order\nfemale\n1993-06-18\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n59341\n21399\n21399\n59583\n2022-09-08 23:56:00\ncreate_order\nfemale\n1987-04-27\n\n\n59342\n21399\n21399\n59587\n2022-09-08 23:58:00\ncreate_order\nfemale\n1987-04-27\n\n\n59343\n21400\n21400\n59586\n2022-09-08 23:57:00\ncreate_order\nmale\n1986-12-31\n\n\n59344\n21401\n21401\n59589\n2022-09-08 23:58:00\ncreate_order\nfemale\n1993-03-20\n\n\n59345\n21402\n21402\n59591\n2022-09-08 23:58:00\ncreate_order\nfemale\n1991-05-24\n\n\n\n\n59346 rows × 7 columns\n\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.2  А тепер спробуйте трохи переписати запит із минулого завдання та порахувати кількість унікальних id в об’єднаній таблиці. Тобто знову поєднайте таблиці, але цього разу просто порахуйте унікальні user_id в одній з колонок з id. Виведіть цю кількість як результат. Назвіть колонку з порахованим значенням users_count.\nПоле у результуючій таблиці: users_count\nПісля того, як вирішите завдання, порівняйте отримане значення з кількістю унікальних користувачів у таблицях users та user_actions, яку ми порахували раніше. З яким значенням воно збігається?\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct a.user_id) as users_count\nFROM   user_actions a \n    JOIN users b using (user_id)\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n20331"
  },
  {
    "objectID": "sql_join.html#left-та-right-join",
    "href": "sql_join.html#left-та-right-join",
    "title": "7  Об’єднання таблиць",
    "section": "7.4 LEFT та RIGHT JOIN",
    "text": "7.4 LEFT та RIGHT JOIN\nНаступний тип об’єднання, який ми розглянемо, це LEFT OUTER JOIN (або просто LEFT JOIN).\nLEFT JOIN— це оператор зовнішнього об’єднання, котрій важливий порядок таблиць у запиті, тобто на відміну від INNER JOIN, він не є симетричним.\nТому наступні два записи вже не є еквівалентними:\nSELECT ...\nFROM table_1 LEFT JOIN table_2\n     ON [condition]\n...\n\n\nSELECT ...\nFROM table_2 LEFT JOIN table_1 \n     ON [condition]\n...\nРезультат об’єднання LEFT JOIN формується так:\n\nСпочатку кожен рядок лівої таблиці зіставляється з кожним рядком правої таблиці (відбувається декартів добуток).\nПотім для кожного об’єднаного рядка перевіряється умова з’єднання, вказана після оператора ON.\nПісля цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.\nДалі в результат додаються ті записи з лівої таблиці (увага: тільки з лівої), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля правої таблиці заповнюються значеннями NULL.\n\nЯкщо уважно подивитися на описаний алгоритм, можна зрозуміти, що він легко зводиться до наступної послідовності дій:\n\nСпочатку відповідно до зазначеної умови виконується INNER JOIN першої та другої таблиць.\nПотім до результату додаються ті записи з лівої таблиці (увага: тільки з лівої), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля правої таблиці заповнюються значеннями NULL.\n\nОсь і вся магія!\nОб’єднання RIGHT JOIN працює аналогічним чином, тільки на другому етапі результат INNER JOIN додаються записи не з лівої, а з правої таблиці.\nДавайте знову розглянемо кілька простих прикладів.\nТак буде виглядати запит та його результат із LEFT JOIN:\nSELECT A.id as id,\n       A.city as city,\n       B.country as country\nFROM table_A as A\n     LEFT JOIN table_B as B\n     ON A.id = B.id\n\n\nТаблиця 7.2: Приклад роботи LEFT JOIN\n\n\n\n\n(a) Таблиця A\n\n\nid\ncity\n\n\n\n\n01\nLondon\n\n\n02\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\nid\ncountry\n\n\n\n\n02\nUkraine\n\n\n03\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\nid\ncity\ncountry\n\n\n\n\n01\nLondon\nNULL\n\n\n02\nKyiv\nUkraine\n\n\n\n\n\n\nУ цьому випадку до результату потрапить запис з id 2, оскільки вона є в обох таблицях, а також запис з id 1 з лівої таблиці.\nДіаграма Венна для LEFT JOIN наведено на рис. 7.3.\n\n\n\n\n\nРисунок 7.3: Діаграма Венна: LEFT JOIN\n\n\n\n\nА ось таким вийде результат запиту з RIGHT JOIN:\nSELECT B.id as id,\n       A.city as city,\n       B.country as country\nFROM table_A as A\n     RIGHT JOIN table_B as B\n     ON A.id = B.id\n\n\nТаблиця 7.3: Приклад роботи RIGHT JOIN\n\n\n\n\n(a) Таблиця A\n\n\nid\ncity\n\n\n\n\n01\nLondon\n\n\n02\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\nid\ncountry\n\n\n\n\n02\nUkraine\n\n\n03\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\nid\ncity\ncountry\n\n\n\n\n02\nKyiv\nUkraine\n\n\n03\nNULL\nPoland\n\n\n\n\n\n\nВсе як і у випадку з LEFT JOIN, тільки в результат вже потрапить запис з id 3 з правої таблиці.\nДіаграма Венна для RIGHT JOIN зображена на рис. 7.4\n\n\n\n\n\nРисунок 7.4: Діаграма Венна: LEFT JOIN\n\n\n\n\nА тепер розглянемо на прикладі наших даних.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.3  За допомогою LEFT JOIN об’єднайте таблиці user_actions та users за ключом user_id. Зверніть увагу на порядок таблиць – ліворуч users_actions, праворуч users. У результаті включіть дві колонки з user_id з обох таблиць. Ці дві колонки назвіть відповідно user_id_left та user_id_right. Також у результат увімкніть колонки order_id, time, action, sex, birth_date. Відсортуйте таблицю, що вийшла, за зростанням id користувача (у колонці з лівої таблиці).\nПоля в результуючій таблиці: user_id_left, user_id_right, order_id, time, action, sex, birth_date\nПісля того як розв’яжете завдання, зверніть увагу на колонки з user_id. Чи немає в якомусь із них пропущених значень?\n\n\n\n\n\nРішення\n%%sql\nSELECT a.user_id as user_id_left,\n       b.user_id as user_id_right,\n       order_id,\n       time,\n       action,\n       sex,\n       birth_date\nFROM   user_actions a\n    LEFT JOIN users b using (user_id)\nORDER BY user_id_left\n\n\n\n\n\n\n\n\n\nuser_id_left\nuser_id_right\norder_id\ntime\naction\nsex\nbirth_date\n\n\n\n\n0\n1\n1.0\n1\n2022-08-24 01:52:00\ncreate_order\nfemale\n1991-10-23\n\n\n1\n1\n1.0\n4683\n2022-08-27 20:56:00\ncreate_order\nfemale\n1991-10-23\n\n\n2\n1\n1.0\n22901\n2022-09-02 00:58:00\ncreate_order\nfemale\n1991-10-23\n\n\n3\n1\n1.0\n23149\n2022-09-02 02:36:00\ncreate_order\nfemale\n1991-10-23\n\n\n4\n2\n2.0\n2\n2022-08-24 06:37:00\ncreate_order\nfemale\n1993-06-18\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n62569\n21399\n21399.0\n59583\n2022-09-08 23:56:00\ncreate_order\nfemale\n1987-04-27\n\n\n62570\n21399\n21399.0\n59587\n2022-09-08 23:58:00\ncreate_order\nfemale\n1987-04-27\n\n\n62571\n21400\n21400.0\n59586\n2022-09-08 23:57:00\ncreate_order\nmale\n1986-12-31\n\n\n62572\n21401\n21401.0\n59589\n2022-09-08 23:58:00\ncreate_order\nfemale\n1993-03-20\n\n\n62573\n21402\n21402.0\n59591\n2022-09-08 23:58:00\ncreate_order\nfemale\n1991-05-24\n\n\n\n\n62574 rows × 7 columns\n\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.4  Тепер знову спробуйте трохи переписати запит з минулого завдання та порахуйте кількість унікальних id у колонці user_id, що надійшла з лівої таблиці user_actions. Виведіть цю кількість як результат. Назвіть колонку з порахованим значенням users_count.\nПоле у результуючій таблиці: users_count\nПісля того, як вирішите завдання, порівняйте отримане значення з кількістю унікальних користувачів у таблицях users та user_actions. З яким значенням воно збіглося цього разу?\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct a.user_id) as users_count\nFROM   user_actions a\n    LEFT JOIN users b using (user_id)\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n21401\n\n\n\n\n\n\n\n\nВи могли помітити, що при об’єднанні таблиць user_actions і users за допомогою LEFT JOIN у стовпцях, що прийшли з правої таблиці users, утворилися значення NULL. Якщо не помітили, спробуйте відсортувати об’єднану таблицю по полях users.user_id і users.birth_date.\nЦе саме те, про що ми говорили — при формуванні об’єднаних рядків для тих id з лівої таблиці, яких не було в правій таблиці, поля з правої таблиці були заповнені порожніми значеннями.\nА тепер давайте перевернемо один трюк.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.5  Візьміть запит із завдання 7.3, де ви об’єднували таблиці user_actions і users за допомогою LEFT JOIN, додайте до запиту оператор WHERE і виключіть значення NULL в колонці user_id з правої таблиці. Включіть у результат ті самі колонки і відсортуйте таблицю, що вийшла, за зростанням id користувача в колонці з лівої таблиці.\nПоля в результуючій таблиці: user_id_left, user_id_right, order_id, time, action, sex, birth_date\nПісля того як розв’яжете завдання, спробуйте порівняти це рішення із завданням 7.1. Подумайте, який JOIN ми отримали після всіх маніпуляцій з результатом. Заодно можете порахувати кількість унікальних user_id у запиті з цього завдання, щоб розставити всі крапки над “i”.\n\n\n\n\n\nРішення\n%%sql\nSELECT a.user_id as user_id_left,\n       b.user_id as user_id_right,\n       order_id,\n       time,\n       action,\n       sex,\n       birth_date\nFROM   user_actions a\n    LEFT JOIN users b using (user_id)\nWHERE  b.user_id IS NOT NULL\nORDER BY user_id_left\n\n\n\n\n\n\n\n\n\nuser_id_left\nuser_id_right\norder_id\ntime\naction\nsex\nbirth_date\n\n\n\n\n0\n1\n1\n1\n2022-08-24 01:52:00\ncreate_order\nfemale\n1991-10-23\n\n\n1\n1\n1\n4683\n2022-08-27 20:56:00\ncreate_order\nfemale\n1991-10-23\n\n\n2\n1\n1\n22901\n2022-09-02 00:58:00\ncreate_order\nfemale\n1991-10-23\n\n\n3\n1\n1\n23149\n2022-09-02 02:36:00\ncreate_order\nfemale\n1991-10-23\n\n\n4\n2\n2\n2\n2022-08-24 06:37:00\ncreate_order\nfemale\n1993-06-18\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n59341\n21399\n21399\n59583\n2022-09-08 23:56:00\ncreate_order\nfemale\n1987-04-27\n\n\n59342\n21399\n21399\n59587\n2022-09-08 23:58:00\ncreate_order\nfemale\n1987-04-27\n\n\n59343\n21400\n21400\n59586\n2022-09-08 23:57:00\ncreate_order\nmale\n1986-12-31\n\n\n59344\n21401\n21401\n59589\n2022-09-08 23:58:00\ncreate_order\nfemale\n1993-03-20\n\n\n59345\n21402\n21402\n59591\n2022-09-08 23:58:00\ncreate_order\nfemale\n1991-05-24\n\n\n\n\n59346 rows × 7 columns"
  },
  {
    "objectID": "sql_join.html#full-join",
    "href": "sql_join.html#full-join",
    "title": "7  Об’єднання таблиць",
    "section": "7.5 FULL JOIN",
    "text": "7.5 FULL JOIN\nЩоб краще розібратися з джойнами, розглянемо ще один тип об’єднання таблиць — FULL OUTER JOIN або просто FULL JOIN. Це оператор повного зовнішнього об’єднання, для якого, як і INNER JOIN, неважливий порядок вказівки таблиць. Проте працює він зовсім інакше.\nЗапит із FULL OUTER JOIN виглядає приблизно так:\nSELECT ...\nFROM table_1 FULL JOIN table_2\n     ON [condition]\n...\n\n\nSELECT ...\nFROM table_2 FULL JOIN table_1 \n     ON [condition]\n...\nРезультат об’єднання FULL JOIN формується так:\n\nСпочатку кожен рядок лівої таблиці зіставляється з кожним рядком правої таблиці (відбувається декартів добуток).\nПотім для кожного об’єднаного рядка перевіряється умова об’єднання, вказана після оператора ON.\nПісля цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.\nДалі в результат додаються ті записи з лівої та правої таблиць (увага: з обох таблиць), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля з іншої таблиці (для лівої це поля з правої, для правої це поля з лівої) заповнюються значеннями NULL.\n\nЦей алгоритм можна звести до наступної послідовності дій:\n\nСпочатку відповідно до зазначеної умови виконується INNER JOIN лівої та правої таблиць.\nДалі в результат додаються ті записи з лівої та правої таблиць (увага: з обох таблиць), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля з іншої таблиці (для лівої це поля з правої, для правої це поля з лівої) заповнюються значеннями NULL.\n\nРозглянемо найпростіший приклад.\nТак буде виглядати запит та його результат з FULL JOIN:\nSELECT A.id as id,\n       A.city as city,\n       B.country as country\nFROM table_A as A\n     FULL JOIN table_B as B\n     ON A.id = B.id\n\n\nТаблиця 7.4: Приклад роботи FULL JOIN\n\n\n\n\n(a) Таблиця A\n\n\nid\ncity\n\n\n\n\n01\nLondon\n\n\n02\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\nid\ncountry\n\n\n\n\n02\nUkraine\n\n\n03\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\nid\ncity\ncountry\n\n\n\n\n01\nLondon\nNULL\n\n\n02\nKyiv\nUkraine\n\n\n03\nNULL\nPoland\n\n\n\n\n\n\nВ результат потрапив спільний запис з id 2, а також всі записи, до яких не було знайдено відповідності з інших таблиць. Усі невідповідності були заповнені порожніми значеннями.\nДіграма Венна для FULL JOIN наведено на рисунку 7.5.\n\n\n\n\n\nРисунок 7.5: Діаграма Венна: FULL JOIN\n\n\n\n\nА тепер розберемося з FULL JOIN на прикладі нашої бази даних.\nУ нас є дві таблиці з датами народження користувачів та кур’єрів – users та couriers. Можна припустити, що в кожній таблиці у колонці birth_date є якісь дати, яких немає в іншій таблиці. Тобто такі дати, в які народився хтось із кур’єрів, але не народився жоден користувач, і навпаки. Ну що ж, спробуємо перевірити цю гіпотезу.\nДля початку згрупуємо дві таблиці по колонці birth_date і порахуємо скільки користувачів/кур’єрів народилися в кожен з днів. Для цього можете виконати такий запит:\n\n%%sql\nSELECT birth_date, COUNT(user_id) AS users_count\nFROM users\nWHERE birth_date IS NOT NULL\nGROUP BY birth_date\n\n\n\n\n\n\n\n\nbirth_date\nusers_count\n\n\n\n\n0\n1991-05-24\n11\n\n\n1\n1994-07-21\n6\n\n\n2\n1992-01-09\n13\n\n\n3\n1997-05-05\n3\n\n\n4\n1990-08-16\n5\n\n\n...\n...\n...\n\n\n4471\n1999-12-01\n1\n\n\n4472\n1998-12-05\n1\n\n\n4473\n1987-09-24\n1\n\n\n4474\n1998-01-02\n1\n\n\n4475\n1988-07-27\n1\n\n\n\n\n4476 rows × 2 columns\n\n\n\n\n%%sql\nSELECT birth_date, COUNT(courier_id) AS couriers_count\nFROM couriers\nWHERE birth_date IS NOT NULL\nGROUP BY birth_date\n\n\n\n\n\n\n\n\nbirth_date\ncouriers_count\n\n\n\n\n0\n1981-06-11\n1\n\n\n1\n1991-06-27\n2\n\n\n2\n1994-05-04\n2\n\n\n3\n1999-06-02\n2\n\n\n4\n1998-12-22\n2\n\n\n...\n...\n...\n\n\n2169\n1999-09-19\n1\n\n\n2170\n1990-06-23\n1\n\n\n2171\n1991-02-21\n1\n\n\n2172\n1990-06-04\n1\n\n\n2173\n1997-04-15\n1\n\n\n\n\n2174 rows × 2 columns\n\n\n\nУ результаті ви отримаєте дві таблиці з унікальними датами і кількістю людей, що народилися у кожен з днів. Давайте їх об’єднаємо.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.6  За допомогою FULL JOIN об’єднайте по ключу birth_date таблиці, отримані в результаті вищезазначених запитів (тобто об’єднайте один з одним два підзапити). Не потрібно змінювати їх, просто додайте потрібний JOIN.\nУ результат включіть дві колонки з birth_date з обох таблиць. Ці дві колонки назвіть відповідно users_birth_date та couriers_birth_date. Також включіть у результат колонки з кількістю користувачів та кур’єрів - users_count та couriers_count.\nВідсортуйте таблицю спочатку по колонці users_birth_date за зростанням, потім по колонці couriers_birth_date - теж за зростанням.\nПоля в результуючій таблиці: users_birth_date, users_count, couriers_birth_date, couriers_count\nПісля того як розв’яжете завдання, проаналізуйте результат. Зверніть увагу на пропущені значення у колонках з датами народження кур’єрів та користувачів. Чи підтвердилося наше припущення?\n\n\n\n\n\nРішення\n%%sql\nWITH a AS (\n    SELECT birth_date, COUNT(user_id) AS users_count\n    FROM users\n    WHERE birth_date IS NOT NULL\n    GROUP BY birth_date\n    ),\n    b AS (\n    SELECT birth_date, COUNT(courier_id) AS couriers_count\n    FROM couriers\n    WHERE birth_date IS NOT NULL\n    GROUP BY birth_date\n    )\n    \nSELECT \n    a.birth_date AS users_birth_date,\n    a.users_count,\n    b.birth_date AS couriers_birth_date,\n    b.couriers_count\nFROM a\nFULL JOIN b on a.birth_date = b.birth_date\nORDER BY users_birth_date, couriers_birth_date\n\n\n\n\n\n\n\n\n\nusers_birth_date\nusers_count\ncouriers_birth_date\ncouriers_count\n\n\n\n\n0\nNaT\nNaN\n1973-07-05\n1.0\n\n\n1\nNaT\nNaN\n1978-01-04\n1.0\n\n\n2\nNaT\nNaN\n1978-07-18\n1.0\n\n\n3\nNaT\nNaN\n1979-12-14\n1.0\n\n\n4\nNaT\nNaN\n1981-01-05\n1.0\n\n\n...\n...\n...\n...\n...\n\n\n4841\n2002-05-11\n1.0\nNaT\nNaN\n\n\n4842\n2002-06-15\n1.0\nNaT\nNaN\n\n\n4843\n2002-07-11\n1.0\nNaT\nNaN\n\n\n4844\n2002-11-05\n1.0\nNaT\nNaN\n\n\n4845\n2003-09-02\n1.0\nNaT\nNaN\n\n\n\n\n4846 rows × 4 columns"
  },
  {
    "objectID": "sql_join.html#операції-над-множинами",
    "href": "sql_join.html#операції-над-множинами",
    "title": "7  Об’єднання таблиць",
    "section": "7.6 Операції над множинами",
    "text": "7.6 Операції над множинами\nЧудово. Запит із FULL JOIN ми начебто склали, але як нам тепер визначити, що кількість записів в отриманій таблиці збігається із загальним числом унікальних дат у двох таблицях — users та couriers? Адже саме стільки рядків ми й очікували отримати, правда?\nПеревірити себе нам допоможуть операції з множинами. У мові SQL їх три:\n\nUNION\nEXCEPT\nINTERSECT\n\nВони дозволяють комбінувати результати кількох запитів один з одним та отримувати один загальний результат. Причому саме комбінувати, а не об’єднувати, як це роблять джойни.\nЦю різницю важливо розуміти: в операціях з множинами не відбувається суміщення стовпців з двох таблиць - база даних просто відбирає рядки з таблиць, що задовольняють типу операції, і додає їх до загального результату.\nОперації над множинами мають наступний синтаксис:\nSELECT column_1, column_2\nFROM table_1\nUNION\nSELECT column_1, column_2\nFROM table_2\n\n\nSELECT column_1, column_2\nFROM table_1\nEXCEPT\nSELECT column_1, column_2\nFROM table_2\n\n\nSELECT column_1, column_2\nFROM table_1\nINTERSECT\nSELECT column_1, column_2\nFROM table_2\n\nОперація EXCEPT повертає всі записи, які є у першому запиті, але відсутні у другому (різниця множин).\nОперація INTERSECT повертає всі записи, які є і в першому, і в другому запиті (перетин множин).\nОперація UNION поєднує записи із двох запитів в один загальний результат (об’єднання множин).\n\nПри цьому за замовчанням ці операції виключають із результату рядки-дублікати. Щоб дублікати не виключалися із результату, необхідно після імені операції вказати ключове слово ALL. Наприклад, так:\nSELECT column_1, column_2\nFROM table_1\nUNION ALL\nSELECT column_1, column_2\nFROM table_2\nДіаграми Венна для операцій над множинами виглядають зображено на рисунку 7.6.\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n(c)\n\n\n\n\nРисунок 7.6: Операції над множинами: діаграма Венна\n\n\nДля роботи цих операцій необхідно, щоб виконувались такі умови:\n\nУ кожному запиті SELECT має бути однакова кількість стовпців.\nТипи даних у стовпцях мають бути сумісні.\n\nПри цьому кількість стовпців в операторі SELECT може бути будь-якою — головне, щоб вона була однаковою.\nНаприклад, наступний запит поверне унікальні ID користувачів, які щось замовляли в нашому сервісі, але яких з якоїсь причини немає в таблиці users:\n\n%%sql\nSELECT user_id\nFROM user_actions\nEXCEPT\nSELECT user_id\nFROM users\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n54\n\n\n1\n86\n\n\n2\n103\n\n\n3\n116\n\n\n4\n120\n\n\n...\n...\n\n\n1065\n18352\n\n\n1066\n12713\n\n\n1067\n18246\n\n\n1068\n18015\n\n\n1069\n20398\n\n\n\n\n1070 rows × 1 columns\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про операції над множинами можна прочитати у документації DuckDB.\nПро теорію множин можна почитати у статті на Вікіпедії.\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.7  Поєднайте два наступні запити один з одним так, щоб на виході вийшов набір унікальних дат із таблиць users та couriers:\nSELECT birth_date\nFROM users\nWHERE birth_date IS NOT NULL\nSELECT birth_date\nFROM couriers\nWHERE birth_date IS NOT NULL\nПомістіть у підзапит набраний після об’єднання набір дат і порахуйте їх кількість. Назвіть колонку з числом дат dates_count.\nПоле у результуючій таблиці: dates_count\nПісля того, як вирішите задачу, порівняйте отримане число дат з кількістю рядків у таблиці, яку ми отримали в минулому завданні. Чи збіглися ці значення?\n\n\n\n\n\nРішення\n%%sql\nWITH sub_union as (\n    SELECT birth_date\n    FROM users\n    WHERE birth_date IS NOT NULL\n    UNION\n    SELECT birth_date\n    FROM couriers\n    WHERE birth_date IS NOT NULL\n    )\n    \nSELECT COUNT(DISTINCT birth_date) as dates_count\nFROM sub_union\n\n\n\n\n\n\n\n\n\ndates_count\n\n\n\n\n0\n4846"
  },
  {
    "objectID": "sql_join.html#cross-join",
    "href": "sql_join.html#cross-join",
    "title": "7  Об’єднання таблиць",
    "section": "7.7 CROSS JOIN",
    "text": "7.7 CROSS JOIN\nНасправді CROSS JOIN - це просто декартів добуток двох таблиць, тобто саме те, що відбувається на першому етапі решти джойнів. Важлива відмінність у синтаксисі CROSS JOIN полягає в тому, що для нього не потрібно вказувати умову для об’єднання:\nSELECT column_1, column_2, ...\nFROM table_1\n     CROSS JOIN table_2\nТой самий результат можна отримати за допомогою наступного запису:\nSELECT column_1, column_2, ...\nFROM table_1, table_2\nРозглянемо простий приклад:\nSELECT\n    A.city as city,\n    B.country as country\nFROM table_A as A\n     CROSS JOIN table_B as B\nЗа допомогою CROSS JOIN ми отримуємо всі можливі комбінації значень із першої та другої таблиці:\n\n\nТаблиця 7.5: Приклад роботи FULL JOIN\n\n\n\n\n(a) Таблиця A\n\n\ncity\n\n\n\n\nLondon\n\n\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\ncountry\n\n\n\n\nUK\n\n\nUkraine\n\n\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\ncity\ncountry\n\n\n\n\nLondon\nUK\n\n\nLondon\nUkraine\n\n\nLondon\nPoland\n\n\nKyiv\nUK\n\n\nKyiv\nUkraine\n\n\nKyiv\nPoland\n\n\n\n\n\n\nА теперь давайте решим простую задачу.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.8  З таблиці users відберіть id перших 100 користувачів (просто виберіть перші 100 записів, використовуючи простий LIMIT) і за допомогою CROSS JOIN поєднайте їх з усіма найменуваннями товарів з таблиці products. Виведіть дві колонки - ID користувача та найменування товару. Результат відсортуйте спочатку за зростанням id користувача, потім на ім’я товару — теж за зростанням.\nПоля у результуючій таблиці: user_id, name\nПісля того як вирішите задачу, подивіться скільки спочатку було рядків у кожній таблиці і порівняйте з тим, скільки їх вийшло після об’єднання.\n\n\n\n\n\nРішення\n%%sql\nwith user_100 as (\n    SELECT user_id\n    from users\n    LIMIT 100\n    )\n\nSELECT  user_100.user_id,\n        products.name\nFROM user_100\nCROSS JOIN products\nORDER BY user_id, name\n\n\n\n\n\n\n\n\n\nuser_id\nname\n\n\n\n\n0\n185\napple juice\n\n\n1\n185\napples\n\n\n2\n185\nbagels\n\n\n3\n185\nbananas\n\n\n4\n185\nbeef\n\n\n...\n...\n...\n\n\n8695\n21402\nwaffles\n\n\n8696\n21402\nwatermelon\n\n\n8697\n21402\nwhite chocolate\n\n\n8698\n21402\nyogurt\n\n\n8699\n21402\nсowberry juice\n\n\n\n\n8700 rows × 2 columns\n\n\n\n\nЗдається, ми розглянули достатньо прикладів об’єднання таблиць. Час переходити до практики!\nПроведемо невелику аналітику нашого сервісу і порахуємо, скільки в середньому товарів замовляє кожен користувач.\nЗавдання може звучати досить абстрактно мовою бізнесу, але не переживайте! Вирішуватимемо її поетапно, поступово перекладаючи її на мову SQL.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.9  Спочатку об’єднайте таблиці user_actions і orders — це ви вже вмієте робити. Як ключ використовуйте поле order_id. Виведіть id користувачів та замовлень, а також список товарів у замовленні. Відсортуйте таблицю за id користувача за зростанням, потім за id замовлення теж за зростанням.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, order_id, product_ids\nПояснення: перед тим, як об’єднувати таблиці, подумайте, який тип з’єднання можна використовувати. Спробуйте різні способи та порівняйте результати.\n\n\n\n\n\nРішення\n%%sql\nSELECT  user_id,\n        order_id,\n        product_ids\nFROM user_actions\nLEFT JOIN orders using (order_id)\nORDER BY user_id, order_id\nLIMIT 1000\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\nproduct_ids\n\n\n\n\n0\n1\n1\n[65, 28]\n\n\n1\n1\n4683\n[1, 15, 40]\n\n\n2\n1\n22901\n[65, 72, 83]\n\n\n3\n1\n23149\n[6, 84, 32]\n\n\n4\n2\n2\n[35, 30, 42, 34]\n\n\n...\n...\n...\n...\n\n\n995\n227\n12572\n[76, 47, 37, 31]\n\n\n996\n227\n12578\n[58]\n\n\n997\n227\n23268\n[74, 25, 67]\n\n\n998\n227\n25873\n[74, 72, 46]\n\n\n999\n227\n25885\n[40, 58, 83]\n\n\n\n\n1000 rows × 3 columns\n\n\n\n\nТепер трохи уточнимо наш запит, оскільки нас цікавлять не всі замовлення з таблиці user_actions, а лише ті, які не були скасовані користувачами, причому унікальні.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.10  Знову об’єднайте таблиці user_actions та orders, але тепер залиште лише унікальні нескасовані замовлення (ми робили схожий запит у завданні 6.7). Інші умови завдання ті самі: вивести ID користувачів та замовлень, а також список товарів у замовленні. Відсортуйте таблицю за id користувача за зростанням, потім за id замовлення теж за зростанням.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, order_id, product_ids\n\n\n\n\n\nРішення\n%%sql\nSELECT  user_id,\n        order_id,\n        product_ids\nFROM user_actions\nLEFT JOIN orders using (order_id)\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order')\nORDER BY user_id, order_id\nLIMIT 1000\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\nproduct_ids\n\n\n\n\n0\n1\n1\n[65, 28]\n\n\n1\n1\n4683\n[1, 15, 40]\n\n\n2\n1\n22901\n[65, 72, 83]\n\n\n3\n1\n23149\n[6, 84, 32]\n\n\n4\n2\n2\n[35, 30, 42, 34]\n\n\n...\n...\n...\n...\n\n\n995\n248\n13935\n[75, 28, 86]\n\n\n996\n248\n15518\n[67, 79, 63]\n\n\n997\n249\n287\n[26, 74, 53, 23]\n\n\n998\n249\n758\n[45, 57, 78]\n\n\n999\n249\n7347\n[30, 14, 6, 9]\n\n\n\n\n1000 rows × 3 columns\n\n\n\n\nЗдається, все готове для того, щоб для кожного користувача порахувати середню кількість товарів у замовленні.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.11  Використовуючи запит із попереднього завдання, порахуйте, скільки в середньому товарів замовляє кожен користувач. Виведіть id користувача та середню кількість товарів у замовленні. Середнє значення округліть до двох знаків після коми. Колонку обчисленими значеннями назвіть avg_order_size. Результат виконання запиту відсортуйте за зростанням ID користувача.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: user_id, avg_order_size\nПояснення: для вирішення вам знадобиться функція array_length. Ми розглядали її у завданні 4.9.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nЩоб вирішити завдання, достатньо взяти запит з минулого завдання, порахувати розмір нескасованих замовлень, а потім зробити групування за користувачами і для кожного з них порахувати середній розмір замовлення.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nwith user_order_prod as (\n    SELECT  user_id,\n            order_id,\n            product_ids\n    FROM user_actions\n    LEFT JOIN orders using (order_id)\n    WHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order')\n    )\n    \nSELECT  user_id,\n        ROUND(AVG(array_length(product_ids, 1)), 2) as avg_order_size\nFROM user_order_prod\nGROUP BY user_id\nORDER BY user_id\nLIMIT 1000\n\n-- або\n-- SELECT user_id,\n--        round(avg(array_length(product_ids, 1)), 2) as avg_order_size\n-- FROM   (SELECT user_id,\n--                order_id\n--         FROM   user_actions\n--         WHERE  order_id not in (SELECT order_id\n--                                 FROM   user_actions\n--                                 WHERE  action = 'cancel_order')) t1\n--     LEFT JOIN orders using(order_id)\n-- GROUP BY user_id\n-- ORDER BY user_id limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\navg_order_size\n\n\n\n\n0\n1\n2.75\n\n\n1\n2\n4.00\n\n\n2\n3\n4.00\n\n\n3\n4\n3.00\n\n\n4\n5\n1.00\n\n\n...\n...\n...\n\n\n995\n1001\n2.71\n\n\n996\n1002\n2.67\n\n\n997\n1003\n3.00\n\n\n998\n1004\n3.40\n\n\n999\n1005\n2.00\n\n\n\n\n1000 rows × 2 columns\n\n\n\n\nА що якби ми захотіли зробити докладнішу аналітику і, наприклад, порахувати середню вартість замовлення (середній чек) кожного клієнта? Для цього нам би знадобилася інформація про вартість кожного окремого замовлення. Давайте проведемо такі розрахунки.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.12  Для початку до таблиці із замовленнями (orders) застосуйте функцію unnest, як ми робили завданні 6.12. Колонку із id товарів назвіть product_id. Потім до розширеної таблиці, що утворилася, за ключом product_id додайте інформацію про ціни на товари (з таблиці products). Повинна вийти таблиця із замовленнями, товарами всередині кожного замовлення та цінами на ці товари. Виведіть колонки з id замовлення, id товару та ціною товару. Результат відсортуйте спочатку за зростанням id замовлення, потім за зростанням id товару.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: order_id, product_id, price\n\n\n\n\n\nРішення\n%%sql\nwith unnest_id as (SELECT order_id,\n                          unnest(orders.product_ids) as product_id\n                   FROM   orders)\nSELECT order_id,\n       product_id,\n       products.price\nFROM   unnest_id\n    LEFT JOIN products using (product_id)\nORDER BY order_id, product_id limit 1000\n\n\n\n\n\n\n\n\n\norder_id\nproduct_id\nprice\n\n\n\n\n0\n1\n28\n75.0\n\n\n1\n1\n65\n100.0\n\n\n2\n2\n30\n140.0\n\n\n3\n2\n34\n98.0\n\n\n4\n2\n35\n90.0\n\n\n...\n...\n...\n...\n\n\n995\n299\n83\n55.0\n\n\n996\n299\n87\n398.0\n\n\n997\n300\n57\n450.0\n\n\n998\n300\n67\n30.0\n\n\n999\n301\n1\n150.0\n\n\n\n\n1000 rows × 3 columns\n\n\n\n\nМаючи таблицю із замовленнями, що містить список товарів та їх ціни, тепер можна легко порахувати вартість кожного замовлення.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.13  Використовуючи запит із завдання 7.12, розрахуйте сумарну вартість кожного замовлення. Виведіть колонки з id замовлень та їх вартістю. Колонку із вартістю замовлення назвіть order_price. Результат відсортуйте за зростанням id замовлення.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: order_id, order_price\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       sum(price) as order_price\nFROM   (SELECT order_id,\n               product_ids,\n               unnest(product_ids) as product_id\n        FROM   orders) t1\n    LEFT JOIN products using(product_id)\nGROUP BY order_id\nORDER BY order_id limit 1000\n\n-- або\n-- with    unnest_id as (\n--             SELECT  order_id,\n--                     unnest(orders.product_ids) as product_id\n--             FROM   orders\n--         ),\n--         price_tbl as (\n--             SELECT  order_id,\n--                     product_id,\n--                     products.price\n--             FROM   unnest_id\n--             LEFT JOIN products using (product_id)\n--                       )\n        \n-- SELECT  order_id,\n--         sum(price) as order_price\n-- FROM price_tbl\n-- GROUP BY order_id\n-- ORDER BY order_id\n-- LIMIT 1000\n\n\n\n\n\n\n\n\n\norder_id\norder_price\n\n\n\n\n0\n1\n175.0\n\n\n1\n2\n394.0\n\n\n2\n3\n493.0\n\n\n3\n4\n156.0\n\n\n4\n5\n51.0\n\n\n...\n...\n...\n\n\n995\n996\n295.0\n\n\n996\n997\n150.0\n\n\n997\n998\n358.0\n\n\n998\n999\n289.0\n\n\n999\n1000\n69.0\n\n\n\n\n1000 rows × 2 columns\n\n\n\n\nОсь тепер у нас є все необхідне, щоб зробити наш перший серйозний аналітичний запит і порахувати різні метрики користувача!\nДавайте об’єднаємо в один запит дані про кількість товарів на замовлення наших користувачів з інформацією про вартість кожного замовлення, а потім розрахуємо кілька корисних показників.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.14  Використовуючи результати попередніх завдань (завд. 7.13 та завд. 7.11), напишіть запит для отримання інформації для кожного користувача:\n\nзагальна кількість замовлень - колонку назвіть orders_count\nсередня кількість товарів у замовленні — avg_order_size\nсумарну вартість усіх покупок - sum_order_value\nсередня вартість замовлення - avg_order_value\nмінімальну вартість замовлення - min_order_value\nмаксимальну вартість замовлення - max_order_value\n\nОтриманий результат відсортуйте за зростанням id користувача.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПам’ятайте, що в розрахунках ми, як і раніше, враховуємо лише нескасовані замовлення. При розрахунку середніх значень округляйте їх до двох знаків після коми.\nПоля в результуючій таблиці: user_id, orders_count, avg_order_size, sum_order_value, avg_order_value, min_order_value, max_order_value\n\n\n\n\n\nРішення\n%%sql\nwith    unnest_id as (\n            SELECT  order_id,\n                    unnest(orders.product_ids) as product_id\n            FROM   orders\n            ),\n        price_tbl as (\n            SELECT  order_id,\n                    product_id,\n                    products.price\n            FROM   unnest_id\n            LEFT JOIN products using (product_id)\n            ),\n        user_order_prod as (\n            SELECT  user_id,\n                    order_id,\n                    product_ids\n            FROM   user_actions\n            LEFT JOIN orders using (order_id)\n            WHERE  order_id in (\n                SELECT order_id\n                FROM   courier_actions\n                WHERE  action = 'deliver_order')\n            ),\n        order_size as (\n            SELECT user_id,\n                    order_id,\n                    round(avg(array_length(product_ids, 1)), 2) as avg_order_size\n            FROM   user_order_prod\n            GROUP BY user_id, order_id\n            ),\n        order_price as (\n            SELECT  order_id,\n                    sum(price) as order_price\n            FROM   price_tbl\n            GROUP BY order_id\n            )\n            \nSELECT  user_id,\n        COUNT(user_id) as orders_count,\n        ROUND(AVG(avg_order_size), 2) as avg_order_size,\n        SUM(order_price) as sum_order_value,\n        ROUND(AVG(order_price), 2) as avg_order_value,\n        MIN(order_price) as min_order_value,\n        MAX(order_price) as max_order_value\nFROM order_size\nLEFT JOIN order_price using (order_id)\nGROUP BY user_id\nORDER BY user_id\nLIMIT 1000\n\n\n\n\n\n\n\n\n\nuser_id\norders_count\navg_order_size\nsum_order_value\navg_order_value\nmin_order_value\nmax_order_value\n\n\n\n\n0\n1\n4\n2.75\n1206.0\n301.50\n170.0\n640.0\n\n\n1\n2\n2\n4.00\n590.0\n295.00\n196.0\n394.0\n\n\n2\n3\n4\n4.00\n2154.0\n538.50\n336.0\n772.0\n\n\n3\n4\n2\n3.00\n329.0\n164.50\n156.0\n173.0\n\n\n4\n5\n1\n1.00\n51.0\n51.00\n51.0\n51.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n995\n1001\n7\n2.71\n2376.0\n339.43\n60.0\n596.0\n\n\n996\n1002\n3\n2.67\n1365.0\n455.00\n75.0\n665.0\n\n\n997\n1003\n1\n3.00\n200.0\n200.00\n200.0\n200.0\n\n\n998\n1004\n5\n3.40\n1906.0\n381.20\n245.0\n498.0\n\n\n999\n1005\n1\n2.00\n94.0\n94.00\n94.0\n94.0\n\n\n\n\n1000 rows × 7 columns\n\n\n\n\nЗ великим завданням ми впоралися – тепер давайте вирішимо кілька додаткових завдань на закріплення нових знань.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.15  За таблицями courier_actions, orders та products визначте 10 найпопулярніших товарів, доставлених у вересні 2022 року. Найпопулярнішими товарами вважатимемо ті, що зустрічалися в замовленнях найчастіше. Якщо товар зустрічається в одному замовленні кілька разів (було куплено кілька одиниць товару), то при підрахунку враховуємо лише одну одиницю товару. Виведіть найменування товарів та скільки разів вони зустрічалися в замовленнях. Нову колонку з кількістю покупок товару назвіть times_purchased.\nПоля у результуючій таблиці: name, times_purchased\n\n\n\n\n\nРішення\n%%sql\nSELECT name,\n       count(product_id) as times_purchased\nFROM   (SELECT order_id,\n               product_id,\n               name\n        FROM   (SELECT DISTINCT order_id,\n                                unnest(product_ids) as product_id\n                FROM   orders\n                    LEFT JOIN courier_actions using (order_id)\n                WHERE  action = 'deliver_order'\n                   and date_part('month', time) = 9\n                   and date_part('year', time) = 2022) t1\n            LEFT JOIN products using (product_id)) t2\nGROUP BY name\nORDER BY times_purchased desc limit 10\n\n\n\n\n\n\n\n\n\nname\ntimes_purchased\n\n\n\n\n0\nbananas\n2632\n\n\n1\npasta\n2623\n\n\n2\nlong loaf\n2622\n\n\n3\nsugar\n2617\n\n\n4\nbread\n2605\n\n\n5\nchicken\n2585\n\n\n6\nblack tea bags\n2581\n\n\n7\nmilk\n2564\n\n\n8\ninstant coffee\n2460\n\n\n9\napple juice\n2373\n\n\n\n\n\n\n\n\nРаніше ми вважали рахували скасованих замовлень (cancel_rate) для кожного користувача. Тепер у нашому розпорядженні є всі необхідні знання, щоб порахувати цей показник у розрізі статі.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.16  Візьміть за основу запит із завдання 5.11 і підтягніть до нього з таблиці users дані про поле користувачів таким чином, щоб усі користувачі з таблиці users_actions залишилися в результаті. Потім порахуйте середнє значення cancel_rate для кожної статі, заокругливши його до трьох знаків після коми. Колонку з порахованим середнім значенням назвіть avg_cancel_rate.\nПам’ятайте про відсутність інформації про поле деяких користувачів після об’єднання таблиць, тому що не всі користувачі таблиці user_action є в таблиці users. Для цієї групи також порахуйте cancel_rate і в результуючій таблиці для порожнього значення в колонці з підлогою вкажіть ‘unknown’ (без лапок). Можливо, для цього доведеться згадати, як працює COALESCE.\nРезультат відсортуйте по колонці зі статтю користувача за зростанням.\nПоля у результуючій таблиці: sex, avg_cancel_rate\n\n\n\n\n\n\nПояснення\n\n\n\n\n\nМетрику cancel_rate у розрізі статі можна порахувати різними способами, у цій задачі пропонуємо наступний алгоритм:\n\nСпочатку порахуйте cancel_rate для кожного користувача.\nПотім додайте інформацію про поле користувачів.\nПотім розрахуйте avg_cancel_rate для кожної статі та округліть значення до трьох знаків після коми.\n\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT coalesce(sex, 'unknown') as sex,\n       round(avg(cancel_rate), 3) as avg_cancel_rate\nFROM   (SELECT user_id,\n               sex,\n               count(distinct order_id) filter (WHERE action = 'cancel_order')::decimal / count(distinct order_id) as cancel_rate\n        FROM   user_actions\n            LEFT JOIN users using(user_id)\n        GROUP BY user_id, sex\n        ORDER BY cancel_rate desc) t\nGROUP BY sex\nORDER BY sex\n\n\n\n\n\n\n\n\n\nsex\navg_cancel_rate\n\n\n\n\n0\nfemale\n0.051\n\n\n1\nmale\n0.048\n\n\n2\nunknown\n0.046\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.17  За таблицями orders та courier_actions визначте id десяти замовлень, які доставляли найдовше.\nПоле у результуючій таблиці: order_id\n\n\n\n\n\n\nПояснення\n\n\n\n\n\nДля розрахунку часу, витраченого на доставку замовлення, використовуйте інформацію про час доставки та час створення замовлення - з даними у форматі часу можна також проводити арифметичні операції (наприклад, обчислювати різницю між ними). Зауважте, що колонки з цими даними знаходяться в різних таблицях. Для визначення найдовших замовлень використовуйте оператор LIMIT.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id\nFROM   (SELECT order_id,\n               time - creation_time as time_to_deliv\n        FROM   orders\n            LEFT JOIN courier_actions using (order_id)\n        WHERE  action = 'deliver_order'\n        ORDER BY time_to_deliv desc) as t1 limit 10\n\n-- або\n-- SELECT order_id\n-- FROM   (SELECT order_id,\n--                time - creation_time as time_to_deliv\n--         FROM   orders\n--             LEFT JOIN courier_actions using (order_id)\n--         WHERE  action = 'deliver_order'\n--         ORDER BY time_to_deliv desc) as t1 limit 10\n\n\n\n\n\n\n\n\n\norder_id\n\n\n\n\n0\n22408\n\n\n1\n58491\n\n\n2\n1155\n\n\n3\n1464\n\n\n4\n4788\n\n\n5\n11064\n\n\n6\n12150\n\n\n7\n14647\n\n\n8\n18991\n\n\n9\n22907"
  },
  {
    "objectID": "sql_join.html#збираємо-списки-array_agg",
    "href": "sql_join.html#збираємо-списки-array_agg",
    "title": "7  Об’єднання таблиць",
    "section": "7.8 Збираємо списки: array_agg()",
    "text": "7.8 Збираємо списки: array_agg()\nДнями менеджер знову звернувся до вас із завданням: попросив зробити вивантаження з таблиці orders з усіма замовленнями та їх вмістом. З листування ви так і не зрозуміли, навіщо всі ці дані, але завдання зробили: натиснули SELECT * і відправили йому excel-файл із замовленнями. Наступного ранку з’ясувалося, що такі дані його не влаштовують, оскільки він не розуміє, що це за списки з наборами чисел. Справді, цей момент ви не врахували. Давайте виправлятися!\narray_agg — це просунута агрегатна функція, яка збирає всі значення в зазначеному стовпці в єдиний список (ARRAY). По суті array_agg - це операція, зворотна unnest, її синтаксис нічим не відрізняється від синтаксису інших агрегатних функцій:\nSELECT column_1, array_agg(column_2) AS new_array\nFROM table\nGROUP BY column_1\nПеред тим, як вирішувати завдання, спробуйте спочатку виконати просту вправу: розгорніть списки з id товарів, помістіть результат у підзапит, а потім відразу ж поверніть все назад у списки за допомогою array_agg. Алгоритм вирішення цього завдання приблизно такий самий.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.18  Змініть списки з id товарів з таблиці orders на списки з найменуваннями товарів. Назви візьміть з таблиці products. Назвіть колонку з новими списками найменувань product_names.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: order_id, product_names\n\n\n\n\n\n\nПояснення\n\n\n\n\n\nДля вирішення задачі вам потрібно зробити unnest колонки product_ids, об’єднати проміжний результат з таблицею products для отримання найменувань товарів, а потім зробити групування з агрегацією в список найменувань.\nДля того, щоб зробити агрегацію значень у колонці до списку, необхідно скористатися функцією array_agg.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       array_agg(name) as product_names\nFROM   (SELECT order_id,\n               unnest(product_ids) as product_id\n        FROM   orders) t join products using(product_id)\nGROUP BY order_id limit 1000\n\n\n\n\n\n\n\n\n\norder_id\nproduct_names\n\n\n\n\n0\n1\n[bananas, cream]\n\n\n1\n3\n[orange juice, sunflower oil, chicken]\n\n\n2\n19\n[bread, buckwheat, oranges, cream]\n\n\n3\n53\n[sunflower oil, peas, apple juice, cranberry j...\n\n\n4\n54\n[black tea bags]\n\n\n...\n...\n...\n\n\n995\n9783\n[pork, milk, chips]\n\n\n996\n9789\n[bananas, energy drink, grain coffee, dried fi...\n\n\n997\n9880\n[lemonade, cookie]\n\n\n998\n9895\n[сowberry juice]\n\n\n999\n9910\n[green tea bags, pork, apple juice, mutton, bl...\n\n\n\n\n1000 rows × 2 columns\n\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.19  З’ясуйте, хто замовляв та доставляв найбільші замовлення. Найбільшими вважають замовлення з найбільшою кількістю товарів.\nВиведіть id замовлення, id користувача та id кур’єра. Також в окремих колонках вкажіть вік користувача та вік кур’єра. Вік виміряйте числом повних років, як ми робили раніше. Рахуйте його щодо останньої дати в таблиці user_actions як для користувачів, так і для кур’єрів. Колонки з віком назвіть user_age та courier_age. Результат відсортуйте за зростанням id замовлення.\nПоля в результуючій таблиці: order_id, user_id, user_age, courier_id, courier_age\n\n\n\n\n\nРішення\n%%sql\nwith order_id_large_size as (SELECT order_id\n                             FROM   orders\n                             WHERE  array_length(product_ids, 1) = (SELECT max(array_length(product_ids, 1))\n                                                                    FROM   orders))\nSELECT DISTINCT order_id,\n                user_id,\n                date_part('year', age((SELECT max(time)\n                       FROM   user_actions), users.birth_date))::integer as user_age, courier_id, date_part('year', age((SELECT max(time)\n                                                                                                  FROM   user_actions), couriers.birth_date))::integer as courier_age\nFROM   (SELECT order_id,\n               user_id\n        FROM   user_actions\n        WHERE  order_id in (SELECT *\n                            FROM   order_id_large_size)) t1\n    LEFT JOIN (SELECT order_id,\n                      courier_id\n               FROM   courier_actions\n               WHERE  order_id in (SELECT *\n                                   FROM   order_id_large_size)) t2 using(order_id)\n    LEFT JOIN users using(user_id)\n    LEFT JOIN couriers using(courier_id)\nORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\nuser_id\nuser_age\ncourier_id\ncourier_age\n\n\n\n\n0\n7949\n3804\n29\n845\n19\n\n\n1\n18853\n5433\n31\n1537\n33\n\n\n2\n29786\n12728\n33\n431\n26\n\n\n3\n49755\n18622\n29\n1619\n32\n\n\n4\n51414\n17170\n31\n2564\n27"
  },
  {
    "objectID": "sql_join.html#self-join",
    "href": "sql_join.html#self-join",
    "title": "7  Об’єднання таблиць",
    "section": "7.9 SELF JOIN",
    "text": "7.9 SELF JOIN\nІ насамкінець розглянемо ще один тип об’єднання таблиць, який теж потрібно знати. Це так званий SELF JOIN.\nSELF JOIN - не що інше, як об’єднання таблиці із самою собою. Так, така операція також можлива і, більше того, часто буває корисною.\nПриєднати таблицю до себе можна з допомогою будь-якого розглянутого раніше типу джойна:\nSELECT ...\nFROM table JOIN table\n     ON [condition]\n\n\nSELECT ...\nFROM table LEFT JOIN table\n     ON [condition]\n\n\nSELECT ...\nFROM table FULL JOIN table\n     ON [condition]\n\n\nSELECT ...\nFROM table CROSS JOIN table\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 7.20  З’ясуйте, які пари товарів купують разом найчастіше.\nПари товарів сформуйте на основі таблиці із замовленнями. Скасовані замовлення не враховуйте. Як результат виведіть дві колонки - колонку з парами найменувань товарів і колонку зі значеннями, які показують, скільки разів конкретна пара зустрілася у замовленнях користувачів. Колонки назвіть відповідно pair та count_pair.\nПари товарів мають бути представлені у вигляді списків із двох найменувань. Пари товарів усередині списків мають бути відсортовані у порядку зростання найменування. Результат відсортуйте спочатку за зменшенням частоти зустрічі пари товарів у замовленнях, потім по колонці pair — за зростанням.\nПоля у результуючій таблиці: pair, count_pair\n\n\n\n\n\n\nПояснення + підказка\n\n\n\n\n\nУ цій задачі вам необхідно зробити SELF JOIN. Подумайте, яку таблицю потрібно приєднати до себе і заздалегідь обробіть дані. Для вирішення рекомендуємо скористатися табличними виразами. Також вам знадобляться функції для роботи зі списками. Ознайомтеся з прикладами документації та подумайте, що можна використовувати у своєму рішенні.\nЗавдання творче і може бути вирішене різними способами.\nДля кожної пари товарів вам необхідно порахувати скільки разів вона зустрілася в замовленнях користувачів. Головна проблема полягає в тому, що при SELF JOIN кожен товар утворює пару з самим собою («A-A») і при цьому кожна пара зустрічається двічі («A-B» та «B-A»). Суть завдання полягає в тому, щоб позбавитися цих двох проблем і отримати коректні розрахунки.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nwith main_table as (SELECT DISTINCT order_id,\n                                    product_id,\n                                    name\n                    FROM   (SELECT order_id,\n                                   unnest(product_ids) as product_id\n                            FROM   orders\n                            WHERE  order_id not in (SELECT order_id\n                                                    FROM   user_actions\n                                                    WHERE  action = 'cancel_order')\n                               and order_id in (SELECT order_id\n                                             FROM   user_actions\n                                             WHERE  action = 'create_order')) t join products using(product_id)\n                    ORDER BY order_id, name)\nSELECT pair,\n       count(order_id) as count_pair\nFROM   (SELECT DISTINCT a.order_id,\n                        case when a.name &gt; b.name then string_to_array(concat(b.name, '+', a.name), '+')\n                             else string_to_array(concat(a.name, '+', b.name), '+') end as pair\n        FROM   main_table a join main_table b\n                ON a.order_id = b.order_id and\n                   a.name != b.name) t\nGROUP BY pair\nORDER BY count_pair desc, pair\n\n-- або\n-- with \n--     t as (select order_id, \n--             unnest(product_ids) as product_id from orders\n--             left join user_actions using(order_id)\n--             where order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')\n--             ),\n\n--     k as (select order_id, t.product_id as pr, t1.product_id as pr1\n--             from t\n--             join t as t1 using(order_id)\n--             where t.product_id != t1.product_id),\n-- \n--     p as (select order_id, pr, pr1, name \n--             from k\n--             left join products on pr = products.product_id),\n-- \n--     s as (select order_id, p.name as name, products.name as name1\n--             from p\n--             left join products on pr1 = products.product_id),\n-- \n--    l as (select  distinct\n--                 order_id, \n--                 array_sort(array_cat(array[name], array[name1])) as pair \n--             from s)\n\n-- select pair, count(*) as count_pair from l\n-- group by  pair\n-- order by count_pair desc, pair \n\n\n\n\n\n\n\n\n\n\n\n\npair\ncount_pair\n\n\n\n\n0\n[bread, chicken]\n249\n\n\n1\n[bread, sugar]\n237\n\n\n2\n[black tea bags, coffee 3 in 1]\n235\n\n\n3\n[bread, long loaf]\n235\n\n\n4\n[chicken, sugar]\n233\n\n\n...\n...\n...\n\n\n3735\n[honey, sesame oil]\n2\n\n\n3736\n[jam, salted fish]\n2\n\n\n3737\n[linseed oil, sesame oil]\n2\n\n\n3738\n[sesame oil, sprats]\n2\n\n\n3739\n[dried fruits, tea mushroom]\n1\n\n\n\n\n3740 rows × 2 columns"
  },
  {
    "objectID": "sql_window.html#over---визначення-вікна",
    "href": "sql_window.html#over---визначення-вікна",
    "title": "8  Віконні функції",
    "section": "8.1 OVER - визначення вікна",
    "text": "8.1 OVER - визначення вікна\nВизначаються вікна за допомогою оператора OVER – у загальному вигляді його синтаксис виглядає так:\nOVER (\n     PARTITION BY column_1, column_2, ...   - визначаються партиції усередині вікна (аналог GROUP BY) \n     ORDER BY column_3, ...                 - вказується сортування записів у партиціях\n     ROWS/RANGE BETWEEN ...                 - задаються межі вікна\n)\nДля проведення обчислень за заданим в OVER вікну використовуються різні функції. Наприклад, з агрегуючою функцією SUM запис може виглядати так:\nSELECT SUM(column) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS sum\nFROM table\nТепер кілька слів про інструкції, які можна вказувати під час створення вікна. Усього їх три:\n\nPARTITION BY\nORDER BY ASC/DESC\nROWS/RANGE BETWEEN\n\nПри цьому всі вони є необов’язковими."
  },
  {
    "objectID": "sql_window.html#partition-by",
    "href": "sql_window.html#partition-by",
    "title": "8  Віконні функції",
    "section": "8.2 PARTITION BY",
    "text": "8.2 PARTITION BY\nІнструкція PARTITION BY визначає стовпець, яким дані ділитися на групи, які називаються партіціями. Наприклад, так як буде виглядати групування за user_id:\nSELECT user_id, date, price, \n       SUM(price) OVER (PARTITION BY user_id) AS sum\nFROM table\nВ результаті такого запиту для кожного запису в таблиці буде обчислено загальну суму всіх покупок даного користувача, а результат обчислень буде вписаний в стовпець sum:\n\n\n\nuser_id\ndate\nprice\nsum\n\n\n\n\nAlex\n09.01\n500\n3950\n\n\nAlex\n13.03\n3000\n3950\n\n\nAlex\n02.08\n450\n3950\n\n\nKate\n25.07\n100\n900\n\n\nKate\n17.09\n800\n900"
  },
  {
    "objectID": "sql_window.html#order-by",
    "href": "sql_window.html#order-by",
    "title": "8  Віконні функції",
    "section": "8.3 ORDER BY",
    "text": "8.3 ORDER BY\nІнструкція ORDER BY визначає стовпець, яким значення всередині вікна будуть сортуватися при обробці. Наприклад, сортування по date всередині вікна задається так:\nSELECT user_id, date, price, \n       SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum\nFROM table\nУ цьому випадку для кожного запису в таблиці буде обчислено суму поточної та всіх попередніх покупок користувача. Результат обчислень буде вписаний у стовпець sum:\n\n\n\nuser_id\ndate\nprice\nsum\n\n\n\n\nAlex\n09.01\n500\n500\n\n\nAlex\n13.03\n3000\n3500\n\n\nAlex\n02.08\n450\n3950\n\n\nKate\n25.07\n100\n100\n\n\nKate\n17.09\n800\n900\n\n\n\nЧому ж рахується сума саме поточної та всіх попередніх, а не взагалі всіх покупок користувача?\nСправа в тому, що при використанні у парі віконних та агрегатних функцій для кожного рядка визначається так звана рамка вікна - набір рядків у її партиції. Якщо в OVER вказати ORDER BY, то за замовчуванням рамка складатиметься з усіх рядків від початку партиції до поточного рядка (також у рамку будуть включені рядки, що дорівнюють поточному рядку за значенням вказаним у ORDER BY).\nСаме тому в нашому прикладі сума вважається за кожним користувачем наростаючим підсумком.\nЯкщо ж ORDER BY не вказувати, то стандартна рамка буде складатися з усіх рядків партиції, тобто буде пораховано суму всіх покупок кожного користувача. Також можна не вказувати і PARTITION BY – тоді рамкою вікна стане вся таблиця, і ми просто порахуємо суму покупок усіх користувачів:\nSELECT user_id, date, price, \n       SUM(price) OVER () AS sum\nFROM table"
  },
  {
    "objectID": "sql_window.html#rowsrange-between",
    "href": "sql_window.html#rowsrange-between",
    "title": "8  Віконні функції",
    "section": "8.4 ROWS/RANGE BETWEEN",
    "text": "8.4 ROWS/RANGE BETWEEN\nІнструкції ROWS та RANGE можуть додатково задавати межі рамки вікна та обмежувати діапазон роботи функцій усередині партиції. Першим аргументом вказується початок рамки, другим - кінець рамки:\nSELECT user_id, date, price, \n       SUM(price) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS sum\nFROM table\nВ результаті для кожного запису в таблиці буде обчислено суму поточної та попередньої покупок користувача, а результат буде знову вписаний в стовпець sum:\n\n\n\nuser_id\ndate\nprice\nsum\n\n\n\n\nAlex\n09.01\n500\n500\n\n\nAlex\n13.03\n3000\n3500\n\n\nAlex\n02.08\n450\n3450\n\n\nKate\n25.07\n100\n100\n\n\nKate\n17.09\n800\n900\n\n\n\nРамку можна встановити в двох режимах:\n\nROWS — початок та кінець рамки визначаються рядками щодо поточного рядка.\nRANGE — початок та кінець рамки задаються різницею значень у стовпці з ORDER BY.\n\nПочаток і кінець рамки задаються одним із наступних способів:\nUNBOUNDED PRECEDING\nзначення PRECEDING\nCURRENT ROW\nзначення FOLLOWING\nUNBOUNDED FOLLOWING\n\nUNBOUNDED PRECEDING: вказує, що рамка починається з першого рядка партиції.\nUNBOUNDED FOLLOWING: вказує, що рамка закінчується на останньому рядку партиції.\nPRECEDING та FOLLOWING: вказують, що рамка починається або закінчується зі зсувом на задану кількість рядків щодо поточного рядка.\nCURRENT ROW: вказує, що рамка починається або закінчується на поточному рядку.\n\nРамка завжди починається з початку рамки та закінчується кінцем рамки. Якщо кінець рамки не вказаний, мається на увазі CURRENT ROW.\nЗа замовчуванням рамка визначається так:\nRANGE UNBOUNDED PRECEDING\nЦе рівносильно розширеному визначенню рамки:\nRANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\nВаріанти значення PRECEDING та значення FOLLOWING допускаються лише у режимі ROWS.\nНаприклад, наступний запис означає створення рамки, що включає 3 рядки до поточної і 3 рядки після поточної (зрозуміло, поточний рядок також включається до рамки):\nROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING\nЯкщо в інструкції ORDER BY знаходиться стовпець date з типом даних DATE, то рамку вікна можна задати так:\nRANGE BETWEEN '3 days' PRECEDING AND '3 days' FOLLOWING\nЦе означатиме рамку, що включає 3 дні перед та 3 дні після поточної дати (включаючи поточну дату).\nПри вказівці рамки через RANGE обов’язковою умовою є лише один стовпчик в інструкції ORDER BY.\nЯк і решта інструкцій, інструкція ROWS/RANGE BETWEEN є необов’язковою."
  },
  {
    "objectID": "sql_window.html#де-та-як-можна-використовувати-віконні-функції",
    "href": "sql_window.html#де-та-як-можна-використовувати-віконні-функції",
    "title": "8  Віконні функції",
    "section": "8.5 Де та як можна використовувати віконні функції?",
    "text": "8.5 Де та як можна використовувати віконні функції?\nТакож важливо знати, що віконні функції дозволяється використовувати у запиті лише у SELECT та ORDER BY. В інших операторах, включаючи WHERE, HAVING і GROUP BY, вони заборонені, оскільки логічно виконуються після звичайних агрегатних функцій.\nЯкщо потрібно відфільтрувати або згрупувати рядки після обчислення віконних функцій, можна використати вкладений запит:\nSELECT user_id, date, price, sum\nFROM (\n    SELECT user_id, date, price, SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum\n    FROM table\n) t\nWHERE sum &gt; 1000\nНад результатом віконних функцій можна виконувати різні арифметичні операції. Також результат віконних функцій може виступати як аргумент інших функцій:\nSELECT user_id, date, price, 1.15 * SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum\nFROM table\n\nSELECT user_id, date, price, ROUND(AVG(price) OVER (PARTITION BY user_id ORDER BY date), 2) AS sum\nFROM table\nТакож для визначення інструкцій усередині вікна можна використовувати розрахункові поля:\nSELECT user_id, date, price, SUM(price) OVER (PARTITION BY DATE_TRUNC('month', date)) AS monthly_sum\nFROM table  \nСамі вікна також можна визначати через оператор WINDOW, а потім викликати по аліасу в операторі SELECT:\nSELECT SUM(column) OVER w AS sum\nFROM table\nWHERE ...\nGROUP BY ...\nHAVING ...\nWINDOW w AS (\n    PARTITION BY ... \n    ORDER BY ...\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    )\nORDER BY ...\nLIMIT ..."
  },
  {
    "objectID": "sql_window.html#використання-віконних-функцій-з-іншими-функціями",
    "href": "sql_window.html#використання-віконних-функцій-з-іншими-функціями",
    "title": "8  Віконні функції",
    "section": "8.6 Використання віконних функцій з іншими функціями",
    "text": "8.6 Використання віконних функцій з іншими функціями\nУ парі з віконними функціями можна використовувати функції різних класів:\n\nАгрегатні функції SUM, AVG, MAX, MIN, COUNT\n\nВсередині вікна до таких функцій можна застосовувати ORDER BY. Так, сортування дозволить отримати замість загальної суми наростаючу, а замість абсолютного максимуму — максимум серед значень до поточного.\n\nРанжируючі функції:\n\n\nROW_NUMBER: проста нумерація (1, 2, 3, 4, 5).\nRANK: нумерація з урахуванням повторюваних значень з пропуском рангів (1, 2, 2, 4, 5).\nDENSE_RANK: нумерація з урахуванням повторюваних значень без пропуску рангів (1, 2, 2, 3, 4).\n\nЗрозуміло, для функцій ранжирування завжди потрібно вказувати ORDER BY, інакше вони працюватимуть некоректно.\n\nФункції зміщення:\n\n\nLAG, LEAD: значення попереднього чи наступного рядка.\nFIRST_VALUE, LAST_VALUE: перше чи останнє значення у вікні.\n\nДля функцій зміщення визначення правил сортування теж необхідне.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про віконні функції можна почитати у документації DuckDB.\nТакож рекомендуємо до прочитання статтю."
  },
  {
    "objectID": "quarto.html#що-таке-quarto",
    "href": "quarto.html#що-таке-quarto",
    "title": "\n9  Quarto\n",
    "section": "\n9.1 Що таке Quarto",
    "text": "9.1 Що таке Quarto\nQuarto — це науково–технічна видавнича система з відкритим кодом, яка ґрунтується на універсальному конверторі документів Pandoc та використовує мову розмітки Markdown. Це універсальний інструмент для тих, хто пише на R, Python, Julia та Observable JavaScript.\nЗа допомогою Quarto можна поєднувати описовий текст і код для створення відформатованих документів, веб–сторінок, постів у блогах, книг тощо.\n\n9.1.1 Назва Quarto\nРозробники Quarto хотіли використати ім’я, яке мало деяке значення в історії видавничої справи. Вибір пав на Quarto (від латинського quārtō, скорочено Qto, 4to або 4º) — це формат книги або брошури в одну четвертину топографічного листа. На кожній стороні листа при цьому поміщається 4 сторінки книги (8 сторінок на один лист).\nНайраннішим відомим виданням такого формату була Книга Сивіл (англ. Sibyllenbuch), що була надрукована Йоганном Гутенбергом у 1452–1453 роках.\n\n\nРисунок 9.1: Quarto\n\n\n9.1.2 Можливості Quarto\nQuarto являє собою текстовий документ спеціального формату .qmd, який можна скомпілювати у різноманітні документи:\n\nДокументи у форматах:\n\nHTML\nPDF\nePub\nMS Word\nOpenOffice\n\n\nПрезентації у форматах:\n\n\nreveal.js (HTML)\n\nPowerPoint (MS Office)\n\nBeamer (LaTeX/PDF)\n\n\nВеб-сторінки:\n\n\nPractical Deep Learning від fast.ai\n\nnbdev від fast.ai\nКурс Julia Workshop for Data Science\n\n\n\nКниги, приклади яких можна переглянути за посиланнями:\n\nPython for Data Analysis\nR for Data Science\nVisualization Curriculum\n\n\nІнтерактивні документи:\n\n\nObservable reactive JavaScript\n\nShiny вебфреймворк\nІнтерактивні віджети Jupyter"
  },
  {
    "objectID": "quarto.html#початок-роботи-з-quarto",
    "href": "quarto.html#початок-роботи-з-quarto",
    "title": "\n9  Quarto\n",
    "section": "\n9.2 Початок роботи з Quarto",
    "text": "9.2 Початок роботи з Quarto\n\n9.2.1 Встановлення Quarto\nДля роботи з Quarto потрібно: 1. Встановити інтерфейс командного рядка Quarto (CLI) під актуальну операційну систему (Windows, Linux або Mac OS).\n\nВстановити плагін для інтегрованого середовища розробки (IDE). На даний момент підтримуються:\n\nVS Code\nRStudio\nJupyter\n\n\n\n9.2.2 Робота з проектами\nСтворити Quarto–проект можна декількома шляхами:\n\nЗа допомогою командного рядка:\n\n\n\nterminal\n\n# веб-сайт\nquarto create-project mysite --type website\n\n# блог\nquarto create-project myblog --type website:blog\n\n# книга\nquarto create-project mybook --type book\n\n\nЗасобами IDE:\n\n\n\nVS Code: File -&gt; New File -&gt; …\n\n\n\n\nРисунок 9.2: Меню створення Quarto–проекту у VS Code\n\n\n\nRStudio: File -&gt; New Project… -&gt; New Directory\n\n\n\n\nРисунок 9.3: Меню створення Quarto–проекту у RStudio\n\n\n9.2.3 Як працює Quarto\nСпочатку Knitr (для R) або Jupyter (для Python або Julia) виконує всі фрагменти коду .qmd-файлу і створює новий markdown (.md) документ, який включає в себе код і всі його результати. Далі .md–файл оброблюється Pandoc для перетворення у різноманітні формати файлів (HTML, PDF, Word тощо).\n\n\nРисунок 9.4: Процедура рендерінгу документів в Quarto\n\n\n9.2.4 Рендерінг\n\nДля рендерінгу документу можна використати кнопку Render в VS Code.\n\n\n\nРисунок 9.5: Клавіша рендерінгу документу в VS Code\n\n\nРендерінг за допомогою командного рядку:\n\n\n\nterminal\n\nquarto render &lt;input&gt; --to &lt;format&gt;\n\n# Наприклад:\nquarto render document.qmd --to docx"
  },
  {
    "objectID": "quarto.html#структура-документів-quatro",
    "href": "quarto.html#структура-документів-quatro",
    "title": "\n9  Quarto\n",
    "section": "\n9.3 Структура документів Quatro",
    "text": "9.3 Структура документів Quatro\nQuatro документи складаються з трьох базових складових:\n\nYAML–шапки1\n\nТекст з використанням розмітки Markdown\nЧанків (анг. chunks) з кодом\n\n\n9.3.1 YAML–шапка\nYAML–шапка знаходиться нагорі документу і відділена трьома дефісами (---) зверху та знизу. В ній зберігається мета–інформація документу: назва, дата створення, автор, інформація щодо роботи коду, контенту і процесу рендерінгу.\n---\ntitle: \"Dracula\"\nauthor: \"Bram Stoker\"\ndate: \"May 26, 1897\"\nformat: \n  html:\n    toc: true\n    code-fold: true\n---\n\n9.3.2 Текст з використанням розмітки Markdown\nЦя частина документу йде одраtextзу після YAML–шапки і складає основну частину документу.\nMarkdown — це популярна і зручна мова розмітки. Ви непевно зустрічали її в README.md–файлах репозиторіїв GitHub, а також у Telegram–повідомленнях.\n\n9.3.3 Чанки з кодом\nЧанки — це блоки, які відділяються від тексту потрійними зворотніми лапками ``` ( анг. backtick) на початку та в кінці. У фігурних дужках вказується мова програмування на якій необхідно виконати код.\nprint('Fly, you fools!')\nРезультат чанку за замовчування виводиться одразу після нього, але все це можна налаштувати."
  },
  {
    "objectID": "quarto.html#yaml-шапка",
    "href": "quarto.html#yaml-шапка",
    "title": "\n9  Quarto\n",
    "section": "\n9.4 YAML-шапка",
    "text": "9.4 YAML-шапка\nМетадані документу можуть бути задані у шапці документу або окремим _quarto.yml-файлом.\nВ цій частині документу зберігається інформація щодо назви документу, дати, автора, налаштування рендерінгу, параметри чанків та інші додаткові налаштування. Всі параметри встановлюються у форматі key: value.\n\n9.4.1 Налаштування виводу\nКлюч format: відповідає за тип вихідного файлу.\n\n\n\n\n\n\n\nТип\nЗначення\nОпис\n\n\n\nДокументи\n\nhtml\npdf\ndocx\nodt\nepub\n\n\nHTML\nPDF\nMS Word\nOpenDocument\nePub\n\n\n\nПрезентації\n\nrevealjs\npptx\nbeamer\n\n\nRevealjs\nPowerPoint\nBeamer\n\n\n\nMarkdown\n\ngfm\ncommonmark\nmarkua\n\n\nGFM\nCommonMark\nMarkua\n\n\n\nWiki\n\nmediawiki\ndokuwiki\nzimwiki\njira\nxwiki\n\n\nMediaWiki\nDocuWiki\nZimWiki\nJira Wiki\nXWiki\n\n\n\n\nА також цілу низку інших форматів, документацію по котрим можна отримати в розділі Reference документації.\n\n9.4.2 Назва, дата та автор\nВ залежності від типу вихідного документу, ці ключі можуть відрізнятися, але наведу основні:\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\ntitle\nНазва документа\n\n\nsubtitle\nПідзаголовок документа\n\n\ndate\nДата документа\n\n\nauthor\nАвтор або автори документа\n\n\n\n9.4.3 Зміст\nДля генерації змісту (анг. table of contents, скорочено toc) необхідно ключу toc задати значення true. В залежності від типу вихідного документу зміст буде згенерований відповідно до заголовків (Розділ 9.5.2).\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\ntoc\nДодайте автоматично створений зміст у вихідний документ.\n\n\ntoc-depth\nКількість рівнів розділу, які потрібно включити у зміст. За замовчуванням 3\n\n\ntoc-title\nЗаголовок, використаний для змісту.\n\n\n\n9.4.4 Локалізація документу\nQuarto, Pandoc та LaTeX генерують текстові елементи документу, які потребують локалізації. Наприклад: “Рисунок” або “Таблиця” для перехресних посилань, назви виносок тощо.\n\n9.4.4.1 Налаштування lang\n\nПриклад використання польської локалізації документу:\n---\ntitle: \"Mój dokument\"\nlang: pl  \n---\nЦе призведе до використання польського перекладу компонентів документу, а також до застосування інших мовних правил обробки документів.\nНаразі доступні повні переклади такими мовами:\n\nанглійська (en, за замовчуванням)\nголландська (nl)\nіспанська (es)\nіталійська (it)\nкитайська (zh)\nкорейська (kr)\nнімецька (de)\nпольська (pl)\nпортугальська (pt)\nросійська (ru)\nфінська (fi)\nфранцузька (fr)\nчеська (cs)\nяпонська (ja)\n\n9.4.4.2 Власна локалізація\nЯкщо вас не влаштовує мова за умовчанням, яка використовується для певної частини документа, ви можете вказати альтернативну мову за допомогою ключа language. Наприклад, щоб замінити значення підписів «Author» і «Published», які використовуються в блоках заголовків, ви можете зробити це:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: \n  title-block-author-single: \"Автор\"\n  title-block-published: \"Опубліковано\"\n---\nВсі ці зміни можна зберегти в окремому .yml-файлі і використовувати власну локалізацію до документу:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: custom.yml\n---\nЯ зробив власну українську локалізацію Quarto-документів, яку Ви можете завантажити з мого GitHub-репозиторія: https://github.com/aranaur/quarto-ukrainian.\nОзнайомитися з усіма офіційними локалізаціями можна за посиланням: https://github.com/quarto-dev/quarto-cli/tree/main/src/resources/language."
  },
  {
    "objectID": "quarto.html#основи-markdown",
    "href": "quarto.html#основи-markdown",
    "title": "\n9  Quarto\n",
    "section": "\n9.5 Основи Markdown",
    "text": "9.5 Основи Markdown\nQuarto ґрунтується на Pandoc та використовує різновид markdown в якості базового синтаксису. Pandoc markdown — це розширена та злегка перероблена версія синтаксису markdown.\nMarkdown — це формат звичайного тексту, який розроблено таким чином, щоб його було легко писати та, що ще важливіше, легко читати.\n\n9.5.1 Форматування тексту\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n*курсив* та **жирний**\n\nкурсив та жирний\n\n\n\nнадрядковий^2^ / підрядковий~2~\nнадрядковий2 / підрядковий2\n\n\n\n~~перекреслення~~\nперекреслення\n\n\n`дослівний код`\nдослівний код\n\n\n\n9.5.2 Заголовки\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n# Заголовок 1\nЗаголовок 1\n\n\n## Заголовок 2\nЗаголовок 2\n\n\n### Заголовок 3\nЗаголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6\n\n\n\n9.5.3 Посилання та рисунки\n\n\nСинтаксис markdown\nРезультат\n\n\n\n[Python](https://python.org)\nPython\n\n\n![Підпис](img/python-logo.jpg)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org \"Python\")\n\n\n\n[![](img/python-logo.jpg){fig-alt=\"Alt text\"}](https://www.python.org)\n\n\n\n\n9.5.4 Списки\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n* невпорядкований список\n    + підпункт 1\n    + підпункт 2\n        - під--підпункт 1\n\n\nневпорядкований список\n\nпідпункт 1\n\nпідпункт 2\n\nпід–підпункт 1\n\n\n\n\n\n\n\n*   пункт 2\n\n    Продовження (відступ 4 інтервали)\n\n\nпункт 2\nПродовження (відступ 4 інтервали)\n\n\n\n\n1. впорядкований список\n2. пункт 2\n    i) підпункт 1\n         A.  під--підпункт 1\n\nвпорядкований список\n\nпункт 2\n\n\nпідпункт 1\n\nпід–підпункт 1\n\n\n\n\n\n\n\n(@)  Список, нумерація якого\n\nпродовжується після\n\n(@)  переривання\n\n\nСписок, нумерація якого\n\nпродовжується після\n\nпереривання\n\n\n\n\nтермін\n: визначення\n\nтермін\n\nвизначення\n\n\n\n\n\n9.5.5 Таблиці\n\n9.5.5.1 Таблиці markdown\nСинтаксис markdown\n| Зліва | Справа | За замовчуванням | По центру |\n|------:|:-------|------------------|:---------:|\n|   12  |  12    |    12            |    12     |\n|  123  |  123   |   123            |   123     |\n|    1  |    1   |     1            |     1     |\nРезультат\n\n\nЗліва\nСправа\nЗа замовчуванням\nПо центру\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\nФормувати такі таблиці вручну досить складно і незручно. В таких випадках на допомогу приходить Markdown Tables Generator.\n\n9.5.5.2 Таблиці з Python\n\nЗа допомогою комбінації функцій Markdown() та пакету tabulate:\n\n\n\nterminal\n\npip install tabulate\n\n\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\ntable = [[\"Bilbo Baggins\", \"Hobbits\", \"Male\"],\n         [\"Beren\", \"Men\", \"Male\"],\n         [\"Nimrodel\", \"Elves\", \"Female\"],\n         [\"Muzgash\", \"Orc\", \"Male\"]]\nMarkdown(tabulate(\n  table, \n  headers=[\"Name\", \"Race\", \"Sex\"]\n))\n\n\n\nТаблиця 9.1: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nPandas DataFrame у форматі консолі:\n\n\nчерез функцію print(), у форматі консолі:\n\n\nimport pandas as pd\n\ndf = pd.DataFrame(data = table,\n    columns = [\"Name\", \"Race\", \"Sex\"])\nprint(df)\n\n            Name     Race     Sex\n0  Bilbo Baggins  Hobbits    Male\n1          Beren      Men    Male\n2       Nimrodel    Elves  Female\n3        Muzgash      Orc    Male\n\n\n\nМожна викликати Python через R за допомогою пакету reticulate та використати функцію kable() з пакету knitr:\n\n\nlibrary(reticulate)\n\nWarning: package 'reticulate' was built under R version 4.2.2\n\nlibrary(knitr)\n\nkable(py$df)\n\n\n\nТаблиця 9.2: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nДодаткові можливості з’являються разом з пакетом kableExtra:\n\n\n# R chunk\nlibrary(kableExtra)\n\npy$df %&gt;% \n  kbl() %&gt;%\n  kable_classic_2(full_width = F)\n\n\n\nТаблиця 9.3: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\n\n\n9.5.6 Рівняння\nДля запису рівняння в середині тексту використовується одинарний символ $ та подвійний $$ для запису рівняння з нового рядка:\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\nу середині тексту: $E = mc^{2}$\nу середині тексту: \\(E=mc^{2}\\)\n\n\n\nз нового рядка:\n\n$$E = mc^{2}$$\nз нового рядка:\\[E = mc^{2}\\]\n\n\n\n\nВ якості допомоги формування рівнянь рекомендую ресурс Online LaTeX Equation Editor.\n\n9.5.7 Діаграми\nQuarto має вбудовану підтримку для створення діаграм Mermaid та Graphviz. Це дає змогу створювати блок–схеми, діаграми послідовності, діаграми станів тощо, використовуючи синтаксис простого тексту.\nПриклад створення блок–схеми за допомогою Mermaid:\n\n```{mermaid}\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n```\n\n\n\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n\n\n\n\n\nБільше інформації у розділі Diagrams.\n\n9.5.8 Відео\nВставляти відео у документи можна за допомогою запису {{&lt; video &gt;}}.\nПриклад використання відео з Youtube:\n{{&lt; video https://www.youtube.com/embed/qOhk7YyxXQ4 &gt;}}\nБільше інформації у розділі Videos.\n\n9.5.9 Виноски\n\n9.5.9.1 Типи виносок\nВиноски — чудовий спосіб привернути додаткову увагу до певних понять або чіткіше вказати, що певний вміст є додатковим або потребує додаткової уваги.\nУ Quarto є п’ять різноманітних виносок: - примітка (note) - застереження (warning) - важливо (important) - підказка (tip) - попередження (caution)\nКолір і значок відрізнятимуться залежно від обраного типу. Ось як виглядають різні виноски в HTML:\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що існує п’ять типів виносок, зокрема: note, tip, warning, caution та important.\n\n\n\n\n\n\n\n\nЗастереження\n\n\n\nВиноски — простий спосіб привернути увагу, наприклад, до цього застереження.\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nВиноски точно покращать Ваш текст.\n\n\n\n\n\n\n\n\nПідказка\n\n\n\nПриклад виноски з текстом\n\n\n\n\n\n\n\n\nРозгорніть, щоб дізнатися про згортання\n\n\n\n\n\nЦе приклад «згорнутої» виноски з попередженням. Використайте collapse=\"true\" щоб згорнути її за замовчуванням та collapse=\"false\" щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n\n\n\n\n9.5.9.2 Синтаксис markdown\nСтворіть виноски в розмітці за допомогою наступного синтаксису (зверніть увагу, що перший заголовок, використаний у виносці, використовується як заголовок виноски):\n::: {.callout-note}\n## Примітка\n\nЗауважте, що існує п’ять типів виносок, зокрема:\n`note`, `tip`, `warning`, `caution` та `important`.\n:::\n\n::: {.callout-tip}\n## Підказка\n\nПриклад виноски з текстом\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Розгорніть, щоб дізнатися про згортання\n\nЦе приклад «згорнутої» виноски з попередженням.\nВикористайте `collapse=\"true\"` щоб згорнути її за замовчуванням та `collapse=\"false\"` щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n:::\n\n9.5.10 Спеціальні символи\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\nтире: -\nтире: -\n\n\nкоротке (середнє) тире: --\nкоротке (середнє) тире: –\n\n\nдовге тире: ---\nдовге тире: —\n\n\n\n\n\n\n\n\n\nПриклади\n\n\n\n\nЖиття прожити — не поле перейти (довге тире)\n2020–2022 (коротке тире)\n25 - 5 (тире)"
  },
  {
    "objectID": "quarto.html#виконання-коду",
    "href": "quarto.html#виконання-коду",
    "title": "\n9  Quarto\n",
    "section": "\n9.6 Виконання коду",
    "text": "9.6 Виконання коду\n\n9.6.1 Налаштування виводу\nІснує широкий спектр доступних параметрів для налаштування виводу виконаного коду. Усі ці параметри можна вказати глобально (у YAML-шапці з ключем execute) або для кожного блоку коду.\n\nПриклад глобальних налаштувань:\n\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\nexecute:\n  echo: false\n---\n\nПриклад налаштування конкретного чанку:\n\n#| echo: true\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nx = np.arange(-4, 4, .012)\ny = np.arange(-4, 4, .012)\nX, Y = np.meshgrid(x, y)\nZ = 1 - np.abs(X) - np.sin(Y**2)\nW = 1 + Y - np.cos(X**2)\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(projection='polar')\nplt.scatter(Z, W, alpha=.03, s=0.2)\nplt.axis('off')\nplt.show()\nПараметри налаштування знаходяться у верхній частині блоку під спеціальним коментарем #|.\n\n\n\n\n\n\nНалаштування\nОпис\n\n\n\neval\nОцініть фрагмент коду (якщо false, просто відтворіть код).\n\n\necho\nПоказувати код (якщо false, код не буде виведено на екран).\n\n\nwarning\nПоказувати попередження, які виникають під час виконання коду\n\n\nerror\nПоказувати помилки у документі (це означає, що помилки під час виконання коду не зупинять обробку документа).\n\n\ninclude\nЗапобігає виводу коду та його результатів.\n\n\n\n9.6.2 Вбудований код\nQuarto дозволяє виводити результат коду в середині тексту. Це особливо зручно, якщо необхідно щоб документ використовував найсвіжіші розрахунки. Проте синтаксис виводу залежить від рушія (анг. engine) Quarto: Jupyter, Knitr або OJS.\n\n9.6.2.1 Jupyter\nЩоб включити збережену змінну, використовуєте IPython.display.Markdown.\nНаприклад, виведемо площу кола за заданим радіусом (radius):\n#| echo: false\n\nfrom IPython.display import Markdown\nimport math\n\nradius = 10\ncircle_area = math.pi * pow(radius, 2)\n\nMarkdown((f\"\"\"\nПлоща кола з радіусом {radius} дорівнює {round(circle_area, 2)}.\n\"\"\"\n))\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що ми використовуємо опцію echo: false, щоб не виводити код у фінальний документ, а тільки результат.\n\n\n\n9.6.2.2 Knitr\nАналогічно до роботи з таблицями (див. Розділ 9.5.5.2) можемо поєднати можливості R та Python для виводу результату коду в тексті документу.\nЩоб включити вирази в розмітку для Knitr, використовується вираз у `r `:\n#| include: false\n\nlibrary(reticulate)\n#| echo: false\n\nimport math\n\nradius = 10\ncircle_area = round(math.pi * pow(radius, 2), 2)\nПлоща кола з радіусом  `r⠀py$radius`  дорівнює `r⠀py$circle_area`.\n\n\n\n\n\n\nПримітка\n\n\n\nЗапис py$radius означає: взяти значення змінної Python з ім’ям radius."
  },
  {
    "objectID": "quarto.html#основи-публікації",
    "href": "quarto.html#основи-публікації",
    "title": "\n9  Quarto\n",
    "section": "\n9.7 Основи публікації",
    "text": "9.7 Основи публікації\nІснує низка способів публікації документів, презентацій і веб-документів, створених за допомогою Quarto. Оскільки вміст, відтворений за допомогою Quarto, використовує стандартні формати (HTML, PDF, MS Word тощо), його можна опублікувати будь-де. Крім того, доступна команда quarto publish для легкої публікації в різних популярних службах (GitHub, Netlify, RStudio Connect тощо), а також різні інструменти, які полегшують публікацію з системи Неперервної інтеграції (анг. Continuous integration).\nСервіси для публікації:\n\n\n\n\n\n\nСервіс\nОпис\n\n\n\nQuarto Pub\nПублікація документів, веб-сайтів і книг Quarto.\n\n\nGitHub Pages\nПублікація документів за допомогою репозиторію GitHub\n\n\nRStudio Connect\nПлатформа для безпечного обміну даними в межах організації.\n\n\nNetlify\nПрофесійна платформа веб-публікації.\n\n\nІнші сервіси\nСкористайтеся цими сервісами, якщо один із наведених вище методів не відповідає вашим вимогам."
  },
  {
    "objectID": "quarto.html#footnotes",
    "href": "quarto.html#footnotes",
    "title": "\n9  Quarto\n",
    "section": "",
    "text": "YAML це рекурсивний акронім YAML Ain’t Markup Language («YAML — не мова розмітки»). У назві відображена історія розвитку: на ранніх етапах мова називалася Yet Another Markup Language («Ще одна мова розмітки») і навіть розглядалася як конкурент XML, але пізніше була перейменована з метою акцентувати увагу на даних, а не на розбивці документів.↩︎"
  },
  {
    "objectID": "sql_window.html#ранжуючі-функції",
    "href": "sql_window.html#ранжуючі-функції",
    "title": "8  Віконні функції",
    "section": "8.7 Ранжуючі функції",
    "text": "8.7 Ранжуючі функції\nПочнемо знайомство з віконними функціями з найпростіших завдань. Для початку попрацюємо з ранжуючими функціями:\nSELECT ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS row_number\nFROM table\n\nSELECT RANK() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS rank\nFROM table\n\nSELECT DENSE_RANK() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS dense_rank\nFROM table\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 8.1  Застосуйте віконні функції до таблиці products і за допомогою ранжирующих функцій упорядкуйте всі товари за ціною від найдорожчих до найдешевших. Додайте до таблиці наступні колонки:\n\nКолонку product_number із порядковим номером товару (функція ROW_NUMBER).\nКолонку product_rank із рангом товару з пропусками рангів (функція RANK).\nКолонку product_dense_rank з рангом товару без перепусток рангів (функція DENSE_RANK).\n\nНе забувайте вказувати у вікні сортування записів — без неї ранжуючі функції можуть давати некоректний результат, якщо таблиця заздалегідь не відсортована. Поділ на партиції всередині вікна зараз не потрібний. Сортувати записи в результуючій таблиці також не потрібно.\nПоля в результуючій таблиці: product_id, name, price, product_number, product_rank, product_dense_rank\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       row_number() OVER (ORDER BY price desc) as product_number,\n       rank() OVER (ORDER BY price desc) as product_rank,\n       dense_rank() OVER (ORDER BY price desc) as product_dense_rank\nFROM   products\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\nproduct_number\nproduct_rank\nproduct_dense_rank\n\n\n\n\n0\n13\ncaviar\n800.0\n1\n1\n1\n\n\n1\n37\nmutton\n559.0\n2\n2\n2\n\n\n2\n15\nolive oil\n450.0\n3\n3\n3\n\n\n3\n57\npork\n450.0\n4\n3\n3\n\n\n4\n43\ndecaffeinated coffee\n400.0\n5\n5\n4\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n83\n83\n49\n\n\n83\n5\ncoffee 3 in 1\n15.0\n84\n84\n50\n\n\n84\n73\ncake\n15.0\n85\n84\n50\n\n\n85\n10\nseeds\n12.0\n86\n86\n51\n\n\n86\n54\npaper bag\n1.0\n87\n87\n52\n\n\n\n\n87 rows × 6 columns"
  },
  {
    "objectID": "sql_window.html#агрегатні-функції",
    "href": "sql_window.html#агрегатні-функції",
    "title": "8  Віконні функції",
    "section": "8.8 Агрегатні функції",
    "text": "8.8 Агрегатні функції\nЗ ранжуючими функціями розібралися, тепер давайте навчимося в парі з віконними і агрегуючі функції:\nSELECT SUM(column) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS sum\nFROM table\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 8.2  Застосуйте віконну функцію до таблиці products і за допомогою агрегатної функції в окремій колонці для кожного запису проставте ціну найдорожчого товару. Колонку із цим значенням назвіть max_price. Потім для кожного товару порахуйте частку його ціни у вартості найдорожчого товару - просто поділіть одну колонку на іншу. Отримані частки округліть до двох знаків після коми. Колонку із частками назвіть share_of_max.\nВиведіть всю інформацію про товари, включаючи значення у нових колонках. Результат відсортуйте спочатку за спаданням ціни товару, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, max_price, share_of_max\nПояснення:\nУ цьому вся задачі вікном виступає вся таблиця. Сортувати всередині вікна вказувати не потрібно.\nЗ результатом агрегації з вікном можна проводити арифметичні та логічні операції. Також до нього можна застосовувати й інші функції - наприклад, округлення, як у цій задачі.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       max(price) OVER () as max_price,\n       round(price / max(price) OVER (), 2) as share_of_max\nFROM   products\nORDER BY price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\nmax_price\nshare_of_max\n\n\n\n\n0\n13\ncaviar\n800.0\n800.0\n1.00\n\n\n1\n37\nmutton\n559.0\n800.0\n0.70\n\n\n2\n15\nolive oil\n450.0\n800.0\n0.56\n\n\n3\n57\npork\n450.0\n800.0\n0.56\n\n\n4\n43\ndecaffeinated coffee\n400.0\n800.0\n0.50\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n800.0\n0.03\n\n\n83\n5\ncoffee 3 in 1\n15.0\n800.0\n0.02\n\n\n84\n73\ncake\n15.0\n800.0\n0.02\n\n\n85\n10\nseeds\n12.0\n800.0\n0.02\n\n\n86\n54\npaper bag\n1.0\n800.0\n0.00\n\n\n\n\n87 rows × 5 columns"
  },
  {
    "objectID": "sql_window.html#віконні-функції-та-order-by",
    "href": "sql_window.html#віконні-функції-та-order-by",
    "title": "8  Віконні функції",
    "section": "8.9 Віконні функції та ORDER BY",
    "text": "8.9 Віконні функції та ORDER BY\nА тепер давайте доповнимо наш попередній запит і вкажемо інструкцію ORDER BY для вікна, що працює в парі агрегатною функцією.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 8.3  Застосуйте дві віконні функції до таблиці products — одна з функцією MAX, а інша MIN — для обчислення максимальної та мінімальної ціни. Для двох вікон задайте інструкцію ORDER BY щодо зменшення ціни. Помістіть результат обчислень у дві колонки max_price та min_price.\nВиведіть всю інформацію про товари, включаючи значення у нових колонках. Результат відсортуйте спочатку за спаданням ціни товару, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, max_price, min_price\nПісля того, як вирішите завдання, проаналізуйте отриманий результат і подумайте, чому вийшли саме такі розрахунки. За потреби поверніться до першого кроку і ще раз уважно ознайомтеся з тим, як працює рамка вікна під час сортування.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       max(price) OVER (ORDER BY price desc) as max_price,\n       min(price) OVER (ORDER BY price desc) as min_price\nFROM   products\nORDER BY price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\nmax_price\nmin_price\n\n\n\n\n0\n13\ncaviar\n800.0\n800.0\n800.0\n\n\n1\n37\nmutton\n559.0\n800.0\n559.0\n\n\n2\n15\nolive oil\n450.0\n800.0\n450.0\n\n\n3\n57\npork\n450.0\n800.0\n450.0\n\n\n4\n43\ndecaffeinated coffee\n400.0\n800.0\n400.0\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n800.0\n25.0\n\n\n83\n5\ncoffee 3 in 1\n15.0\n800.0\n15.0\n\n\n84\n73\ncake\n15.0\n800.0\n15.0\n\n\n85\n10\nseeds\n12.0\n800.0\n12.0\n\n\n86\n54\npaper bag\n1.0\n800.0\n1.0\n\n\n\n\n87 rows × 5 columns\n\n\n\n\nТепер застосуємо віконну функцію з інструкцією ORDER BY для вирішення практичного завдання.\nЯк ми пам’ятаємо з першого кроку, вказівка сортування визначає рамку вікна від початку таблиці або партиції до поточного рядка. Давайте використовуємо цю особливість розрахунку кумулятивної суми, тобто зробимо так, щоб для кожного запису повертався результат додавання її значення зі значеннями всіх попередніх записів.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 8.4  Спочатку на основі таблиці orders сформуйте нову таблицю із загальною кількістю замовлень по дням. Підраховуючи кількість замовлень, не враховуйте скасовані замовлення (їх можна визначити за таблицею user_actions). Колонку з днями назвіть date, а колонку з числом замовлень orders_count.\nПотім помістіть отриману таблицю в підзапит і застосуйте до неї віконну функцію в парі з функцією SUM для розрахунку кумулятивної суми числа замовлень. Не забудьте для вікна вказати інструкцію ORDER BY за датою.\nНазвіть колонку з накопичувальною сумою orders_cum_count. В результаті такої операції значення кумулятивної суми для останнього дня має вийти рівним загальній кількості замовлень за весь період.\nСортувати результуючу таблицю робити не потрібно.\nПоля в результуючій таблиці: date, orders_count, orders_cum_count\nПояснення:\nЗверніть увагу, що віконні функції як результат повертають значення типу DECIMAL, незважаючи на те, що вхідне значення знаходиться у форматі INTEGER. Тому не забудьте отримане значення кумулятивної суми додатково привести до цілісного формату.\n\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT creation_time::date as date,\n    COUNT(*) as orders_count\nFROM orders\nWHERE order_id NOT IN (SELECT order_id from user_actions WHERE action = 'cancel_order')\nGROUP BY date)\n\nselect date,\n    orders_count,\n    SUM(orders_count) OVER (ORDER BY date)::integer as orders_cum_count\nFROM t1\n\n\n\n\n\n\n\n\n\ndate\norders_count\norders_cum_count\n\n\n\n\n0\n2022-08-24\n138\n138\n\n\n1\n2022-08-25\n1059\n1197\n\n\n2\n2022-08-26\n1447\n2644\n\n\n3\n2022-08-27\n2141\n4785\n\n\n4\n2022-08-28\n2998\n7783\n\n\n5\n2022-08-29\n3267\n11050\n\n\n6\n2022-08-30\n3371\n14421\n\n\n7\n2022-08-31\n3410\n17831\n\n\n8\n2022-09-01\n3688\n21519\n\n\n9\n2022-09-02\n5001\n26520\n\n\n10\n2022-09-03\n5709\n32229\n\n\n11\n2022-09-04\n6010\n38239\n\n\n12\n2022-09-05\n4675\n42914\n\n\n13\n2022-09-06\n3451\n46365\n\n\n14\n2022-09-07\n4777\n51142\n\n\n15\n2022-09-08\n5474\n56616"
  },
  {
    "objectID": "sql_window.html#віконні-функції-та-partition-by",
    "href": "sql_window.html#віконні-функції-та-partition-by",
    "title": "8  Віконні функції",
    "section": "8.10 Віконні функції та PARTITION BY",
    "text": "8.10 Віконні функції та PARTITION BY\nУ попередніх завданнях як вікно виступала вся таблиця. Тепер давайте навчимося додавати у параметри вікна поділ на партиції та попрацюємо з інструкцією PARTITION BY.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 8.5  Для кожного користувача у таблиці user_actions порахуйте порядковий номер кожного замовлення. Для цього застосовуйте віконну функцію ROW_NUMBER до колонки з часом замовлення. Не забудьте вказати поділ на партиції за користувачами та сортування усередині партицій. Скасовані замовлення не враховуйте. Нову колонку із порядковим номером замовлення назвіть order_number. Результат відсортуйте спочатку за зростанням ID користувача, потім за зростанням order_number. Додати LIMIT 1000.\nПоля в результуючій таблиці: user_id, order_id, time, order_number\n\n\n\n%%sql SELECT user_id, order_id, time, row_number() OVER (PARTITION BY user_id ORDER BY time) as order_number FROM user_actions WHERE order_id not in (SELECT order_id FROM user_actions WHERE action = ‘cancel_order’) ORDER BY user_id, order_number limit 1000"
  },
  {
    "objectID": "sql_window.html#віконні-функції-та-зміщення",
    "href": "sql_window.html#віконні-функції-та-зміщення",
    "title": "8  Віконні функції",
    "section": "8.11 Віконні функції та зміщення",
    "text": "8.11 Віконні функції та зміщення\nТепер давайте попрацюємо з функціями зміщення – у цьому теж немає нічого складного:\nSELECT LAG(column, 1) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS lag_value\nFROM table\n\nSELECT LEAD(column, 1) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS lead_value\nFROM table\nВ якості першого аргументу функцій LAG і LEAD вказується колонка зі значеннями, в якості другого — те, скільки рядків проводити зміщення (назад і вперед відповідно). Другий аргумент можна не вказувати, за умовчанням його значення дорівнює 1.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 8.6  Доповніть запит із попереднього завдання та за допомогою віконної функції для кожного замовлення кожного користувача розрахуйте, скільки часу пройшло з попереднього замовлення.\nДля цього спочатку в окремому стовпці за допомогою LAG зробіть зміщення по стовпцю часу на одне значення назад. Стовпець зі зміщеними значеннями назвіть time_lag. Потім відніміть від кожного значення колонці time нове значення зі зміщенням (або можете використовувати вже знайому функцію AGE). Назвіть колонку з отриманим інтервалом time_diff. Змінювати формат відображення значень не потрібно, вони повинні мати приблизно такий вигляд:\n3 days, 12:18:22\nЯк і раніше, не враховуйте скасовані замовлення. Також залиште у запиті порядковий номер кожного замовлення, розрахований на минулому етапі. Результат відсортуйте спочатку за зростанням ID користувача, потім за зростанням порядкового номера замовлення. Додати LIMIT 1000.\nПоля в результуючій таблиці: user_id, order_id, time, order_number, time_lag, time_diff\nПояснення:\nНе забувайте про поділ на партиції та сортування усередині вікна.\nТакож зверніть увагу, що в результаті зміщення перших замовлень кожного користувача в колонці time_lag вийшли пропущені значення. Для таких записів функція не знайшла попередніх значень та повернула NULL. Те саме сталося в записах користувачів з одним замовленням — усередині партиції з одним записом просто нема куди зміщатися.\nПропущені значення, що утворилися, прибирати з результату не потрібно.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       time,\n       row_number() OVER (PARTITION BY user_id\n                          ORDER BY time) as order_number,\n       lag(time, 1) OVER (PARTITION BY user_id\n                          ORDER BY time) as time_lag,\n       time - lag(time, 1) OVER (PARTITION BY user_id\n                                 ORDER BY time) as time_diff\nFROM   user_actions\nWHERE  order_id not in (SELECT order_id\n                        FROM   user_actions\n                        WHERE  action = 'cancel_order')\nORDER BY user_id, order_number limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\ntime\norder_number\ntime_lag\ntime_diff\n\n\n\n\n0\n1\n1\n2022-08-24 01:52:00\n1\nNaT\nNaT\n\n\n1\n1\n4683\n2022-08-27 20:56:00\n2\n2022-08-24 01:52:00\n3 days 19:04:00\n\n\n2\n1\n22901\n2022-09-02 00:58:00\n3\n2022-08-27 20:56:00\n5 days 04:02:00\n\n\n3\n1\n23149\n2022-09-02 02:36:00\n4\n2022-09-02 00:58:00\n0 days 01:38:00\n\n\n4\n2\n2\n2022-08-24 06:37:00\n1\nNaT\nNaT\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n995\n248\n13935\n2022-08-30 17:13:00\n8\n2022-08-30 11:04:00\n0 days 06:09:00\n\n\n996\n248\n15518\n2022-08-31 02:25:00\n9\n2022-08-30 17:13:00\n0 days 09:12:00\n\n\n997\n249\n287\n2022-08-25 03:54:00\n1\nNaT\nNaT\n\n\n998\n249\n758\n2022-08-25 15:19:00\n2\n2022-08-25 03:54:00\n0 days 11:25:00\n\n\n999\n249\n7347\n2022-08-28 19:27:00\n3\n2022-08-25 15:19:00\n3 days 04:08:00\n\n\n\n\n1000 rows × 6 columns\n\n\n\n\nДавайте для повноти картини порахуємо, скільки в середньому проходить між замовленнями кожного користувача.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 8.7  На основі запиту попереднього завдання для кожного користувача розрахуйте, скільки в середньому часу проходить між його замовленнями. Порахуйте цей показник лише для користувачів, які за весь час оформили більше одного замовлення.\nСередній час між замовленнями виразіть у годинах, округливши значення до цілого числа. Колонку із середнім значенням часу назвіть hours_between_orders. Результат відсортуйте за зростанням id користувача.\nДодайте в запит оператор LIMIT і включіть у результат лише перші 1000 записів.\nПоля у результуючій таблиці: user_id, hours_between_orders\nПояснення:\nЩоб перевести значення інтервалу в години, необхідно витягти з нього кількість секунд, а потім поділити на кількість секунд в одній годині. Для отримання кількості секунд з інтервалу можна скористатися такою конструкцією:\nSELECT EXTRACT(epoch FROM INTERVAL '3 days, 1:21:32')\n\nРезультат:\n264092  \nФункція EXTRACT працює аналогічно до функції DATE_PART, яку ми розглядали раніше, але має дещо інший синтаксис. Спробуйте скористатися функцією EXTRACT у цій задачі.\nВ результаті всіх розрахунків для кожного користувача з більш ніж одним замовленням, у вас має вийти ціле число годин, яке в середньому проходить між його замовленнями. Подумайте, як отримати з даних користувачів з одним замовленням. За потреби додатково перетворіть середнє значення годин на цілий тип даних.\nПовторювати всі попередні віконні функції з попереднього запиту не обов’язково — залиште найнеобхідніше.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       avg(time_diff)::integer as hours_between_orders\nFROM   (SELECT user_id,\n               order_id,\n               time,\n               extract(epoch\n        FROM   (time - lag(time, 1)\n        OVER (\n        PARTITION BY user_id\n        ORDER BY time)))/3600 as time_diff\n        FROM   user_actions\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')) t\nWHERE  time_diff is not null\nGROUP BY user_id\nORDER BY user_id limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\nhours_between_orders\n\n\n\n\n0\n1\n72\n\n\n1\n2\n107\n\n\n2\n3\n64\n\n\n3\n4\n77\n\n\n4\n6\n10\n\n\n...\n...\n...\n\n\n995\n1125\n35\n\n\n996\n1126\n48\n\n\n997\n1127\n36\n\n\n998\n1129\n32\n\n\n999\n1130\n20\n\n\n\n\n1000 rows × 2 columns"
  },
  {
    "objectID": "sql_window.html#задачі-з-rows-between",
    "href": "sql_window.html#задачі-з-rows-between",
    "title": "8  Віконні функції",
    "section": "8.12 Задачі з ROWS BETWEEN",
    "text": "8.12 Задачі з ROWS BETWEEN\nНастав час трохи попрацювати з інструкцією ROWS BETWEEN, яку докладно розглядали раніше. Нагадаємо, що початок і кінець рамки задаються такими способами:\nUNBOUNDED PRECEDING\nзначення PRECEDING\nCURRENT ROW\nзначення FOLLOWING\nUNBOUNDED FOLLOWING\nОсь ще один приклад вказівки меж рамки:\nSELECT SUM(column_3) OVER (PARTITION BY column_1 \n                           ORDER BY column_2 \n                           ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING) AS sum\nFROM table\nАле в яких завданнях корисно вказувати рамку для розрахунків? Перше, що спадає на думку будь-якому аналітику, — ковзна середня.\nКовзне середнє - це показник, який обчислюється в кожній точці часового ряду як середнє значення за N попередніх періодів (днів, тижнів, місяців тощо в залежності від рівня агрегації даних). Ковзне середнє переміщається по часовому ряду і щоразу враховує фіксовану кількість значень - для проведення таких розрахунків якраз і потрібна рамка вікна, яка задається інструкцією ROWS BETWEEN.\nСпробуймо провести такі розрахунки на наших даних.\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 8.8  Спочатку на основі таблиці orders сформуйте нову таблицю із загальною кількістю замовлень щодня. Ви вже робили у завданні 8.4. Підраховуючи кількість замовлень, не враховуйте скасовані замовлення (їх можна визначити за таблицею user_actions). Назвіть колонку з кількістю замовлень orders_count.\nПотім помістіть отриману таблицю в підзапит і застосуйте до неї віконну функцію в парі з функцією AVG для розрахунку ковзного середнього числа замовлень. Ковзне середнє для кожного запису рахуйте за трьома попередніми днями. Подумайте, як правильно встановити межі рамки, щоб отримати коректні розрахунки.\nОтримані значення ковзного середнього округліть до двох знаків після коми. Колонку із розрахованим показником назвіть moving_avg. Сортувати результуючу таблицю робити не потрібно.\nПоля у результуючій таблиці: date, orders_count, moving_avg\nПояснення:\nПри вирішенні завдання можете пробувати різні межі рамки та перевіряти себе вручну. Важливо для кожної дати врахувати у розрахунках саме 3 попередні дні.\nЗаповнювати пропущені значення у цій задачі не потрібно. Подумайте чому вони могли з’явитися.\n\n\n\n\n\nРішення\n%%sql\nSELECT date, orders_count, \n       round(AVG(orders_count) over \n        ( order by orders_count  rows between 3 preceding and 1 preceding),2) as moving_avg\nfrom  (SELECT creation_time :: date as date,\n              count(order_id) as orders_count,\n              sum(count(order_id)) OVER (ORDER BY creation_time :: date) as orders_cum_count\n       FROM   orders\n       WHERE  order_id not in (SELECT order_id\n                               FROM   user_actions\n                               WHERE  action = 'cancel_order')\n       GROUP BY date) as t1\n\n\n\n\n\n\n\n\n\ndate\norders_count\nmoving_avg\n\n\n\n\n0\n2022-08-24\n138\nNaN\n\n\n1\n2022-08-25\n1059\n138.00\n\n\n2\n2022-08-26\n1447\n598.50\n\n\n3\n2022-08-27\n2141\n881.33\n\n\n4\n2022-08-28\n2998\n1549.00\n\n\n5\n2022-08-29\n3267\n2195.33\n\n\n6\n2022-08-30\n3371\n2802.00\n\n\n7\n2022-08-31\n3410\n3212.00\n\n\n8\n2022-09-06\n3451\n3349.33\n\n\n9\n2022-09-01\n3688\n3410.67\n\n\n10\n2022-09-05\n4675\n3516.33\n\n\n11\n2022-09-07\n4777\n3938.00\n\n\n12\n2022-09-02\n5001\n4380.00\n\n\n13\n2022-09-08\n5474\n4817.67\n\n\n14\n2022-09-03\n5709\n5084.00\n\n\n15\n2022-09-04\n6010\n5394.67"
  }
]