[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python в науці про дані",
    "section": "",
    "text": "Вступне слово\nКнига-конспект матеріалів з курсу “Python for Data Science”."
  },
  {
    "objectID": "sql.html#схема-бази-даних",
    "href": "sql.html#схема-бази-даних",
    "title": "SQL",
    "section": "Схема бази даних",
    "text": "Схема бази даних\nУ цьому розділі ми будемо використовувати набори даних, які представляють сервіс з доставки продуктів. Тут зберігається документація, котра допоможе розібратися з ними. У таблиці продемонстровані зв’язки між таблицями, а також опис даних.\n\n\n\n\nerDiagram\n    orders }|..|{ products : product_ids-product_id\n    orders }|..|{ courier_actions : order_id\n    users }|..|{ user_actions : user_id\n    user_actions }|..|{ orders : order_id\n    user_actions }|..|{ courier_actions : time\n    courier_actions }|..|{ courier : product\n    \n    users {\n        DATE birth_date\n        VARCHAR sex\n        INT user_id\n    }\n    user_actions {\n        INT user_id\n        VARCHAR actions\n        INT order_id\n        TIMESTAMP time\n    }\n    orders {\n        INT order_id\n        ARRAY product_ids\n        TIMESTAMP creation_time\n    }\n    products {\n        INT product_id\n        NUMERIC price\n        VARCHAR name\n    }\n    courier_actions {\n        INT courier_id\n        VARCHAR action\n        INT order_id\n        TIMESTAMP time\n    }\n    courier {\n        INT courier_id\n        VARCHAR sex\n        DATE birth_date\n    }"
  },
  {
    "objectID": "sql.html#типи-даних",
    "href": "sql.html#типи-даних",
    "title": "SQL",
    "section": "Типи даних",
    "text": "Типи даних\nВ таблицях можуть зберігатися різні типи даних: цілі і дробові числа, текст, дати, масиви чисел. У цих даних ви зустрінетесь з наступними типами:\n\n\n\n\n\n\n\n\n\nТипи даних\nОпис\nПриклад\n\n\n\n\n0\nINT\nЦіле число\nid користувача: 123\n\n\n1\nNUMERIC / DECIMAL\nДійсне число\nВартість товару: 120.55\n\n\n2\nVARCHAR\nТекст\nДія із замовленням: «create_order»\n\n\n3\nDATE\nДата з точністю до дня\nДата народження користувача: 25/03/91\n\n\n4\nTIMESTAMP\nДата з точністю до секунди\nЧас реєстрації у додатку: 24/08/22 01:52:24\n\n\n5\n[]\nМасив\nСписок id товаров у замовленні: [1, 13, 22]\n\n\n\n\n\n\n\nБільш детально почитати про типи даних можна за посиланням"
  },
  {
    "objectID": "sql.html#структура-та-наповнення-таблиць",
    "href": "sql.html#структура-та-наповнення-таблиць",
    "title": "SQL",
    "section": "Структура та наповнення таблиць",
    "text": "Структура та наповнення таблиць\nuser_actions – дії користувачів із замовленнями.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\nuser_id\nINT\nid користувача\n\n\n1\norder_id\nINT\nid замовлення\n\n\n2\naction\nVARCHAR(50)\nдія користувача із замовленням; \"create_order\"...\n\n\n3\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\n\ncourier_actions – дії кур’єрів із замовленнями.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\norder_id\nINT\nid замовлення\n\n\n2\naction\nVARCHAR(50)\nдія кур'єра із замовленням; 'accept order' - п...\n\n\n3\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\n\norders - інформація про замовлення.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\norder_id\nINT\nid замовлення\n\n\n1\ncreation_time\nTIMESTAMP\nчас створення замовлення\n\n\n2\nproduct_ids\ninteger[]\nсписок id товарів у замовленні\n\n\n\n\n\n\n\nusers - інформація про користувачів.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\nuser_id\nINT\nid користувача\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\ncouriers - інформація про кур’єрів.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\nproducts - інформація про товари, які доставляє сервіс.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ дужках типу VARCHAR вказано максимально допустиму кількість символів у тексті. У типу даних NUMERIC у дужках вказано загальну кількість символів."
  },
  {
    "objectID": "sql_basics.html#select",
    "href": "sql_basics.html#select",
    "title": "2  Базові запити",
    "section": "2.1 SELECT",
    "text": "2.1 SELECT\nДавайте напишемо перший запит мовою SQL:\n\n%%sql\nSELECT *\nFROM orders\nLIMIT 5\n\n\n\n\n\n\n\n\norder_id\ncreation_time\nproduct_ids\n\n\n\n\n0\n1\n2022-08-24 01:52:00\n[65, 28]\n\n\n1\n2\n2022-08-24 06:37:00\n[35, 30, 42, 34]\n\n\n2\n3\n2022-08-24 07:35:00\n[24, 70, 77]\n\n\n3\n4\n2022-08-24 10:39:00\n[72, 40, 20]\n\n\n4\n5\n2022-08-24 12:34:00\n[48]\n\n\n\n\n\n\n\nДаний запис можна дослівно перекласти:\n\nSELECT *: “взяти все”.\nFROM courier_actions: з таблиці courier_actions.\nLIMIT 10: вивести тільки перші 10 спостережень.\n\nМи можемо написати більш явний запит і отримати той сами результат:\n\n%%sql\nSELECT \n    action, \n    courier_id, \n    order_id, \n    time\nFROM \n    courier_actions\nLIMIT 5\n\n\n\n\n\n\n\n\naction\ncourier_id\norder_id\ntime\n\n\n\n\n0\ncreate_order\n1\n1\n2022-08-24 01:52:00\n\n\n1\ncreate_order\n2\n2\n2022-08-24 06:37:00\n\n\n2\ncreate_order\n3\n3\n2022-08-24 07:35:00\n\n\n3\ncreate_order\n4\n4\n2022-08-24 10:39:00\n\n\n4\ncreate_order\n5\n5\n2022-08-24 12:34:00\n\n\n\n\n\n\n\nНа практиці таблиці можуть бути дуже великими, тому дуже бажано використовувати оператор LIMIT для того щоб не виводити всю таблицю, що може займати багато часу. Крім того, можливо такий запит навіть не буде виконано, оскільки розумні дата інженери заборонили виконувати такі запити.\n\n\n\n\n\n\nПримітка\n\n\n\nОператор FROM завжди вказується після оператора SELECT. У зворотному порядку їх записувати не можна – база даних поверне помилку."
  },
  {
    "objectID": "sql_basics.html#order-by",
    "href": "sql_basics.html#order-by",
    "title": "2  Базові запити",
    "section": "2.2 ORDER BY",
    "text": "2.2 ORDER BY\nДля сортування значень по будь-якій колонці SQL використовується оператор ORDER BY з ключовими словами ASC (за зростанням) або DESC (за спаданням).\nПри цьому за умовчанням сортування відбувається за зростанням, тобто ASC не обов’язково вказувати. Для сортування за спаданням після ORDER BY необхідно явно вказати DESC:\nSELECT column_1, column_2\nFROM table\nORDER BY column_1           -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 ASC       -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC      -- сортування за спаданням\n\nЗавдання 2.1 Виведіть всі записи з таблиці products, відсортувавши їх за найменуванням товарів у алфавітному порядку, тобто. за зростанням. Для сортування використовуйте оператор ORDER BY.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\n\nПримітка\n\n\n\nСортування можна робити не тільки по полях зі значеннями, вираженими числами, але й по полях, значення яких представлені у вигляді тексту, як у нашому випадку.\n\n\nРішення:\n\n\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nORDER BY name\nLIMIT 5\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n62\napple juice\n120.0\n\n\n1\n71\napples\n75.0\n\n\n2\n39\nbagels\n45.0\n\n\n3\n65\nbananas\n100.0\n\n\n4\n66\nbeef\n370.0\n\n\n\n\n\n\n\nСортувати результат SQL-запиту можна відразу за декількома колонками, вказуючи їх після ORDER BY через кому разом із напрямком сортування (ASC або DESC):\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2    -- спочатку сортування по першій колонці (за спаданням),\n                                    -- потім по другій (за зростанням)\n\n\n\n\n\n\nПримітка\n\n\n\nВажливо пам’ятати, що при роботі з великими таблицями потрібно по можливості обмежувати кількість виведених записів, щоб не створювати зайве навантаження на базу даних.\n\n\nОператори ORDER BY та LIMIT можна поєднувати в одному запиті, при цьому оператор LIMIT записується та виконується після оператора ORDER BY, обмежуючи кількість записів у вже відсортованому результаті:\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2\nLIMIT 5\n\nЗавдання 2.2 Відсортуйте таблицю courier_actions спочатку по колонці courier_id за зростанням id кур’єра, потім по колонці action (знову за зростанням), а потім по колонці time, але вже за спаданням — від останньої дії до першої. Не забудьте включити колонку order_id.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: courier_id, order_id, action, time.\n\n\n\n\n\n\nПримітка\n\n\n\nЯк ви вже здогадалися, сортувати таблиці можна навіть по полях з датами та часом.\n\n\n\n\n%%sql\nSELECT courier_id,\n       order_id,\n       action,\n       time\nFROM   courier_actions\nORDER BY courier_id, action, time DESC limit 5\n\n\n\n\n\n\n\n\ncourier_id\norder_id\naction\ntime\n\n\n\n\n0\n1\n1\ncreate_order\n2022-08-24 01:52:00\n\n\n1\n2\n2\ncreate_order\n2022-08-24 06:37:00\n\n\n2\n3\n3\ncreate_order\n2022-08-24 07:35:00\n\n\n3\n4\n4\ncreate_order\n2022-08-24 10:39:00\n\n\n4\n5\n5\ncreate_order\n2022-08-24 12:34:00\n\n\n\n\n\n\n\nЗараз важливо запам’ятати порядок запису всіх відомих нам ключових слів:\n\nSELECT\nFROM\nORDER BY\nLIMIT\n\nТакож важливо зрозуміти, що порядок їх виконання дещо відрізняється від того, в якій послідовності вони вказуються в SQL-запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nПотім SELECT - відбираються вказані стовпці.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\n\nЗавдання 2.3 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, визначте 5 найдорожчих товарів у таблиці products, які доставляє наш сервіс. Виведіть їх найменування та ціну.\nПоля у результуючій таблиці: name, price.\nРішення:\n\n\n%%sql\nSELECT name,\n       price\nFROM   products\nORDER BY price desc limit 5\n\n\n\n\n\n\n\n\nname\nprice\n\n\n\n\n0\ncaviar\n800.0\n\n\n1\nmutton\n559.0\n\n\n2\nolive oil\n450.0\n\n\n3\npork\n450.0\n\n\n4\ndecaffeinated coffee\n400.0"
  },
  {
    "objectID": "sql_basics.html#as",
    "href": "sql_basics.html#as",
    "title": "2  Базові запити",
    "section": "2.3 AS",
    "text": "2.3 AS\nПри складанні SQL-запитів колонкам у результуючій таблиці можна надавати будь-які інші імена (їх ще називають «аліасами»). Це можна робити за допомогою оператора AS:\nSELECT name AS new_name\nFROM table\nЯкщо раптом вам здасться, що на написання оператора AS йде занадто багато часу і сил, його можна опустити, вказавши нове ім’я колонки без нього. Наступний запис також спрацює:\nSELECT name new_name\nFROM table\n\nЗавдання 2.4 Повторіть запит із з попереднього прикладу (Завдання 2.3), але тепер колонки name і price перейменуйте відповідно на product_name і product_price.\nПоля у результуючій таблиці: product_name, product_price\nРішення:\n\n\n%%sql\n\nSELECT name AS product_name,\n       price AS product_price\nFROM   products\nORDER BY price desc limit 5\n\n\n\n\n\n\n\n\nproduct_name\nproduct_price\n\n\n\n\n0\ncaviar\n800.0\n\n\n1\nmutton\n559.0\n\n\n2\nolive oil\n450.0\n\n\n3\npork\n450.0\n\n\n4\ndecaffeinated coffee\n400.0"
  },
  {
    "objectID": "sql_basics.html#length",
    "href": "sql_basics.html#length",
    "title": "2  Базові запити",
    "section": "2.4 LENGTH",
    "text": "2.4 LENGTH\nУ SQL-запитах до колонок таблиць можна використовувати різні функції, наприклад, як в Excel.\nУ загальному вигляді синтаксис функцій виглядає приблизно так:\nSELECT function(a, b, c, ...)\nFROM table\nЗамість function вказується назва функції, а дужках — її аргументи. Як аргументи можуть виступати як колонки зі значеннями, так і окремі значення. Залежно від функції кількість аргументів може відрізнятися.\nЯкщо ви коли-небудь працювали в Excel, то вам, напевно, знайомі різні функції на кшталт SUM, MIN, MAX тощо, які роблять деякі обчислення по стовпцях. У SQL вони називаються агрегуючими функціями.\nЗараз як приклад розглянемо функцію LENGTH. Вона виконує досить просте завдання — підраховує кількість символів у поданому їй на вхід значенні текстового типу (текстовий тип даних часто називають рядком — від англ. «string»). Іншими словами, функція LENGTH вимірює довжину деякого рядка у символах:\n\n%%sql\nSELECT LENGTH('I.love.Python') as py_love\n\n\n\n\n\n\n\n\npy_love\n\n\n\n\n0\n13\n\n\n\n\n\n\n\nФункція LENGTH також може застосовуватись до всього стовпця. У такому випадку довжина символів буде порахована для кожного значення в стовпці. Відповідний запит виглядатиме так:\nSELECT LENGTH(column) AS column_length\nFROM table\n\nЗавдання 2.5 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, а також функцію LENGTH, визначте товар із найдовшою назвою у таблиці products. Виведіть його найменування, довжину найменування у символах, а також ціну цього товару. Назвіть колонку з довжиною найменування в символах name_length.\nПоля у результуючій таблиці: name, name_length, price.\nРішення:\n\n\n%%sql\nSELECT name,\n       length(name) as name_length,\n       price\nFROM   products\nORDER BY name_length desc limit 1\n\n\n\n\n\n\n\n\nname\nname_length\nprice\n\n\n\n\n0\nfruit drink blueberry\n21\n170.0\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що в цьому прикладі ви сортуєте результуючу таблицю по розрахунковій колонці name_length, якої спочатку не було таблиці products.\nТаке сортування за новими колонками можливе, оскільки це узгоджується з порядком виконання операторів у запиті: спочатку виконується вибір колонок і всі перетворення над ними в операторі SELECT — і тільки потім проводиться сортування за вказаними в ORDER BY стовпчиками. Тобто на момент сортування всі розрахункові поля вже існують, а значить, їх можна вказувати в ORDER BY.\nТакож зверніть увагу, що ми двічі вказуємо колонку name в операторі SELECT: вперше просто звертаємося до неї за ім’ям, а вдруге - використовуємо її як аргумент функції LENGTH. У цьому випадку теж немає жодних протиріч - ми можемо вибирати колонку стільки разів, скільки необхідно, причому для цього навіть необов’язково надавати цим колонкам різні аліаси (база даних сама перейменує дублікат колонки).\n\n\n:::\nУ SQL, як й у багатьох інших мовах, функції можна застосовувати до інших функцій, тобто. послідовно:\nSELECT function_one(function_two(a, b), c)\nУ наведеній вище конструкції a, b, c аргументи функцій. При цьому одним із аргументів функції function_one є результат виконання функції function_two.\nТаким чином, спочатку буде виконана функція function_two, а потім її результат буде поданий на вхід функції function_one як один з аргументів.\nРозглянемо такий випадок на прикладі функцій UPPER та LEFT. Функція UPPER наводить подане їй на вхід текстове значення до верхнього регістру:\nSELECT \n    UPPER('I.love.Python') AS upper_all\n\nРезультат:\nI.LOVE.PYTHON\nФункція LEFT повертає перші n символів у рядку:\nSELECT \n    LEFT('I.love.Python', 6) AS first_n\n\nРезультат:\nI.love\nМи можемо застосувати ці функції послідовно і в результаті отримаємо перші три символів верхнього регістру:\nSELECT \n    UPPER(LEFT('I.love.Python', 6))\n\nРезультат:\nI.LOVE\n\n\n\n\n\n\nОбережно\n\n\n\nВажливо: зверніть увагу, що у блоці SELECT не можна виконати дві операції окремо, тобто. ми не можемо спочатку створити розрахункову колонку з першими шістьма символами, а потім відразу ж звернутися до цієї нової колонки, застосувавши до неї функцію UPPER.\n\n\nНаступний запит не буде виконано, база даних поверне помилку:\nSELECT \n    LEFT('I.love.Python', 3) AS first_n,\n    UPPER(first_n) AS upper_first_n\n\nРезультат:\nError running query: column \"new_name\" does not exist\nВ межах одного запиту колонки створюються не по черзі, а разом, тому в межах одного запиту колонки upper_first_n не існує, поки блок SELECT не буде повністю виконаний. Дуже важливо враховувати цю особливість мови.\nОднак на практиці до нових колонок доводиться звертатися досить часто — саме для цього є підзапити (запити до інших запитів). А поки що нам достатньо розуміти, що застосовувати функції до розрахункових колонок у тому ж запиті не можна."
  },
  {
    "objectID": "sql_basics.html#split_part",
    "href": "sql_basics.html#split_part",
    "title": "2  Базові запити",
    "section": "2.5 SPLIT_PART",
    "text": "2.5 SPLIT_PART\nФункція SPLIT_PART розбиває поданий їй на вхід рядок на кілька частин відповідно до зазначеного роздільника та повертає одну з частин.\nКрім самого рядка (або колонки зі значеннями рядкового типу), функція приймає ще два аргументи — роздільник і порядковий номер частини, яку необхідно повернути. Подивіться наступний приклад:\n\nЗавдання 2.6  \nSELECT SPLIT_PART('I.love.Python', '.', 3)\n\nРезультат:\nPython\n\nУ прикладі вище рядок ‘I.love.Python’ було розбито на три частини (‘I’, ‘love’ та ‘Python’) по роздільнику “.”. Функція повернула ‘Python’, оскільки третім аргументом ми вказали частину із порядковим номером 3.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з іншими функціями для роботи з рядками можна ознайомитись за посиланням.\n\n\n\nЗавдання 2.7 Застосуйте послідовно функції UPPER та SPLIT_PART до колонки name та перетворіть найменування товарів у таблиці products так, щоб від назв залишилося тільки перше слово, записане у верхньому регістрі. Колонку з новою назвою, що складається із першого слова, назвіть first_word.\nУ результаті виведіть вихідні найменування товарів, нові найменування з першого слова, а також ціну товарів. Результат відсортуйте за зростанням початкового найменування товару в колонці name.\nПоля у результуючій таблиці: name, first_word, price\n\n\n%%sql\nSELECT\n    name,\n    UPPER(SPLIT_PART(name, ' ', 1)) AS first_word,\n    price\nFROM\n    products\nORDER BY\n    name\n\n\n\n\n\n\n\n\nname\nfirst_word\nprice\n\n\n\n\n0\napple juice\nAPPLE\n120.0\n\n\n1\napples\nAPPLES\n75.0\n\n\n2\nbagels\nBAGELS\n45.0\n\n\n3\nbananas\nBANANAS\n100.0\n\n\n4\nbeef\nBEEF\n370.0\n\n\n...\n...\n...\n...\n\n\n82\nwaffles\nWAFFLES\n55.0\n\n\n83\nwatermelon\nWATERMELON\n120.0\n\n\n84\nwhite chocolate\nWHITE\n60.0\n\n\n85\nyogurt\nYOGURT\n45.0\n\n\n86\nсowberry juice\nСOWBERRY\n190.0\n\n\n\n\n87 rows × 3 columns"
  },
  {
    "objectID": "sql_basics.html#cast",
    "href": "sql_basics.html#cast",
    "title": "2  Базові запити",
    "section": "2.6 CAST",
    "text": "2.6 CAST\nІноді виникає необхідність змінити тип даних у якійсь колонці результуючої таблиці, не змінюючи при цьому властивості вихідної таблиці, наприклад, перетворити число на текст (тип даних VARCHAR). І тому існує функція CAST.\nНа вхід функції CAST необхідно подати ім’я колонки, вказавши через AS тип даних, до якого потрібно привести всі значення:\nSELECT CAST(column AS VARCHAR)\nFROM table\nТакож можна змінити тип даних за допомогою спеціального синтаксису з двома двокрапками («::»):\nSELECT column::VARCHAR\nFROM table\nНаприклад, переведемо текст ‘100’ у число 100:\nSELECT CAST('100' AS INTEGER)\n\nРезультат:\n100\nЗверніть увагу, що для успішної конвертації значення повинні бути конвертованими у вказаний тип. Наприклад, текст, який не виглядає як число, перевести до числового типу даних не вийде:\nSELECT CAST('text' AS INTEGER)\n\nРезультат:\nError running query: invalid input syntax for type integer: \"text\"\nАналогічним чином можна, наприклад, перетворити текст на дату (якщо він виглядає як дата):\nSELECT '2022-12-31'::DATE as date\n\nРезультат:\n2022-12-31\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з функцією CAST та перетворенням типів даних можна ознайомитись за цим посиланням.\nПро самі типи даних можна почитати тут.\n\n\n\nЗавдання 2.8 Змініть тип колонки price з таблиці products на VARCHAR. Виведіть колонки з найменуванням товарів, ціною у вихідному форматі та ціною у форматі VARCHAR. Нову колонку з ціною у новому форматі назвіть price_char.\nРезультат відсортуйте за зростанням початкового найменування товару в колонці name. Кількість записів, що виводяться, не обмежуйте.\nПоля в результуючій таблиці: name, price, price_char\nРішення:\n\n\n%%sql\nSELECT \n    name,\n    price,\n    CAST(price as VARCHAR) as price_char\nFROM\n    products\nORDER BY\n    name\n\n\n\n\n\n\n\n\nname\nprice\nprice_char\n\n\n\n\n0\napple juice\n120.0\n120.0\n\n\n1\napples\n75.0\n75.0\n\n\n2\nbagels\n45.0\n45.0\n\n\n3\nbananas\n100.0\n100.0\n\n\n4\nbeef\n370.0\n370.0\n\n\n...\n...\n...\n...\n\n\n82\nwaffles\n55.0\n55.0\n\n\n83\nwatermelon\n120.0\n120.0\n\n\n84\nwhite chocolate\n60.0\n60.0\n\n\n85\nyogurt\n45.0\n45.0\n\n\n86\nсowberry juice\n190.0\n190.0\n\n\n\n\n87 rows × 3 columns"
  },
  {
    "objectID": "sql_basics.html#concat",
    "href": "sql_basics.html#concat",
    "title": "2  Базові запити",
    "section": "2.7 CONCAT",
    "text": "2.7 CONCAT\nУ цьому підрозділі ми ще трохи попрацюємо з текстовими даними та розглянемо функцію CONCAT, за допомогою якої можна з’єднувати в один рядок значення кількох стовпців.\nФункція CONCAT приймає на вхід кілька аргументів і повертає результат їхньої послідовної складання один з одним. Хороша аналогія - складання речень з різних карток зі словами:\nSELECT CONCAT('SQL', ' ', 'Python ', 2023)\n\nРезультат:\nSQL Python 2023\nПри цьому аргументи не обов’язково мають бути виражені текстовими значеннями — головне, вони мають бути конвертованими в текст. У прикладі вище число 2023 можна конвертувати в текст ‘2023’, тому запит працює без помилок.\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції CONCAT можна за посиланням.\n\n\n\nЗавдання 2.9 Для перших 5 записів з таблиці orders виведіть інформацію у такому вигляді (зверніть увагу на пробіли):\nЗамовлення № [id_замовлення] створено [дата]\nОтриману колонку назвіть order_info.\nПриклад результату:\nЗамовлення № 65 створено 2022-09-01\nРішення:\n\n\n%%sql\nSELECT \n    CONCAT(\n        'Замовлення № ',\n        order_id,\n        ' створено ',\n        creation_time::DATE\n        ) as order_info\nFROM   \n    orders\nLIMIT 5\n\n\n\n\n\n\n\n\norder_info\n\n\n\n\n0\nЗамовлення № 1 створено 2022-08-24\n\n\n1\nЗамовлення № 2 створено 2022-08-24\n\n\n2\nЗамовлення № 3 створено 2022-08-24\n\n\n3\nЗамовлення № 4 створено 2022-08-24\n\n\n4\nЗамовлення № 5 створено 2022-08-24"
  },
  {
    "objectID": "sql_basics.html#date_part",
    "href": "sql_basics.html#date_part",
    "title": "2  Базові запити",
    "section": "2.8 DATE_PART",
    "text": "2.8 DATE_PART\nЯк ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (DATE) і часу (TIMESTAMP). Давайте трохи попрацюємо з такими даними.\nНасправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція DATE_PART. Її синтаксис наступний:\nSELECT DATE_PART(part, column)\nНа місці part необхідно в лапках вказати ту частину, яку потрібно витягти: 'year', 'month', 'day', 'hour' тощо. На місці column слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:\nSELECT DATE_PART('day', DATE '2022-01-12')\n\nРезультат:\n12.00\n\n\nSELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')\n\nРезультат:\n31.00\nВище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами dates. Тоді запит виглядав би так:\nSELECT DATE_PART('day', dates)\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції DATE_PART можна за посиланням.\n\n\n::: {#exr-sql10} Виведіть id десяти відсотків кур’єрів та їхні роки народження з таблиці couriers, використовуючи вибірку Бернуллі та встановіть початкове значення генератора випадкових величин (seed) рівний 123.\nРік народження необхідно одержати з колонки birth_date. Нову колонку з роком назвіть birth_year.\nПоля у результуючій таблиці: courier_id, birth_year\nУ цьому прикладі ми використаємо випадкову вибірки Бернуллі за допомогою оператора USING SAMPLE, після котрого вказується розмір вибірки, а в дужках метод формування та початкове значення генератора випадкових величин.\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з прикладами формування вибірок у DuckDB можна за посиланням.\n\n\nРішення: ## DATE_PART\nЯк ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (DATE) і часу (TIMESTAMP). Давайте трохи попрацюємо з такими даними.\nНасправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція DATE_PART. Її синтаксис наступний:\nSELECT DATE_PART(part, column)\nНа місці part необхідно в лапках вказати ту частину, яку потрібно витягти: 'year', 'month', 'day', 'hour' тощо. На місці column слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:\nSELECT DATE_PART('day', DATE '2022-01-12')\n\nРезультат:\n12.00\n\n\nSELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')\n\nРезультат:\n31.00\nВище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами dates. Тоді запит виглядав би так:\nSELECT DATE_PART('day', dates)\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції DATE_PART можна за посиланням.\n\n\n::: {#exr-sql10} Виведіть id десяти відсотків кур’єрів та їхні роки народження з таблиці couriers, використовуючи вибірку Бернуллі та встановіть початкове значення генератора випадкових величин (seed) рівний 123.\nРік народження необхідно одержати з колонки birth_date. Нову колонку з роком назвіть birth_year.\nПоля у результуючій таблиці: courier_id, birth_year\nУ цьому прикладі ми використаємо випадкову вибірки Бернуллі за допомогою оператора USING SAMPLE, після котрого вказується розмір вибірки, а в дужках метод формування та початкове значення генератора випадкових величин.\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з прикладами формування вибірок у DuckDB можна за посиланням.\n\n\nРішення: ## DATE_PART\nЯк ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (DATE) і часу (TIMESTAMP). Давайте трохи попрацюємо з такими даними.\nНасправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція DATE_PART. Її синтаксис наступний:\nSELECT DATE_PART(part, column)\nНа місці part необхідно в лапках вказати ту частину, яку потрібно витягти: 'year', 'month', 'day', 'hour' тощо. На місці column слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:\nSELECT DATE_PART('day', DATE '2022-01-12')\n\nРезультат:\n12.00\n\n\nSELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')\n\nРезультат:\n31.00\nВище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами dates. Тоді запит виглядав би так:\nSELECT DATE_PART('day', dates)\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції DATE_PART можна за посиланням.\n\n\n\nЗавдання 2.10 Виведіть id десяти відсотків кур’єрів та їхні роки народження з таблиці couriers, використовуючи вибірку Бернуллі та встановіть початкове значення генератора випадкових величин (seed) рівний 123.\nРік народження необхідно одержати з колонки birth_date. Нову колонку з роком назвіть birth_year.\nПоля у результуючій таблиці: courier_id, birth_year\nУ цьому прикладі ми використаємо випадкову вибірки Бернуллі за допомогою оператора USING SAMPLE, після котрого вказується розмір вибірки, а в дужках метод формування та початкове значення генератора випадкових величин.\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з прикладами формування вибірок у DuckDB можна за посиланням.\n\n\nРішення:\n\n\n%%sql\nSELECT courier_id,\n       date_part('year', birth_date) birth_year\nFROM   couriers\nUSING SAMPLE 10 PERCENT (bernoulli, 123)\n\n\n\n\n\n\n\n\ncourier_id\nbirth_year\n\n\n\n\n0\n17\n1997.0\n\n\n1\n24\n1986.0\n\n\n2\n40\n1993.0\n\n\n3\n49\n1996.0\n\n\n4\n52\n1995.0\n\n\n...\n...\n...\n\n\n97\n933\n1987.0\n\n\n98\n934\n1994.0\n\n\n99\n978\n1991.0\n\n\n100\n981\n1989.0\n\n\n101\n1005\n1994.0\n\n\n\n\n102 rows × 2 columns\n\n\n\n\n%%sql\nSELECT * FROM couriers LIMIT 5\n\n\n\n\n\n\n\n\ncourier_id\nbirth_date\nsex\n\n\n\n\n0\n1\n1981-06-11\nfemale\n\n\n1\n2\n1991-06-27\nmale\n\n\n2\n3\n1994-05-04\nmale\n\n\n3\n4\n1999-06-02\nmale\n\n\n4\n5\n1998-12-22\nfemale"
  },
  {
    "objectID": "sql_basics.html#coalesce",
    "href": "sql_basics.html#coalesce",
    "title": "2  Базові запити",
    "section": "2.9 COALESCE",
    "text": "2.9 COALESCE\nВи могли помітити, що в минулому прикладі (Завдання 2.10) для окремих рядків функція DATE_PART не повернула рік народження кур’єра, а замість них утворилися порожні значення. Якщо не помітили, уважно подивіться на результат запиту.\nНасправді це сталося тому, що в наших даних у колонці birth_date є перепустки — так звані значення NULL (у виводі результату це NA). Іншими словами, для окремих кур’єрів просто не вказано їхні дні народження. Є безліч варіантів, чому так могло статися, але ми зараз не маємо часу все це з’ясовувати — нам просто потрібно навчитися якось обробляти такі випадки.\nДавайте зробимо так, щоб замість порожніх значень функція DATE_PART повертала якесь інше значення. У цьому нам допоможе функція COALESCE, яка повертає перше не NULL значення зі списку поданих на вхід аргументів.\nРоботу COALESCE можна описати так: вона буквально читає список значень зліва направо і, як тільки бачить значення, яке не є NULL, відразу ж повертає його та припиняє читання списку. Подивіться уважно на такі приклади:\nSELECT COALESCE(NULL, 'I am not NULL' , 'I.love.Python')\n\nРезультат:\nI am not NULL\n\n\nSELECT COALESCE(NULL, 25, 100, 150)\n\nРезультат:\n25\n\n\nSELECT COALESCE('NULL', 'I am not NULL', 'I.love.Python')\n\nРезультат:\nNULL\nОдним із аргументів функції COALESCE може бути результат виконання іншої функції:\nSELECT COALESCE(NULL, LOWER('I am not NULL'), 'I.love.Python')\n\nРезультат:\ni am not null\nЩоб заповнити пропуски в колонці, достатньо застосувати функцію COALESCE до колонки з пропусками та вказати як другий аргумент те значення, яке ми хочемо бачити замість NULL:\nSELECT COALESCE(column, 'filler value')\nFROM table\nФункція COALESCE застосовується до кожного значення колонки. Якщо це значення виявиться NULL, вона замінить його значення, вказане другим аргументом. Якщо значення колонці, навпаки, виявиться не NULL, то функція просто поверне це значення.\nПри цьому до колонки з перепустками можна заздалегідь застосовувати різні інші функції:\nSELECT COALESCE(LEFT(column, 5), 'filler value')\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nЗ іншими прикладами використання функції COALESCE можна за посиланням.\n\n\n\nЗавдання 2.11 Як і в попередньому прикладі (Завдання 2.10), знову виведіть id десяти відсотків кур’єрів та їх роки народження, тільки тепер до вилученого року застосуйте функцію COALESCE. Вкажіть параметри функції так, щоб замість значення NULL в результат потрапляло текстове значення unknown. Назви полів залиште колишніми.\nПоля у результуючій таблиці: courier_id, birth_year\nРішення:\n\n\n%%sql\nSELECT\n    courier_id,\n    COALESCE(date_part('year', birth_date)::VARCHAR, 'unknown') birth_year\nFROM\n    couriers\nUSING SAMPLE 10 PERCENT (bernoulli, 123)\n\n\n\n\n\n\n\n\ncourier_id\nbirth_year\n\n\n\n\n0\n17\n1997\n\n\n1\n24\n1986\n\n\n2\n40\n1993\n\n\n3\n49\n1996\n\n\n4\n52\n1995\n\n\n...\n...\n...\n\n\n97\n933\n1987\n\n\n98\n934\n1994\n\n\n99\n978\n1991\n\n\n100\n981\n1989\n\n\n101\n1005\n1994\n\n\n\n\n102 rows × 2 columns"
  },
  {
    "objectID": "sql_basics.html#арифметичні-оператори",
    "href": "sql_basics.html#арифметичні-оператори",
    "title": "2  Базові запити",
    "section": "2.10 Арифметичні оператори",
    "text": "2.10 Арифметичні оператори\nДля роботи з числовими значеннями в DuckDB доступны різні арифметичні оператори. Нижче наведена таблиця з найбільш вживаними операторами:\n\n\n\nОператор\nОпис\nПриклад\nРезультат\n\n\n\n\n+\nДодавання\n2 + 3\n5\n\n\n-\nВіднімання\n2 - 3\n-1\n\n\n*\nМноження\n2 * 3\n6\n\n\n/\nДілення\n4 / 2\n2\n\n\n%\nЗалишок від ділення\n5 % 4\n1\n\n\n^\nПіднесення до степеня\n2 ^ 3\n8\n\n\n\nЯкби ми захотіли перевести 7600 гривен у долари за курсом 1 долар = 40 гривень, то операція виглядала б так:\nSELECT 7500 / 40\n\nРезультат:\n190\nЯкби нам потрібно було відняти з кожного значення в одній із колонок нашої таблиці якесь число (наприклад, 100), то запит виглядав би так:\nSELECT column - 100\nFROM table\nКрім того, в арифметичних операціях можуть брати участь одразу кілька колонок. Наприклад, для кожного рядка таблиці можна обчислити середнє арифметичне двох чисел, які містяться у двох різних колонках:\nSELECT (column_1 + column_2) / 2 AS average\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з усіма арифметичними операторами можна за посиланням.\n\n\n\nЗавдання 2.12 Давайте уявимо, що з якоїсь незрозумілої причини ми раптом вирішили відразу підвищити ціну всіх товарів у таблиці products на 5%.\nВиведіть id та найменування всіх товарів, їх стару та нову ціну. Колонку зі старою ціною назвіть old_price, а колонку з новою – new_price.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price.\nРішення:\n\n\n%%sql\nSELECT \n    product_id,\n    name,\n    price as old_price,\n    price * 1.05 as new_price\nFROM\n    products\nORDER BY\n    new_price DESC, product_id\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n840.00\n\n\n1\n37\nmutton\n559.0\n586.95\n\n\n2\n15\nolive oil\n450.0\n472.50\n\n\n3\n57\npork\n450.0\n472.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n26.25\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.75\n\n\n84\n73\ncake\n15.0\n15.75\n\n\n85\n10\nseeds\n12.0\n12.60\n\n\n86\n54\npaper bag\n1.0\n1.05\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_basics.html#математичні-функції",
    "href": "sql_basics.html#математичні-функції",
    "title": "2  Базові запити",
    "section": "2.11 Математичні функції",
    "text": "2.11 Математичні функції\nПоряд з арифметичними операторами DuckDB також доступні різні математичні функції. Наприклад, для округлення чисел можна використовувати функцію ROUND:\nSELECT ROUND(100.5454, 2)\n\nРезультат:\n100.55\n\n\nSELECT ROUND(100.551, 1)\n\nРезультат:\n100.6\n\n\nSELECT ROUND(100.5511)\n\nРезультат:\n101.0\nПершим аргументом вказується саме значення, яке хочемо округлити. Другим число знаків після точки, до якої хочемо округлити. Другий аргумент вказувати не обов’язково: якщо його не вказати, відбудеться округлення до цілого числа (проте тип даних при цьому не зміниться).\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з усіма арифметичними операторами можна за посиланням.\n\n\n\nЗавдання 2.13 Знову, як і в минулому завданні (Завдання 2.12), підвищите ціну всіх товарів на 5%, тільки тепер до колонки з новою ціною застосуйте функцію ROUND. Виведіть id та найменування товарів, їх стару ціну, а також нову ціну із округленням. Нову ціну округліть до десятих, але тип даних не змінюйте.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price.\nРішення:\n\n\n%%sql\nSELECT \n    product_id,\n    name,\n    price as old_price,\n    ROUND(price * 1.05, 1) as new_price\nFROM\n    products\nORDER BY\n    new_price DESC, product_id\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n840.0\n\n\n1\n37\nmutton\n559.0\n587.0\n\n\n2\n15\nolive oil\n450.0\n472.5\n\n\n3\n57\npork\n450.0\n472.5\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.0\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n26.3\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.8\n\n\n84\n73\ncake\n15.0\n15.8\n\n\n85\n10\nseeds\n12.0\n12.6\n\n\n86\n54\npaper bag\n1.0\n1.1\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_basics.html#case",
    "href": "sql_basics.html#case",
    "title": "2  Базові запити",
    "section": "2.12 CASE",
    "text": "2.12 CASE\nА якби ми захотіли підвищити ціну не на всі товари, а, скажімо, тільки на дорогі?\nДля цього нам потрібно було б створити деяку функцію, яка перевіряла б кожне значення в колонці price і порівнювала б його з якимось пороговим значенням. Якби ціна виявлялася вищою за цей поріг, то функція підвищувала б ціну, а якщо ні — залишала б без змін.\nІ таку функцію можна задати за допомогою умовної конструкції CASE. Вона має наступний синтаксис:\nCASE  \nWHEN logical_expression_1 THEN expression_1\nWHEN logical_expression_2 THEN expression_2\n...\nELSE expression_else\nEND AS case_example\nЦя конструкція може бути громіздкою, але насправді в ній немає нічого складного. Логіка роботи оператора CASE досить проста:\n\nНа кожному етапі WHEN - THEN обчислюється деякий логічний вираз logical_expression, що стоїть після WHEN. Якщо воно виявляється істинним (TRUE), то в якості результату оператор повертає вираз expression, що стоїть після THEN, і закінчує свою роботу.\nЯкщо вираз виявляється помилковим (FALSE), то оператор продовжує роботу та перевіряє наступну умову.\nЯкщо жодна з умов не проходить перевірку на істинність, повертається вираз, вказаний після ELSE. При цьому ELSE вказувати не обов’язково - якщо його не вказати, то повернеться порожнє значення NULL (у разі, якщо всі перевірки після WHEN виявилися помилковими).\nНасамкінець обов’язково вказується ключове слово END, яке говорить про закінчення конструкції CASE. Також після END новому розрахунковому полю за допомогою AS можна надати деяке ім’я, але це робити не обов’язково. Обов’язковими є лише ключові слова CASE, WHEN, THEN та END.\n\nНаступна конструкція розіб’є весь список найменувань на три категорії: «м’ясо», «риба» та «інше». Відповідно, якщо у перших двох умовах ми не врахуємо якісь назви з колонки name (наприклад, «телятину»), то вони потраплять до категорії «інше».\nSELECT name,\n       CASE \n       WHEN name='свинина' OR name='баранина' OR name='курка' THEN \"м'ясо\"\n       WHEN name='тріска' OR name='форель' OR name='окунь' THEN 'риба'\n       ELSE 'інше'\n       END AS сategory\nFROM table\nТепер трохи про логічні вирази: SQL можуть включати оператори порівняння і логічні операції.\nДо операторів порівняння належать:\n\n= («рівно»)\n&lt;&gt; або != («не дорівнює»)\n&lt; («менше»)\n&gt; («більше»)\n&lt;= («менше або дорівнює»)\n&gt;= («більше чи дорівнює»)\n\nРезультатом роботи операторів порівняння можуть бути три стани:\n\nTRUE («істина»)\nFALSE (помилка)\nNULL («невизначений стан» - коли одне з порівнюваних значень NULL)\n\nЗ цими трьома станами можна проводити такі логічні операції:\n\nAND («І»)\nOR («АБО»)\nNOT («НЕ»)\n\nРезультатом цих логічних операцій також можуть бути три вищевказані логічні стани (TRUE, FALSE або NULL):\n\n\n\na\nb\na AND b\na OR b\n\n\n\n\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nNULL\nNULL\nTRUE\n\n\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nNULL\nFALSE\nNULL\n\n\nNULL\nNULL\nNULL\nNULL\n\n\n\n\n\n\na\nNOT a\n\n\n\n\nTRUE\nFALSE\n\n\nFALSE\nTRUE\n\n\nNULL\nNULL\n\n\n\nТаким чином, оператори порівняння та логічні операції дозволяють писати комплексні логічні вирази.\nЗапам’ятати всі ці таблиці та комбінації не обов’язково. Головне, завжди тримайте цю пам’ятку під рукою.\nПрипустимо, відомо, що \\(a=10\\) і \\(b=5\\). Тоді наступний логічний вираз поверне TRUE:\na &gt;= 10 OR b &gt; 10\nТакож важливо розуміти, що є пріоритети виконання операцій:\n\nмноження та поділ (* та /)\nдодавання та віднімання (+ та -)\nоператори порівняння (=, !=, &gt;, &lt;, &gt;=, &lt;=)\nNOT\nAND\nOR\n\nНа порядок виконання операторів можна також впливати за допомогою дужок. Вирази, поміщені в дужки, матимуть найвищий пріоритет — як у математиці.\n\nЗавдання 2.14 Підвищіть ціну на 5% тільки на товари, вартість яких перевищує 100 одиниць. Ціну решти товарів залиште без змін. Також не підвищуйте ціну на ікру (caviar), яка й так коштує 800 одиниць. Виведіть id та найменування всіх товарів, їх стару та нову ціну. Ціну округляти не потрібно.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price\nРішення:\n\n\n%%sql\nSELECT \n    product_id,\n    name,\n    price as old_price,\n    CASE\n    WHEN price &lt;= 100 or name = 'caviar' THEN price\n    ELSE price * 1.05\n    END AS new_price\nFROM\n    products\nORDER BY\n    new_price DESC, product_id\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n800.00\n\n\n1\n37\nmutton\n559.0\n586.95\n\n\n2\n15\nolive oil\n450.0\n472.50\n\n\n3\n57\npork\n450.0\n472.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n25.00\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.00\n\n\n84\n73\ncake\n15.0\n15.00\n\n\n85\n10\nseeds\n12.0\n12.00\n\n\n86\n54\npaper bag\n1.0\n1.00\n\n\n\n\n87 rows × 4 columns\n\n\n\nУявіть, що до вас звернувся менеджер із сусіднього відділу із проханням порахувати ПДВ кожного товару. Жодних додаткових даних він вам не надав, тому ви вирішили виконати завдання на власний розсуд, вважаючи, що ПДВ єдиний для всіх товарів і становить 20%.\n\nЗавдання 2.15 Обчисліть ПДВ кожного товару у таблиці products та розрахуйте ціну без урахування ПДВ. Виведіть всю інформацію про товари, включаючи суму податку та ціну без його врахування. Колонки із сумою податку та ціною без ПДВ назвіть відповідно tax та price_before_tax. Округліть значення у цих колонках до двох знаків після коми.\nРезультат відсортуйте спочатку за спаданням ціни товару без урахування ПДВ, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, tax, price_before_tax.\nРішення:\n\n\n%%sql\nSELECT \n    product_id,\n    name,\n    price,\n    ROUND((price * 0.2) / 1.2, 2) as tax,\n    ROUND(price / 1.2, 2) as price_before_tax\nFROM\n    products\nORDER BY\n    price_before_tax DESC, product_id\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ntax\nprice_before_tax\n\n\n\n\n0\n13\ncaviar\n800.0\n133.33\n666.67\n\n\n1\n37\nmutton\n559.0\n93.17\n465.83\n\n\n2\n15\nolive oil\n450.0\n75.00\n375.00\n\n\n3\n57\npork\n450.0\n75.00\n375.00\n\n\n4\n43\ndecaffeinated coffee\n400.0\n66.67\n333.33\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n4.17\n20.83\n\n\n83\n5\ncoffee 3 in 1\n15.0\n2.50\n12.50\n\n\n84\n73\ncake\n15.0\n2.50\n12.50\n\n\n85\n10\nseeds\n12.0\n2.00\n10.00\n\n\n86\n54\npaper bag\n1.0\n0.17\n0.83\n\n\n\n\n87 rows × 5 columns"
  },
  {
    "objectID": "sql_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "href": "sql_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "title": "2  Базові запити",
    "section": "2.13 Типові помилки при написанні SQL-запитів.",
    "text": "2.13 Типові помилки при написанні SQL-запитів.\n\nНеправильний порядок або помилки у ключових словах. Правильний порядок операторів у запиті виглядає так:\n\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- угруповання даних\nHAVING      -- фільтрація даних після угруповання\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\nНеправильно названі функції та оператори, що використовуються в запиті (наприклад, DATEPART, а не DATE_PART).\nНеправильно вказано імена стовпців.\nНеправильно виконано сортування записів.\nНеправильно проведено розрахунки.\nПропущена кома при перерахуванні стовпців у SELECT\nЗайва кома після імені останнього стовпця в SELECT\nНе закриті дужки (перевірте, що кількість дужок дорівнює кількості закривають).\nДопущено помилку в підзапиті (перед виконанням всього запиту перевірте, чи працюють окремі підзапити).\nЗапущено відразу кілька запитів, не розділених крапкою з комою."
  },
  {
    "objectID": "sql_filtering.html#where",
    "href": "sql_filtering.html#where",
    "title": "3  Фільтрація даних",
    "section": "3.1 WHERE",
    "text": "3.1 WHERE\nВ SQL для фільтрації даних використовується оператор WHERE. Після оператора WHERE вказується логічний вираз, результат якого визначає, чи буде рядок включений до результуючої таблиці. Якщо умова виявляється істинною (TRUE), то рядок включається до результату, якщо хибним (FALSE) — рядок виключається.\nТаким чином, кожен рядок у таблиці проходить перевірку на відповідність певній умові, і в результаті цих перевірок формується таблиця, над якою проводяться операції, зазначені в блоці SELECT.\nОператор WHERE та логічний вираз вказуються після блоку FROM:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 0\nНаприклад, у результаті зазначеного вище запиту у вибірці попадуть лише записи з невід’ємними значеннями в колонці column_2.\nУ свою чергу оператори ORDER BY і LIMIT записуються вже після оператора WHERE. Якщо додати їх у приклад вище, запит виглядатиме так:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 0\nORDER BY column_1\nLIMIT 100\nУ результаті ми спочатку відфільтруємо необхідні нам рядки, потім виберемо стовпчики, виділені в SELECT, а потім сортуємо результуючу таблицю, обмеживши число виведених записів.\nТаким чином порядок запису відомих нам на поточний момент ключових слів виглядає так:\n\nSELECT\nFROM\nWHERE\nORDER BY\nLIMIT\n\nЗнову звернемо увагу, що порядок виконання відрізняється від того, в якій послідовності вони вказуються в запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nДалі WHERE - відфільтровуються рядки, що відповідають умові.\nПотім SELECT - відбираються зазначені стовпці та застосовуються функції.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\nІншими словами, в результаті виконання запиту спочатку відбувається підготовка таблиці до роботи, а потім над нею виконуються різні операції.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про оператор WHERE можна за посиланням.\n\n\n\nЗавдання 3.1 Напишіть SQL-запит до таблиці products та виведіть всю інформацію про товари, ціна яких не перевищує 100 одиниць. Результат відсортуйте за зростанням id товару.\nПоля у результуючій таблиці: product_id, name, price\nРішення:\n\n\n%%sql\nSELECT \n    product_id,\n    name,\n    price\nFROM   products\nWHERE  price &lt;= 100\nORDER BY product_id\nLIMIT  10;\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n2\ngreen tea bags\n50.0\n\n\n1\n3\nstill water\n80.0\n\n\n2\n4\nlollipops\n46.0\n\n\n3\n5\ncoffee 3 in 1\n15.0\n\n\n4\n6\ncrackers\n25.0\n\n\n5\n8\ndrying\n30.0\n\n\n6\n9\nblack leaf tea\n84.0\n\n\n7\n10\nseeds\n12.0\n\n\n8\n14\nmayonnaise\n60.0\n\n\n9\n18\nketchup\n58.0\n\n\n\n\n\n\n\nФільтрувати дані в таблицях можна не тільки по полях з числовими значеннями, але і по полях зі значеннями, представленими у вигляді тексту:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 = 'text'\nУ прикладі вище в результуючу таблицю потраплять лише рядки, значення в яких повністю збігаються із зазначеним у WHERE рядком 'text'.\nПри порівнянні рядків також допускається використовувати нерівності:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt; 'text'\nВтім, така операція використовується рідше, оскільки не цілком очевидно, що означає «один рядок більше за інший».\nНасправді порядок сортування даних рядкового типу зазвичай визначається заздалегідь встановленими правилами сортування, у яких значення мають довжина рядка в символах, порядок букв відповідно до алфавіту, наявність особливих символів, регістр тощо. Ми не будемо докладно зупинятись на цій темі — за бажання про це можна додатково прочитати у документації.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про правила сортування даних рядкового типу можна за посиланням.\n\n\n\nЗавдання 3.2 Виберіть користувачів жіночої статі з таблиці users. Виведіть лише id цих користувачів. Результат відсортуйте за зростанням id.\nДодайте в запит оператор LIMIT і виведіть лише 1000 перших ID з відсортованого списку.\nПоле у результуючій таблиці: user_id\nРішення:\n\n\n%%sql\nSELECT \n    user_id\nFROM   \n    users\nWHERE  \n    sex = 'female'\nORDER BY \n    user_id \nLIMIT 1000\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n7\n\n\n1\n131\n\n\n2\n202\n\n\n3\n246\n\n\n4\n346\n\n\n...\n...\n\n\n511\n21137\n\n\n512\n21170\n\n\n513\n21291\n\n\n514\n21326\n\n\n515\n21402\n\n\n\n\n516 rows × 1 columns"
  },
  {
    "objectID": "quarto.html#що-таке-quarto",
    "href": "quarto.html#що-таке-quarto",
    "title": "4  Quarto",
    "section": "4.1 Що таке Quarto",
    "text": "4.1 Що таке Quarto\nQuarto — це науково–технічна видавнича система з відкритим кодом, яка ґрунтується на універсальному конверторі документів Pandoc та використовує мову розмітки Markdown. Це універсальний інструмент для тих, хто пише на R, Python, Julia та Observable JavaScript.\nЗа допомогою Quarto можна поєднувати описовий текст і код для створення відформатованих документів, веб–сторінок, постів у блогах, книг тощо.\n\n4.1.1 Назва Quarto\nРозробники Quarto хотіли використати ім’я, яке мало деяке значення в історії видавничої справи. Вибір пав на Quarto (від латинського quārtō, скорочено Qto, 4to або 4º) — це формат книги або брошури в одну четвертину топографічного листа. На кожній стороні листа при цьому поміщається 4 сторінки книги (8 сторінок на один лист).\nНайраннішим відомим виданням такого формату була Книга Сивіл (англ. Sibyllenbuch), що була надрукована Йоганном Гутенбергом у 1452–1453 роках.\n\n\n\nРисунок 4.1: Quarto\n\n\n\n\n4.1.2 Можливості Quarto\nQuarto являє собою текстовий документ спеціального формату .qmd, який можна скомпілювати у різноманітні документи:\n\nДокументи у форматах:\n\nHTML\nPDF\nePub\nMS Word\nOpenOffice\n\nПрезентації у форматах:\n\nreveal.js (HTML)\nPowerPoint (MS Office)\nBeamer (LaTeX/PDF)\n\nВеб-сторінки:\n\nPractical Deep Learning від fast.ai\nnbdev від fast.ai\nКурс Julia Workshop for Data Science\n\nКниги, приклади яких можна переглянути за посиланнями:\n\nPython for Data Analysis\nR for Data Science\nVisualization Curriculum\n\nІнтерактивні документи:\n\nObservable reactive JavaScript\nShiny вебфреймворк\nІнтерактивні віджети Jupyter"
  },
  {
    "objectID": "quarto.html#початок-роботи-з-quarto",
    "href": "quarto.html#початок-роботи-з-quarto",
    "title": "4  Quarto",
    "section": "4.2 Початок роботи з Quarto",
    "text": "4.2 Початок роботи з Quarto\n\n4.2.1 Встановлення Quarto\nДля роботи з Quarto потрібно: 1. Встановити інтерфейс командного рядка Quarto (CLI) під актуальну операційну систему (Windows, Linux або Mac OS).\n\nВстановити плагін для інтегрованого середовища розробки (IDE). На даний момент підтримуються:\n\nVS Code\nRStudio\nJupyter\n\n\n\n\n4.2.2 Робота з проектами\nСтворити Quarto–проект можна декількома шляхами:\n\nЗа допомогою командного рядка:\n\n\n\nterminal\n\n# веб-сайт\nquarto create-project mysite --type website\n\n# блог\nquarto create-project myblog --type website:blog\n\n# книга\nquarto create-project mybook --type book\n\n\nЗасобами IDE:\n\n\nVS Code: File -&gt; New File -&gt; …\n\n\n\n\nРисунок 4.2: Меню створення Quarto–проекту у VS Code\n\n\n\nRStudio: File -&gt; New Project… -&gt; New Directory\n\n\n\n\nРисунок 4.3: Меню створення Quarto–проекту у RStudio\n\n\n\n\n4.2.3 Як працює Quarto\nСпочатку Knitr (для R) або Jupyter (для Python або Julia) виконує всі фрагменти коду .qmd-файлу і створює новий markdown (.md) документ, який включає в себе код і всі його результати. Далі .md–файл оброблюється Pandoc для перетворення у різноманітні формати файлів (HTML, PDF, Word тощо).\n\n\n\nРисунок 4.4: Процедура рендерінгу документів в Quarto\n\n\n\n\n4.2.4 Рендерінг\n\nДля рендерінгу документу можна використати кнопку Render в VS Code.\n\n\n\n\nРисунок 4.5: Клавіша рендерінгу документу в VS Code\n\n\n\nРендерінг за допомогою командного рядку:\n\n\n\nterminal\n\nquarto render &lt;input&gt; --to &lt;format&gt;\n\n# Наприклад:\nquarto render document.qmd --to docx"
  },
  {
    "objectID": "quarto.html#структура-документів-quatro",
    "href": "quarto.html#структура-документів-quatro",
    "title": "4  Quarto",
    "section": "4.3 Структура документів Quatro",
    "text": "4.3 Структура документів Quatro\nQuatro документи складаються з трьох базових складових:\n\nYAML–шапки1\nТекст з використанням розмітки Markdown\nЧанків (анг. chunks) з кодом\n\n\n4.3.1 YAML–шапка\nYAML–шапка знаходиться нагорі документу і відділена трьома дефісами (---) зверху та знизу. В ній зберігається мета–інформація документу: назва, дата створення, автор, інформація щодо роботи коду, контенту і процесу рендерінгу.\n---\ntitle: \"Dracula\"\nauthor: \"Bram Stoker\"\ndate: \"May 26, 1897\"\nformat: \n  html:\n    toc: true\n    code-fold: true\n---\n\n\n4.3.2 Текст з використанням розмітки Markdown\nЦя частина документу йде одраtextзу після YAML–шапки і складає основну частину документу.\nMarkdown — це популярна і зручна мова розмітки. Ви непевно зустрічали її в README.md–файлах репозиторіїв GitHub, а також у Telegram–повідомленнях.\n\n\n4.3.3 Чанки з кодом\nЧанки — це блоки, які відділяються від тексту потрійними зворотніми лапками ``` ( анг. backtick) на початку та в кінці. У фігурних дужках вказується мова програмування на якій необхідно виконати код.\n```{python}\nprint('Fly, you fools!')\n```\nРезультат чанку за замовчування виводиться одразу після нього, але все це можна налаштувати."
  },
  {
    "objectID": "quarto.html#yaml-шапка",
    "href": "quarto.html#yaml-шапка",
    "title": "4  Quarto",
    "section": "4.4 YAML-шапка",
    "text": "4.4 YAML-шапка\nМетадані документу можуть бути задані у шапці документу або окремим _quarto.yml-файлом.\nВ цій частині документу зберігається інформація щодо назви документу, дати, автора, налаштування рендерінгу, параметри чанків та інші додаткові налаштування. Всі параметри встановлюються у форматі key: value.\n\n4.4.1 Налаштування виводу\nКлюч format: відповідає за тип вихідного файлу.\n\n\n\n\n\n\n\n\nТип\nЗначення\nОпис\n\n\n\n\nДокументи\n\nhtml\npdf\ndocx\nodt\nepub\n\n\nHTML\nPDF\nMS Word\nOpenDocument\nePub\n\n\n\nПрезентації\n\nrevealjs\npptx\nbeamer\n\n\nRevealjs\nPowerPoint\nBeamer\n\n\n\nMarkdown\n\ngfm\ncommonmark\nmarkua\n\n\nGFM\nCommonMark\nMarkua\n\n\n\nWiki\n\nmediawiki\ndokuwiki\nzimwiki\njira\nxwiki\n\n\nMediaWiki\nDocuWiki\nZimWiki\nJira Wiki\nXWiki\n\n\n\n\nА також цілу низку інших форматів, документацію по котрим можна отримати в розділі Reference документації.\n\n\n4.4.2 Назва, дата та автор\nВ залежності від типу вихідного документу, ці ключі можуть відрізнятися, але наведу основні:\n\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\n\ntitle\nНазва документа\n\n\nsubtitle\nПідзаголовок документа\n\n\ndate\nДата документа\n\n\nauthor\nАвтор або автори документа\n\n\n\n\n\n4.4.3 Зміст\nДля генерації змісту (анг. table of contents, скорочено toc) необхідно ключу toc задати значення true. В залежності від типу вихідного документу зміст буде згенерований відповідно до заголовків (Розділ 4.5.2).\n\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\n\ntoc\nДодайте автоматично створений зміст у вихідний документ.\n\n\ntoc-depth\nКількість рівнів розділу, які потрібно включити у зміст. За замовчуванням 3\n\n\ntoc-title\nЗаголовок, використаний для змісту.\n\n\n\n\n\n4.4.4 Локалізація документу\nQuarto, Pandoc та LaTeX генерують текстові елементи документу, які потребують локалізації. Наприклад: “Рисунок” або “Таблиця” для перехресних посилань, назви виносок тощо.\n\n4.4.4.1 Налаштування lang\nПриклад використання польської локалізації документу:\n---\ntitle: \"Mój dokument\"\nlang: pl  \n---\nЦе призведе до використання польського перекладу компонентів документу, а також до застосування інших мовних правил обробки документів.\nНаразі доступні повні переклади такими мовами:\n\nанглійська (en, за замовчуванням)\nголландська (nl)\nіспанська (es)\nіталійська (it)\nкитайська (zh)\nкорейська (kr)\nнімецька (de)\nпольська (pl)\nпортугальська (pt)\nросійська (ru)\nфінська (fi)\nфранцузька (fr)\nчеська (cs)\nяпонська (ja)\n\n\n\n4.4.4.2 Власна локалізація\nЯкщо вас не влаштовує мова за умовчанням, яка використовується для певної частини документа, ви можете вказати альтернативну мову за допомогою ключа language. Наприклад, щоб замінити значення підписів «Author» і «Published», які використовуються в блоках заголовків, ви можете зробити це:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: \n  title-block-author-single: \"Автор\"\n  title-block-published: \"Опубліковано\"\n---\nВсі ці зміни можна зберегти в окремому .yml-файлі і використовувати власну локалізацію до документу:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: custom.yml\n---\nЯ зробив власну українську локалізацію Quarto-документів, яку Ви можете завантажити з мого GitHub-репозиторія: https://github.com/aranaur/quarto-ukrainian.\nОзнайомитися з усіма офіційними локалізаціями можна за посиланням: https://github.com/quarto-dev/quarto-cli/tree/main/src/resources/language."
  },
  {
    "objectID": "quarto.html#основи-markdown",
    "href": "quarto.html#основи-markdown",
    "title": "4  Quarto",
    "section": "4.5 Основи Markdown",
    "text": "4.5 Основи Markdown\nQuarto ґрунтується на Pandoc та використовує різновид markdown в якості базового синтаксису. Pandoc markdown — це розширена та злегка перероблена версія синтаксису markdown.\nMarkdown — це формат звичайного тексту, який розроблено таким чином, щоб його було легко писати та, що ще важливіше, легко читати.\n\n4.5.1 Форматування тексту\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n*курсив* та **жирний**\nкурсив та жирний\n\n\nнадрядковий^2^ / підрядковий~2~\nнадрядковий2 / підрядковий2\n\n\n~~перекреслення~~\nперекреслення\n\n\n`дослівний код`\nдослівний код\n\n\n\n\n\n4.5.2 Заголовки\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n# Заголовок 1\nЗаголовок 1\n\n\n## Заголовок 2\nЗаголовок 2\n\n\n### Заголовок 3\nЗаголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6\n\n\n\n\n\n4.5.3 Посилання та рисунки\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n[Python](https://python.org)\nPython\n\n\n![Підпис](img/python-logo.jpg)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org \"Python\")\n\n\n\n[![](img/python-logo.jpg){fig-alt=\"Alt text\"}](https://www.python.org)\n\n\n\n\n\n\n4.5.4 Списки\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n* невпорядкований список\n    + підпункт 1\n    + підпункт 2\n        - під--підпункт 1\n\nневпорядкований список\n\nпідпункт 1\nпідпункт 2\n\nпід–підпункт 1\n\n\n\n\n\n*   пункт 2\n\n    Продовження (відступ 4 інтервали)\n\nпункт 2\nПродовження (відступ 4 інтервали)\n\n\n\n1. впорядкований список\n2. пункт 2\n    i) підпункт 1\n         A.  під--підпункт 1\n\nвпорядкований список\nпункт 2\n\nпідпункт 1\n\nпід–підпункт 1\n\n\n\n\n\n(@)  Список, нумерація якого\n\nпродовжується після\n\n(@)  переривання\n\nСписок, нумерація якого\n\nпродовжується після\n\nпереривання\n\n\n\nтермін\n: визначення\n\nтермін\n\nвизначення\n\n\n\n\n\n\n\n4.5.5 Таблиці\n\n4.5.5.1 Таблиці markdown\n\nСинтаксис markdown\n| Зліва | Справа | За замовчуванням | По центру |\n|------:|:-------|------------------|:---------:|\n|   12  |  12    |    12            |    12     |\n|  123  |  123   |   123            |   123     |\n|    1  |    1   |     1            |     1     |\n\n\nРезультат\n\n\n\nЗліва\nСправа\nЗа замовчуванням\nПо центру\n\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\nФормувати такі таблиці вручну досить складно і незручно. В таких випадках на допомогу приходить Markdown Tables Generator.\n\n\n\n4.5.5.2 Таблиці з Python\n\nЗа допомогою комбінації функцій Markdown() та пакету tabulate:\n\n\n\nterminal\n\npip install tabulate\n\n\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\ntable = [[\"Bilbo Baggins\", \"Hobbits\", \"Male\"],\n         [\"Beren\", \"Men\", \"Male\"],\n         [\"Nimrodel\", \"Elves\", \"Female\"],\n         [\"Muzgash\", \"Orc\", \"Male\"]]\nMarkdown(tabulate(\n  table, \n  headers=[\"Name\", \"Race\", \"Sex\"]\n))\n\n\n\nТаблиця 4.1: Персонажі Середзем’я\n\n\nName\nRace\nSex\n\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nPandas DataFrame у форматі консолі:\n\n\nчерез функцію print(), у форматі консолі:\n\n\nimport pandas as pd\n\ndf = pd.DataFrame(data = table,\n    columns = [\"Name\", \"Race\", \"Sex\"])\nprint(df)\n\n            Name     Race     Sex\n0  Bilbo Baggins  Hobbits    Male\n1          Beren      Men    Male\n2       Nimrodel    Elves  Female\n3        Muzgash      Orc    Male\n\n\n\nМожна викликати Python через R за допомогою пакету reticulate та використати функцію kable() з пакету knitr:\n\n#| label: tbl-character-2\n#| tbl-cap: Персонажі Середзем'я\n\n\nlibrary(reticulate)\nlibrary(knitr)\n\nkable(py$df)\n\nДодаткові можливості з’являються разом з пакетом kableExtra:\n\n#| label: tbl-character-3\n#| tbl-cap: Персонажі Середзем'я\n\n# R chunk\nlibrary(kableExtra)\n\npy$df %&gt;% \n kbl() %&gt;%\n kable_classic_2(full_width = F)\n\n\n\n4.5.6 Рівняння\nДля запису рівняння в середині тексту використовується одинарний символ $ та подвійний $$ для запису рівняння з нового рядка:\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\nу середині тексту: $E = mc^{2}$\nу середині тексту: \\(E=mc^{2}\\)\n\n\nз нового рядка:\n\n$$E = mc^{2}$$\nз нового рядка:\n\\[E = mc^{2}\\]\n\n\n\nВ якості допомоги формування рівнянь рекомендую ресурс Online LaTeX Equation Editor.\n\n\n4.5.7 Діаграми\nQuarto має вбудовану підтримку для створення діаграм Mermaid та Graphviz. Це дає змогу створювати блок–схеми, діаграми послідовності, діаграми станів тощо, використовуючи синтаксис простого тексту.\nПриклад створення блок–схеми за допомогою Mermaid:\n\n```{mermaid}\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n```\n\n\n\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n\n\n\n\n\nБільше інформації у розділі Diagrams.\n\n\n4.5.8 Відео\nВставляти відео у документи можна за допомогою запису {{&lt; video &gt;}}.\nПриклад використання відео з Youtube:\n{{&lt; video https://www.youtube.com/embed/qOhk7YyxXQ4 &gt;}}\nБільше інформації у розділі Videos.\n\n\n4.5.9 Виноски\n\n4.5.9.1 Типи виносок\nВиноски — чудовий спосіб привернути додаткову увагу до певних понять або чіткіше вказати, що певний вміст є додатковим або потребує додаткової уваги.\nУ Quarto є п’ять різноманітних виносок: - примітка (note) - застереження (warning) - важливо (important) - підказка (tip) - попередження (caution)\nКолір і значок відрізнятимуться залежно від обраного типу. Ось як виглядають різні виноски в HTML:\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що існує п’ять типів виносок, зокрема: note, tip, warning, caution та important.\n\n\n\n\n\n\n\n\nЗастереження\n\n\n\nВиноски — простий спосіб привернути увагу, наприклад, до цього застереження.\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nВиноски точно покращать Ваш текст.\n\n\n\n\n\n\n\n\nПідказка\n\n\n\nПриклад виноски з текстом\n\n\n\n\n\n\n\n\nРозгорніть, щоб дізнатися про згортання\n\n\n\n\n\nЦе приклад «згорнутої» виноски з попередженням. Використайте collapse=\"true\" щоб згорнути її за замовчуванням та collapse=\"false\" щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n\n\n\n\n\n4.5.9.2 Синтаксис markdown\nСтворіть виноски в розмітці за допомогою наступного синтаксису (зверніть увагу, що перший заголовок, використаний у виносці, використовується як заголовок виноски):\n::: {.callout-note}\n## Примітка\n\nЗауважте, що існує п’ять типів виносок, зокрема:\n`note`, `tip`, `warning`, `caution` та `important`.\n:::\n\n::: {.callout-tip}\n## Підказка\n\nПриклад виноски з текстом\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Розгорніть, щоб дізнатися про згортання\n\nЦе приклад «згорнутої» виноски з попередженням.\nВикористайте `collapse=\"true\"` щоб згорнути її за замовчуванням та `collapse=\"false\"` щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n:::\n\n\n\n4.5.10 Спеціальні символи\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\nтире: -\nтире: -\n\n\nкоротке (середнє) тире: --\nкоротке (середнє) тире: –\n\n\nдовге тире: ---\nдовге тире: —\n\n\n\n\n\n\n\n\n\nПриклади\n\n\n\n\nЖиття прожити — не поле перейти (довге тире)\n2020–2022 (коротке тире)\n25 - 5 (тире)"
  },
  {
    "objectID": "quarto.html#виконання-коду",
    "href": "quarto.html#виконання-коду",
    "title": "4  Quarto",
    "section": "4.6 Виконання коду",
    "text": "4.6 Виконання коду\n\n4.6.1 Налаштування виводу\nІснує широкий спектр доступних параметрів для налаштування виводу виконаного коду. Усі ці параметри можна вказати глобально (у YAML-шапці з ключем execute) або для кожного блоку коду.\n\nПриклад глобальних налаштувань:\n\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\nexecute:\n  echo: false\n---\n\nПриклад налаштування конкретного чанку:\n\n```{python}\n#| echo: true\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nx = np.arange(-4, 4, .012)\ny = np.arange(-4, 4, .012)\nX, Y = np.meshgrid(x, y)\nZ = 1 - np.abs(X) - np.sin(Y**2)\nW = 1 + Y - np.cos(X**2)\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(projection='polar')\nplt.scatter(Z, W, alpha=.03, s=0.2)\nplt.axis('off')\nplt.show()\n```\nПараметри налаштування знаходяться у верхній частині блоку під спеціальним коментарем #|.\n\n\n\n\n\n\n\nНалаштування\nОпис\n\n\n\n\neval\nОцініть фрагмент коду (якщо false, просто відтворіть код).\n\n\necho\nПоказувати код (якщо false, код не буде виведено на екран).\n\n\nwarning\nПоказувати попередження, які виникають під час виконання коду\n\n\nerror\nПоказувати помилки у документі (це означає, що помилки під час виконання коду не зупинять обробку документа).\n\n\ninclude\nЗапобігає виводу коду та його результатів.\n\n\n\n\n\n4.6.2 Вбудований код\nQuarto дозволяє виводити результат коду в середині тексту. Це особливо зручно, якщо необхідно щоб документ використовував найсвіжіші розрахунки. Проте синтаксис виводу залежить від рушія (анг. engine) Quarto: Jupyter, Knitr або OJS.\n\n4.6.2.1 Jupyter\nЩоб включити збережену змінну, використовуєте IPython.display.Markdown.\nНаприклад, виведемо площу кола за заданим радіусом (radius):\n```{python}\n#| echo: false\n\nfrom IPython.display import Markdown\nimport math\n\nradius = 10\ncircle_area = math.pi * pow(radius, 2)\n\nMarkdown((f\"\"\"\nПлоща кола з радіусом {radius} дорівнює {round(circle_area, 2)}.\n\"\"\"\n))\n```\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що ми використовуємо опцію echo: false, щоб не виводити код у фінальний документ, а тільки результат.\n\n\n\n\n4.6.2.2 Knitr\nАналогічно до роботи з таблицями (див. Розділ 4.5.5.2) можемо поєднати можливості R та Python для виводу результату коду в тексті документу.\nЩоб включити вирази в розмітку для Knitr, використовується вираз у `r `:\n```{r}\n#| include: false\n\nlibrary(reticulate)\n```\n```{python}\n#| echo: false\n\nimport math\n\nradius = 10\ncircle_area = round(math.pi * pow(radius, 2), 2)\n```\nПлоща кола з радіусом  `r⠀py$radius`  дорівнює `r⠀py$circle_area`.\n\n\n\n\n\n\nПримітка\n\n\n\nЗапис py$radius означає: взяти значення змінної Python з ім’ям radius."
  },
  {
    "objectID": "quarto.html#основи-публікації",
    "href": "quarto.html#основи-публікації",
    "title": "4  Quarto",
    "section": "4.7 Основи публікації",
    "text": "4.7 Основи публікації\nІснує низка способів публікації документів, презентацій і веб-документів, створених за допомогою Quarto. Оскільки вміст, відтворений за допомогою Quarto, використовує стандартні формати (HTML, PDF, MS Word тощо), його можна опублікувати будь-де. Крім того, доступна команда quarto publish для легкої публікації в різних популярних службах (GitHub, Netlify, RStudio Connect тощо), а також різні інструменти, які полегшують публікацію з системи Неперервної інтеграції (анг. Continuous integration).\nСервіси для публікації:\n\n\n\n\n\n\n\nСервіс\nОпис\n\n\n\n\nQuarto Pub\nПублікація документів, веб-сайтів і книг Quarto.\n\n\nGitHub Pages\nПублікація документів за допомогою репозиторію GitHub\n\n\nRStudio Connect\nПлатформа для безпечного обміну даними в межах організації.\n\n\nNetlify\nПрофесійна платформа веб-публікації.\n\n\nІнші сервіси\nСкористайтеся цими сервісами, якщо один із наведених вище методів не відповідає вашим вимогам."
  },
  {
    "objectID": "quarto.html#footnotes",
    "href": "quarto.html#footnotes",
    "title": "4  Quarto",
    "section": "",
    "text": "YAML це рекурсивний акронім YAML Ain’t Markup Language («YAML — не мова розмітки»). У назві відображена історія розвитку: на ранніх етапах мова називалася Yet Another Markup Language («Ще одна мова розмітки») і навіть розглядалася як конкурент XML, але пізніше була перейменована з метою акцентувати увагу на даних, а не на розбивці документів.↩︎"
  }
]