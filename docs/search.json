[
  {
    "objectID": "sql_subquery.html#порядок-виконання-запитів",
    "href": "sql_subquery.html#порядок-виконання-запитів",
    "title": "6  Підзапити",
    "section": "6.1 Порядок виконання запитів",
    "text": "6.1 Порядок виконання запитів\nПерш ніж переходити до підзапитів, давайте трохи поговоримо про порядок виконання запитів у SQL.\nДо цього моменту ми вже встигли познайомитися з основними операторами, які складають “скелет” стандартного SQL-запиту: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY та LIMIT.\nМи вже знаємо, що порядок їх написання у запиті наступний:\nSELECT      -- перелік полів результуючої таблиці\nFROM        -- вказівник джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- групування даних\nHAVING      -- фільтрація даних після групування\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів у виводі\nПроте важливо розуміти, що порядок виконання операторів у базах даних дещо відрізняється від порядку їх написання у запиті. У спрощеному вигляді порядок виконання запиту такий:\nFROM       -- вказівник джерела даних\nWHERE      -- фільтрація даних\nGROUP BY   -- групування даних\nHAVING     -- фільтрація даних після групування\nSELECT     -- перелік полів результуючої таблиці\nORDER BY   -- сортування результуючої таблиці\nLIMIT      -- бмеження кількості записів у виводі\nТаким чином:\n\nСпочатку з допомогою FROM визначається таблиця.\nПотім відповідно до зазначеної у WHERE умові з цієї таблиці відбираються записи.\nПотім вибрані дані групуються та агрегуються за допомогою GROUP BY.\nДалі з агрегованих записів відбираються ті, які задовольняють умову HAVING.\nТільки після цього відповідно до зазначених у SELECT інструкціях формується результуюча таблиця — проводяться всі необхідні обчислення, надаються нові імена тощо.\nПотім результуюча таблиця сортується відповідно до ORDER BY.\nІ нарешті спрацьовує обмеження кількості рядків, вказане в LIMIT.\n\nНасправді це дуже важлива інформація, яку слід пам’ятати при складанні будь-яких SQL-запитів.\nМожливо, ви вже зіткнулися з помилками, коли намагалися в блоці WHERE використовувати фільтрацію по нових полях, розрахованих у SELECT. Така операція не відповідає порядку виконання операторів і тому так робити не можна. Також ви могли потрапити в ситуацію, коли при фільтрації у HAVING у вас не приймався аліас колонки, розрахованої в SELECT. Це відбувалося з тієї ж причини – база даних просто ще не знала про те, що ви надали колонці нове ім’я.\nІ ще одна важлива порада. Зверніть увагу, що фільтрацію даних за неагрегованими значеннями можна робити як у блоці WHERE, так і в блоці HAVING. Уважно подивіться на такі запити:\nSELECT sex, COUNT(user_id)\nFROM users\nWHERE sex != 'male'\nGROUP BY sex\n\n\nSELECT sex, COUNT(user_id)\nFROM users\nGROUP BY sex\nHAVING sex != 'male'\nЇх результат буде однаковим (можете переконатися в цьому самі).\nПроте робити фільтрацію за неагрегованими даними рекомендується саме у блоці WHERE, тобто заздалегідь. У такому разі ви ще до угруповання прибираєте з розрахунків непотрібні вам дані і таким чином не витрачаєте обчислювальні ресурси на підрахунок значень, які будуть відфільтровані вами пізніше.\nЦе важливий момент щодо оптимізації SQL-запитів, тому рекомендуємо вам взяти до уваги інформацію."
  },
  {
    "objectID": "sql_subquery.html#підзапити",
    "href": "sql_subquery.html#підзапити",
    "title": "6  Підзапити",
    "section": "6.2 Підзапити",
    "text": "6.2 Підзапити\nПідзапити це потужним інструментом в мові SQL, який дозволяє нам виконувати запити в середині інших запитів. Вони дають можливість створювати складніші і більш гнучкі запити, які вимагають доступу до даних з кількох таблиць або виконання додаткових обчислень.\nОдин із сценаріїв використання підзапитів - це пошук даних в одній таблиці на основі значень з іншої таблиці. Наприклад, ми можемо створити запит, що повертає всіх клієнтів, які зробили замовлення на товари з певної категорії, використовуючи підзапит для вибірки ідентифікаторів цих товарів з таблиці товарів.\nНаприклад у нас є дві таблиці: clients і orders. Нам потрібно отримати список клієнтів, які зробили замовлення після певної дати. Для цього ми можемо скористатися підзапитом:\nSELECT *\nFROM clients\nWHERE ID IN (SELECT client_id\n             FROM orders\n             WHERE data &gt; '2023-01-01');\n)\nІншими словами, підзапит — це лише запит усередині іншого запиту.\nПідзапити можуть застосовуватись у таких частинах основного запиту:\n\nв операторі FROM;\nв операторі SELECT (якщо запит повертає один стовпець з одним значенням);\nв операторах WHERE та HAVING (якщо запит повертає один стовпець з одним або декількома значеннями).\n\nАле давайте про все по порядку.\nНасамперед важливо зрозуміти, що з результату виконання підзапиту можна звертатися також як і до таблиць у базі даних, тобто використовувати їх у блоці FROM замість наявних таблиць:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM table\n) AS subquery_1\nВ межах даного запиту спочатку буде виконано підзапит, який відбере колонки column_1 і column_2 з таблиці table, а потім вже з таблиці, що утворилася, основний запит вибере колонку column_1.\nВажливий момент: при використанні підзапиту в блоці FROM сформованій на основі підзапиту таблиці необхідно привласнити якийсь аліас, інакше основний запит не спрацює. У прикладі вище ми позначили результат підзапиту subquery_1.\nКрім того, рівнів вкладеності може бути декілька:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM (\n        SELECT column_1, column_2, column_3\n        FROM table\n    ) AS subquery_1\n) AS subquery_2\nВ даному випадку послідовність роботи запиту така: спочатку буде виконано підзапит, що повертає результат subquery_1, потім підзапит, що повертає результат subquery_2, і тільки потім в результаті основного підзапиту потрапить колонка column_1. В результаті виходить щось схоже на матрьошку, при цьому до основної таблиці table звертається тільки перший підзапит subquery_1.\nНаведений приклад досить умовний і на практиці колонки в такий спосіб відбирати не варто, але загальну ідею він має передавати.\nРозуміння того, як працюють підзапити в блоці FROM, нам особливо стане в нагоді, коли ми вчитимемося об’єднувати різні таблиці.\nА зараз давайте вирішимо просте завдання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.1  Використовуючи дані з таблиці user_actions, розрахуйте середню кількість замовлень для всіх користувачів нашого сервісу. Для цього спочатку в підзапиті порахуйте скільки замовлень зробив кожен користувач, а потім зверніться до результату підзапиту в блоці FROM і вже в основному запиті усередніть кількість замовлень по всіх користувачах. Отриману середню кількість замовлень всіх користувачів округліть до двох знаків після коми. Назвіть колонку з цим значенням orders_avg.\nПоле у результуючій таблиці: orders_avg\nПояснення: до колонок з підзапиту можна застосовувати агрегатні функції — так само, як би ми зверталися до колонок вихідних таблиць.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(orders_count), 2) as orders_avg\nFROM   (SELECT count(order_id) as orders_count\n        FROM   user_actions\n        WHERE  action = 'create_order'\n        GROUP BY user_id) as t1\n\n\n\n\n\n\n\n\n\norders_avg\n\n\n\n\n0\n2.78"
  },
  {
    "objectID": "sql_subquery.html#табличні-вирази-with",
    "href": "sql_subquery.html#табличні-вирази-with",
    "title": "6  Підзапити",
    "section": "6.3 Табличні вирази: WITH",
    "text": "6.3 Табличні вирази: WITH\nВирішуючи попереднє завдання, ви могли запитати себе: а що якщо один і той же підзапит буде використовуватися в декількох частинах основного запиту? Невже щоразу доведеться дублювати той самий підзапит? А якщо рівнів вкладеності буде кілька? Чи не вийде тоді надто складний та громіздкий запит, який буде складно читати?\nДля таких випадків SQL передбачений оператор WITH, який дозволяє створювати так звані табличні вирази (CTE, анг. common table expressions) - тимчасові таблиці, які існують тільки для одного запиту. Їхнє основне призначення полягає в розбиття складних запитів на кілька частин.\nТабличні вирази створюються так:\nWITH subquery_1 AS (\n    SELECT column_1, column_2\n    FROM table\n)\nSELECT column_1\nFROM subquery_1\nПорівняйте запит вище з результатом запиту, який ми використовували раніше:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM table\n) AS subquery_1\nОператор WITH може містити кілька табличних виразів, причому до зазначених раніше виразів можна звертатися у подальших виразах:\nWITH subquery_1 AS (\n    SELECT column_1, column_2, column_3\n    FROM table\n    ),\n     subquery_2 AS (\n    SELECT column_1, column_2\n    FROM subquery_1\n    )\n\nSELECT column_1\nFROM subquery_2\nМожете знову порівняти запит вище із запитом, який ми використовували раніше:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM (\n        SELECT column_1, column_2, column_3\n        FROM table\n    ) AS subquery_1\n) AS subquery_2\nВикористовувати у своїх запитах оператор WITH чи ні вирішувати вам, але в деяких випадках він може спростити роботу з кодом запиту.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про WITH та табличні вирази можна почитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.2  Повторіть запит із завдання 6.1, але тепер замість підзапиту використовуйте оператор WITH та табличний вираз. Умови завдання ті самі.\nПоле у результуючій таблиці: orders_avg\n\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT user_id,\n                   count(order_id) as orders_count\n            FROM   user_actions\n            WHERE  action = 'create_order'\n            GROUP BY user_id)\nSELECT round(avg(orders_count), 2) as orders_avg\nFROM   t1\n\n\n\n\n\n\n\n\n\norders_avg\n\n\n\n\n0\n2.78\n\n\n\n\n\n\n\nЩе один важливий напрямок застосування підзапитів - створення більш просунутих умовних виразів в операторах WHERE та HAVING. Але оскільки і в тому, і в іншому випадку синтаксис і призначення підзапитів приблизно однакові, у цьому уроці ми розглядатимемо все на прикладі підзапитів у WHERE.\nНасамперед важливо зрозуміти, що підзапит, який повертає одне значення, може використовуватися як звичайне значення спільно з операторами порівняння.\nУявіть, що нам потрібно порівняти значення в якомусь стовпці з максимальним, мінімальним чи середнім значенням у цьому стовпці. Зробити це в рамках одного запиту не вийде, оскільки агрегатні функції не можна використовувати в блоці WHERE.\nНаприклад, наступний запит не працюватиме (база даних повідомить про помилку):\nSELECT column\nFROM table\nWHERE column = MAX(column) \nУ той же час такий запит спрацює, тому що підзапит виконається першим і поверне одне значення:\nSELECT column\nFROM table\nWHERE column = (SELECT MAX(column) FROM table) \nВ результаті виконання такого запиту ми отримаємо всі значення в колонці column, що дорівнює максимальному значенню в цій колонці.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.3  Виведіть з таблиці products інформацію про всі товари крім найдешевшого. Результат відсортуйте за зменшенням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nWHERE  price != (SELECT min(price)\n                 FROM   products)\nORDER BY product_id desc\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n87\nveal\n398.0\n\n\n1\n86\ncold coffee\n70.0\n\n\n2\n85\njam\n200.0\n\n\n3\n84\ntangerines\n90.0\n\n\n4\n83\nwaffles\n55.0\n\n\n...\n...\n...\n...\n\n\n81\n5\ncoffee 3 in 1\n15.0\n\n\n82\n4\nlollipops\n46.0\n\n\n83\n3\nstill water\n80.0\n\n\n84\n2\ngreen tea bags\n50.0\n\n\n85\n1\nsugar\n150.0\n\n\n\n\n86 rows × 3 columns\n\n\n\nУ блоці WHERE результати підзапитів, що повертають одне значення, також можна використовувати в арифметичних операціях:\nSELECT column\nFROM table\nWHERE column = (SELECT MAX(column) FROM table) - 100\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.4  Виведіть інформацію про товари в таблиці products, ціна на які перевищує середню ціну всіх товарів на 20 і більше одиниць. Результат відсортуйте за зменшенням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nWHERE  price &gt;= (SELECT avg(price)\n                 FROM   products) + 20\nORDER BY product_id desc\nLIMIT 10\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n87\nveal\n398.0\n\n\n1\n85\njam\n200.0\n\n\n2\n77\nchicken\n298.0\n\n\n3\n69\ncranberry juice\n175.0\n\n\n4\n66\nbeef\n370.0\n\n\n5\n64\npineapple\n200.0\n\n\n6\n61\nhoney\n380.0\n\n\n7\n59\nsesame oil\n250.0\n\n\n8\n57\npork\n450.0\n\n\n9\n51\nsmoked fish\n195.0"
  },
  {
    "objectID": "sql_subquery.html#підзапит-з-інтервалом-часу-interval",
    "href": "sql_subquery.html#підзапит-з-інтервалом-часу-interval",
    "title": "6  Підзапити",
    "section": "6.4 Підзапит з інтервалом часу: INTERVAL",
    "text": "6.4 Підзапит з інтервалом часу: INTERVAL\nУ яких випадках нам може стати в нагоді підзапит в операторі WHERE?\nУявімо, що нам потрібно провести якісь розрахунки за останні N днів — скажімо, за останній тиждень. Чи будемо ми вручну відраховувати 7 днів від останньої дати в нашій таблиці? Зрозуміло, що ні. Крім того, остання дата може згодом змінитись, коли до нас надійдуть нові дані. Щоразу писати новий запит і рахувати дату вручну — заняття не для нас.\nДля вирішення такого завдання ми можемо спочатку за допомогою підзапиту обчислити останню дату наших даних, а потім відкласти від неї тиждень.\nЩоб відкласти від дати або додати до неї певний проміжок часу, можна використовувати нескладні арифметичні операції з датами. Наприклад, від поточної дати можна відібрати якийсь проміжок INTERVAL:\nSELECT NOW() - INTERVAL '1 year 2 months 1 week'\n\nРезультат:\n2022-04-24 13:10\nДо речі, NOW() — корисна функція, яка дозволяє отримувати поточну дату та час (у вашому випадку вона буде іншою):\nSELECT NOW()\n\nРезультат:\n2022-07-10 16:11\n\n\n\n\n\n\nПримітка\n\n\n\nЗ іншими прикладами роботи з INTERVAL та арифметичними операціями з датами можна ознайомитись тут.\nПро функцію NOW() можна додатково прочитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.5  Порахуйте кількість унікальних клієнтів у таблиці user_actions, які зробили за останній тиждень хоча б одне замовлення. Отриману колонку зі значенням назвіть users_count. В якості поточної дати, від якої відкладати тиждень, використовуйте останню дату тієї ж таблиці user_actions.\nПоле у результуючій таблиці: users_count\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct user_id) as users_count\nFROM   user_actions\nWHERE  action = 'create_order'\n   and time &gt; (SELECT max(time)\n            FROM   user_actions) - interval '1 week'\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n17352\n\n\n\n\n\n\n\nВиходить, що в одному з минулих завдань (4.10) ми неправильно рахували вік кур’єрів. Дійсно, як перша дата у функції AGE() ми використовували поточну дату, а не останню дату в наших даних. Давайте виправимо це прикре непорозуміння, адже тепер у нас для цього є всі необхідні знання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.6  За допомогою функції AGE() і агрегатної функції знову розрахуйте вік наймолодшого кур’єра чоловічої статі в таблиці couriers, але цього разу в якості першої дати використовуйте останню дату з таблиці courier_actions. Щоб вийшла саме дата, перед застосуванням функції AGE() переведіть пораховану останню дату у формат DATE, як ми робили у 2.9. Вік кур’єра виміряйте кількістю років, місяців і днів і переведіть його до типу VARCHAR. Отриману колонку зі значенням віку назвіть min_age.\nПоле у результуючій таблиці: min_age\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цій задачі результат підзапиту виступає як аргумент функції. Щоб весь запит виглядав компактнішим, для приведення даних до іншого типу можна використовувати формат запису з двома двокрапками - ::.\nТакож зверніть увагу, що для отримання необхідного результату ми звертаємось до різних таблиць у рамках одного загального запиту – так можна робити теж.\n\n\n\n\nРішення\n%%sql\n-- варіант 1\nSELECT age((SELECT max(time)::date\n            FROM   courier_actions), max(birth_date))::varchar as min_age\nFROM   couriers\nWHERE  sex = 'male'\n\n-- варіант 2\n-- SELECT min(age((SELECT max(time)::date\n--                 FROM   courier_actions), birth_date))::varchar as min_age\n-- FROM   couriers\n-- WHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nmin_age\n\n\n\n\n0\n16 years 10 months 11 days\n\n\n\n\n\n\n\nПідзапит, який повертає кілька значень, може використовуватися в блоці WHERE спільно з оператором IN — наприклад, коли нам потрібно перевірити, чи збігається значення в стовпці з одним із значень із певної множини, отриманої в результаті виконання підзапиту:\nSELECT column_1\nFROM table_1\nWHERE column_1 IN (SELECT column_2 FROM table_2) \nПри цьому, запит вище буде рівносильний запиту з табличним виразом:\nWITH subquery AS (\n    SELECT column_2\n    FROM table_2\n    )\n\nSELECT column_1\nFROM table_1\nWHERE column_1 IN (SELECT * FROM subquery) \nЗверніть увагу, що при використанні в операторі табличного виразу WHERE звернутися просто до його імені не можна - необхідно попередньо вибрати всі його записи, тобто написати підзапит. При цьому в табличному вираженні має бути лише один стовпець, інакше база даних поверне помилку.\nКрім того, в табличному вираженні можна зберігати лише одне значення (наприклад, результат агрегації) і аналогічним чином викликати його в операторі WHERE як змінну:\nWITH subquery AS (\n    SELECT MAX(column_2)\n    FROM table_2\n    )\n\nSELECT column_1\nFROM table_1\nWHERE column_1 = (SELECT * FROM subquery) \nДавайте розглянемо такий приклад.\nЗ наших даних досить легко відібрати скасовані замовлення - достатньо вказати у WHERE потрібний фільтр. Але як відібрати створені, але не скасовані замовлення? Це якраз можна зробити за допомогою підзапиту або табличного виразу.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.7  З таблиці user_actions за допомогою підзапиту або табличного виразу відберіть усі замовлення, які не було скасовано користувачами. Виведіть стовпчик з id цих замовлень. Результат запиту відсортуйте за зростанням id замовлення. Додайте в запит оператор LIMIT та виведіть лише перші 10 рядків результуючої таблиці.\nПоле у результуючій таблиці: order_id\n\n\n\n\n\nРішення\n%%sql\n-- варіант 1\nSELECT order_id\nFROM   user_actions\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order')\nORDER BY order_id limit 10\n\n-- варіант 2\n-- SELECT order_id\n-- FROM   user_actions\n-- WHERE  order_id not in (SELECT order_id\n--                         FROM   user_actions\n--                         WHERE  action = 'cancel_order')\n-- ORDER BY order_id limit 10\n\n\n\n\n\n\n\n\n\norder_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n5\n6\n\n\n6\n8\n\n\n7\n9\n\n\n8\n10\n\n\n9\n11"
  },
  {
    "objectID": "sql_subquery.html#підзапити-в-блоці-select",
    "href": "sql_subquery.html#підзапити-в-блоці-select",
    "title": "6  Підзапити",
    "section": "6.5 Підзапити в блоці SELECT",
    "text": "6.5 Підзапити в блоці SELECT\nЯк було зазначено в першому кроці, вкладений запит може бути розміщений і після оператора SELECT. Однак результатом підзапиту в такому випадку може бути тільки одне значення — наприклад, результат застосування агрегатної функції до якоїсь колонки:\nSELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1\nFROM table\nВ такому випадку з таблиці table буде обрано колонка column_1, і навпаки кожного значення у цій колонці буде виведено результат виконання вкладеного запиту, тобто максимальне значення у цій колонці. При цьому давати аліасу результату підзапиту не обов’язково.\nТакож результати підзапитів у блоці SELECT можна використовувати у обчисленнях:\nSELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2\nFROM table\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.8  Використовуючи дані з таблиці user_actions, розрахуйте скільки замовлень зробив кожен користувач і відобразіть це в стовпці orders_count. В окремому стовпці orders_avg навпроти кожного користувача вкажіть середню кількість замовлень всіх користувачів, округливши до двох знаків після коми. Також для кожного користувача порахуйте відхилення замовлень від середнього значення. Відхилення рахуйте так: число замовлень «мінус» заокруглене середнє значення. Назвіть колонку з відхиленням orders_diff. Результат відсортуйте за зростанням id користувача. Додайте в запит оператор LIMIT та виведіть лише перші 10 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, orders_count, orders_avg, orders_diff\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цій задачі можна використовувати підзапит, написаний у перших завданнях цього уроку. Щоб не довелося двічі писати той самий підзапит, можна використовувати оператор WITH.\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT user_id,\n                   count(order_id) as orders_count\n            FROM   user_actions\n            WHERE  action = 'create_order'\n            GROUP BY user_id)\nSELECT user_id,\n       orders_count,\n       round((SELECT avg(orders_count) FROM   t1), 2) as orders_avg,\n       orders_count - round((SELECT avg(orders_count) FROM   t1), 2) as orders_diff\nFROM   t1\nORDER BY user_id limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\norders_count\norders_avg\norders_diff\n\n\n\n\n0\n1\n4\n2.78\n1.22\n\n\n1\n2\n2\n2.78\n-0.78\n\n\n2\n3\n4\n2.78\n1.22\n\n\n3\n4\n2\n2.78\n-0.78\n\n\n4\n5\n1\n2.78\n-1.78\n\n\n...\n...\n...\n...\n...\n\n\n995\n996\n4\n2.78\n1.22\n\n\n996\n997\n4\n2.78\n1.22\n\n\n997\n998\n2\n2.78\n-0.78\n\n\n998\n999\n3\n2.78\n0.22\n\n\n999\n1000\n5\n2.78\n2.22\n\n\n\n\n1000 rows × 4 columns\n\n\n\nПеред тим, як піти далі, пропонуємо вам вирішити ще кілька завдань на підзапити.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.9  Виведіть id та вміст 100 останніх доставлених замовлень із таблиці orders. Вмістом замовлень вважаються списки з id товарів, що входять у замовлення. Результат відсортуйте за зростанням id замовлення.\nПоля у результуючій таблиці: order_id, product_ids\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що вміст замовлень знаходиться у таблиці orders, а інформація про дії із замовленнями – у таблиці courier_actions.\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       product_ids\nFROM   orders\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order'\n                    ORDER BY time desc limit 100)\nORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\nproduct_ids\n\n\n\n\n0\n59466\n[71, 50, 45]\n\n\n1\n59481\n[26, 30, 84, 1]\n\n\n2\n59482\n[32, 42, 79, 56]\n\n\n3\n59487\n[9, 62, 77]\n\n\n4\n59489\n[67, 42]\n\n\n...\n...\n...\n\n\n95\n59591\n[74, 26, 69, 3]\n\n\n96\n59592\n[34, 58, 31]\n\n\n97\n59593\n[52, 46, 40]\n\n\n98\n59594\n[2, 62]\n\n\n99\n59595\n[18, 30, 67]\n\n\n\n\n100 rows × 2 columns\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.10  З таблиці couriers виведіть всю інформацію про кур’єрів, які у вересні 2022 року доставили 30 і більше замовлень. Результат відсортуйте за зростанням id кур’єра.\nПоля в результуючій таблиці: courier_id, birth_date, sex\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що інформація про кур’єрів знаходиться в таблиці couriers, а інформація про дії із замовленнями - у таблиці courier_actions.\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       birth_date,\n       sex\nFROM   couriers\nWHERE  courier_id in (SELECT courier_id\n                      FROM   courier_actions\n                      WHERE  date_part('month', time) = 9\n                         and date_part('year', time) = 2022\n                         and action = 'deliver_order'\n                      GROUP BY courier_id having count(distinct order_id) &gt;= 30)\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_date\nsex\n\n\n\n\n0\n23\n1990-03-26\nmale\n\n\n1\n869\n2001-08-25\nfemale\n\n\n2\n1466\n1994-04-07\nmale\n\n\n3\n1664\n1987-12-16\nmale\n\n\n\n\n\n\n\nУ цій задачі об’єднаємо знання про конструкцію CASE та підзапити.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.11  Призначте знижку 15% на товари, ціна яких перевищує середню ціну на всі товари на 50 і більше одиниць, а також знижку 10% на товари, ціна яких нижча за середню на 50 і більше одиниць. Ціну інших товарів усередині діапазону (середнє – 50; середнє + 50) залиште без змін. При розрахунку середньої ціни округліть її до двох знаків після коми.\nВиведіть інформацію про всі товари із зазначенням старої та нової ціни. Колонку із новою ціною назвіть new_price. Результат відсортуйте спочатку за спаданням колишньої ціни в колонці price, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, new_price"
  }
]