[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python в науці про дані",
    "section": "",
    "text": "Вступне слово\nКнига-конспект матеріалів з курсу “Python for Data Science”."
  },
  {
    "objectID": "03_control_constructs.html#присваєння",
    "href": "03_control_constructs.html#присваєння",
    "title": "3  Керуючі конструкції",
    "section": "3.1 Присваєння",
    "text": "3.1 Присваєння\nОператор присвоєння - це процес зв’язування імен та значень. Для цього використовується символ =.\n\nname = \"Frodo\"\nring = 1\ndic = {}"
  },
  {
    "objectID": "03_control_constructs.html#порядок-присвоєння",
    "href": "03_control_constructs.html#порядок-присвоєння",
    "title": "3  Керуючі конструкції",
    "section": "3.2 Порядок присвоєння",
    "text": "3.2 Порядок присвоєння"
  },
  {
    "objectID": "03_control_constructs.html#контроль-циклів",
    "href": "03_control_constructs.html#контроль-циклів",
    "title": "3  Керуючі конструкції",
    "section": "3.3 Контроль циклів",
    "text": "3.3 Контроль циклів\n\ni = 0\nwhile i < 15:\n    i += 1\n    if i == 7:\n        i = 7\n        continue\n    if i == 13:\n        break\n    print(i)\n\n1\n2\n3\n4\n5\n6\n8\n9\n10\n11\n12"
  },
  {
    "objectID": "05_sql.html#схема-бази-даних",
    "href": "05_sql.html#схема-бази-даних",
    "title": "SQL",
    "section": "Схема бази даних",
    "text": "Схема бази даних\nУ цьому розділі ми будемо використовувати набори даних, які представляють сервіс з доставки продуктів. Тут зберігається документація, котра допоможе розібратися з ними. У таблиці продемонстровані зв’язки між таблицями, а також опис даних.\n\n\n\n\nerDiagram\n    orders }|..|{ products : product_ids-product_id\n    orders }|..|{ courier_actions : order_id\n    users }|..|{ user_actions : user_id\n    user_actions }|..|{ orders : order_id\n    user_actions }|..|{ courier_actions : time\n    courier_actions }|..|{ courier : product\n    \n    users {\n        DATE birth_date\n        VARCHAR sex\n        INT user_id\n    }\n    user_actions {\n        INT user_id\n        VARCHAR actions\n        INT order_id\n        TIMESTAMP time\n    }\n    orders {\n        INT order_id\n        ARRAY product_ids\n        TIMESTAMP creation_time\n    }\n    products {\n        INT product_id\n        NUMERIC price\n        VARCHAR name\n    }\n    courier_actions {\n        INT courier_id\n        VARCHAR action\n        INT order_id\n        TIMESTAMP time\n    }\n    courier {\n        INT courier_id\n        VARCHAR sex\n        DATE birth_date\n    }"
  },
  {
    "objectID": "05_sql.html#типи-даних",
    "href": "05_sql.html#типи-даних",
    "title": "SQL",
    "section": "Типи даних",
    "text": "Типи даних\nВ таблицях можуть зберігатися різні типи даних: цілі і дробові числа, текст, дати, масиви чисел. У цих даних ви зустрінетесь з наступними типами:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nТипи даних\nОпис\nПриклад\n\n\n\n\nINT\nЦіле число\nid користувача: 123\n\n\nNUMERIC / DECIMAL\nДійсне число\nВартість товару: 120.55\n\n\nVARCHAR\nТекст\nДія із замовленням: «create_order»\n\n\nDATE\nДата з точністю до дня\nДата народження користувача: 25/03/91\n\n\nTIMESTAMP\nДата з точністю до секунди\nЧас реєстрації у додатку: 24/08/22 01:52:24\n\n\n[]\nМасив\nСписок id товаров у замовленні: [1, 13, 22]\n\n\n\n\n\n\nБільш детально почитати про типи даних можна за посиланням"
  },
  {
    "objectID": "05_sql.html#структура-та-наповнення-таблиць",
    "href": "05_sql.html#структура-та-наповнення-таблиць",
    "title": "SQL",
    "section": "Структура та наповнення таблиць",
    "text": "Структура та наповнення таблиць\nuser_actions – дії користувачів із замовленнями.\n\n\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\nuser_id\nINT\nid користувача\n\n\norder_id\nINT\nid замовлення\n\n\naction\nVARCHAR(50)\nдія користувача із замовленням; “create_order” - створення замовлення, “cancel_order” - скасування замовлення\n\n\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\ncourier_actions – дії кур’єрів із замовленнями.\n\n\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\ncourier_id\nINT\nid кур’єра\n\n\norder_id\nINT\nid замовлення\n\n\naction\nVARCHAR(50)\nдія кур’єра із замовленням; ‘accept order’ - прийняття замовлення, ‘deliver order’ - доставка замовлення\n\n\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\norders - інформація про замовлення.\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\norder_id\nINT\nid замовлення\n\n\ncreation_time\nTIMESTAMP\nчас створення замовлення\n\n\nproduct_ids\ninteger[]\nсписок id товарів у замовленні\n\n\n\n\n\n\nusers - інформація про користувачів.\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\nuser_id\nINT\nid користувача\n\n\nbirth_date\nDATE\nдата народження\n\n\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\ncouriers - інформація про кур’єрів.\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\ncourier_id\nINT\nid кур’єра\n\n\nbirth_date\nDATE\nдата народження\n\n\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\nproducts - інформація про товари, які доставляє сервіс.\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\nproduct_id\nINT\nid продукту\n\n\nname\nVARCHAR(50)\nназва товару\n\n\nprice\nFLOAT(4)\nціна товару\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка!\n\n\n\nУ дужках типу VARCHAR вказано максимально допустиму кількість символів у тексті. У типу даних NUMERIC у дужках вказано загальну кількість символів."
  },
  {
    "objectID": "05_01_basics.html#select",
    "href": "05_01_basics.html#select",
    "title": "4  Базові запити",
    "section": "4.1 SELECT",
    "text": "4.1 SELECT\nДавайте напишемо перший запит мовою SQL:\n\nSELECT *\nFROM courier_actions\nLIMIT 5\n\n\n5 records\n\n\ncourier_id\norder_id\naction\ntime\n\n\n\n\n12\n1\naccept_order\n2022-08-24 01:52:00\n\n\n12\n1\ndeliver_order\n2022-08-24 02:15:00\n\n\n156\n2\naccept_order\n2022-08-24 06:37:00\n\n\n156\n2\ndeliver_order\n2022-08-24 06:56:00\n\n\n49\n3\naccept_order\n2022-08-24 07:35:00\n\n\n\n\n\nДаний запис можна дослівно перекласти:\n\nSELECT *: “взяти все”.\nFROM courier_actions: з таблиці courier_actions.\nLIMIT 10: вивести тільки перші 10 спостережень.\n\nМи можемо написати більш явний запит і отримати той сами результат:\n\nSELECT \n    action, \n    courier_id, \n    order_id, \n    time\nFROM \n    courier_actions\nLIMIT 5\n\n\n5 records\n\n\naction\ncourier_id\norder_id\ntime\n\n\n\n\naccept_order\n12\n1\n2022-08-24 01:52:00\n\n\ndeliver_order\n12\n1\n2022-08-24 02:15:00\n\n\naccept_order\n156\n2\n2022-08-24 06:37:00\n\n\ndeliver_order\n156\n2\n2022-08-24 06:56:00\n\n\naccept_order\n49\n3\n2022-08-24 07:35:00\n\n\n\n\n\nНа практиці таблиці можуть бути дуже великими, тому дуже бажано використовувати оператор LIMIT для того щоб не виводити всю таблицю, що може займати багато часу. Крім того, можливо такий запит навіть не буде виконано, оскільки розумні дата інженери заборонили виконувати такі запити.\n\n\n\n\n\n\nПримітка!\n\n\n\nОператор FROM завжди вказується після оператора SELECT. У зворотному порядку їх записувати не можна – база даних поверне помилку."
  },
  {
    "objectID": "05_01_basics.html#order-by",
    "href": "05_01_basics.html#order-by",
    "title": "4  Базові запити",
    "section": "4.2 ORDER BY",
    "text": "4.2 ORDER BY\nДля сортування значень по будь-якій колонці SQL використовується оператор ORDER BY з ключовими словами ASC (за зростанням) або DESC (за спаданням).\nПри цьому за умовчанням сортування відбувається за зростанням, тобто ASC не обов’язково вказувати. Для сортування за спаданням після ORDER BY необхідно явно вказати DESC:\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1           -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 ASC       -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC      -- сортування за спаданням\n\n\nПриклад 4.1 Виведіть всі записи з таблиці products, відсортувавши їх за найменуванням товарів у алфавітному порядку, тобто. за зростанням. Для сортування використовуйте оператор ORDER BY.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\n\nПримітка!\n\n\n\nСортування можна робити не тільки по полях зі значеннями, вираженими числами, але й по полях, значення яких представлені у вигляді тексту, як у нашому випадку.\n\n\nРішення:\n\nSELECT product_id,\n       name,\n       price\nFROM   products\nORDER BY name\nLIMIT 5\n\n\n5 records\n\n\nproduct_id\nname\nprice\n\n\n\n\n62\napple juice\n120\n\n\n71\napples\n75\n\n\n39\nbagels\n45\n\n\n65\nbananas\n100\n\n\n66\nbeef\n370\n\n\n\n\n\n\nСортувати результат SQL-запиту можна відразу за декількома колонками, вказуючи їх після ORDER BY через кому разом із напрямком сортування (ASC або DESC):\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2    -- спочатку сортування по першій колонці (за спаданням),\n                                    -- потім по другій (за зростанням)\n\n\n\n\n\n\n\nПримітка!\n\n\n\nВажливо пам’ятати, що при роботі з великими таблицями потрібно по можливості обмежувати кількість виведених записів, щоб не створювати зайве навантаження на базу даних.\n\n\nОператори ORDER BY та LIMIT можна поєднувати в одному запиті, при цьому оператор LIMIT записується та виконується після оператора ORDER BY, обмежуючи кількість записів у вже відсортованому результаті:\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2\nLIMIT 5\n\n\nПриклад 4.2 Відсортуйте таблицю courier_actions спочатку по колонці courier_id за зростанням id кур’єра, потім по колонці action (знову за зростанням), а потім по колонці time, але вже за спаданням — від останньої дії до першої. Не забудьте включити колонку order_id.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: courier_id, order_id, action, time.\n\n\n\n\n\n\nПримітка!\n\n\n\nЯк ви вже здогадалися, сортувати таблиці можна навіть по полях з датами та часом.\n\n\n\nSELECT courier_id,\n       order_id,\n       action,\n       time\nFROM   courier_actions\nORDER BY courier_id, action, time DESC limit 5\n\n\n5 records\n\n\ncourier_id\norder_id\naction\ntime\n\n\n\n\n1\n233\naccept_order\n2022-08-25 01:55:00\n\n\n1\n194\naccept_order\n2022-08-25 00:57:00\n\n\n1\n98\naccept_order\n2022-08-24 21:53:00\n\n\n1\n233\ndeliver_order\n2022-08-25 02:16:00\n\n\n1\n194\ndeliver_order\n2022-08-25 01:15:00\n\n\n\n\n\n\nЗараз важливо запам’ятати порядок запису всіх відомих нам ключових слів:\n\nSELECT\nFROM\nORDER BY\nLIMIT\n\nТакож важливо зрозуміти, що порядок їх виконання дещо відрізняється від того, в якій послідовності вони вказуються в SQL-запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nПотім SELECT - відбираються вказані стовпці.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\n\nПриклад 4.3 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, визначте 5 найдорожчих товарів у таблиці products, які доставляє наш сервіс. Виведіть їх найменування та ціну.\nПоля у результуючій таблиці: name, price.\n\nSELECT name,\n       price\nFROM   products\nORDER BY price desc limit 5\n\n\n5 records\n\n\nname\nprice\n\n\n\n\ncaviar\n800\n\n\nmutton\n559\n\n\nolive oil\n450\n\n\npork\n450\n\n\ndecaffeinated coffee\n400"
  },
  {
    "objectID": "05_01_basics.html#as",
    "href": "05_01_basics.html#as",
    "title": "4  Базові запити",
    "section": "4.3 AS",
    "text": "4.3 AS\nПри складанні SQL-запитів колонкам у результуючій таблиці можна надавати будь-які інші імена (їх ще називають «аліасами»). Це можна робити за допомогою оператора AS:\n\nSELECT name AS new_name\nFROM table\n\nЯкщо раптом вам здасться, що на написання оператора AS йде занадто багато часу і сил, його можна опустити, вказавши нове ім’я колонки без нього. Наступний запис також спрацює:\n\nSELECT name new_name\nFROM table\n\n\nПриклад 4.4 Повторіть запит із з попереднього прикладу (Приклад 4.3), але тепер колонки name і price перейменуйте відповідно на product_name і product_price.\nПоля у результуючій таблиці: product_name, product_price\n\nSELECT name AS product_name,\n       price AS product_price\nFROM   products\nORDER BY price desc limit 5\n\n\n5 records\n\n\nproduct_name\nproduct_price\n\n\n\n\ncaviar\n800\n\n\nmutton\n559\n\n\nolive oil\n450\n\n\npork\n450\n\n\ndecaffeinated coffee\n400"
  },
  {
    "objectID": "05_01_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "href": "05_01_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "title": "4  Базові запити",
    "section": "4.9 Типові помилки при написанні SQL-запитів.",
    "text": "4.9 Типові помилки при написанні SQL-запитів.\n\nНеправильний порядок або помилки у ключових словах. Правильний порядок операторів у запиті виглядає так:\n\n\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- угруповання даних\nHAVING      -- фільтрація даних після угруповання\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\n\nНеправильно названі функції та оператори, що використовуються в запиті (наприклад, DATEPART, а не DATE_PART).\nНеправильно вказано імена стовпців.\nНеправильно виконано сортування записів.\nНеправильно проведено розрахунки.\nПропущена кома при перерахуванні стовпців у SELECT\nЗайва кома після імені останнього стовпця в SELECT\nНе закриті дужки (перевірте, що кількість дужок дорівнює кількості закривають).\nДопущено помилку в підзапиті (перед виконанням всього запиту перевірте, чи працюють окремі підзапити).\nЗапущено відразу кілька запитів, не розділених крапкою з комою.\n\n\n\n\n\n\n\nПримітка!\n\n\n\nЗараз деякі пункти можуть бути незрозумілими, але з часом ви розберетеся, про що йдеться."
  },
  {
    "objectID": "04_quarto.html#що-таке-quarto",
    "href": "04_quarto.html#що-таке-quarto",
    "title": "7  Quarto",
    "section": "7.1 Що таке Quarto",
    "text": "7.1 Що таке Quarto\nQuarto — це науково–технічна видавнича система з відкритим кодом, яка ґрунтується на універсальному конверторі документів Pandoc та використовує мову розмітки Markdown. Це універсальний інструмент для тих, хто пише на R, Python, Julia та Observable JavaScript.\nЗа допомогою Quarto можна поєднувати описовий текст і код для створення відформатованих документів, веб–сторінок, постів у блогах, книг тощо.\n\n7.1.1 Назва Quarto\nРозробники Quarto хотіли використати ім’я, яке мало деяке значення в історії видавничої справи. Вибір пав на Quarto (від латинського quārtō, скорочено Qto, 4to або 4º) — це формат книги або брошури в одну четвертину топографічного листа. На кожній стороні листа при цьому поміщається 4 сторінки книги (8 сторінок на один лист).\nНайраннішим відомим виданням такого формату була Книга Сивіл (англ. Sibyllenbuch), що була надрукована Йоганном Гутенбергом у 1452–1453 роках.\n\n\n\nРисунок 7.1: Quarto\n\n\n\n\n7.1.2 Можливості Quarto\nQuarto являє собою текстовий документ спеціального формату .qmd, який можна скомпілювати у різноманітні документи:\n\nДокументи у форматах:\n\nHTML\nPDF\nePub\nMS Word\nOpenOffice\n\nПрезентації у форматах:\n\nreveal.js (HTML)\nPowerPoint (MS Office)\nBeamer (LaTeX/PDF)\n\nВеб-сторінки:\n\nPractical Deep Learning від fast.ai\nnbdev від fast.ai\nКурс Julia Workshop for Data Science\n\nКниги, приклади яких можна переглянути за посиланнями:\n\nPython for Data Analysis\nR for Data Science\nVisualization Curriculum\n\nІнтерактивні документи:\n\nObservable reactive JavaScript\nShiny вебфреймворк\nІнтерактивні віджети Jupyter"
  },
  {
    "objectID": "04_quarto.html#початок-роботи-з-quarto",
    "href": "04_quarto.html#початок-роботи-з-quarto",
    "title": "7  Quarto",
    "section": "7.2 Початок роботи з Quarto",
    "text": "7.2 Початок роботи з Quarto\n\n7.2.1 Встановлення Quarto\nДля роботи з Quarto потрібно: 1. Встановити інтерфейс командного рядка Quarto (CLI) під актуальну операційну систему (Windows, Linux або Mac OS).\n\nВстановити плагін для інтегрованого середовища розробки (IDE). На даний момент підтримуються:\n\nVS Code\nRStudio\nJupyter\n\n\n\n\n7.2.2 Робота з проектами\nСтворити Quarto–проект можна декількома шляхами:\n\nЗа допомогою командного рядка:\n\n\n\nterminal\n\n# веб-сайт\nquarto create-project mysite --type website\n\n# блог\nquarto create-project myblog --type website:blog\n\n# книга\nquarto create-project mybook --type book\n\n\nЗасобами IDE:\n\n\nVS Code: File -> New File -> …\n\n\n\n\nРисунок 7.2: Меню створення Quarto–проекту у VS Code\n\n\n\nRStudio: File -> New Project… -> New Directory\n\n\n\n\nРисунок 7.3: Меню створення Quarto–проекту у RStudio\n\n\n\n\n7.2.3 Як працює Quarto\nСпочатку Knitr (для R) або Jupyter (для Python або Julia) виконує всі фрагменти коду .qmd-файлу і створює новий markdown (.md) документ, який включає в себе код і всі його результати. Далі .md–файл оброблюється Pandoc для перетворення у різноманітні формати файлів (HTML, PDF, Word тощо).\n\n\n\nРисунок 7.4: Процедура рендерінгу документів в Quarto\n\n\n\n\n7.2.4 Рендерінг\n\nДля рендерінгу документу можна використати кнопку Render в VS Code.\n\n\n\n\nРисунок 7.5: Клавіша рендерінгу документу в VS Code\n\n\n\nРендерінг за допомогою командного рядку:\n\n\n\nterminal\n\nquarto render <input> --to <format>\n\n# Наприклад:\nquarto render document.qmd --to docx"
  },
  {
    "objectID": "04_quarto.html#структура-документів-quatro",
    "href": "04_quarto.html#структура-документів-quatro",
    "title": "7  Quarto",
    "section": "7.3 Структура документів Quatro",
    "text": "7.3 Структура документів Quatro\nQuatro документи складаються з трьох базових складових:\n\nYAML–шапки1\nТексту з використанням розмітки Markdown\nЧанків (анг. chunks) з кодом\n\n\n7.3.1 YAML–шапка\nYAML–шапка знаходиться нагорі документу і відділена трьома дефісами (---) зверху та знизу. В ній зберігається мета–інформація документу: назва, дата створення, автор, інформація щодо роботи коду, контенту і процесу рендерінгу.\n---\ntitle: \"Dracula\"\nauthor: \"Bram Stoker\"\ndate: \"May 26, 1897\"\nformat: \n  html:\n    toc: true\n    code-fold: true\n---\n\n\n7.3.2 Тексту з використанням розмітки Markdown\nЦя частина документу йде одразу після YAML–шапки і складає основну частину документу.\nMarkdown — це популярна і зручна мова розмітки. Ви непевно зустрічали її в README.md–файлах репозиторіїв GitHub, а також у Telegram–повідомленнях.\n\n\n7.3.3 Чанки з кодом\nЧанки — це блоки, які відділяються від тексту потрійними зворотніми лапками ``` ( анг. backtick) на початку та в кінці. У фігурних дужках вказується мова програмування на якій необхідно виконати код.\n```{python}\nprint('Fly, you fools!')\n```\nРезультат чанку за замовчування виводиться одразу після нього, але все це можна налаштувати."
  },
  {
    "objectID": "04_quarto.html#yaml-шапка",
    "href": "04_quarto.html#yaml-шапка",
    "title": "7  Quarto",
    "section": "7.4 YAML-шапка",
    "text": "7.4 YAML-шапка\nМетадані документу можуть бути задані у шапці документу або окремим _quarto.yml-файлом.\nВ цій частині документу зберігається інформація щодо назви документу, дати, автора, налаштування рендерінгу, параметри чанків та інші додаткові налаштування. Всі параметри встановлюються у форматі key: value.\n\n7.4.1 Налаштування виводу\nКлюч format: відповідає за тип вихідного файлу.\n\n\n\n\n\n\n\n\nТип\nЗначення\nОпис\n\n\n\n\nДокументи\n\nhtml\npdf\ndocx\nodt\nepub\n\n\nHTML\nPDF\nMS Word\nOpenDocument\nePub\n\n\n\nПрезентації\n\nrevealjs\npptx\nbeamer\n\n\nRevealjs\nPowerPoint\nBeamer\n\n\n\nMarkdown\n\ngfm\ncommonmark\nmarkua\n\n\nGFM\nCommonMark\nMarkua\n\n\n\nWiki\n\nmediawiki\ndokuwiki\nzimwiki\njira\nxwiki\n\n\nMediaWiki\nDocuWiki\nZimWiki\nJira Wiki\nXWiki\n\n\n\n\nА також цілу низку інших форматів, документацію по котрим можна отримати в розділі Reference документації.\n\n\n7.4.2 Назва, дата та автор\nВ залежності від типу вихідного документу, ці ключі можуть відрізнятися, але наведу основні:\n\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\n\ntitle\nНазва документа\n\n\nsubtitle\nПідзаголовок документа\n\n\ndate\nДата документа\n\n\nauthor\nАвтор або автори документа\n\n\n\n\n\n7.4.3 Зміст\nДля генерації змісту (анг. table of contents, скорочено toc) необхідно ключу toc задати значення true. В залежності від типу вихідного документу зміст буде згенерований відповідно до заголовків (Розділ 7.5.2).\n\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\n\ntoc\nДодайте автоматично створений зміст у вихідний документ.\n\n\ntoc-depth\nКількість рівнів розділу, які потрібно включити у зміст. За замовчуванням 3\n\n\ntoc-title\nЗаголовок, використаний для змісту.\n\n\n\n\n\n7.4.4 Локалізація документу\nQuarto, Pandoc та LaTeX генерують текстові елементи документу, які потребують локалізації. Наприклад: “Рисунок” або “Таблиця” для перехресних посилань, назви виносок тощо.\n\n7.4.4.1 Налаштування lang\nПриклад використання польської локалізації документу:\n---\ntitle: \"Mój dokument\"\nlang: pl  \n---\nЦе призведе до використання польського перекладу компонентів документу, а також до застосування інших мовних правил обробки документів.\nНаразі доступні повні переклади такими мовами:\n\nанглійська (en, за замовчуванням)\nголландська (nl)\nіспанська (es)\nіталійська (it)\nкитайська (zh)\nкорейська (kr)\nнімецька (de)\nпольська (pl)\nпортугальська (pt)\nросійська (ru)\nфінська (fi)\nфранцузька (fr)\nчеська (cs)\nяпонська (ja)\n\n\n\n7.4.4.2 Власна локалізація\nЯкщо вас не влаштовує мова за умовчанням, яка використовується для певної частини документа, ви можете вказати альтернативну мову за допомогою ключа language. Наприклад, щоб замінити значення підписів «Author» і «Published», які використовуються в блоках заголовків, ви можете зробити це:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: \n  title-block-author-single: \"Автор\"\n  title-block-published: \"Опубліковано\"\n---\nВсі ці зміни можна зберегти в окремому .yml-файлі і використовувати власну локалізацію до документу:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: custom.yml\n---\nЯ зробив власну українську локалізацію Quarto-документів, яку Ви можете завантажити з мого GitHub-репозиторія: https://github.com/aranaur/quarto-ukrainian.\nОзнайомитися з усіма офіційними локалізаціями можна за посиланням: https://github.com/quarto-dev/quarto-cli/tree/main/src/resources/language."
  },
  {
    "objectID": "04_quarto.html#основи-markdown",
    "href": "04_quarto.html#основи-markdown",
    "title": "7  Quarto",
    "section": "7.5 Основи Markdown",
    "text": "7.5 Основи Markdown\nQuarto ґрунтується на Pandoc та використовує різновид markdown в якості базового синтаксису. Pandoc markdown — це розширена та злегка перероблена версія синтаксису markdown.\nMarkdown — це формат звичайного тексту, який розроблено таким чином, щоб його було легко писати та, що ще важливіше, легко читати.\n\n7.5.1 Форматування тексту\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n*курсив* та **жирний**\nкурсив та жирний\n\n\nнадрядковий^2^ / підрядковий~2~\nнадрядковий2 / підрядковий2\n\n\n~~перекреслення~~\nперекреслення\n\n\n`дослівний код`\nдослівний код\n\n\n\n\n\n7.5.2 Заголовки\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n# Заголовок 1\nЗаголовок 1\n\n\n## Заголовок 2\nЗаголовок 2\n\n\n### Заголовок 3\nЗаголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6\n\n\n\n\n\n7.5.3 Посилання та рисунки\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n[Python](https://python.org)\nPython\n\n\n![Підпис](img/python-logo.jpg)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org \"Python\")\n\n\n\n[![](img/python-logo.jpg){fig-alt=\"Alt text\"}](https://www.python.org)\n\n\n\n\n\n\n7.5.4 Списки\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n* невпорядкований список\n    + підпункт 1\n    + підпункт 2\n        - під--підпункт 1\n\nневпорядкований список\n\nпідпункт 1\nпідпункт 2\n\nпід–підпункт 1\n\n\n\n\n\n*   пункт 2\n\n    Продовження (відступ 4 інтервали)\n\nпункт 2\nПродовження (відступ 4 інтервали)\n\n\n\n1. впорядкований список\n2. пункт 2\n    i) підпункт 1\n         A.  під--підпункт 1\n\nвпорядкований список\nпункт 2\n\nпідпункт 1\n\nпід–підпункт 1\n\n\n\n\n\n(@)  Список, нумерація якого\n\nпродовжується після\n\n(@)  переривання\n\nСписок, нумерація якого\n\nпродовжується після\n\nпереривання\n\n\n\nтермін\n: визначення\n\nтермін\n\nвизначення\n\n\n\n\n\n\n\n7.5.5 Таблиці\n\n7.5.5.1 Таблиці markdown\n\nСинтаксис markdown\n| Зліва | Справа | За замовчуванням | По центру |\n|------:|:-------|------------------|:---------:|\n|   12  |  12    |    12            |    12     |\n|  123  |  123   |   123            |   123     |\n|    1  |    1   |     1            |     1     |\n\n\nРезультат\n\n\n\nЗліва\nСправа\nЗа замовчуванням\nПо центру\n\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\nФормувати такі таблиці вручну досить складно і незручно. В таких випадках на допомогу приходить Markdown Tables Generator.\n\n\n\n7.5.5.2 Таблиці з Python\n\nЗа допомогою комбінації функцій Markdown() та пакету tabulate:\n\n\n\nterminal\n\npip install tabulate\n\n\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\ntable = [[\"Bilbo Baggins\", \"Hobbits\", \"Male\"],\n         [\"Beren\", \"Men\", \"Male\"],\n         [\"Nimrodel\", \"Elves\", \"Female\"],\n         [\"Muzgash\", \"Orc\", \"Male\"]]\nMarkdown(tabulate(\n  table, \n  headers=[\"Name\", \"Race\", \"Sex\"]\n))\n\n\n\nТаблиця 7.1: Персонажі Середзем’я\n\n\nName\nRace\nSex\n\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nPandas DataFrame у форматі консолі:\n\n\nчерез функцію print(), у форматі консолі:\n\n\nimport pandas as pd\n\ndf = pd.DataFrame(data = table,\n    columns = [\"Name\", \"Race\", \"Sex\"])\nprint(df)\n\n            Name     Race     Sex\n0  Bilbo Baggins  Hobbits    Male\n1          Beren      Men    Male\n2       Nimrodel    Elves  Female\n3        Muzgash      Orc    Male\n\n\n\nМожна викликати Python через R за допомогою пакету reticulate та використати функцію kable() з пакету knitr:\n\n\nlibrary(reticulate)\nlibrary(knitr)\n\nkable(py$df)\n\n\n\nТаблиця 7.2: Персонажі Середзем’я\n\n\nName\nRace\nSex\n\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nДодаткові можливості з’являються разом з пакетом kableExtra:\n\n\n# R chunk\nlibrary(kableExtra)\n\npy$df %>% \n  kbl() %>%\n  kable_classic_2(full_width = F)\n\n\n\nТаблиця 7.3:  Персонажі Середзем’я \n \n  \n    Name \n    Race \n    Sex \n  \n \n\n  \n    Bilbo Baggins \n    Hobbits \n    Male \n  \n  \n    Beren \n    Men \n    Male \n  \n  \n    Nimrodel \n    Elves \n    Female \n  \n  \n    Muzgash \n    Orc \n    Male \n  \n\n\n\n\n\n\n\n\n\n7.5.6 Рівняння\nДля запису рівняння в середині тексту використовується одинарний символ $ та подвійний $$ для запису рівняння з нового рядка:\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\nу середині тексту: $E = mc^{2}$\nу середині тексту: \\(E=mc^{2}\\)\n\n\nз нового рядка:\n\n$$E = mc^{2}$$\nз нового рядка:\n\\[E = mc^{2}\\]\n\n\n\nВ якості допомоги формування рівнянь рекомендую ресурс Online LaTeX Equation Editor.\n\n\n7.5.7 Діаграми\nQuarto має вбудовану підтримку для створення діаграм Mermaid та Graphviz. Це дає змогу створювати блок–схеми, діаграми послідовності, діаграми станів тощо, використовуючи синтаксис простого тексту.\nПриклад створення блок–схеми за допомогою Mermaid:\n\n```{mermaid}\nflowchart LR\n  A[Квадратна форма] --> B(Кругла форма)\n  B --> C{Рішення}\n  C --> D[Результат один]\n  C --> E[Результат два]\n```\n\n\n\nflowchart LR\n  A[Квадратна форма] --> B(Кругла форма)\n  B --> C{Рішення}\n  C --> D[Результат один]\n  C --> E[Результат два]\n\n\n\n\n\n\n\n\nБільше інформації у розділі Diagrams.\n\n\n7.5.8 Відео\nВставляти відео у документи можна за допомогою запису {{< video >}}.\nПриклад використання відео з Youtube:\n{{< video https://www.youtube.com/embed/qOhk7YyxXQ4 >}}\nБільше інформації у розділі Videos.\n\n\n7.5.9 Виноски\n\n7.5.9.1 Типи виносок\nВиноски — чудовий спосіб привернути додаткову увагу до певних понять або чіткіше вказати, що певний вміст є додатковим або потребує додаткової уваги.\nУ Quarto є п’ять різноманітних виносок: - примітка (note) - застереження (warning) - важливо (important) - підказка (tip) - попередження (caution)\nКолір і значок відрізнятимуться залежно від обраного типу. Ось як виглядають різні виноски в HTML:\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що існує п’ять типів виносок, зокрема: note, tip, warning, caution та important.\n\n\n\n\n\n\n\n\nЗастереження\n\n\n\nВиноски — простий спосіб привернути увагу, наприклад, до цього застереження.\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nВиноски точно покращать Ваш текст.\n\n\n\n\n\n\n\n\nПідказка\n\n\n\nПриклад виноски з текстом\n\n\n\n\n\n\n\n\nРозгорніть, щоб дізнатися про згортання\n\n\n\n\n\nЦе приклад «згорнутої» виноски з попередженням. Використайте collapse=\"true\" щоб згорнути її за замовчуванням та collapse=\"false\" щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n\n\n\n\n\n7.5.9.2 Синтаксис markdown\nСтворіть виноски в розмітці за допомогою наступного синтаксису (зверніть увагу, що перший заголовок, використаний у виносці, використовується як заголовок виноски):\n::: {.callout-note}\n## Примітка\n\nЗауважте, що існує п’ять типів виносок, зокрема:\n`note`, `tip`, `warning`, `caution` та `important`.\n:::\n\n::: {.callout-tip}\n## Підказка\n\nПриклад виноски з текстом\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Розгорніть, щоб дізнатися про згортання\n\nЦе приклад «згорнутої» виноски з попередженням.\nВикористайте `collapse=\"true\"` щоб згорнути її за замовчуванням та `collapse=\"false\"` щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n:::\n\n\n\n7.5.10 Спеціальні символи\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\nтире: -\nтире: -\n\n\nкоротке (середнє) тире: --\nкоротке (середнє) тире: –\n\n\nдовге тире: ---\nдовге тире: —\n\n\n\n\n\n\n\n\n\nПриклади\n\n\n\n\nЖиття прожити — не поле перейти (довге тире)\n2020–2022 (коротке тире)\n25 - 5 (тире)"
  },
  {
    "objectID": "04_quarto.html#виконання-коду",
    "href": "04_quarto.html#виконання-коду",
    "title": "7  Quarto",
    "section": "7.6 Виконання коду",
    "text": "7.6 Виконання коду\n\n7.6.1 Налаштування виводу\nІснує широкий спектр доступних параметрів для налаштування виводу виконаного коду. Усі ці параметри можна вказати глобально (у YAML-шапці з ключем execute) або для кожного блоку коду.\n\nПриклад глобальних налаштувань:\n\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\nexecute:\n  echo: false\n---\n\nПриклад налаштування конкретного чанку:\n\n```{python}\n#| echo: true\n\nimport matplotlib.pyplot as plt\nplt.plot([1, 2, 3, 4])\nplt.show()\n```\nПараметри налаштування знаходяться у верхній частині блоку під спеціальним коментарем #|.\n\n\n\n\n\n\n\nНалаштування\nОпис\n\n\n\n\neval\nОцініть фрагмент коду (якщо false, просто відтворіть код).\n\n\necho\nПоказувати код (якщо false, код не буде виведено на екран).\n\n\nwarning\nПоказувати попередження, які виникають під час виконання коду\n\n\nerror\nПоказувати помилки у документі (це означає, що помилки під час виконання коду не зупинять обробку документа).\n\n\ninclude\nЗапобігає виводу коду та його результатів.\n\n\n\n\n\n7.6.2 Вбудований код\nQuarto дозволяє виводити результат коду в середині тексту. Це особливо зручно, якщо необхідно щоб документ використовував найсвіжіші розрахунки. Проте синтаксис виводу залежить від рушія (анг. engine) Quarto: Jupyter, Knitr або OJS.\n\n7.6.2.1 Jupyter\nЩоб включити збережену змінну, використовуєте IPython.display.Markdown.\nНаприклад, виведемо площу кола за заданим радіусом (radius):\n```{python}\n#| echo: false\n\nfrom IPython.display import Markdown\nimport math\n\nradius = 10\ncircle_area = math.pi * pow(radius, 2)\n\nMarkdown((f\"\"\"\nПлоща кола з радіусом {radius} дорівнює {round(circle_area, 2)}.\n\"\"\"\n))\n```\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що ми використовуємо опцію echo: false, щоб не виводити код у фінальний документ, а тільки результат.\n\n\n\n\n7.6.2.2 Knitr\nАналогічно до роботи з таблицями (див. Розділ 7.5.5.2) можемо поєднати можливості R та Python для виводу результату коду в тексті документу.\nЩоб включити вирази в розмітку для Knitr, використовується вираз у `r `:\n```{r}\n#| include: false\n\nlibrary(reticulate)\n```\n```{python}\n#| echo: false\n\nimport math\n\nradius = 10\ncircle_area = round(math.pi * pow(radius, 2), 2)\n```\nПлоща кола з радіусом  `r⠀py$radius`  дорівнює `r⠀py$circle_area`.\n\n\n\n\n\n\nПримітка\n\n\n\nЗапис py$radius означає: взяти значення змінної Python з ім’ям radius."
  },
  {
    "objectID": "04_quarto.html#основи-публікації",
    "href": "04_quarto.html#основи-публікації",
    "title": "7  Quarto",
    "section": "7.7 Основи публікації",
    "text": "7.7 Основи публікації\nІснує низка способів публікації документів, презентацій і веб-документів, створених за допомогою Quarto. Оскільки вміст, відтворений за допомогою Quarto, використовує стандартні формати (HTML, PDF, MS Word тощо), його можна опублікувати будь-де. Крім того, доступна команда quarto publish для легкої публікації в різних популярних службах (GitHub, Netlify, RStudio Connect тощо), а також різні інструменти, які полегшують публікацію з системи Неперервної інтеграції (анг. Continuous integration).\nСервіси для публікації:\n\n\n\n\n\n\n\nСервіс\nОпис\n\n\n\n\nQuarto Pub\nПублікація документів, веб-сайтів і книг Quarto.\n\n\nGitHub Pages\nПублікація документів за допомогою репозиторію GitHub\n\n\nRStudio Connect\nПлатформа для безпечного обміну даними в межах організації.\n\n\nNetlify\nПрофесійна платформа веб-публікації.\n\n\nІнші сервіси\nСкористайтеся цими сервісами, якщо один із наведених вище методів не відповідає вашим вимогам."
  },
  {
    "objectID": "05_01_basics.html#length",
    "href": "05_01_basics.html#length",
    "title": "4  Базові запити",
    "section": "4.4 LENGTH",
    "text": "4.4 LENGTH\nУ SQL-запитах до колонок таблиць можна використовувати різні функції, наприклад, як в Excel.\nУ загальному вигляді синтаксис функцій виглядає приблизно так:\n\nSELECT function(a, b, c, ...)\nFROM table\n\nЗамість function вказується назва функції, а дужках — її аргументи. Як аргументи можуть виступати як колонки зі значеннями, так і окремі значення. Залежно від функції кількість аргументів може відрізнятися.\nЯкщо ви коли-небудь працювали в Excel, то вам, напевно, знайомі різні функції на кшталт SUM, MIN, MAX тощо, які роблять деякі обчислення по стовпцях. У SQL вони називаються агрегуючими функціями.\nЗараз як приклад розглянемо функцію LENGTH. Вона виконує досить просте завдання — підраховує кількість символів у поданому їй на вхід значенні текстового типу (текстовий тип даних часто називають рядком — від англ. «string»). Іншими словами, функція LENGTH вимірює довжину деякого рядка у символах:\n\nSELECT LENGTH('You shall not pass!') as gendalf_say\n\n\n1 records\n\n\ngendalf_say\n\n\n\n\n19\n\n\n\n\n\nФункція LENGTH також може застосовуватись до всього стовпця. У такому випадку довжина символів буде порахована для кожного значення в стовпці. Відповідний запит виглядатиме так:\n\nSELECT LENGTH(column) AS column_length\nFROM table\n\n\nПриклад 4.5 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, а також функцію LENGTH, визначте товар із найдовшою назвою у таблиці products. Виведіть його найменування, довжину найменування у символах, а також ціну цього товару. Назвіть колонку з довжиною найменування в символах name_length.\nПоля у результуючій таблиці: name, name_length, price.\n\nSELECT name,\n       length(name) as name_length,\n       price\nFROM   products\nORDER BY name_length desc limit 1\n\n\n1 records\n\n\nname\nname_length\nprice\n\n\n\n\nfruit drink blueberry\n21\n170\n\n\n\n\n\n\n\n\n\n\n\nПримітка!\n\n\n\nЗверніть увагу, що в цьому прикладі ви сортуєте результуючу таблицю по розрахунковій колонці name_length, якої спочатку не було таблиці products.\nТаке сортування за новими колонками можливе, оскільки це узгоджується з порядком виконання операторів у запиті: спочатку виконується вибір колонок і всі перетворення над ними в операторі SELECT — і тільки потім проводиться сортування за вказаними в ORDER BY стовпчиками. Тобто на момент сортування всі розрахункові поля вже існують, а значить, їх можна вказувати в ORDER BY.\nТакож зверніть увагу, що ми двічі вказуємо колонку name в операторі SELECT: вперше просто звертаємося до неї за ім’ям, а вдруге - використовуємо її як аргумент функції LENGTH. У цьому випадку теж немає жодних протиріч - ми можемо вибирати колонку стільки разів, скільки необхідно, причому для цього навіть необов’язково надавати цим колонкам різні аліаси (база даних сама перейменує дублікат колонки).\n\n\n\nУ SQL, як й у багатьох інших мовах, функції можна застосовувати до інших функцій, тобто. послідовно:\n\nSELECT function_one(function_two(a, b), c)\n\nУ наведеній вище конструкції a, b, c аргументи функцій. При цьому одним із аргументів функції function_one є результат виконання функції function_two.\nТаким чином, спочатку буде виконана функція function_two, а потім її результат буде поданий на вхід функції function_one як один з аргументів.\nРозглянемо такий випадок на прикладі функцій UPPER та LEFT. Функція UPPER наводить подане їй на вхід текстове значення до верхнього регістру:\n\nSELECT \n    UPPER('You Shall not pass!') AS upper_all\n\nРезультат:\nYOU SHALL NOT PASS!\n\nФункція LEFT повертає перші n символів у рядку:\n\nSELECT \n    LEFT('You shall not pass!', 9) AS first_n\n\nРезультат:\nYou shall\n\nМи можемо застосувати ці функції послідовно і в результаті отримаємо перші три символів верхнього регістру:\n\nSELECT \n    UPPER(LEFT('You shall not pass!', 3))\n\nРезультат:\nYOU\n\n\n\n\n\n\n\nОбережно!\n\n\n\nВажливо: зверніть увагу, що у блоці SELECT не можна виконати дві операції окремо, тобто. ми не можемо спочатку створити розрахункову колонку з першими шістьма символами, а потім відразу ж звернутися до цієї нової колонки, застосувавши до неї функцію UPPER.\n\n\nНаступний запит не буде виконано, база даних поверне помилку:\n\nSELECT \n    LEFT('You shall not pass!', 3) AS first_n,\n    UPPER(first_n) AS upper_first_n\n\nРезультат:\nError running query: column \"new_name\" does not exist\n\nВ межах одного запиту колонки створюються не по черзі, а разом, тому в межах одного запиту колонки upper_first_n не існує, поки блок SELECT не буде повністю виконаний. Дуже важливо враховувати цю особливість мови.\nОднак на практиці до нових колонок доводиться звертатися досить часто — саме для цього є підзапити (запити до інших запитів). А поки що нам достатньо розуміти, що застосовувати функції до розрахункових колонок у тому ж запиті не можна."
  },
  {
    "objectID": "05_01_basics.html#split_part",
    "href": "05_01_basics.html#split_part",
    "title": "4  Базові запити",
    "section": "4.5 SPLIT_PART",
    "text": "4.5 SPLIT_PART\nФункція SPLIT_PART розбиває поданий їй на вхід рядок на кілька частин відповідно до зазначеного роздільника та повертає одну з частин.\nКрім самого рядка (або колонки зі значеннями рядкового типу), функція приймає ще два аргументи — роздільник і порядковий номер частини, яку необхідно повернути. Подивіться наступний приклад:\n\nПриклад 4.6  \n\nSELECT SPLIT_PART('You shall not pass!', ' ', 4)\n\nРезультат:\npass!\n\n\nУ прикладі вище рядок ‘You Shall not pass!’ було розбито на чотири частини (‘You’, ‘shall’, ‘not’ і ‘pass!’) по роздільнику “пробіл”. Функція повернула ‘pass’, оскільки третім аргументом ми вказали частину із порядковим номером 4.\n\n\n\n\n\n\nПримітка!\n\n\n\nДокладніше з іншими функціями для роботи з рядками можна ознайомитись за посиланням.\n\n\n\nПриклад 4.7 Застосуйте послідовно функції UPPER та SPLIT_PART до колонки name та перетворіть найменування товарів у таблиці products так, щоб від назв залишилося тільки перше слово, записане у верхньому регістрі. Колонку з новою назвою, що складається із першого слова, назвіть first_word.\nУ результаті виведіть вихідні найменування товарів, нові найменування з першого слова, а також ціну товарів. Результат відсортуйте за зростанням початкового найменування товару в колонці name.\nПоля у результуючій таблиці: name, first_word, price\n\nSELECT\n    name,\n    UPPER(SPLIT_PART(name, ' ', 1)) AS first_word,\n    price\nFROM\n    products\nORDER BY\n    name\n\n\nDisplaying records 1 - 10\n\n\nname\nfirst_word\nprice\n\n\n\n\napple juice\nAPPLE\n120\n\n\napples\nAPPLES\n75\n\n\nbagels\nBAGELS\n45\n\n\nbananas\nBANANAS\n100\n\n\nbeef\nBEEF\n370\n\n\nblack chocolate\nBLACK\n60\n\n\nblack leaf tea\nBLACK\n84\n\n\nblack tea bags\nBLACK\n56\n\n\nbread\nBREAD\n40\n\n\nbuckwheat\nBUCKWHEAT\n67"
  },
  {
    "objectID": "05_01_basics.html#cast",
    "href": "05_01_basics.html#cast",
    "title": "4  Базові запити",
    "section": "4.6 CAST",
    "text": "4.6 CAST\nІноді виникає необхідність змінити тип даних у якійсь колонці результуючої таблиці, не змінюючи при цьому властивості вихідної таблиці, наприклад, перетворити число на текст (тип даних VARCHAR). І тому існує функція CAST.\nНа вхід функції CAST необхідно подати ім’я колонки, вказавши через AS тип даних, до якого потрібно привести всі значення:\n\nSELECT CAST(column AS VARCHAR)\nFROM table\n\nТакож можна змінити тип даних за допомогою спеціального синтаксису з двома двокрапками («::»):\n\nSELECT column::VARCHAR\nFROM table\n\nНаприклад, переведемо текст ‘100’ у число 100:\n\nSELECT CAST('100' AS INTEGER)\n\nРезультат:\n100\n\nЗверніть увагу, що для успішної конвертації значення повинні бути конвертованими у вказаний тип. Наприклад, текст, який не виглядає як число, перевести до числового типу даних не вийде:\n\nSELECT CAST('text' AS INTEGER)\n\nРезультат:\nError running query: invalid input syntax for type integer: \"text\"\n\nАналогічним чином можна, наприклад, перетворити текст на дату (якщо він виглядає як дата):\n\nSELECT '2022-12-31'::DATE as date\n\nРезультат:\n2022-12-31\n\n\n\n\n\n\n\nПримітка!\n\n\n\nДокладніше з функцією CAST та перетворенням типів даних можна ознайомитись за цим посиланням.\nПро самі типи даних можна почитати тут.\n\n\n\nПриклад 4.8 Змініть тип колонки price з таблиці products на VARCHAR. Виведіть колонки з найменуванням товарів, ціною у вихідному форматі та ціною у форматі VARCHAR. Нову колонку з ціною у новому форматі назвіть price_char.\nРезультат відсортуйте за зростанням початкового найменування товару в колонці name. Кількість записів, що виводяться, не обмежуйте.\nПоля в результуючій таблиці: name, price, price_char\n\nSELECT \n    name,\n    price,\n    CAST(price as VARCHAR) as price_char\nFROM\n    products\nORDER BY\n    name\n\n\nDisplaying records 1 - 10\n\n\nname\nprice\nprice_char\n\n\n\n\napple juice\n120\n120.0\n\n\napples\n75\n75.0\n\n\nbagels\n45\n45.0\n\n\nbananas\n100\n100.0\n\n\nbeef\n370\n370.0\n\n\nblack chocolate\n60\n60.0\n\n\nblack leaf tea\n84\n84.0\n\n\nblack tea bags\n56\n56.0\n\n\nbread\n40\n40.0\n\n\nbuckwheat\n67\n67.0"
  },
  {
    "objectID": "05_01_basics.html#concat",
    "href": "05_01_basics.html#concat",
    "title": "4  Базові запити",
    "section": "4.7 CONCAT",
    "text": "4.7 CONCAT\nУ цьому підрозділі ми ще трохи попрацюємо з текстовими даними та розглянемо функцію CONCAT, за допомогою якої можна з’єднувати в один рядок значення кількох стовпців.\nФункція CONCAT приймає на вхід кілька аргументів і повертає результат їхньої послідовної складання один з одним. Хороша аналогія - складання речень з різних карток зі словами:\n\nSELECT CONCAT('SQL', ' ', 'Python ', 2023)\n\nРезультат:\nSQL Python 2022\n\nПри цьому аргументи не обов’язково мають бути виражені текстовими значеннями — головне, вони мають бути конвертованими в текст. У прикладі вище число 2023 можна конвертувати в текст ‘2023’, тому запит працює без помилок.\n\n\n\n\n\n\nПримітка!\n\n\n\nОзнайомитись з іншими прикладами використання функції CONCAT можна за посиланням.\n\n\n\nПриклад 4.9 Для перших 5 записів з таблиці orders виведіть інформацію у такому вигляді (зверніть увагу на пробіли):\nЗамовлення № [id_замовлення] створено [дата]\nОтриману колонку назвіть order_info.\nПриклад результату:\n\nЗамовлення № 65 створено 2022-09-01\n\nРішення:\n\nSELECT \n    CONCAT('Замовлення № ', order_id, ' створено ', creation_time::DATE) as order_info\nFROM   \n    orders\nLIMIT 5\n\n\n5 records\n\n\norder_info\n\n\n\n\nЗамовлення № 1 створено 2022-08-24\n\n\nЗамовлення № 2 створено 2022-08-24\n\n\nЗамовлення № 3 створено 2022-08-24\n\n\nЗамовлення № 4 створено 2022-08-24\n\n\nЗамовлення № 5 створено 2022-08-24"
  },
  {
    "objectID": "05_01_basics.html#date_part",
    "href": "05_01_basics.html#date_part",
    "title": "4  Базові запити",
    "section": "4.8 DATE_PART",
    "text": "4.8 DATE_PART\nЯк ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (DATE) і часу (TIMESTAMP). Давайте трохи попрацюємо з такими даними.\nНасправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція DATE_PART. Її синтаксис наступний:\n\nSELECT DATE_PART(part, column)\n\nНа місці part необхідно в лапках вказати ту частину, яку потрібно витягти: 'year', 'month', 'day', 'hour' тощо. На місці column слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:\n\nSELECT DATE_PART('day', DATE '2022-01-12')\n\nРезультат:\n12.00\n\n\nSELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')\n\nРезультат:\n31.00\n\nВище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами dates. Тоді запит виглядав би так:\n\nSELECT DATE_PART('day', dates)\n\n\n\n\n\n\n\nПримітка!\n\n\n\nОзнайомитись з іншими прикладами використання функції DATE_PART можна за посиланням.\n\n\n\nПриклад 4.10 Виведіть id всіх кур’єрів та їхні роки народження з таблиці couriers.\nРік народження необхідно одержати з колонки birth_date. Нову колонку з роком назвіть birth_year. Результат відсортуйте спочатку за спаданням року народження кур’єра (тобто від наймолодших до найстарших), потім за зростанням id кур’єра.\nПоля у результуючій таблиці: courier_id, birth_year\nРішення:\n\nSELECT courier_id,\n       date_part('year', birth_date) birth_year\nFROM   couriers\nORDER BY birth_year desc, courier_id\n\n\nDisplaying records 1 - 10\n\n\ncourier_id\nbirth_year\n\n\n\n\n83\nNA\n\n\n187\nNA\n\n\n200\nNA\n\n\n232\nNA\n\n\n411\nNA\n\n\n450\nNA\n\n\n467\nNA\n\n\n481\nNA\n\n\n726\nNA\n\n\n790\nNA\n\n\n\n\n\n\n\nSELECT courier_id,\n       coalesce(date_part('year', birth_date)::varchar, 'unknown') birth_year\nFROM   couriers\nORDER BY birth_year desc, courier_id\n\n\nDisplaying records 1 - 10\n\n\ncourier_id\nbirth_year\n\n\n\n\n83\nunknown\n\n\n187\nunknown\n\n\n200\nunknown\n\n\n232\nunknown\n\n\n411\nunknown\n\n\n450\nunknown\n\n\n467\nunknown\n\n\n481\nunknown\n\n\n726\nunknown\n\n\n790\nunknown"
  }
]