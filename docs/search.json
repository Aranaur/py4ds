[
  {
    "objectID": "python_basics.html#функції",
    "href": "python_basics.html#функції",
    "title": "\n1  Функції та змінні\n",
    "section": "\n1.1 Функції",
    "text": "1.1 Функції\nШвидше за все, більшість з вас, ніколи раніше не програмували, тому давайте почнемо з основ. Давайте відкриємо Visual Studio Code, або VS Code, яка є дуже популярною програмою для написання коду в наш час. Вам не обов’язково писати код за допомогою саме цього інструменту. Насправді, все, що нам потрібно в кінці дня - це так званий текстовий редактор, програма для написання тексту. Внизу екрану знаходиться так зване вікно терміналу, це інтерфейс командного рядка, або інтерфейс CLI, до базового комп’ютера, будь то ваш Mac або ПК, або навіть якийсь сервер у хмарі. Давайте напишемо наступний код у вікні терміналу:\n\n\nTerminal\n\ncode hello.py\n\nЯк ми скоро побачимо, будь-яка програма, яку ви пишете на Python, зазвичай має ім’я файлу, яке закінчується на .py, щоб вказати комп’ютеру, що це дійсно програма, написана на Python.\nПісля виконання коду з’явиться нове вікно з назвою hello.py. Давайте напишемо наступний код у файлі print('Привіт, світ!'). Навіть якщо ви ніколи раніше не програмували, швидше за все, ви можете здогадатися, що буде робити ця проста програма. Для того, щоб запустити програму, натисніть на стрілку у верхньому правому куті вікна або поверніться до вікна терміналу та виконайте наступну команду:\n\n\nTerminal\n\npython hello.py\n\nЩо це означає? Виявляється, що коли я пишу код на такій мові, як Python, мені потрібно інтерпретувати код зверху вниз, зліва направо, щоб комп’ютер розумів, що необхідно робити. Зрештою, навіть якщо ви не дуже багато знаєте про комп’ютери, ви, напевно, чули, що комп’ютери розуміють лише нулі та одиниці, так звану двійкову систему числення. Що ж, якщо це так, то щось не дуже схоже, що print('Привіт, світ!') є нулями та одиницями. Ми повинні якось перевести це в нулі та одиниці, які розуміє комп’ютер. Отже, Python - це не лише мова, якою ми будемо писати код, це також програма, інакше відома як інтерпретатор, яку ви безкоштовно встановлюєте на власний комп’ютер. І ви можете запустити цей інтерпретатор, передавши йому на вхід ім’я вашого файлу, у нашому випадку hello.py. І тоді цей інтерпретатор, займеться процесом його читання зверху вниз, зліва направо, і ефективно переведе його в ті нулі та одиниці, які комп’ютер може зрозуміти. Тож давайте виконаємо цю команду і якщо я нічого не переплутав, я побачу на екрані першу програму:\n\nprint('Привіт, світ!')\n\nПривіт, світ!\n\n\nА тепер давайте зробимо крок назад і подумаємо, що ж ми щойно зробили, і що ж ми бачимо на екрані? Перш за все, у більшості мов програмування ви маєте доступ до того, що називається функціями.\nФункція (анг. functions) - це дія або дієслово, яке дозволяє вам робити щось у програмі. Загалом, будь-яка мова постачається з певним наперед визначеним набором функцій, деяких базових дій або дієслів, які комп’ютер вже знає. А ви можете використовувати ці функції за власним бажанням, щоб змусити комп’ютер виконувати ці дії. Програма hello.py, про яку йде мова, використовує одну функцію. І ви, мабуть, можете здогадатися, що мова йде про функцію print(). Дана функція друку, звичайно, не друкує якийсь наперед визначений рядок тексту. Вона друкує те, що ви їй передаєте. І тут ми знайомимось з ще однією частиною термінології у світі програмування, а саме аргументи.\nАргументи (анг. arguments) - це вхідні дані для функції, які якимось чином впливають на її поведінку. Розробники Python, звичайно, не знали, що саме ми з вами захочемо надрукувати на екрані. Тому вони розробили цю функцію друку з можливістю приймати на вхід деякий рядок тексту щоб ця функція в кінцевому підсумку надрукувала його на екрані. Наша програма hello.py виводить на екранПривіт, світ!. І це, як правило, у програмуванні називається побічним ефектом (анг. side effects). Він може бути візуальним, звуковим, виконувати запису файл або базу даних тощо.\nОтже, я написав першу програму. Все пройшло за планом. Я не зробив жодної помилки. Але, чесно кажучи, коли ви вчитеся програмувати, і навіть коли ви навчилися програмувати, через роки ви будете робити помилки. І ці помилки відносяться до терміну, який ви, можливо, вже знаєте, а саме до багів. Баг (анг. bugs) - це помилка у програмі. Вони можуть приймати найрізноманітніші форми і наша задача навчитися виправляти їх. Ми розглянемо багато інструментів, як розумових, так і технічних, за допомогою яких ви зможете вирішити ці проблеми.\nТож дозвольте мені зараз навмисно зробити помилку: припустимо, що я забув дописати закриваючі дужки в кінці коду. Код на 99% правильний. Але навіть такі маленькі, здавалося б, незначні деталі, на які ми з вами насправді не звертаємо уваги якщо надсилаємо електронного листа чи текстове повідомлення, це просто друкарська помилка. Нічого страшного. Для комп’ютера це буде великою проблемою. Комп’ютер сприйме вас буквально. І якщо ви не закінчите свою думку так, як очікує мова програмування, вона не обов’язково запуститься взагалі:\n\nprint('Привіт, світ!'\n\n'(' was never closed (&lt;string&gt;, line 1)\n\n\nЦя помилка, на щастя, досить проста, вона говорить про те, що відкрита дужка ніколи не була закрита. І тепер інтуїтивно зрозуміло, що мені потрібно зробити - закрити її. На жаль, іноді повідомлення про помилки будуть не такими зручними для користувача.\nА тепер давайте розглянемо, як ми можемо покращити цю програму. Давайте почнемо вдосконалювати цю програму, щоб зробити її більш інтерактивною - чи можу я змусити програму сказати щось на кшталт \"Привіт, Гаррі\", \"Привіт, Герміоно\", \"Привіт, Рон\" або будь-яке інше ім’я користувача? Для цього я повернуся до hello.py і додам ще один рядок коду на самому початку, який просто запитає ім’я користувача.\n\nprint('Як тебе звати?')\nprint('Привіт, світ!')\n\nАле насправді мені потрібна інша функція, щоб отримати дані від користувача. І чудово, що в Python є функція з назвою input(). Якщо почитати документацію до функції цієї функції, виявляється, що вона приймає аргумент - рядок, який буде виведений на екран. Тож я можу покращити попередній код і записати наступне:\n\ninput('Як тебе звати? ') # Гаррі\nprint('Привіт, світ!')\n\n\n\nПривіт, світ!\n\n\nНа жаль, програма нічого не робить з введеним ім’ям. Гаразд, чи можу я виправити це? Я можу перейти до рядка 2 і змінити світ на Гаррі:\n\ninput('Як тебе звати? ') # Гаррі\nprint('Привіт, Гаррі')\n\n\n\nПривіт, Гаррі\n\n\nЗвичайно, програма працює не так, як передбачалося: уявімо, що наш користувач - це Герміона:\n\ninput('Як тебе звати? ') # Герміона\nprint('Привіт, Гаррі')\n\n\n\nПривіт, Гаррі\n\n\nЦе називається “закодувати” або “жорсткий код” (анг. hard-code, hard coding) - я записав буквальне ім’я в середині коду.\nОтже, нам потрібен якийсь спосіб отримати назад те, що ввів користувач, і, зрештою, щось з цим зробити. Для цього ми скористаємося ще однією особливістю програмування, а саме особливістю деяких функцій, яка полягає в тому, що вони можуть повертати значення (анг. return values). Метафорично кажучи, нам потрібно, щоб функція отримувала вхідні дані від користувача, а потім передавала їх мені, щоб я міг щось з ними зробити. Але якщо це буде передано мені, я хочу це кудись помістити, щоб потім надрукувати на екрані. Мені потрібно зробити еквівалент того, якби я взяв аркуш паперу, записав на ньому ім’я, щоб потім ввести його як вхідні дані у функцію друку. І для цього нам знадобиться ще одна особливість програмування, а саме змінні.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Функції та змінні</span>"
    ]
  },
  {
    "objectID": "python_basics.html#змінні",
    "href": "python_basics.html#змінні",
    "title": "\n1  Функції та змінні\n",
    "section": "\n1.2 Змінні",
    "text": "1.2 Змінні\nШвидше за все, більшість з вас знайомі зі змінними ще з уроків математики: x, y, z і тому подібне. Програмування має таку саму здатність створити змінну, в даному випадку, в пам’яті комп’ютера. І ця змінна може зберігати значення, число, якийсь текст, навіть зображення, відео чи щось інше. Змінна - це просто контейнер для якогось значення всередині комп’ютера або всередині вашої програми.\nПри виборі імені змінної давайте дотримуватись певних правил, щоб наш код виконувався без помилок та його було зручно читати:\n\nІм’я змінної починається з літери;\nДля імен змінних використовуватимемо маленькі літери з підкресленням замість пробілу;\nІм’я змінної не повинно співпадати з назвою ключових слів Python. Наприклад, назвати змінну if або True – погана ідея. Ключових слів не так багато, з частиною ми скоро познайомимося.\n\n```{python}\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n```\nТож повертаючись до попереднього прикладу я створю змінну name використовуючи оператор присвоєння =. Це означає, що ви хочете присвоїти у змінну name в лівій частині отримане значення функції input() праворуч, незалежно від того, що ввів користувач. Отже зараз десь у пам’яті комп’ютера є контейнер, що містить 'Гаррі'. Але тут легко припуститися помилки. Припустімо, я вирішу спробувати надрукувати введене ім’я. І я, наче за здогадкою, вводжу змінну name через кому, після 'Привіт' у другому рядочку коду:\n\nname = input('Як тебе звати? ') # Гаррі\nprint('Привіт, name')\n\n\n\nПривіт, name\n\n\nВочевидь це не те, що я очікував. Нам потрібен інший спосіб виводити значення всередині змінної, а не лише слово name. Дозвольте мені спробувати зробити це кількома різними способами.\nУ першому випадку я приберу запис name з другого рядка, і залишу змінну print(name) окремим рядком. Цього разу я буду більш уважним і не буду брати name у лапки, тому що ми вже бачили, що подвійні лапки означають буквально роздрукувати 'n-a-m-e':\n\nname = input('Як тебе звати? ') # Гаррі\nprint('Привіт,')\nprint(name)\n\n\n\nПривіт,\n\n\nГаррі\n\n\nГаразд, це працює, хоча і не так добре як хотілося. Принаймні, я вирішив проблему, просто поки що не дуже добре.\nАле дозвольте мені зробити крок назад і представити кілька інших концепцій, з якими ми повинні бути знайомі, оскільки наші програми стають довшими, і вони вже не обмежуються одним, двома або навіть трьома рядками. Зрештою, наші програми стануть десятками рядків, можливо, навіть сотнями рядків. Давайте закладемо основу для успіху. Виявляється, що Python та багато інших мов програмування підтримують те, що називається коментарями.\nКоментарі (анг. comments) - це примітки до вашого коду. Для включення коментарів до коду Python як правило, використовується символ хешу #. Це дозволяє вам писати еквівалент примітки до коду, але так, щоб не порушити ваш код. Комп’ютер фактично ігнорує ваші коментарі.\nТож я хочу додати кілька коментарів до попередньої програми:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт,')\nprint(name)\n\nЩойно я прокоментував кожен шматок коду. Навіщо? Ну по-перше, якщо я завтра вранці прокинусь і забуду все, що відбувалося минулого дня, зручно, маючи коментарі, зрозуміти що саме робить ця програма, щоб не читати сам код. По-друге, якщо ви допустили помилку, ви можете прочитати, що ви мали на увазі, коли писали код. А потім ви можете подивитися на код і з’ясувати, чи робить він зараз те, що ви хотіли. Це не є необхідним для такої маленької програми, як зараз. - з одного-двох-трьох рядків цілком очевидно, що робить програма. Але якщо ви звикнете коментувати свій код, це буде корисно, щоб нагадувати собі та іншим про те, що ви задумали і що робить ваш код.\nА що якщо необхідно написати коментар, який займе декілька рядків? В такому випадку можна використати спеціальну техніку використовуючи потрійні лапки (одинарні або подвійні):\n\n'''\nЗапитати користувача про ім'я\nі вивести привітання\n'''\nname = input('Як тебе звати? ') # Гаррі\nprint('Привіт,')\nprint(name)\n\nКоментарі також можуть слугувати своєрідним списком справ для вас самих. У програмуванні є таке поняття як псевдокод.\nПсевдокод (анг. pseudocode) - це неформальна форма запису. Це просто використання природної мови, щоб висловити свої думки лаконічно, методично, алгоритмічно тощо. Тож, наприклад, якби я сьогодні не був впевнений, як я хочу написати цю програму, але я знав, що я хочу зробити, я міг би просто написавши наступне в hello.py:\n\n# Запитати користувача про ім'я\n\n# Вивести привітання\n\nІ вже після цього приступити до написання повноцінного коду. Отже, псевдокод - це гарний спосіб структурувати список справ, особливо якщо ви поки не знаєте, як писати код.\nГаразд, давайте повернемося до нашої програми і спробуємо ще вдосконалити її. У програмуванні іноді існує багато способів вирішити одну і ту ж проблему. І ось один із способів вирішити цю проблему: давайте у середині функції print() “додамо” змінну name. Це не додавання як таке, я не додаю числа, очевидно, але я хочу додати ім’я людини до рядка тексту:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт,' + name)\n\n\n\nПривіт,Гаррі\n\n\nТак краще, але тут є невелика помилка, хоча і естетична. Тут не вистачає пробілу, але давайте просто скористаємося інтуїцією: якщо я пропускаю пробіл після коми, чому б мені просто не додати його вручну?\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт, ' + name) # додали пробіл після коми\n\n\n\nПривіт, Гаррі\n\n\nА тепер, якщо подивитися уважніше, ви могли помітити, що я поставив цей, здавалося б, зайвий пробіл у першому рядку мого коду після знаку питання: name = input('Як тебе звати? '). Це теж було просто для естетики. Я хотів перемістити курсор користувача на один пробіл праворуч, щоб коли користувач вводив своє ім’я, він не був одразу поруч з тим самим знаком питання.\nАле є й інші способи зробити це. Виявляється, що деякі функції, зокрема print(), приймають декілька аргументів. І виявляється, що якщо ви відокремлюєте входи у функцію, так звані аргументи функції, комою, ви можете передати декілька аргументів. Тобто я можу передати 'Привіт, ' і name як два окремих аргументи функції print():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт, ', name)\n\n\n\nПривіт,  Гаррі\n\n\nГаразд, я трохи перестарався. Тепер у мене чомусь два пробіли. Виявляється, коли ви передаєте на друк кілька аргументів, програма автоматично вставляє пробіл для вас. Тож, якщо мені не потрібен додатковий пробіл, мені не потрібно вставляти додатковий пробіл у рядок:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт,', name)\n\n\n\nПривіт, Гаррі\n\n\nТепер все виглядає граматично так, як я хотів би. Який з цих підходів кращий? Останній підхід використовує функцію print() з двома аргументами, 'Привіт,' і змінна name. Попередня версія, нагадаю, технічно використовувала один аргумент, хоча це виглядало трохи дивно. Тоді це був один аргумент в тому сенсі, що комп’ютер, як і математики, спочатку виконує те, що знаходиться всередині круглих дужок. Тож, якщо всередині дужок у вас є рядок тексту, 'Привіт,' який мені потрібно додати, то у вас є +, який означає не додавання як таке, а конкатенацію, щоб з’єднати те, що зліва, і те, що справа. І все це відбувається динамічно.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Функції та змінні</span>"
    ]
  },
  {
    "objectID": "python_basics.html#рядки",
    "href": "python_basics.html#рядки",
    "title": "\n1  Функції та змінні\n",
    "section": "\n1.3 Рядки",
    "text": "1.3 Рядки\nДозвольте мені повернутися до коду, про який йде мова, і подивитися, чи зможемо ми показати вам пару інших способів вирішення тієї ж проблеми, підкресливши, той факт, що ми працюємо з рядками (анг. ‘strings’). Для таких даних у Python є окремий тип даних str - послідовність тексту.\nДавайте повернемося до одного з попередніх варіантів написання програми з подвійним використанням функції print():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт, ')\nprint(name)\n\n\n\nПривіт, \n\n\nГаррі\n\n\nЦе було непогано, але був візуальний побічний ефект, який мені просто не подобався. Але є інший спосіб це виправити. Очевидно, що функція друку автоматично виводить порожній рядок, тому ми бачимо 'Привіт, ' на одному рядку, а 'Гаррі' на наступному. Як змінити таку поведінку функції print()? Тут слід згадати, що функції приймають аргументи, які впливають на їх поведінку. Виявляється, що якщо ми подивимось документацію до функції print() у Python. І одна з найкращих речей, яку ви можете зробити, вивчаючи мову програмування - це навчитися читати документацію, тому що більшість відповідей на ваші запитання можна знайти саме у документації. Тож давайте розглянемо документацію до функції print():\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\nЗ нього випливає наступне: - назва функції: print; - *objects означає, що функія може приймати будь-яку кількість об’єктів; - sep=' ' (скорочено від англ. separator) - родільник, який використовується для розділення об’єктів, які виводяться. За замовчуванням це пробіл; - end='\\n' - символ, який виводиться після останнього об’єкта. За замовчуванням це символ нового рядка (\\n).\n\n\n\n\n\n\nПримітка\n\n\n\nДокументація до Python доступна на docs.python.org.\n\n\nТепер ми знаємо, що функція print() приймає аргумент end, який використовується для визначення символу, який виводиться після останнього об’єкта. Тому, якщо ми хочемо вивести 'Привіт, ' та 'Гаррі' на одному рядку, нам потрібно використати функцію print() двічі, передаючи аргумент end у першому виклику функції print():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт, ', end='')\nprint(name)\n\n\n\nПривіт, \n\n\nГаррі\n\n\nВ той же час, якщо ми хочемо використати функцію print() для виведення декількох об’єктів, ми можемо використати аргумент sep для визначення роздільника між об’єктами:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт', name, sep=', ')\n\n\n\nПривіт, Гаррі\n\n\nУ випадках, коли нам необхідно використовувати апострофи або лапки в середині тексту, ми можемо використовувати різні види лапок, щоб уникнути помилки.\n\nprint(\"Привіт, 'Гаррі'\")\nprint('Привіт, \"Гаррі\"')\n\nЩе однією технікою є використання символу \\ перед апострофом або лапками, які ми хочемо використати в тексті. Це називається екрануванням (англ. escaping).\n\nprint('Привіт, \\'Гаррі\\'')\nprint(\"Привіт, \\\"Гаррі\\\"\")\n\n\n1.3.1 f-рядки\nf-рядки (англ. formatted string) - це рядки, які містять вирази, які обчислюються. Щоб створити f-рядок, ми використовуємо літеру f перед відкриваючою лапкою або апострофом. Вирази, які ми хочемо обчислити, ми пишемо в фігурних дужках {}. Якщо повернутися до нашого прикладу, ми можемо використати f-рядки, щоб вивести ім’я разом зі словом 'Привіт':\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести ім'я\nprint(f'Привіт, {name}')\n\n\n\nПривіт, Гаррі\n\n\nf-рядки роблять код більш читабельним і зручним, особливо коли ви працюєте з багатьма змінними і значеннями. Якщо ви працюєте з більш ранньою версією Python, то корисно знати і про інші методи форматування.\n\nЗа допомогою оператора %\n\nЦей спосіб форматування рядків уже застарів, але все ще використовується в деяких старих проектах. Синтаксис схожий на форматування рядків у мові C, де %s використовується для вставки рядка, а %d для вставки числа:\n\nname = \"Гаррі\"\nage = 11\nprint(\"My name is %s and I am %d years old\" % (name, age))\n\nMy name is Гаррі and I am 11 years old\n\n\n\nЗа допомогою методу format\n\n\nЦе метод рядка, який дає змогу форматувати текст, замінюючи вхідні аргументи всередині фігурних дужок {}. Ось приклад використання методу format():\n\nname = \"Гаррі\"\nage = 11\nprint(\"Моє ім'я {}. Мені {} років.\".format(name, age))\n\nМоє ім'я Гаррі. Мені 11 років.\n\n\nЗнаки {} у рядку були замінені на змінні, які були передані в метод format(). Це дає змогу створювати динамічні рядки, які змінюються залежно від змінних, переданих у метод format(). Можна використовувати індекси для заміни змінних:\n\nname = \"Гаррі\"\nage = 11\nprint(\"Моє ім'я {1}. Мені {0} років.\".format(name, age))\n\nМоє ім'я 11. Мені Гаррі років.\n\n\nТут ми використовували індекс 1 для заміни змінної age, індекс 0 - для змінної name. Це може бути корисно, якщо потрібно змінювати порядок виведення змінних у рядку. Крім того, можна використовувати іменовані аргументи для заміни:\n\nprint(\"Моє ім'я {name}. Мені {age} років.\".format(name='Гаррі', age=11))\n\nМоє ім'я Гаррі. Мені 11 років.\n\n\n\n1.3.2 Методи рядків\nНавіть коли ми виконували відносно прості операції, ми, як правило, покладалися на те, що користувач буде вводити саме те, що ми хочемо, щоб він ввів. Однак, це не означає, що результат вводу буде виглядати так, як ми хочемо. Чесно кажучи, ми з вами маємо звичку на веб-сайтах і в додатках часто випадково натискати пробіл, або на початку введення, або в кінці. Можливо, через те, що пробіл дуже велика клавіша, досить часто трапляються випадкові пробіли до або після введення даних користувачем. Також, ми з вами, безумовно, маємо звичку не завжди писати слова з великої літери, як слід. Якщо ми надсилаємо текстові повідомлення, ми, ймовірно, трохи поспішаємо і просто надсилаємо все в нижньому регістрі. Ми з вами не можемо покладатися на те, що нам обов’язково вдасться надрукувати все правильно, коли ми користуємося якимось програмним забезпеченням, чи то додатком, чи то веб-сайтом, чи чимось іншим.\nАле виявляється, що рядки самі по собі мають багато вбудованих функцій. Це означає, що ми можемо маніпулювати даними, введеними користувачем, щоб зробити більше, ніж просто приєднати їх до чогось іншого. Ми можемо очистити його або переформатувати таким чином, щоб він виглядав трохи краще для нас.\nДавайте повернемося до нашого прикладу, але цього разу я спеціальну напишу ім’я користувача з маленької літери та з зайвими пробілами на початку і у кінці:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '  гаррі  '\n\n# Вивести ім'я\nprint(f'Привіт, {name}')\n\n\n\nПривіт,   гаррі  \n\n\nЯк бачите, ім’я виводиться з пробілами на початку і в кінці. Якщо ми хочемо видалити пробіли з початку і кінця рядка, ми можемо використати метод .strip():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '  гаррі  '\n\n# Вивести ім'я\nprint(f'Привіт, {name.strip()}')\n\n\n\nПривіт, гаррі\n\n\nВже краще, але що робити з ім’ям, яке введене з маленької літери? Ми можемо використати метод .capitalize(), щоб перетворити першу літеру рядка на велику:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '  гаррі  '\n\n# Вивести ім'я\nprint(f'Привіт, {name.strip().capitalize()}')\n\n\n\nПривіт, Гаррі\n\n\nТепер розглянемо приклад, коли користувач вводить не тільки ім’я, але і прізвище:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '   гаррі поттер   '\n\n# Вивести ім'я\nprint(f'Привіт, {name.strip().capitalize()}')\n\n\n\nПривіт, Гаррі поттер\n\n\nМетод .capitalize() перетворює першу літеру рядка на велику. Але якщо нам необхідно записати і ім’я, і прізвище з великої літери? Ми можемо використати метод .title():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '   гаррі поттер   '\n\n# Вивести ім'я\nprint(f'Привіт, {name.strip().title()}')\n\n\n\nПривіт, Гаррі Поттер\n\n\nЗ іншої сторони, якщо ми хочемо вивести тільки ім’я, а користувач ввів ім’я та прізвище, ми можемо використати метод .split(). Цього разу я не буду додавати зайвих пробілів до імені:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # 'гаррі поттер'\n\n# Розділити рядок на дві частини\nfirst, last = name.split(\" \")\n\n# Вивести ім'я\nprint(f'Привіт, {first.capitalize()}')\n\n\n\nПривіт, Гаррі\n\n\n\n1.3.3 Спеціальні символи в рядках\nМи вже знаємо, що для створення рядка достатньо використовувати подвійні чи одинарні лапки. Все, що знаходиться всередині лапок, сприйматиметься як рядок.\n\nstring1 = 'Привіт, світ!'\nstring2 = \"Моє ім'я Гаррі\"\n\nЯкщо ми виведемо string1 і string2 на друк за допомогою функції print(), то побачимо на екрані всі символи, які ми помістили всередині лапок. Але це завжди так. У Python, як і в більшості мов програмування, у рядках можуть бути використані спеціальні символи. Вони називаються екранованими послідовностями.\nОсь деякі з найбільш часто використовуваних екранованих послідовностей у Python:\n\n\n\\n — перенесення рядка\n\n\\t - табуляція\n\n\\' - одинарна лапка\n\n\\\" - подвійна лапка\n\n\\\\ — зворотний слеш\n\nРозберемо їх використання відразу на прикладі:\n\nstring1 = '\\'Ґрифіндор\\' - чемпіон з квідичу!\\n1996 – 1997'\nprint(string1)\n\n'Ґрифіндор' - чемпіон з квідичу!\n1996 – 1997\n\n\nТаким чином, коли у рядку з’являється зворотний слеш \\, програма чекає після нього спеціальний символ. Сам зворотний слеш не виводиться на друк. А символ після слеша вже інтерпретується, наприклад, як перенесення рядка чи відступ.\nПодивіться ще приклади:\n\nprint(\"Привіт\\nсвіт!\")\n\nПривіт\nсвіт!\n\n\n\nprint(\"C:\\\\Users\\\\user\\\\Desktop\\\\file.txt\")\n\nC:\\Users\\user\\Desktop\\file.txt\n\n\n\nprint(\"Ім'я:\\tГаррі\")\n\nІм'я:   Гаррі\n\n\n\nprint('Кам\\'яні стіни, як і в «Ґрінґотсі», освітлювали смолоскипи')\n\nКам'яні стіни, як і в «Ґрінґотсі», освітлювали смолоскипи\n\n\n\nprint(\"Кам'яні стіни, як і в «Ґрінґотсі», освітлювали смолоскипи\")\n\nКам'яні стіни, як і в «Ґрінґотсі», освітлювали смолоскипи\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nДокументація до методів рядків у Python доступна за посиланням.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Функції та змінні</span>"
    ]
  },
  {
    "objectID": "python_basics.html#цілі-числа",
    "href": "python_basics.html#цілі-числа",
    "title": "\n1  Функції та змінні\n",
    "section": "\n1.4 Цілі числа",
    "text": "1.4 Цілі числа\nЦілі числа, int (англ. integer) - це окремий тип даних у Python. Цілі числа можуть бути додатніми, від’ємними або нулем. Наприклад, 1, -1 та 0 - цілі числа. Цілі числа можна додавати, віднімати, множити та ділити. Крім того є ще декілька операцій, які можна виконувати з цілими числами, такі як піднесення до степеня, взяття остачі від ділення та інші. Давайте розглянемо їх:\n\n\n+: додавання\n\n-: віднімання\n\n*: множення\n\n**: зведення в ступінь\n\n/: ділення\n\n//: цілочислове ділення, арифметична операція, результатом якої є ціла частина частки, отриманого поділом одного цілого числа на інше ціле число\n\n%: залишок від ділення\n\nДавайте подивимось, чи зможемо ми створити власний маленький калькулятор. Цього разу ми створемо файл calculator.py та запишемо у нього наступний код:\n\n\nTerminal\n\ncode calculator.py\n\nДля початку ми попросимо користувача ввести перше число, а потім друге. Після цього ми виведемо результат додавання, віднімання, множення та ділення цих чисел. Давайте запустимо наш файл та перевіримо, чи працює наш калькулятор:\n# Запитати користувача про перше число\nfirst_number = input('Введіть перше число: ') # '1'\n\n# Запитати користувача про друге число\nsecond_number = input('Введіть друге число: ') # '2'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {first_number + second_number}')\n\n\nРезультат додавання: 1 + 2 = 3\n\n\nЩо тут відбувається? Чому результат додавання двох чисел дорівнює 12? Це тому, що ми використали метод input(), який завжди повертає рядок. Щоб вирішити цю проблему, нам потрібно перетворити рядок у ціле число. Для цього ми можемо використати функцію int(). Давайте виправимо наш код та перевіримо, чи працює наш калькулятор:\n\n# Запитати користувача про перше число\nfirst_number = int(input('Введіть перше число: ')) # '1'\n\n# Запитати користувача про друге число\nsecond_number = int(input('Введіть друге число: ')) # '2'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {first_number + second_number}')\n\n\n\nРезультат додавання: 1 + 2 = 3\n\n\nВзагалі то ми можемо написати весь наш калькулятор у одному рядку:\n\nprint(f'Результат додавання: {int(input(\"Введіть перше число: \")) + int(input(\"Введіть друге число: \"))}')\n\n\n\nРезультат додавання: 3\n\n\nОднак далеко не завжди перетворення типів проходить без помилок, наприклад, ми не зможемо зробити таке перетворення:\n\na = 'my number is 42'\nb = int(a) # отримаємо помилку\n\ninvalid literal for int() with base 10: 'my number is 42'\n\n\nЦе означає, що рядок 'my number is 42' не може бути відразу представлена як ціле число. Ми могли б взяти з цього рядка лише число 42 і перевести його до цілого числа. Скоро ми навчимося так робити.\n\n\n\n\n\n\nПримітка\n\n\n\nЯкщо ви хочете дізнатися більше про цілі числа, то можете прочитати документацію.\n\n\n\n1.4.1 Рядки та їх незмінюваність\nРядки належать до незмінних об’єктів у Python. Які практичні наслідки виникають з того факту, що рядки, на відміну від списків, є незмінними об’єктами?\nЩоб показати, що рядки є незмінюваними об’єктами, ми можемо використати такий приклад коду:\n\nmy_string = \"abcde\"\nmy_string[0] = \"f\"\n\n'str' object does not support item assignment\n\n\nКоли ми запустимо цей код, ми отримаємо повідомлення про помилку TypeError, яке свідчить про те, що рядковий об’єкт не підтримує присвоєння елементу. Це відбувається тому, що в Python рядки - це незмінні об’єкти, їх не можна змінювати після створення. Якщо ми хочемо створити новий рядок на основі існуючого, то ми повинні створити новий об’єкт рядка. Наприклад, ми можемо створити новий рядок, який замінює перший символ рядка “a” на символ “f”, використовуючи такий код:\n\nmy_string = \"abcde\"\nnew_string = \"f\" + my_string[1:]\nprint(new_string)\n\nfbcde\n\n\nЦе створить новий рядок через використання рядка \"f\" і всіх символів з оригінального рядка, починаючи з індексу 1. Результатом буде рядок \"fbcde\" - новий рядок, який ми можемо використовувати далі в нашій програмі.\nЩоб остаточно закріпити відмінності в роботі зі змінюваними і незмінюваними об’єктами, давайте порівняємо списки і рядки:\n\nmy_str = \"Hello, world!\"\nprint(my_str.lower()) # поверне нам новий рядок\n\nhello, world!\n\n\n\nmy_list = [3, 2, 1]\nprint(my_list.append(4)) # нічого не поверне, змінить my_list\n\nNone\n\nprint(my_list)\n\n[3, 2, 1, 4]\n\n\nЖоден метод не змінить змінну my_str, а ось різні методи списків можуть змінити структуру списку my_list.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Функції та змінні</span>"
    ]
  },
  {
    "objectID": "python_basics.html#числа-з-плаваючою-комою",
    "href": "python_basics.html#числа-з-плаваючою-комою",
    "title": "\n1  Функції та змінні\n",
    "section": "\n1.5 Числа з плаваючою комою",
    "text": "1.5 Числа з плаваючою комою\nPython також підтримує числа з плаваючою комою (англ. floating point numbers). Це числа, які мають дробову частину. Наприклад, 3.14 - число з плаваючою комою. Щоб використати число з плаваючою комою, ми можемо використати тип float. Зараз наш калькулятор дещо наївно припускає, що користувач буде вводити лише цілі числа. Давайте виправимо це:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '1.2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3.4'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {first_number + second_number}')\n\n\n\nРезультат додавання: 1.2 + 3.4 = 4.6\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЯкщо ви хочете дізнатися більше про числа з плаваючою комою, то можете прочитати документацію.\n\n\nПрипустимо, що я не хочу, щоб остаточна відповідь була значенням з плаваючою комою, наприклад, 4.6. Я був би радий, якби ми просто округлили до найближчого цілого. Щоб це зробити, ми можемо використати функцію round(). Для початку давайте ознайомимося з документацією:\nround(number, ndigits=None)\n\n\nnumber - число, яке ми хочемо округлити\n\nndigits - кількість знаків після коми, до якої ми хочемо округлити число. Якщо ми не вказуємо цей аргумент, то число буде округлено до найближчого цілого.\n\nДавайте виправимо наш код та перевіримо, чи працює наш калькулятор:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '1.2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3.4'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {round(first_number + second_number)}')\n\n\n\nРезультат додавання: 1.2 + 3.4 = 5\n\n\nДавайте цього разу додамо 1 до 999:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '1'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '999'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {round(first_number + second_number)}')\n\n\n\nРезультат додавання: 1 + 999 = 1000\n\n\nВідповідь, звісно, тут має бути і є 1000, незалежно від того, округляємо ми чи ні. Це просто арифметика з цілими числами. Але в США, як правило, форматують довгі числа, ставлячи коми після або перед кожною трійкою цифр. В інших країнах все навпаки, там замість цього ставлять крапки та коми. Це системні налаштування.\nЩо, якщо я хочу, щоб це було виведено як 1,000, просто щоб було трохи зрозуміліше, що це саме тисяча? Якщо ви хочете, щоб Python вивів число з комами, для цього є спеціальна нотація з використанням двокрапки. Давайте спробуємо це:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '1'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '999'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {first_number + second_number:,}')\n\n\n\nРезультат додавання: 1 + 999 = 1,000\n\n\nДавайте модифікуємо наш калькулятор, щоб він виконував ділення:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3'\n\n# Вивести результат ділення\nprint(f'Результат ділення: {first_number} / {second_number} = {first_number / second_number}')\n\n\n\nРезультат ділення: 2 / 3 = 0.6666666666666666\n\n\nЩо, якщо я хочу, щоб результат ділення був округлений до 2 знаків після коми? Ми знову повертаємось до функції round(), але цього разу ми передаємо другий аргумент, який вказує, до якого знаку після коми ми хочемо округлити. Давайте спробуємо це:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3'\n\n# Вивести результат ділення\nprint(f'Результат ділення: {first_number} / {second_number} = {round(first_number / second_number, 2)}')\n\n\n\nРезультат ділення: 2 / 3 = 0.67\n\n\nАле є інший спосіб зробити це, який може бути трохи зрозумілішим. Якщо ви хочете, щоб Python вивів число з комами, для цього є спеціальна нотація з використанням двокрапки. Для цього я додам запис 0.2f після двокрапки всередині f-рядку:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3'\n\n# Вивести результат ділення\nprint(f'Результат ділення: {first_number} / {second_number} = {first_number / second_number:.2f}')\n\n\n\nРезультат ділення: 2 / 3 = 0.67\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nІноді для розв’язання задачі нам потрібно створити змінну і зберегти в ній нескінченність у математичному сенсі слова. Для цього нам допоможе така форма запису:\nx = float('inf')\nАналогічно до позитивної нескінченності float('inf'), float('-inf') є спеціальним значенням для чисел із плаваючою крапкою з негативною нескінченністю.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Функції та змінні</span>"
    ]
  },
  {
    "objectID": "python_basics.html#власні-функції",
    "href": "python_basics.html#власні-функції",
    "title": "\n1  Функції та змінні\n",
    "section": "\n1.6 Власні функції",
    "text": "1.6 Власні функції\nМи вже знаємо, що Python має вбудовані функції, такі як print(), input(), round() та інші. Але Python також дозволяє нам створювати власні функції. До цього моменту ми вже декілька разів писали програми, які просто казали “привіт”. І кожного разу я використовую print(), але хіба не було б чудово, якби ми могли просто викликати функцію hello(), яка б просто віталася за нас? Давайте спробуємо це зробити:\n\nname = input('Введіть ваше ім\\'я: ') # 'Гаррі'\nhello()\nprint(name)\n\n\n\nname 'hello' is not defined\n\n\nГаррі\n\n\nІ от ми отримали помилку, що функція hello() не визначена. Це означає, що ми не можемо викликати функцію, яку ми не визначили. Давайте визначимо функцію hello(). Для цього ми використаємо ключове слово def від англійського define (визначити). Давайте спробуємо це зробити:\n\ndef hello():\n    print('Привіт,')\n\nname = input('Введіть ваше ім\\'я: ') # 'Гаррі'\nhello()\nprint(name)\n\n\n\nПривіт,\n\n\nГаррі\n\n\nЧому б нам не подумати про те, як ми могли б параметризувати ту ж саму функцію? Тобто, чи можемо ми налаштувати hello(), щоб воно приймало ім’я користувача як вхідні дані, щоб ми могли сказати не тільки привітання, але й ім’я людини в одному рядку. Для цього нам потрібно передати ім’я як аргумент у функцію hello(). Давайте спробуємо це зробити:\n\ndef hello(name):\n    print('Привіт,', name)\n\nname = input('Введіть ваше ім\\'я: ') # 'Гаррі'\nhello(name)\n\n\n\nПривіт, Гаррі\n\n\nЗверніть увагу на відступи в нашому коді. Вони дуже важливі. Вони показують, що функція hello() належить до блоку коду, який починається з def hello(name): і закінчується з print('Привіт,', name). Відступ дорівнює 4 пробілам або одного табулятора. Це дуже важливо, оскільки в Python відступи використовуються для визначення блоків коду. Якщо ви не використовуєте правильні відступи, то ви отримаєте помилку:\n\nname = 'Гаррі'\n\ndef hello(name):\nprint('Привіт,', name)\n\nhello(name)\n\nexpected an indented block after function definition on line 3 (&lt;string&gt;, line 4)\n\n\nЧерговість записів у коді також важлива. Якщо ви спробуєте викликати функцію hello() до того, як ви її визначите, то ви отримаєте помилку:\n\nhello(name)\n\nПривіт, Гаррі\n\n\nname = 'Гаррі'\n\ndef hello(name):\n    print('Привіт,', name)\n\nІнтерпретатор Python сприйматиме вас буквально. І якщо ви використовуєте функцію, вона вже повинна існувати на момент її виклику.\nТепер давайте додамо значення за замовчування до функції hello(). Це означає, що якщо ми не передамо ім’я у функцію hello(), то вона використовуватиме значення за замовчуванням. Давайте спробуємо це зробити:\n\ndef hello(name='світ'):\n    print('Привіт,', name)\n\nhello()\n\nПривіт, світ\n\n\nАле ми можемо зануритися глибше і назвати свою функцію main(). Це не обов’язкова вимога, але це певна конвенція у світі програмування. Це означає, що це головна функція, яка виконується, коли ми запускаємо нашу програму. Давайте спробуємо це зробити:\n\ndef main():\n    name = input('Введіть ваше ім\\'я: ') # 'Гаррі'\n    hello(name)\n\ndef hello(name):\n    print('Привіт,', name)\n\nmain()\n\n\n\nПривіт, Гаррі\n\n\nВикликаючи головну функцію main() таким чином, це позбавляє мене від проблем з порядком записів у коді. Таким чином, я можу організувати свій код і впорядкувати його.\nА тепер дозвольте мені зробити ще одну технічну помилку. Я спробую прибрати значення name у функції hello():\n\ndef main():\n    name = 'Гаррі'\n    hello()\n\ndef hello():\n    print('Привіт,', name)\n\nmain()\n\nПривіт, Гаррі\n\n\nАле заковика в тому, що name тепер існує тільки в main(). Ця проблема називається областю видимості (англ. scope). Це означає, що змінні, які ви визначаєте всередині функції, не будуть доступні за межами цієї функції. Це означає, що name не існує всередині функції hello().\nДо цього наші функції не повертали нічого. Вони просто виводили щось на екран. Але що, якщо ми хочемо, щоб функція повертала значення? Для цього ми використовуємо ключове слово return. Давайте спробуємо це зробити на нашому калькуляторі. Напишемо функцію, яка буде повертати квадрат числа. Цю задачу можна вирішити різними шляхами, тож я пропоную паралельно познайомитися з новою функцією pow(), яка приймає два аргументи і повертає перший аргумент, піднесений до степеня, який вказаний другим аргументом. Давайте спробуємо це зробити:\n\n\nЛістинг 1.1: calculator.py\n\ndef main():\n    x = int(input('Введіть число: ')) # '2'\n    print(f'Число {x} в квадраті дорівнює {square(x)}')\n\ndef square(n):\n    return pow(n, 2)\n\nmain()\n\n\n\n\n\nЧисло 2 в квадраті дорівнює 4",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Функції та змінні</span>"
    ]
  },
  {
    "objectID": "python_basics.html#інтерактивний-режим",
    "href": "python_basics.html#інтерактивний-режим",
    "title": "\n1  Функції та змінні\n",
    "section": "\n1.7 Інтерактивний режим",
    "text": "1.7 Інтерактивний режим\nВиявляється, у Python не обов’язково писати код у файлі на кшталт hello.py, а потім запускати його у вікні терміналу. Однією з особливостей, яка багатьом подобається в Python, є те, що він підтримує так званий інтерактивний режим (англ. interactive mode). Щоб запустити Python у інтерактивному режимі, відкрийте термінал та напишіть python:\n\n\nTerminal\n\n&gt; python\nPython 3.11.4 (tags/v3.11.4:d2340ef, Jun  7 2023, 05:45:37) [MSC v.1934 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n\nЯк бачите, з’явився новий символ &gt;&gt;&gt;. Це означає, що Python готовий приймати команди. Наприклад, якщо я напишу print('Hello, world!') та натисну Enter, то Python виведе рядок 'Hello, world!':\n\n\nTerminal\n\n&gt;&gt;&gt; print('Привіт, світ!')\nПривіт, світ!\n\nТакож, якщо я напишу 2 + 2 та натисну Enter, то Python виведе результат додавання двох чисел:\n\n\nTerminal\n\n&gt;&gt;&gt; 2 + 2\n4\n\nЩоб вийти з інтерактивного режиму, напишіть exit() та натисніть Enter:\n\n\nTerminal\n\n&gt;&gt;&gt; exit()\n&gt;",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Функції та змінні</span>"
    ]
  },
  {
    "objectID": "python_basics.html#завдання",
    "href": "python_basics.html#завдання",
    "title": "\n1  Функції та змінні\n",
    "section": "\n1.8 Завдання",
    "text": "1.8 Завдання\n\n\nЗавдання 1.1  Давайте запрограмуємо кота! Створіть три змінні:\n\n\ncat_name з рядком як мінімум із двох символів\n\ncat_age з невід’ємним числом\n\nis_fluffy з True абоFalse`\n\n\nРішенняcat_name = 'Azmodan'\ncat_age = 2\nis_fluffy = True\n\n\n\n\n\n\nЗавдання 1.2  Давайте напишемо програму для пошуку довжини гіпотенузи. Створіть змінні a та b, в яких будуть записані довжини катетів прямокутного трикутника. Після чого розрахуйте c і збережіть у ній довжину гіпотенузи цього трикутника.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розрахунку довжини гіпотенузи використовуйте теорему Піфагора. А операція квадратного кореня аналогічна зведенню в ступінь 0.5.\n\n\n\n\nРішенняc = (a**2 + b**2)**0.5\n\n\n\n\n\n\nЗавдання 1.3  У змінній father_age зберігається вік батька, а змінної son_age — вік сина. Порахуйте, через скільки років батько буде вдвічі старшим за сина. Результат збережіть змінну result.\nПриклад:\nfather_age = 20\nson_age = 3\nresult = 14\n\nfather_age = 30.5\nson_age = 5.1\nresult = 20.3\n\nРішенняfather_age = 20\nson_age = 3\nresult = father_age - 2 * son_age\n\n\n\n\n\n\nЗавдання 1.4  Задані дійсні числа a, b та с – сторони трикутника. Обчисліть периметр та площу трикутника. Результат збережіть у змінні perimeter та area відповідно.\nПриклад:\na = 3\nb = 4\nc = 5\n\nperimeter = 12\narea = 6\n\\[ S = \\sqrt{p(p-a)(p-b)(p-c)} \\] \\[ p = \\frac{a+b+c}{2} \\]\n\n\n(0.85, 4.15, 0.85, 4.15)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПериметр – це сума довжин усіх сторін. Площу трикутника по трьох сторонах можна обчислити за допомогою формули Герона. Квадратний корінь - це зведення у ступінь 0.5.\nА ви знали, що Формула Герона міститься в «Метриці» Герона Олександрійського (I століття н. е.) і названа на його честь (хоча вона була відома ще Архімеду). Герон цікавився трикутниками з цілими сторонами, площі яких теж є цілими, такі трикутники звуться героновими, найпростішим героновим трикутником є єгипетський трикутник.\n\n\n\n\nРішенняa = 3\nb = 4\nc = 5\n\nperimeter = a + b + c\np = perimeter * 0.5\narea = (p * (p-a) * (p - b) * (p - c)) ** 0.5\n\n\n\n\n\n\nЗавдання 1.5  У змінну n збережено ціле число – кількість секунд. Напишіть програму, яка конвертує задану кількість секунд n на години, хвилини та секунди. Результат збережіть у змінні hours, minutes, seconds.\nТобто спочатку потрібно порахувати, скільки в число n помістилося цілих годин, цілих хвилин і скільки після цього залишилося секунд. Розглянемо приклад:\nn = 125\n\nhours = 0\nminutes = 2\nseconds  = 5\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nВам може допомогти цілочислове ділення // залишок від ділення %.\n\n\n\n\nРішенняn = 125\nhours = n // 3600\nminutes = (n % 3600) // 60\nseconds = n % 60\n\n\n\n\n\n\nЗавдання 1.6  У змінній price_new зберігається ціна кілограма бананів у числовому форматі, а змінної price_old — ціна кілограма бананів рік тому. Обчисліть, скільки відсотків за модулем змінилася ціна протягом року. Результат збережіть у змінну result. Результат округліть до двох знаків після коми.\nПриклад:\nprice_new = 89.99 \nprice_old = 75.50\nresult = 19.19\n\n\nprice_new = 24\nprice_old = 72\nresult = 66.67\n\nРішенняprice_new = 89.99\nprice_old = 75.50\nresult = round(abs(price_new - price_old) / price_old * 100, 2)\n\n\n\n\n\n\nЗавдання 1.7  Створіть змінні:\n\n\na зі значенням 5 типу int\n\n\nb зі значенням '10' типу str\n\n\nc із значенням True типу bool.\n\nУ змінну my_sum збережіть суму трьох змінних, які ви створили, перетворивши b і з типу int.\n\nРішенняa = 5\nb = '10'\nc = True\nmy_sum = a + int(b) + int(c)\n\n\n\n\n\n\nЗавдання 1.8  У змінній a збережено число з десятковою частиною у форматі рядка, наприклад '3.14'. У змінну збережіть цілу частину з числа змінної a.\nПриклади:\na = '3.14'\nc = 3\n\na = '99.9'\nc = 99\n\na = '0.33'\nc = 0\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nВсе, що нам потрібно зробити, це перекласти змінну a в int. Відразу рядок '3.14' в int перекласти не вийде, подумайте, який тип потрібно перевести змінну на першому етапі?\n\n\n\n\nРішенняa = '3.14'\nc = int(float(a))\n\n\n\n\n\n\nЗавдання 1.9  У змінній x збережено ціле позитивне число. Обчисліть x + x0x0x. Результат збережіть змінну result.\nТобто якщо x = 2, то потрібно обчислити 2 + 20202.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nСпробуйте скласти два рядки за допомогою знака +\n\n\n\n\nРішенняx = 2\nresult = x + int(str(x) + '0' + str(x) + '0' + str(x))\n\n# або\nresult = x + int(f'{x}0{x}0{x}') # але про це пізніше\n\n\n\n\n\n\nЗавдання 1.10  Збережіть у змінний square рядок, який виводить на екран прямокутник 4 х 4, сформований із зірочок, розділених пробілом.\nprint(square)\n\n* * * *\n* * * *\n* * * *\n* * * *\n\nРішенняsquare = '* * * *\\n' * 4\n\n\n\n\n\n\nЗавдання 1.11  У змінній x міститься число з десятковою частиною але у форматі рядка. У змінну y збережіть ціле число, яке дорівнює десятковій частині числа x.\nПриклад:\n```{python}\nx = 3.14 \ny = 14 \n\nx = 2.02 \ny = 2\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПодумайте, які методи рядків допоможуть нам у цьому завданні.\n\n\n\n\nРішенняx = 3.14\n\ny = int(str(x).split('.')[1])\n\n\n\n\n\n\nЗавдання 1.12  У змінну a збережено деяке речення, у якому можуть бути додані зайві пробіли. Напишіть програму, яка прибиратиме з a зайві пропуски і зберігатиме результат у змінну result. Усі слова мають бути розділені одним пропуском, а на початку та наприкінці речення пропусків бути не повинно.\nПриклад:\n```{python}\na = \"Я вивчаю нову мову програмування.   \"\nresult = \"Я вивчаю нову мову програмування.\"\n```\n\nРішенняa = \"Я вивчаю нову мову програмування.   \"\n\nresult = ' '.join(a.split())\n\n\n\n\n\n\nЗавдання 1.13  Напишіть програму, ґрунтуючись на введенні та виведенні в прикладах. Введенням буде рядок a. Результат збережіть у result.\nПриклад:\n```{python}\na = \"div*2\"\nresult = \"&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;\"\n\na = \"p*1\" \nresult = \"&lt;p&gt;&lt;/p&gt;\"\n\na = \"li*3\"\nresult = \"&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;\"\n```\n\nРішенняa = \"div*2\"\n\nstring, number = a.split('*')\nresult = f\"&lt;{string}&gt;&lt;/{string}&gt;\" * int(number)\n\n\n\n\n\n\nЗавдання 1.14  Напишіть програму, яка прийматиме рядок зі слів і повертатиме рядок, у якому ці слова будуть відсортовані в лексикографічному порядку. Початковий рядок міститься у змінній x, результат збережіть у result.\nПриклад:\n```{python}\nx = 'Світ надзвичайно широкий має укладисті далі'\nresult = 'Світ далі має надзвичайно широкий укладисті'\n```\n\nРішенняx = 'Світ надзвичайно широкий має укладисті далі'\n\nresult = ' '.join(sorted(x.split()))\n\n\n\n\n\n\nЗавдання 1.15  Порахуйте, скільки разів у реченні x зустрічається рядок y. Результат збережіть у змінну result.\nПриклад:\n```{python}\nx = 'На підвіконні у вітальні в бабусі росли квіти, квіти були червоні та жовті, дуже гарні квіти.'\ny = 'квіти'\nresult = 3\n```\n\nРішенняx = 'На підвіконні у вітальні в бабусі росли квіти, квіти були червоні та жовті, дуже гарні квіти.'\ny = 'квіти'\n\nresult = x.count(y)\n\n\n\n\n\n\nЗавдання 1.16  Напишіть програму, яка прийматиме номер кредитної картки card і повертатиме номер картки, у якому буде видно тільки останні 4 цифри. Інші цифри мають замінюватися зірочками. Результат збережіть у result.\nПриклад:\n```{python}\ncard = '5468350018455833'\nresult = '************5833'\n```\n\nРішенняcard = '5468350018455833'\n\nresult = '*' * 12 + card[-4:]\n\n\n\n\n\n\nЗавдання 1.17  У змінній а збережено речення. Видаліть із речення всі входження слова або символу b. Результат збережіть у result.\nПриклад:\n```{python}\na = 'Вечірнє сонце, дякую за день!'\nb = 'e'\nresult = 'Вчірнє сонц, дякую за днь!'\n```\n\nРішенняa = 'Вечірнє сонце, дякую за день!'\nb = 'е'\n\nresult = a.replace(b, '')",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Функції та змінні</span>"
    ]
  },
  {
    "objectID": "sql_agg.html#унікальні-значення-distinct",
    "href": "sql_agg.html#унікальні-значення-distinct",
    "title": "16  Агрегація даних",
    "section": "16.1 Унікальні значення: DISTINCT",
    "text": "16.1 Унікальні значення: DISTINCT\nКлючове слово DISTINCT дає змогу відбирати унікальні записи, тобто позбавлятися всіх дублікатів у таблиці.\nВказується DISTINCT одразу після SELECT. Для виведення унікальних значень в одній колонці можна скласти наступний запит:\nSELECT DISTINCT column\nFROM table\nДавайте спершу вирішимо просте завдання.\n\n\nЗавдання 16.1  Виведіть ID всіх унікальних користувачів з таблиці user_actions. Результат відсортуйте за зростанням id.\nПоле у результуючій таблиці: user_id\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT user_id\nFROM   user_actions\nORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n21396\n21398\n\n\n21397\n21399\n\n\n21398\n21400\n\n\n21399\n21401\n\n\n21400\n21402\n\n\n\n\n21401 rows × 1 columns\n\n\n\nКлючове слово DISTINCT можна застосовувати не тільки до однієї колонки, а й одразу до кількох.\nНаприклад, запит для двох колонок виглядатиме так:\nSELECT DISTINCT column_1, column_2\nFROM table\nУ такому випадку запит поверне унікальні комбінації значень в колонках.\n\n\nЗавдання 16.2  Застосуйте DISTINCT відразу до двох колонок таблиці courier_actions та відберіть унікальні пари значень courier_id та order_id.\nРезультат відсортуйте спочатку за зростанням id кур’єра, потім за зростанням id замовлення.\nПоля у результуючій таблиці: courier_id, order_id\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT courier_id,\n                order_id\nFROM   courier_actions\nORDER BY courier_id, order_id\n\n\n\n\n\n\n\n\n\ncourier_id\norder_id\n\n\n\n\n0\n1\n98\n\n\n1\n1\n194\n\n\n2\n1\n233\n\n\n3\n1\n522\n\n\n4\n1\n1251\n\n\n...\n...\n...\n\n\n59590\n3166\n56165\n\n\n59591\n3166\n56940\n\n\n59592\n3167\n56176\n\n\n59593\n3167\n58039\n\n\n59594\n3167\n58774\n\n\n\n\n59595 rows × 2 columns",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Агрегація даних</span>"
    ]
  },
  {
    "objectID": "sql_agg.html#базова-агрегація-count-sum-avg-min-max",
    "href": "sql_agg.html#базова-агрегація-count-sum-avg-min-max",
    "title": "16  Агрегація даних",
    "section": "16.2 Базова агрегація: COUNT, SUM, AVG, MIN, MAX",
    "text": "16.2 Базова агрегація: COUNT, SUM, AVG, MIN, MAX\nАгрегатними функціями називають функції, які обробляють певний набір спостережень і повертають одне узагальнююче значення. Якщо ви коли-небудь працювали в Excel, то, напевно, стикалися з підрахунком суми або максимального/мінімального значення по стовпцю — йдеться саме про це.\nОсь кілька прикладів таких функцій у SQL:\n\nCOUNT: повертає кількість значень у колонці;\nSUM: обчислює суму значень;\nAVG: обчислює середнє значення;\nMAX: обчислює максимальне значення;\nMIN: обчислює мінімальне значення.\n\nПриклад:\nSELECT COUNT(column) AS count\nFROM table\n\n\nSELECT SUM(column_1) AS sum,\n       AVG(column_2) AS average\nFROM table\nЗверніть увагу, що деякі з вищезгаданих функцій не можна застосовувати до колонок з текстом, датами та часом, оскільки не цілком зрозуміло, що, наприклад, означає знайти середнє значення або суму найменувань товарів.\nУ той самий час «максимальне» найменування товару обчислити можна — функція MAX шукатиме найбільше значення упорядкованої послідовності (відповідно до встановлених правил сортування значень рядкового типу).\nВтім, заучувати межі застосування цих функцій не потрібно — просто керуйтеся здоровим глуздом.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про агрегатні функції в DuckDB можна ознайомитися тут.\n\n\n\n\nЗавдання 16.3  Порахуйте максимальну та мінімальну ціни товарів у таблиці products. Поля назвіть відповідно max_price, min_price.\nПоля у результуючій таблиці: max_price, min_price\nПояснення: в одному запиті можна використовувати відразу кілька агрегаційних функцій — якщо необхідно, то навіть по кількох різних колонках.\n\n\n\n\nРішення\n%%sql\nSELECT max(price) as max_price,\n       min(price) as min_price\nFROM   products\n\n\n\n\n\n\n\n\n\nmax_price\nmin_price\n\n\n\n\n0\n800.0\n1.0",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Агрегація даних</span>"
    ]
  },
  {
    "objectID": "sql_agg.html#count-vs-countcolumn",
    "href": "sql_agg.html#count-vs-countcolumn",
    "title": "16  Агрегація даних",
    "section": "16.3 COUNT(*) vs COUNT(column)",
    "text": "16.3 COUNT(*) vs COUNT(column)\nТакож при підрахунку кількості записів іноді замість найменування колонки як атрибут функції COUNT використовують зірочку «*»:\nSELECT COUNT(*)\nFROM table\nОднак важливо враховувати один нюанс: запит із зірочкою повертає кількість взагалі всіх записів у таблиці, а запит із зазначенням стовпця — кількість тих записів, де в заданому стовпці значення не є NULL.\nТаким чином, якщо в деякій колонці column є перепустки, вирази COUNT(*) і COUNT(column) повернуть різні значення.\nДавайте перевіримо!\n\n\nЗавдання 16.4  Як ви пам’ятаєте, у таблиці users в деяких користувачів не було зазначено їх дати народження.\nПорахуйте в одному запиті кількість усіх записів у таблиці та кількість лише тих записів, для яких у колонці birth_date вказана дата народження.\nКолонку із загальним числом записів назвіть dates, а колонку із записами без перепусток — dates_not_null.\nПоля у результуючій таблиці: dates, dates_not_null\n\n\n\n\nРішення\n%%sql\nSELECT count(*) as dates,\n       count(birth_date) as dates_not_null\nFROM   users\n\n\n\n\n\n\n\n\n\ndates\ndates_not_null\n\n\n\n\n0\n20331\n20281\n\n\n\n\n\n\n\nІ ще один важливий момент: агрегатні функції можна застосовувати в поєднанні з ключовим словом DISTINCT. У такому випадку розрахунки будуть проводитися лише за унікальними значеннями.\nЯкщо у випадку з MIN та MAX це не має особливого сенсу, то при розрахунку AVG, SUM та COUNT іноді це буває корисно:\nSELECT SUM(DISTINCT column) AS sum_distinct\nFROM table\nПри цьому досить часто DISTINCT використовується саме в поєднанні з COUNT для підрахунку числа унікальних користувачів, унікальних замовлень тощо.\nSELECT COUNT(DISTINCT column) AS count_distinct\nFROM table\n\n\nЗавдання 16.5  Порахуйте кількість всіх значень у колонці user_id у таблиці user_actions, а також кількість унікальних значень у цій колонці (тобто кількість унікальних користувачів сервісу).\nКолонку з першим отриманим значенням назвіть users, а колонку з другим – unique_users.\nПоля у результуючій таблиці: users, unique_users\n\n\n\n\nРішення\n%%sql\nSELECT count(user_id) as users,\n       count(distinct user_id) as unique_users\nFROM   user_actions\n\n\n\n\n\n\n\n\n\nusers\nunique_users\n\n\n\n\n0\n62574\n21401",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Агрегація даних</span>"
    ]
  },
  {
    "objectID": "sql_agg.html#фільтрація-та-агрегація",
    "href": "sql_agg.html#фільтрація-та-агрегація",
    "title": "16  Агрегація даних",
    "section": "16.4 Фільтрація та агрегація",
    "text": "16.4 Фільтрація та агрегація\nА якщо для розрахунків нам потрібні не всі дані в стовпці, а тільки якась частина? Тоді в запит з агрегатними функціями можна включити оператор WHERE, вказавши умову для відбору записів:\nSELECT COUNT(column_1) AS count\nFROM table\nWHERE column_2 &gt; 100\nУ такому випадку спочатку буде виконана фільтрація таблиці і тільки потім буде проведена агрегація по записах, що залишилися.\nПро всяк випадок нагадаємо порядок виконання у запиті відомих нам ключових операторів:\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\n\nЗавдання 16.6  Порахуйте кількість кур’єрів жіночої статі у таблиці couriers. Отриманий стовпець з одним значенням назвіть couriers.\nПоле в результуючій таблиці: couriers\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct courier_id) as couriers\nFROM   couriers\nWHERE  sex = 'female'\n\n\n\n\n\n\n\n\n\ncouriers\n\n\n\n\n0\n1149\n\n\n\n\n\n\n\nІ ще одне завдання на агрегацію із фільтрацією. На цей раз проведемо розрахунки по колонці з даними у форматі TIMESTAMP.\n\n\nЗавдання 16.7  Розрахуйте час, коли було здійснено першу та останню доставку замовлень у таблиці courier_actions.\nКолонку з часом першої доставки назвіть first_delivery, а колонку з часом останньої – last_delivery.\nПоля у результуючій таблиці: first_delivery, last_delivery\nПояснення: зауважте, що в таблиці з діями кур’єрів є не тільки записи з часом доставки замовлень, але й записи з часом їх прийняття.\n\n\n\n\nРішення\n%%sql\nSELECT min(time) as first_delivery,\n       max(time) as last_delivery\nFROM   courier_actions\nWHERE  action = 'deliver_order'\n\n\n\n\n\n\n\n\n\nfirst_delivery\nlast_delivery\n\n\n\n\n0\n2022-08-24 02:15:00\n2022-09-08 23:59:00\n\n\n\n\n\n\n\nУ поєднанні з агрегатними функціями можна використовувати ті ж умовні конструкції, які ми розглядали раніше.\nДавайте додамо до нашого запиту більш цікаву фільтрацію.\n\n\nЗавдання 16.8  Уявіть, що один із користувачів сервісу зробив замовлення, до якого увійшли одна пачка крекерів (crackers), одна пачка чіпсів (chips) та один енергетичний напій (energy drink). Порахуйте вартість такого замовлення.\nКолонку із розрахованою вартістю замовлення назвіть order_price.\nДля розрахунків використовуйте таблицю products.\nПоле в результуючій таблиці: order_price\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля вирішення завдання необхідно «сформувати» описане замовлення, відібравши з таблиці products зазначені товари та порахувавши їхню сумарну вартість.\n\n\n\n\n\nРішення\n%%sql\nSELECT sum(price) as order_price\nFROM   products\nWHERE  name in ('crackers', 'chips', 'energy drink')\n\n\n\n\n\n\n\n\n\norder_price\n\n\n\n\n0\n235.0",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Агрегація даних</span>"
    ]
  },
  {
    "objectID": "sql_agg.html#довжина-списку-array_length",
    "href": "sql_agg.html#довжина-списку-array_length",
    "title": "16  Агрегація даних",
    "section": "16.5 Довжина списку: ARRAY_LENGTH",
    "text": "16.5 Довжина списку: ARRAY_LENGTH\nЯк пам’ятаєте, у таблиці orders вміст замовлень представлено вигляді списків товарів (масивів). Щоб порахувати кількість товарів у кожному замовленні, можна скористатися функцією array_length.\nФункція array_length обчислює кількість елементів у масиві (довжину масиву) і записується так:\nSELECT array_length(ARRAY['first', 'second', 'third'], 1)\n\nРезультат:\n3\nСинтаксис може здатися вам трохи складним, але це лише на перший погляд! Давайте розбиратися.\nARRAY['first', 'second', 'third'] – це деякий список із трьох значень: 'first', 'second', 'third’.\nОдиниця як другий аргумент — це розмірність масиву, за якій рахується його довжина. Так як список у нас одновимірний (просто значення, записані в один рядок), то вибір у нас невеликий – можемо вказати лише першу розмірність.\nЯкби в нас була таблиця N x N, в якій були б і рядки, і стовпці, то розмірності було б дві: перша відповідала кількості рядків, а друга — числу стовпців. У такому випадку ми могли б вказати або першу, або другу розмірність.\nДавайте уявімо, що у нас є проста таблиця наступного виду:\n _______\n| 1 | 2 |\n| 3 | 4 |\n| 5 | 6 |\n ‾‾‾‾‾‾‾\nУ цій таблиці 3 рядки та 2 стовпці, тому її можна описати у вигляді наступного списку з трьох вкладених у нього списків:\nARRAY[[1,2], [3,4], [5,6]]\nУ прикладі вище кількість списків усередині основного списку — кількість рядків у таблиці, а кількість елементів усередині кожного внутрішнього списку — кількість стовпців.\nЗверніть увагу на результат обчислень функції array_length для першої та другої розмірності:\nSELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)\n\nРезультат:\n3\n\nSELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)\n\nРезультат:\n2\nУ це досить складно повірити, але значеннями в основній таблиці справді можуть бути інші таблиці (матриці). На щастя, у нас не такі дані, тому ми працюватимемо із простими однорозмірними списками значень.\nВ якості аргументу функції array_length на місці масиву можна вказувати ім’я колонки, яка містить масиви (у нашому випадку це колонка product_ids):\nSELECT array_length(column, 1)\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nДізнатися більше про функції для роботи з масивами можна у документації. З деякими з них ми познайомимося далі.\n\n\n\n\nЗавдання 16.9  Порахуйте кількість замовлень у таблиці orders із дев’ятьма і більше товарами. Для цього скористайтесь функцією array_length, відфільтруйте дані щодо кількості товарів у замовленні та проведіть агрегацію. Отриманий стовпець назвіть orders.\nПоле в результуючій таблиці: orders\nПояснення: у наших даних у колонці product_ids містяться звичайні списки товарів лише з однією розмірністю.\n\n\n\n\nРішення\n%%sql\nSELECT count(order_id) as orders\nFROM   orders\nWHERE  array_length(product_ids, 1) &gt;= 9\n\n\n\n\n\n\n\n\n\norders\n\n\n\n\n0\n5",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Агрегація даних</span>"
    ]
  },
  {
    "objectID": "sql_agg.html#різниця-часу-age",
    "href": "sql_agg.html#різниця-часу-age",
    "title": "16  Агрегація даних",
    "section": "16.6 Різниця часу: AGE",
    "text": "16.6 Різниця часу: AGE\nВ якості агрегатних функцій можуть виступати не тільки стовпці, але також розрахункові колонки або результат іншої функції:\nSELECT AVG(some_function(column))\nFROM table\n\n\nSELECT AVG(column_1 + column_2)\nFROM table\nСпробуємо розрахувати середній вік користувачів чоловічої статі. Для цього скористаємось новою для нас функцією AGE.\nФункція AGE повертає різницю між двома значеннями, наведеними у форматі TIMESTAMP. При цьому від першого значення віднімається друге, а сама різниця повертається у форматі INTERVAL:\nSELECT AGE('2022-12-12', '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nТаким чином, з '2021-11-10' до '2022-12-12' пройшло рівно 397 днів.\nЯкщо в якості першого аргументу нічого не вказати, то на місце першої дати автоматично підставиться поточна дата (опівніч поточного дня, тобто початок дня).\nЯкщо сьогодні '2022-12-12', то з '2021-11-10' пройшло рівно стільки ж днів, скільки у прикладі вище:\nSELECT AGE(TIMESTAMP '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nНасправді поточній даті відповідає значення current_date, яке можна вказувати як аргумент функції AGE:\nSELECT AGE(TIMESTAMP '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nМожете самостійно запустити два запити - з current_date і без - і порівняти отримані результати. У вашому випадку це будуть нові результати, але вони мають збігтися.\nА саме значення current_date можна викликати так:\nSELECT current_date\n\nРезультат:\n2023-06-01  \nДля того щоб результат відображався не у кількості днів, а в зручнішому форматі, можна переводити результат обчислень у тип VARCHAR:\nSELECT AGE(current_date, '2021-11-10')::VARCHAR\n\nРезультат:\n1 year 1 mon 2 days\n\n\nЗавдання 16.10  За допомогою функції AGE і агрегатної функції розрахуйте вік наймолодшого кур’єра чоловічої статі в таблиці couriers.\nВік виведіть через кількість років, місяців і днів (як у прикладі вище), перевівши їх у тип VARCHAR.\nВ якості дати, відносно якої необхідно розрахувати вік кур’єрів, використовуйте свою поточну дату (або не вказуйте її на місці першого аргументу, як показано в прикладах).\nОтриману колонку зі значенням віку назвіть min_age.\nПоле у результуючій таблиці: min_age\nПояснення: оскільки в якості дати, щодо якої проводиться розрахунок віку, ми використовуємо поточну дату, кожен новий день ми отримуватимемо новий результат.\nЗрозуміло, що рахувати вік у такий спосіб не зовсім коректно. Ми навчимося робити це правильно в розділі «Підзапити».\n\n\n\n\nРішення\n%%sql\nSELECT age(max(birth_date))::varchar as min_age\nFROM   couriers\nWHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nmin_age\n\n\n\n\n0\n17 years 8 months 28 days 13:03:18.214",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Агрегація даних</span>"
    ]
  },
  {
    "objectID": "sql_agg.html#агрегація-з-case-when",
    "href": "sql_agg.html#агрегація-з-case-when",
    "title": "16  Агрегація даних",
    "section": "16.7 Агрегація з CASE WHEN",
    "text": "16.7 Агрегація з CASE WHEN\nАргументом агрегатної функції може бути і складніша розрахункова колонка - наприклад, отримана в результаті роботи конструкції CASE.\nУ такому випадку сама конструкція CASE поміщається всередину дужок агрегатної функції:\nAVG(\n    CASE  \n    WHEN logical_expression_1 THEN expression_1\n    WHEN logical_expression_2 THEN expression_2\n    ELSE expression_else\n    END\n)\nТак, якби в нашій таблиці всі товари були розбиті за категоріями і ми захотіли б порахувати середню ціну товарів з урахуванням підвищувальних чи знижувальних коефіцієнтів для кожної категорії, то ми могли б зробити це, наприклад, так:\nSELECT AVG(\n    CASE \n    WHEN category=\"м'ясо\" THEN price*0.95\n    WHEN category=\"риба\" THEN price*0.9\n    WHEN category=\"напої\" THEN price*1.05\n    ELSE price\n    END\n    ) AS avg_price\nFROM products\nДавайте ускладнимо одне з попередніх завдань і розрахуємо вартість ще одного замовлення.\n\n\nЗавдання 16.11  Порахуйте вартість замовлення, в якому будуть три пачки крекерів ('crackers'), дві пачки чіпсів ('chips') та один енергетичний напій ('energy drink'). Колонку із розрахованою вартістю замовлення назвіть order_price.\nДля розрахунків використовуйте таблицю products.\nПоле в результуючій таблиці: order_price\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розв’язання задачі необхідно за допомогою конструкції CASE створити розрахункову колонку, в якій навпроти кожного товару, який увійшов у замовлення, проставити ціну, помножену на кількість таких товарів у замовленні. Для товарів, які не увійшли у замовлення, необхідно вказати ціну, що дорівнює 0 або NULL. Потім за допомогою агрегатної функції достатньо порахувати суму значень у новій розрахунковій колонці.\n\n\n\n\n\nРішення\n%%sql\nSELECT sum(case when name = 'crackers' then price * 3\n                when name = 'chips' then price * 2\n                when name = 'energy drink' then price\n                else 0 end) as order_price\nFROM   products\n\n\n\n\n\n\n\n\n\norder_price\n\n\n\n\n0\n355.0",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Агрегація даних</span>"
    ]
  },
  {
    "objectID": "sql_agg.html#агрегатні-вирази-з-фільтрацією",
    "href": "sql_agg.html#агрегатні-вирази-з-фільтрацією",
    "title": "16  Агрегація даних",
    "section": "16.8 Агрегатні вирази з фільтрацією",
    "text": "16.8 Агрегатні вирази з фільтрацією\nМи розглянули кілька прикладів, коли в якості агрументу агрегатних функцій виступає результат виконання іншої функції.\nАле агрегатна функція може і сама опинитися на місці аргументу якоїсь функції:\nSELECT some_function(SUM(column)) AS result\nFROM table\nНаочний приклад — застосування функції ROUND до результату агрегації:\nSELECT ROUND(SUM(column)) AS rounded_sum\nFROM table\nДавайте вирішимо схоже завдання і заразом ненадовго повернемося до наших напоїв та оператора LIKE.\n\n\nЗавдання 16.12  Розрахуйте середню ціну товарів у таблиці products, у назвах яких є слова 'tea' чи 'coffee'. Виключіть з розрахунку товари, що містять «іван-чай» ('ivan-tea') або «чайний гриб» ('tea mushroom').\nСередню ціну округліть до двох знаків після коми. Стовпець із отриманим значенням назвіть avg_price.\nПоле у результуючій таблиці: avg_price\nПояснення: пам’ятайте, що виконання логічних виразів можна керувати за допомогою дужок. Це може стати в нагоді.\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(price), 2) as avg_price\nFROM   products\nWHERE  (name like '%tea%'\n    or name like '%coffee%')\n   and name not like '%ivan-tea%'\n   and name not like '%mushroom%'\n\n\n\n\n\n\n\n\n\navg_price\n\n\n\n\n0\n135.23\n\n\n\n\n\n\n\nВтім, бувають і випадки, коли як аргументи деякої функції виступають відразу кілька агрегатних функцій:\nSELECT some_function(SUM(column_1), SUM(column_2)) AS result\nFROM table\nНаприклад, нам уже знайома функція AGE, яка може приймати одразу два аргументи - дату кінця та дату початку деякого періоду часу.\n\n\nЗавдання 16.13  Скористайтеся функцією AGE та розрахуйте різницю у віці між найстарішим та наймолодшим користувачами чоловічої статі у таблиці users.\nРізницю у віці висловіть кількістю років, місяців та днів, перевівши її у тип VARCHAR.\nНазвіть колонку з порахованим значенням age_diff.\nПоле у результуючій таблиці: age_diff\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЦе завдання можна вирішити різними способами: можна просто знайти різницю між датами народження наймолодшого і найстарішого користувачів, а можна порахувати різницю між їх віком. Можете піти будь-яким шляхом. Якщо рахуватимете вік, то в якості першої дати використовуйте свою поточну дату (current_date).\n\n\n\n\n\nРішення\n%%sql\nSELECT age(max(birth_date), min(birth_date))::varchar as age_diff\nFROM   users\nWHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nage_diff\n\n\n\n\n0\n21 years 9 months 27 days\n\n\n\n\n\n\n\nА тепер розглянемо приклад, коли агрегатна функція приймає в якості аргументу одну функцію і при цьому сама є аргументом іншої функції.\nВиглядати це може так:\nSELECT function_two(SUM(funtion_one(column))) AS result\nFROM table\nУ цьому прикладі спочатку до колонки column застосовується функція funtion_one, потім за допомогою функції SUM буде пораховано суму отриманих значень, і тільки потім до результату агрегації застосовується функція funtion_two.\n\n\nЗавдання 16.14  Розрахуйте середню кількість товарів у замовленнях з таблиці orders, які користувачі оформляли у вихідні дні (субота та неділя) протягом усього часу роботи сервісу.\nОтримане значення округліть до двох знаків після коми. Назвіть колонку з ним avg_order_size.\nПоле у результуючій таблиці: avg_order_size\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розрахунку кількості товарів у замовленнях скористайтесь функцією array_length. Для фільтрації таблиці у вихідні дні можна використовувати функцію DATE_PART з параметром 'dow'.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(array_length(product_ids, 1)), 2) as avg_order_size\nFROM   orders\nWHERE  date_part('dow', creation_time) in (6, 0)\n\n\n\n\n\n\n\n\n\navg_order_size\n\n\n\n\n0\n3.39\n\n\n\n\n\n\n\nРезультати декількох агрегатних функцій можна використовувати в одному запиті для проведення над ними арифметичних операцій:\nSELECT (SUM(column_1) + SUM(column_2)) / 2\nFROM table\nУ запиті вище буде пораховано середнє арифметичне двох сум — значень колонки column_1 і значень колонки column_2.\n\n\nЗавдання 16.15  На основі даних у таблиці user_actions порахуйте: - кількість унікальних користувачів сервісу; - кількість унікальних замовлень - скільки замовлень припадає на одного користувача.\nУ результуючій таблиці відобразіть усі три значення – поля назвіть відповідно unique_users, unique_orders, orders_per_user.\nПоказник числа замовлень користувача округліть до двох знаків після коми.\nПоля у результуючій таблиці: unique_users, unique_orders, orders_per_user\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nЩоб отримати коректний результат поділу, необхідно хоча б одне із значень попередньо привести до типу DECIMAL (або помножити на 1.0). Інакше результатом розподілу цілого числа інше ціле число буде теж ціле число.\nДо речі, з подібною проблемою можна ознайомитись на stackoverflow. Це дуже корисний ресурс для пошуку відповідей на свої запитання. Навіть досвідчені програмісти часто ним користуються. Можете вже зараз почати виробляти звичку звертатися до нього за необхідності.\nТакож пам’ятайте, що використовувати в розрахунках аліаси нових колонок не можна.\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct user_id) as unique_users,\n       count(distinct order_id) as unique_orders,\n       round(count(distinct order_id) * 1.0 / count(distinct user_id),\n             2) as orders_per_user\nFROM   user_actions\n\n-- Рішення через DECIMAL\n-- SELECT count(distinct user_id) as unique_users,\n--        count(distinct order_id) as unique_orders,\n--        round(count(distinct order_id)::DECIMAL / count(distinct user_id),\n--              2) as orders_per_user\n-- FROM   user_actions\n\n\n\n\n\n\n\n\n\nunique_users\nunique_orders\norders_per_user\n\n\n\n\n0\n21401\n59595\n2.78\n\n\n\n\n\n\n\nІ насамкінець познайомимося з більш просунутим функціоналом — агрегатними виразами з фільтрацією.\nЯкщо після агрегатної функції вказати ключове слово FILTER і помістити в дужках деяку умову condition після WHERE, то агрегатній функції на вхід будуть подані тільки ті рядки, для яких умова фільтра виявиться істинною.\nЗагалом ця конструкція виглядає так:\nSELECT agg_function(column) FILTER (WHERE condition)\nFROM table\nНаприклад, якби ми захотіли порахувати середню ціну тільки для товарів категорії 'fish', то запит виглядав би так:\nSELECT AVG(price) FILTER (WHERE category = 'fish') AS avg_fish_price\nFROM table\nЗверніть увагу: це дуже схоже на звичайну фільтрацію з агрегацією, яку ми розглядали в попередніх завданнях, тільки в даному випадку умова відбору записів вказується відразу в блоці SELECT.\nПеревага такого запису в тому, що він дозволяє проводити розрахунки без проміжних запитів з умовами у блоці WHERE.\nРозглянемо ще один приклад.\nУ нашому випадку досить зрозуміло, як порахувати загальну кількість користувачів. Також зрозуміло, як порахувати кількість користувачів, які хоча б раз скасовували замовлення — досить просто вказати потрібну умову в операторі WHERE. Але як у рамках одного запиту порахувати тих, хто ніколи не скасовував своє замовлення?\nОскільки об’єднувати кілька запитів разом ми поки що не вміємо, нам допоможе прийти агрегатний вираз.\n\n\nЗавдання 16.16  Порахуйте скільки користувачів ніколи не скасовували своє замовлення. Для цього із загальної кількості всіх унікальних користувачів відніміть кількість унікальних користувачів, які хоча б раз скасовували замовлення. Подумайте, яку умову необхідно вказати у FILTER, щоб отримати коректний результат.\nОтриманий стовпець назвіть users_count.\nПоле в результуючій таблиці: users_count\n\n\n\n\nРішення\n%%sql\n-- Рішення через різницю\nSELECT count(distinct user_id) - count(distinct user_id) filter (WHERE action = 'cancel_order') as users_count\nFROM   user_actions\n\n-- Рішення через вкладений запит\n-- SELECT count(distinct user_id) filter (WHERE user_id not in (SELECT DISTINCT user_id\n--                                                              FROM   user_actions\n--                                                              WHERE  action = 'cancel_order')) as users_count\n-- FROM   user_actions\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n\n\n\n\n\nДавайте вирішимо ще одне завдання на агрегатні вирази з фільтрацією - цього разу з більш складними розрахунками.\n\n\nЗавдання 16.17  Порахуйте:\n\nзагальну кількість замовлень у таблиці orders\nкількість замовлень із п’ятьма та більше товарами\nчастку замовлень із п’ятьма та більше товарами у загальній кількості замовлень.\n\nУ результуючій таблиці відобразіть усі три значення - поля назвіть відповідно orders, large_orders, large_orders_share.\nЧастку замовлень із п’ятьма та більше товарами у загальній кількості товарів округліть до двох знаків після коми.\nПоля в результуючій таблиці: orders, large_orders, large_orders_share\nПояснення: при розрахунку частки не забудьте хоча б одне із значень попередньо привести до типу DECIMAL (або домножити на 1.0). Також пам’ятайте, що використовувати в розрахунках аліаси нових колонок не можна.\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct order_id) as orders,\n       count(distinct order_id) filter (WHERE array_length(product_ids, 1) &gt;= 5) as large_orders,\n       round(count(distinct order_id) filter (WHERE array_length(product_ids, 1) &gt;= 5)::decimal / count(distinct order_id),\n             2) as large_orders_share\nFROM   orders\n\n\n\n\n\n\n\n\n\norders\nlarge_orders\nlarge_orders_share\n\n\n\n\n0\n59595\n11498\n0.19",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Агрегація даних</span>"
    ]
  },
  {
    "objectID": "python_conditionals.html#оператори-порівняння",
    "href": "python_conditionals.html#оператори-порівняння",
    "title": "\n2  Умовні оператори\n",
    "section": "\n2.1 Оператори порівняння",
    "text": "2.1 Оператори порівняння\nВиявляється, що Python постачається з великою кількістю вбудованого синтаксису. Наприклад, ось лише деякі з символів, які ви можете використовувати у Python, щоб ставити запитання, зокрема математичні.\nЗмінні та значення можна порівнювати між собою за допомогою операцій порівняння:\n\n\nx &lt; y: x строго менше y,\n\nx &lt;= y: x менше або дорівнює y,\n\nx &gt; y: x строго більше y,\n\nx &gt;= y: x більше або дорівнює y,\n\nx == y: x дорівнює y,\n\nx != y: x не дорівнює y.\n\nДля того, щоб ставити запитання з використанням цих символів нам знадобиться ще одне ключове слово в Python. І це ключове слово, досить просто, як і в англійській мові, - if. Ви можете задавати питання в Python-коді на кшталт: якщо відповідь на це питання істинна, то виконайте цей код для мене.\nДавайте створимо новий файл compare.py і спробуємо використати ці оператори порівняння:\n\n\nTerminal\n\ncode hello.py\n\nНаступний код буде порівнювати значення і приймати рішення на основі цих значень:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 2\n\nif x &lt; y:\n    print('x менше y')\nif x &gt; y:\n    print('x більше y')\nif x == y:\n    print('x дорівнює y')\n\n\n\nx менше y\n\n\nДавайте побудуємо діаграму того, як працює цей код:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x &lt; y}\n    B -- True --&gt; C[\"'x менше y'\"]\n    C --&gt; D{x &gt; y}\n    B -- False --&gt; D\n    D -- True --&gt; E[\"'x більше y'\"]\n    E --&gt; F{x == y}\n    D -- False --&gt; F\n    F -- True --&gt; G[\"'x дорівнює y'\"]\n    G --&gt; H(Кінець)\n    F -- False --&gt; H\n\n\n\n\nРисунок 2.1: Діаграма роботи коду з порівняннями\n\n\n\n\nЗа такої конфігурації коду, ми тричі викликаємо ключове слово if, щоб задати три різні запитання. Якщо відповідь на запитання є True, то виконується код, який знаходиться після нього. Якщо відповідь на запитання є False, то код, який знаходиться після нього, не виконується.\nТакий код виконує свою задачу, але він не є найкращим. Якщо ви помітите, ми використовуємо три окремі запитання, щоб визначити, яке з двох чисел є більшим. Це можна зробити краще, використовуючи ключове слово elif.\nelif - це скорочення від else if. Це означає, що якщо попередні запитання були False, то ви можете задати нове запитання. Якщо відповідь на це запитання є True, то виконується код, який знаходиться після нього. Якщо відповідь на це запитання є False, то код, який знаходиться після нього, не виконується. Давайте перепишемо наш код з використанням elif:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 2\n\nif x &lt; y:\n    print('x менше y')\nelif x &gt; y:\n    print('x більше y')\nelif x == y:\n    print('x дорівнює y')\n\n\n\nx менше y\n\n\nОтже, яке покращення я щойно зробив? Давайте подивимось на діаграму:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x &lt; y}\n    B -- True --&gt; C[\"'x менше y'\"]\n    C --&gt; H(Кінець)\n    B -- False --&gt; D{x &gt; y}\n    D -- True --&gt; E[\"'x більше y'\"]\n    E --&gt; H\n    D -- False --&gt; F{x == y}\n    F -- True --&gt; G[\"'x дорівнює y'\"]\n    G --&gt; H\n    F -- False --&gt; H\n\n\n\n\nРисунок 2.2: Діаграма роботи коду з порівняннями з elif\n\n\n\n\nЦього разу ми використовуємо три запитання, але якщо відповідь на перше запитання є True, то виконується код, який знаходиться після нього, і код, який знаходиться після наступних запитань, не виконується. Якщо відповідь на перше запитання є False, то виконується наступне запитання. Якщо відповідь на друге запитання є True, то виконується код, який знаходиться після нього, і код, який знаходиться після наступного запитання, не виконується. Якщо відповідь друге це запитання є False, то виконується наступне запитання. І так далі. Якщо відповідь на всі запитання є False, то жоден код не виконується.\nЩо це нам дає? Це дає нам можливість задавати багато запитань, але виконувати код лише одного запитання, якщо відповідь на нього є True. Це дозволяє нам писати більш читабельний код, а також економити час на виконання коду.\nАле, якщо замислитись, то чи є сенс задавати третє, останнє питання x == y? Число x може бути або меншим за y, або більшим за y, або дорівнюватиме y. Якщо виключити перші два сценарії, то логічно, що x має дорівнювати y. В таких випадках ми можемо використовувати ключове слово else і не перевіряти зайвої умови. Давайте перепишемо наш код з використанням else:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 1\n\nif x &lt; y:\n    print('x менше y')\nelif x &gt; y:\n    print('x більше y')\nelse:\n    print('x дорівнює y')\n\n\n\nx дорівнює y\n\n\nДавайте подивимось на діаграму:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x &lt; y}\n    B -- True --&gt; C[\"'x менше y'\"]\n    C --&gt; H(Кінець)\n    B -- False --&gt; D{x &gt; y}\n    D -- True --&gt; E[\"'x більше y'\"]\n    E --&gt; H\n    D -- False --&gt; F[\"'x дорівнює y'\"]\n    F --&gt; H\n\n\n\n\nРисунок 2.3: Діаграма роботи коду з порівняннями з else\n\n\n\n\nВи можете побачити на цих діаграмах відносне зменшення складності програми. Чим менше рядків коду, тим менша ймовірність того, що ви зробите помилку, і тим легше його читати іншим людям. Крім того, такий підхід дозволяє нам економити час на виконання коду, оскільки ми не будемо перевіряти зайві умови.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Умовні оператори</span>"
    ]
  },
  {
    "objectID": "python_conditionals.html#логічні-оператори-or-and-та-not",
    "href": "python_conditionals.html#логічні-оператори-or-and-та-not",
    "title": "\n2  Умовні оператори\n",
    "section": "\n2.2 Логічні оператори or, and та not\n",
    "text": "2.2 Логічні оператори or, and та not\n\nВи можете використовувати логічні оператори or, and та not для створення більш складних умов. Ці оператори дозволяють вам об’єднувати умови, щоб визначити, чи хочете ви виконати цей рядок коду або інший.\n\n2.2.1 Логічний оператор or\n\nЦього разу перевіримо, чи дорівнює x числу y. Для цього використаємо оператори or:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 2\n\nif x &lt; y or x &gt; y:\n    print('x не дорівнює y')\nelse:\n    print('x дорівнює y')\n\n\n\nx не дорівнює y\n\n\nДіаграма роботи коду з оператором or:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x &lt; y}\n    B -- True --&gt; C[\"'x не дорівнює y'\"]\n    C --&gt; H(Кінець)\n    B -- False --&gt; D{x &gt; y}\n    D -- True --&gt; C\n    D -- False --&gt; F[\"'x дорівнює y'\"]\n    F --&gt; H\n\n\n\n\nРисунок 2.4: Діаграма роботи коду з порівняннями з or\n\n\n\n\nЧи можемо ми покращити цей код? Так, можемо. Насправді нам не має потреби перевіряти дві умови щодо нерівності x та y. Значно краще одразу перевірити, чи не дорівнює x числу y. Для цього ми можемо викорситати оператор заперечення !=:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 2\n\nif x != y:\n    print('x не дорівнює y')\nelse:\n    print('x дорівнює y')\n\n\n\nx не дорівнює y\n\n\nДіаграма роботи коду з оператором заперечення !=:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x != y}\n    B -- True --&gt; C[\"'x не дорівнює y'\"]\n    C --&gt; H(Кінець)\n    B -- False --&gt; D[\"'x дорівнює y'\"]\n    D --&gt; H\n\n\n\n\nРисунок 2.5: Діаграма роботи коду з оператором заперечення !=\n\n\n\n\nТакий код працює так само, як і попередній, але він є більш читабельним і ефективним.\n\n2.2.2 Логічний оператор and\n\nДавайте розберемо роботу ще одного оператора - and. Цей оператор дозволяє нам перевірити, чи виконуються обидві умови. Цього разу я пропоную створити програму grade.py, яка буде визначати оцінку студента за його балами:\n\n\nTerminal\n\ncode grade.py\n\nУ змінну score будемо приймати значення балу. Система оцінювання в різних університетах може дещо відрізнятися, але в цілому вона виглядає так:\n\n\n90 &lt;= score &lt;= 100 - A\n\n\n80 &lt;= score &lt; 90 - B\n\n\n70 &lt;= score &lt; 80 - C\n\n\n66 &lt;= score &lt; 70 - D\n\n\n60 &lt;= score &lt; 66 - E\n\n\n21 &lt;= score &lt; 60 - FX\n\n\nscore &lt; 20 - F\n\n\nДавайте напишемо код, який буде визначати оцінку студента за його балами:\n\nscore = int(input('Введіть бал: ')) # 90\n\nif score &gt;= 90 and score &lt;= 100:\n    print('Оцінка: A')\nelif score &gt;= 80 and score &lt; 90:\n    print('Оцінка: B')\nelif score &gt;= 70 and score &lt; 80:\n    print('Оцінка: C')\nelif score &gt;= 66 and score &lt; 70:\n    print('Оцінка: D')\nelif score &gt;= 60 and score &lt; 66:\n    print('Оцінка: E')\nelif score &gt;= 21 and score &lt; 60:\n    print('Оцінка: FX')\nelse:\n    print('Оцінка: F')\n\n\n\nОцінка: A\n\n\nPython дозволяє поміняти місцями score і відповідний бал при порівнянні. Такий код буде працювати так само, як і попередній:\n\nscore = int(input('Введіть бал: ')) # 80\n\nif 90 &lt;= score and score &lt;= 100:\n    print('Оцінка: A')\nelif 80 &lt;= score and score &lt; 90:\n    print('Оцінка: B')\nelif 70 &lt;= score and score &lt; 80:\n    print('Оцінка: C')\nelif 66 &lt;= score and score &lt; 70:\n    print('Оцінка: D')\nelif 60 &lt;= score and score &lt; 66:\n    print('Оцінка: E')\nelif 21 &lt;= score and score &lt; 60:\n    print('Оцінка: FX')\nelse:\n    print('Оцінка: F')\n\n\n\nОцінка: B\n\n\nКрім того, Python дозволяє об’єднувати діапазони порівнянь:\n\nscore = int(input('Введіть бал: ')) # 70\n\nif 90 &lt;= score &lt;= 100:\n    print('Оцінка: A')\nelif 80 &lt;= score &lt; 90:\n    print('Оцінка: B')\nelif 70 &lt;= score &lt; 80:\n    print('Оцінка: C')\nelif 66 &lt;= score &lt; 70:\n    print('Оцінка: D')\nelif 60 &lt;= score &lt; 66:\n    print('Оцінка: E')\nelif 21 &lt;= score &lt; 60:\n    print('Оцінка: FX')\nelse:\n    print('Оцінка: F')\n\n\n\nОцінка: C\n\n\nВ даному випадку це здебільшого естетичне покращення, Python все ще виконує ті ж самі порівняння.\nЯкщо переосмислити логіку, то можна зробити це ще краще. Якщо ми знаємо, що вхідні дані на даний момент будуть в межах від 0 до 100, ми можемо зробити деякі припущення: якщо score більше або дорівнює 90, то оцінка буде A, після цього ми можемо перевірити, чи score більше або дорівнює 80, якщо так, то оцінка буде B, і так далі. Це дозволить нам зменшити кількість перевірок, які ми робимо. Давайте перепишемо наш код:\n\nscore = int(input('Введіть бал: ')) # 70\n\nif score &gt;= 90:\n    print('Оцінка: A')\nelif score &gt;= 80:\n    print('Оцінка: B')\nelif score &gt;= 70:\n    print('Оцінка: C')\nelif score &gt;= 66:\n    print('Оцінка: D')\nelif score &gt;= 60:\n    print('Оцінка: E')\nelif score &gt;= 21:\n    print('Оцінка: FX')\nelse:\n    print('Оцінка: F')\n\n\n\nОцінка: C\n\n\nТака невеличка оптимізація дозволяє нам зменшити кількість перевірок і пришвидшити виконання коду.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Умовні оператори</span>"
    ]
  },
  {
    "objectID": "python_conditionals.html#парність-та-оператор",
    "href": "python_conditionals.html#парність-та-оператор",
    "title": "\n2  Умовні оператори\n",
    "section": "\n2.3 Парність та оператор %\n",
    "text": "2.3 Парність та оператор %\n\nДавайте розглянемо ще один приклад. Напишемо програму parity.py, яка буде перевіряти, чи є число парним:\n\n\nTerminal\n\ncode parity.py\n\nУ змінну x будемо приймати значення числа. Якщо число ділиться на 2 без остачі, то воно є парним. Давайте напишемо код, який буде перевіряти, чи є число парним:\n\nx = int(input('Введіть число: ')) # 2\n\nif x % 2 == 0:\n    print('Число парне')\nelse:\n    print('Число непарне')\n\n\n\nЧисло парне\n\n\nЯк ми можемо покращити цей результат? Згадаймо, що у нас є можливість вигадувати власні функції. Припустимо, що нам потрібно вміти визначати, чи є число парним або непарним. Ми можемо створити функцію is_even, яка буде приймати число і повертати True, якщо число парне, і False в протилежному випадку. Це називається булевими значеннями bool - один з типів даних в Python. Давайте перепишемо наш код:\n\ndef main():\n    x = int(input('Введіть число: ')) # 2\n\n    if is_even(x):\n        print('Число парне')\n    else:\n        print('Число непарне')\n\ndef is_even(n):\n    if x % 2 == 0:\n        return True\n    else:\n        return False\n\nmain()\n\n\n\nЧисло парне\n\n\nЧи можемо ми покращити дизайн цього коду? Так, можемо. І я покажу вам дещо, що зараз широко відоме як щось “пітоничне” (англ. pythonic) - це спосіб вирішення задачі притаманний мові програмування Python. Замість того, щоб ставити питання if-else, використовуючи чотири рядки, в Python ви можете згорнути його в один більш елегантний рядок коду:\n\ndef main():\n    x = int(input('Введіть число: ')) # 2\n\n    if is_even(x):\n        print('Число парне')\n    else:\n        print('Число непарне')\n\ndef is_even(n):\n    return True if n % 2 == 0 else False\n\nmain()\n\n\n\nЧисло парне\n\n\nЗгідно з ідеєю не просто писати правильний код, а писати все кращий і кращий код, але при цьому залишати його читабельним, я можу зробити ще кращий варіант: n % 2 == 0 поверне True, якщо n парне, і False в протилежному випадку. Таким чином, я можу просто повернути результат виразу n % 2 == 0:\n\ndef main():\n    x = int(input('Введіть число: ')) # 2\n\n    if is_even(x):\n        print('Число парне')\n    else:\n        print('Число непарне')\n\ndef is_even(n):\n    return n % 2 == 0\n\nmain()\n\n\n\nЧисло парне\n\n\nМабуть, це найелегантніший спосіб реалізувати цю задачу, але він може бути не так очевидним для початківців.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Умовні оператори</span>"
    ]
  },
  {
    "objectID": "python_conditionals.html#оператор-зіставлення-з-шаблонами-match",
    "href": "python_conditionals.html#оператор-зіставлення-з-шаблонами-match",
    "title": "\n2  Умовні оператори\n",
    "section": "\n2.4 Оператор зіставлення з шаблонами: match\n",
    "text": "2.4 Оператор зіставлення з шаблонами: match\n\nКлючове слово, яке ви можете використовувати в останніх версіях Python, називається match - це механізм зіставлення з шаблонами. Це дозволяє вам виконувати дії в залежності від значення змінної.\nСтворимо програму house.py, яка запитує у користувача його ім’я, а потім просто виводить гуртожиток1, на якому він навчається у книгах про Гаррі Поттера.\n\n\nTerminal\n\ncode house.py\n\nДля початку у змінну name будемо приймати ім’я. Далі за допомогою конструкції if-elif-else будемо визначати до якого гуртожитку належить студент. Давайте напишемо код:\n\nname = input('Введіть ім\\'я: ') # Драко\n\nif name == 'Гаррі':\n    print('Ґрифіндор')\nelif name == 'Герміона':\n    print('Ґрифіндор')\nelif name == 'Рон':\n    print('Ґрифіндор')\nelif name == 'Драко':\n    print('Слизерин')\nelse:\n    print('Хто?')\n\n\n\nСлизерин\n\n\nУ цьому коді є певна повторюваність: Гаррі, Герміона та Рон належать до Гріфіндору. Давайте об’єднаємо ці умови в одну:\n\nname = input('Введіть ім\\'я: ') # Герміона\n\nif name == 'Гаррі' or name == 'Герміона' or name == 'Рон':\n    print('Ґрифіндор')\nelif name == 'Драко':\n    print('Слизерин')\nelse:\n    print('Хто?')\n\n\n\nҐрифіндор\n\n\nЩо ж, виявляється, є ще один підхід, який, можливо, зробить ваш код трохи менш багатослівним. Ви можете уявити, наскільки складним може стати цей код, якщо у нас будуть не тільки Гаррі, Герміона і Рон, але й ціла купа інших імен для Грифіндору, Слизерину і всіх інших гуртожитків Гоґвортсу. Якщо ви хочете зробити це більш елегантним, ви можете використовувати ключове слово match:\n\nname = input('Введіть ім\\'я: ') # Рон\n\nmatch name:\n    case 'Гаррі':\n        print('Ґрифіндор')\n    case 'Герміона':\n        print('Ґрифіндор')\n    case 'Рон':\n        print('Ґрифіндор')\n    case 'Драко':\n        print('Слизерин')\n    case _:\n        print('Хто?')\n\n\n\nҐрифіндор\n\n\nЗверніть увагу на те, що я використовую _ для визначення варіанту за замовчуванням. Це означає, що якщо жоден з варіантів не відповідає значенню name, то виконається варіант за замовчуванням. Це дозволяє нам уникнути використання else в кінці.\nТепер у нас знову є три оператори case для Гаррі, Герміони та Рона. Для об’єднання цих трьох операторів case ми можемо використовувати оператор |:\n\nname = input('Введіть ім\\'я: ') # Гаррі\n\nmatch name:\n    case 'Гаррі' | 'Герміона' | 'Рон':\n        print('Ґрифіндор')\n    case 'Драко':\n        print('Слизерин')\n    case _:\n        print('Хто?')\n\n\n\nҐрифіндор\n\n\nЯк завжди у випадку з Python і програмуванням загалом, існують різні способи розв’язання цих задач. Це просто ще один інструмент у вашому арсеналі. Можливо, він покращив ситуацію та зробив ваш код більш читабельним.\nВарто зазначити, що Вам не потрібен оператор break для виходу з case, Ви просто використовуєте _ як паличку-виручалочку в кінці коду.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Умовні оператори</span>"
    ]
  },
  {
    "objectID": "python_conditionals.html#порівняння-рядків",
    "href": "python_conditionals.html#порівняння-рядків",
    "title": "\n2  Умовні оператори\n",
    "section": "\n2.5 Порівняння рядків",
    "text": "2.5 Порівняння рядків\nПорівняння рядків влаштовано трохи хитріше. Почнемо з простого та розглянемо порівняння двох однакових рядків:\n\nprint('abc' == 'abc')\n\nTrue\n\n\nА якщо записати так:\n\nprint('abc' &gt; 'abc')\n\nFalse\n\n\nДавайте розберемося, чому 'abc' &gt; 'aba' поверне нам True. Порівняння рядків у Python відбувається лексикографічно, тобто посимвольно зліва направо. Якщо символи збігаються, Python переходить до наступного символу в рядку і продовжує порівняти доти, доки не знайде різниця між символами в рядку. Якщо символи в рядках різняться, то Python визначає, який рядок “більше” (за алфавітом, у прямому значенні за номером в алфавіті). Якщо символи до цієї позиції збігаються, то рядок, у якого наступний символ більший, вважається “більшим”. При цьому, якщо літери збігаються, то також враховується розмір, маленька літера більша за великий 'a' &gt; 'A' . Розглянемо приклади:\n\nstr1 = 'hello'\nstr2 = 'world'\nprint(str1 &lt; str2 ) \n\nTrue\n\n\n\nstr1 = 'apple'\nstr2 = 'banana'\nprint(str1 &gt; str2) \n\nFalse\n\n\n\nstr1 = 'abc'\nstr2 = 'aba'\nprint(str1 &gt; str2 ) \n\nTrue",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Умовні оператори</span>"
    ]
  },
  {
    "objectID": "python_conditionals.html#завдання",
    "href": "python_conditionals.html#завдання",
    "title": "\n2  Умовні оператори\n",
    "section": "\n2.6 Завдання",
    "text": "2.6 Завдання\n\n\nЗавдання 2.1  Вкажіть усі порівняння, внаслідок яких ми отримаємо True.\n\n'ІВАН' &lt; 'іван'\n'Python' &lt; 'R'\n'big number' != 'bug number'\n'ЯЯЯ' == 'Я Я'\n'гірка' &gt;= 'зірка'\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЯкщо ви сумніваєтеся, виконайте ці порівняння в Python і подивіться на результат.\n\n\n\n\n\n\n\n\n\nПравильні відповіді\n\n\n\n\n\n\n'ІВАН' &lt; 'іван': розмір букв відіграє роль при порівнянні, хоч це й однакове слово, але маленький “іван” більше.\n'Python' &lt; 'R': порівняння відбувається за першим символом, 'R' стоїть в алфавіті правіше, значить 'R' &gt; 'P', отримуємо True\n'big number' != 'bug number': рядки різняться в одному символі, отримуємо True\n'ЯЯЯ' == 'Я Я': пробіли грають роль при порівнянні, пробіл буде менше будь-якого символу. Отримуємо False.\n'гірка' &gt;= 'зірка': порівняння відбувається за першим символом, 'з' більше ніж 'г', отримуємо False\n\n\n\n\n\n\n\n\nЗавдання 2.2  У змінній m зберігається ціле позитивне число – тривалість сну в хвилинах. Якщо тривалість сну становитиме від 7 до 9 години включно, то в змінну optimal_sleep_duration збережіть значення True. В іншому випадку призначте це змінною значення False.\nПриклад:\nm = 410  \noptimal_sleep_duration = False\n\nm = 500\noptimal_sleep_duration = True\n\nРішенняm = 410\noptimal_sleep_duration = m / 60 &gt;= 7 and m / 60 &lt;= 9\n\n# або\noptimal_sleep_duration = 7 * 60 &lt;= m &lt;= 9 * 60\n\n\n\n\n\n\nЗавдання 2.3  У змінній x зберігається ціле число. Перевірте, чи це число ділиться без залишку на 3 і на 7. Результат збережіть в змінну result. Змінна результат повинен мати логічний тип даних.\nПриклад: - якщо x = 7, то result = False. - якщо x = 21, то result = True.\n\nРішенняx = 21\nresult = x % 3 == 0 and x % 7 == 0\n\n\n\n\n\n\nЗавдання 2.4  У змінних str_1 і str_2 збережено два рядки. Якщо рядки містять однакові літери, вам потрібно зберегти у змінну is_the_same_letters значення True, якщо літери в рядках відрізняються - збережіть у змінну значення False.\nМи не враховуємо порядок букв, їхню кількість і регістр.\nПриклад:\n```{python}\nstr_1 = 'AaB'\nstr_2 = 'Ab'\nis_the_same_letters = True \n\nstr_1 = 'Aa'\nstr_2 = 'AaB'\nis_the_same_letters = False\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПодивіться, що вийде, якщо застосувати set до рядка: set(str_1), як нам може це допомогти з рішенням?\n\n\n\n\nРішенняstr_1 = 'AaB'\nstr_2 = 'Ab'\n\nis_the_same_letters = set(str_1.lower()) == set(str_2.lower())\n\n\n\n\n\n\nЗавдання 2.5  Дано два рядки str_1 і str_2. Збережіть у result True, якщо str_1 є анаграмою str_2, і False в іншому випадку. Регістр літер (велика чи маленька буква) не повинен впливати на роботу програми. Тобто 'Літо' і ‘Тіло’ ’це валідна анаграма.\nАнаграма - це слово або фраза, утворена шляхом перестановки літер іншого слова або фрази, зазвичай з використанням усіх вихідних літер рівно один раз.\nПриклад:\n```{python}\nstr_1 = \"Привіт\"\nstr_2 = \"Провал\"\nresult = False\n\nstr_1 = \"Літо\"\nstr_2 = \"Тіло\"\nresult = True\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nСпробуйте застосувати функцію sorted() до рядка.\n\n\n\n\nРішенняstr_1 = \"Привіт\"\nstr_2 = \"Провал\"\n\nresult = sorted(str_1.lower()) == sorted(str_2.lower())\n\n\n\n\n\n\nЗавдання 2.6  У змінних a та b задано значення довжини та ширини прямокутника відповідно. Перевірте, чи є цей прямокутник квадратом.\nЗбережіть у змінну result значення True, якщо це квадрат, інакше False.\nПриклад:\n```{python}\n# Приклад 1\na = 121 \nb = 100 \nresult = False\n\n# Приклад 2\na = 10 \nb = 10 \nresult = True\n```\n\nРішенняa = 121\nb = 100\nresult = a == b\n\n# або\nresult = True if a == b else False\n\n\n\n\n\n\nЗавдання 2.7  У змінних a і b задано два числа. Квадрат якого числа більший? Збережіть це число в result.\nПриклад:\n```{python}\n# Приклад 1\na = 1 \nb = 2 \nresult = 2\n\n# Приклад 2\na = 2 \nb = -3 \nresult = -3\n```\n\nРішенняa = 1\nb = 2\nresult = a if a ** 2 &gt; b ** 2 else b\n\n\n\n\n\n\nЗавдання 2.8  Катя і Діма вирішили купити квартиру в Києві. Сімейний бюджет обмежений, тому їм підходять такі варіанти:\n\nВартість не більше 1.5 млн, площа не менше 50 квадратних метрів, віддаленість від метро не більше 25 хвилин пішки.\nВартість не більше 1.3 млн, площа не менше 35 квадратних метрів, віддаленість від метро не більше 5 хвилин пішки.\n\nНапишіть програму, яка отримує на вхід вартість квартири p, площу s і віддаленість від метро d, і зберігає у змінну result повідомлення про те, підходить квартира чи ні у форматі True або False.\nПриклад:\n```{python}\n#Приклад 1\np = 1295000 #вартість\ns = 32 #площа\nd = 13 #віддаленість від метро\n\nresult = False\n\n#Приклад 2\np = 1498000 #вартість\ns = 51.9 #площа\nd = 23 #віддаленість від метро\n\nresult = True\n```\n\nРішенняp = 1295000\ns = 32\nd = 13\n\nresult = (p &lt;= 1500000 and s &gt;= 50 and d &lt;= 25) or (p &lt;= 1300000 and s &gt;= 35 and d &lt;= 5)\n\n# або\n\nif p &lt;= 1500000 and s &gt;= 50 and d &lt;= 25:\n    result = True\nelif p &lt;= 1300000 and s &gt;= 35 and d &lt;= 5:\n    result = True\nelse: \n    result = False\n\n\n\n\n\n\nЗавдання 2.9  Катя завершила навчання на курсі Machine Learning і набрала K балів за розв’язання задач. Щоб отримати сертифікат про проходження курсу, необхідно набрати щонайменше M балів. Якщо Катя набрала від L балів, то отримає сертифікат з відзнакою.\nЗмінні K, M і L уже визначені.\nНапишіть програму, яка збереже у змінну result інформацію про результати проходження курсу в такому форматі: - \"Недостатньо балів\", якщо Каті не вистачило балів для отримання сертифіката, - \"Сертифікат видано\", якщо Катя набрала кількість балів, необхідну для отримання сертифіката, - \"Видано сертифікат з відзнакою\", якщо Катя набрала ≥ L балів.\nПриклад:\n```{python}\n# Приклад 1\nK = 121 #кількість балів, отриманих Катею\nM = 100 #кількість балів, необхідна для отримання сертифіката\nL = 150 #кількість балів, необхідна для отримання сертифіката з відзнакою\n\nresult = \"Сертифікат видано\"\n\n# Приклад 2\nK = 148 \nM = 110 \nL = 145 \n\nresult = \"Видано сертифікат з відзнакою\"\n```\n\nРішенняK = 121\nM = 100\nL = 150\n\nif K &lt; M:\n    result = \"Недостатньо балів\"\nelif K &gt;= L:\n    result = \"Видано сертифікат з відзнакою\"\nelse:\n    result = \"Сертифікат видано\"\n\n\n\n\n\n\nЗавдання 2.10  Компанія вирішила виплатити співробітникам премію в розмірі:\n\n2 оклади, якщо його стаж роботи ≥ 2 роки\n5 окладів, якщо стаж роботи ≥ 5 років\n10 окладів, якщо стаж роботи ≥ 15 років\n\nУ змінній x - зарплата співробітника, у змінній y - стаж. Обчисліть розмір премії, результат збережіть у змінну result.\nПриклад:\n```{python}\n# Приклад 1\nx = 150000\ny = 3\nresult = 300000\n\n# Приклад 2\nx = 100000\ny = 1\nresult = 0\n\n# Приклад 3\nx = 200000\ny = 16\nresult = 2000000\n```\n\nРішенняx = 150000\ny = 3\n\nif y &gt;= 15:\n    result = 10 * x\nelif y &gt;= 5:\n    result = 5 * x\nelif y &gt;= 2:\n    result = 2 * x\nelse:\n    result = 0\n\n\n\n\n\n\nЗавдання 2.11  Дано словник dict_age, у якому зберігається інформація про вік трьох братів у форматі:\n\nключ - це ім’я\nзначення - це вік, число цілих років.\n\nЯкщо вік у братів різний і виходить однозначно визначити середнього брата, збережіть ім’я середнього брата у змінну result.\nЯкщо хоча б у двох братів вік однаковий, то збережіть у змінну result порожній рядок.\nПриклад:\n```{python}\ndict_age = {'Антон': 5, \n            'Денис': 14, \n            'Борис': 9}\nresult = 'Борис'\n\ndict_age = {'Марк': 5, \n            'Авель': 5, \n            'Карп': 9}\nresult = ''\n```\n\nРішенняdict_age = {'Антон': 5, \n            'Денис': 14, \n            'Борис': 9}\n\nages = list(dict_age.values())\nif len(set(ages)) == 3:\n    middle_index = ages.index(sorted(ages)[1])\n    result = list(dict_age.keys())[middle_index]    \nelse:\n    result = ''\n\n\n\n\n\n\nЗавдання 2.12  Напишіть програму, яка прийматиме довжини сторін трикутника a, b і c, визначатиме, чи є він прямокутним, і зберігатиме результат перевірки в result у форматі True або False.\n\nПрямокутний трикутник - це трикутник, у якому один кут прямий (тобто 90 градусів).\nНайдовша сторона (гіпотенуза) не обов’язково буде останнім аргументом.\nУсі аргументи будуть цілими числами.\n\nПриклад:\n```{python}\na = 3\nb = 5\nc = 4\nresult = True\n\na = 70\nb = 130\nc = 110\nresult = False\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПам’ятаєте теорему Піфагора? Квадрат гіпотенузи дорівнює сумі квадратів катетів (двох інших сторін)\n\n\n\n\nРішенняa = 3\nb = 5\nc = 4\n\nif a &gt; b and a &gt; c:\n    if a ** 2 == b ** 2 + c ** 2:\n        result = True\n    else:\n        result = False\nelif b &gt; a and b &gt; c:\n    if b ** 2 == a ** 2 + c ** 2:\n        result = True\n    else:\n        result = False\nelse:\n    if c ** 2 == a ** 2 + b ** 2:\n        result = True\n    else:\n        result = False\n\n# або\n\nvalues_list = sorted([a, b, c])\nif values_list[-1]**2 == values_list[0]**2 + values_list[1]**2:\n    result = True\nelse:\n    result = False\n\n\n\n\n\n\nЗавдання 2.13  Напишіть програму, яка буде вираховувати або довжину кола, або периметр квадрата, виходячи з переданих аргументів.\nНа вхід подаються буква у змінній f і число у змінній v.\nБуква визначатиме геометричну фігуру:\n'S' - квадрат 'С' - коло\nЯкщо буквою задано квадрат, то другий аргумент, число v, вважається довжиною сторони квадрата. В іншому випадку число вважається радіусом кола.\nРезультат збережіть у result\nЧисло pi візьміть рівним 3.14.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПам’ятаєте теорему Піфагора? Квадрат гіпотенузи дорівнює сумі квадратів катетів (двох інших сторін)\n\n\n\n\nРішенняf = 'S'\nv = 5\n\nif f == 'S':\n    result = v * 4\nelse:\n    result = 2 * 3.14 * v",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Умовні оператори</span>"
    ]
  },
  {
    "objectID": "python_loops.html#цикл-while",
    "href": "python_loops.html#цикл-while",
    "title": "\n3  Цикли\n",
    "section": "\n3.1 Цикл while\n",
    "text": "3.1 Цикл while\n\nКлючове слово while - це конструкція, яка дозволяє мені ставити питання знову і знову. Кожного разу, коли ми бачили питання, воно було у формі булевого виразу, True або False. Повертаючись до нашої попередньої програми, як я можу тричі надрукувати 'Няв!' і тричі поставити запитання, відповідь на яке була б True або False? Для цього нам необхідно задати змінну, яка буде відповідати за кількість нявкань. Назвемо її i (від ітерація). Ініціалізуємо її значенням 3. Потім ми можемо поставити питання: чи менше i за 0? Якщо так, то ми надрукуємо 'Няв!' і зменшимо i на одиницю. Це буде виглядати так:\n\ni = 3\nwhile i &gt; 0:\n    print(\"Няв!\")\n    i = i - 1\n\nНяв!\nНяв!\nНяв!\n\n\nТепер давайте подивимось на блок-схему цієї програми:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B[\"i = 3\"]\n    B --&gt; C{\"i &gt; 0\"}\n    C -- True --&gt; D[\"'Няв!'\"]\n    D --&gt; E[\"i = i - 1\"]\n    E --&gt; C\n    C -- False --&gt; F(Кінець)\n\n\n\n\nРисунок 3.2: Блок-схема програми cat.py з циклом while\n\n\n\n\nЦю задачу можна вирішити дещо й іншим шляхом. Програмісти досить часто починають відлік з нуля. Це умовність, і вона має навіть свої переваги. Тож ми ініціалізуємо i значенням 0, але змінимо умову на i &lt; 3. І тепер ми можемо збільшувати i на одиницю, а не зменшувати. Але і це ще не все, у випадках коли ми збільшуємо або зменшуємо якесь число, ми можемо скористатися спеціальними операторами += і -=. Таким чином, наш код можна спростити до наступного вигляду:\n\ni = 0\nwhile i &lt; 3:\n    print(\"Няв!\")\n    i += 1\n\nНяв!\nНяв!\nНяв!\n\n\nТакий підхід називається “синтаксичним цукром” (англ. syntactic sugar), тобто це не новий функціонал, а лише спрощений синтаксис для існуючого функціоналу. Такий підхід дозволяє зробити код трошки читабельним і зрозумілим.\nДавайте подивимось на блок-схему цієї програми:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B[\"i = 0\"]\n    B --&gt; C{\"i &lt; 3\"}\n    C -- True --&gt; D[\"'Няв!'\"]\n    D --&gt; E[\"i += 1\"]\n    E --&gt; C\n    C -- False --&gt; F(Кінець)\n\n\n\n\nРисунок 3.3: Блок-схема програми cat.py з циклом while",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_loops.html#цикл-for-та-списки",
    "href": "python_loops.html#цикл-for-та-списки",
    "title": "\n3  Цикли\n",
    "section": "\n3.2 Цикл for та списки",
    "text": "3.2 Цикл for та списки\nДля демонстрації можливостей циклу for, нам слід познайомитися ще з однією ідеєю в Python, а саме списками list - це структура даних, яка дозволяє зберігати декілька значень у одній змінній. Списки в Python створюються за допомогою квадратних дужок [] і можуть містити будь-які значення, в тому числі інші списки.\nПринцип роботи циклу for полягає в тому, що він дозволяє ітераційно перебирати список елементів, наприклад так:\n\nfor i in [0, 1, 2]:\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nТакий код став коротшим, ніж варіант з циклом while. Список у цій програмі - це саме [0, 1, 2]. Але що в цьому варіанті коду не так? Якщо ми захочемо змінити кількість нявкань, нам доведеться змінювати список. Це не дуже зручно. Щоб цього уникнути, ми можемо скористатися функцією range(), яка дозволяє створити список послідовності чисел. Таким чином, ми можемо переписати наш код наступним чином:\n\nfor i in range(3):\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nДозвольне показати Вам ще дещо пітонічнє: зверніть увагу, що хоча я визначаю змінну i, я ніколи не використовую її. Але в Python є угода, що якщо вам потрібна змінна тільки тому, що функція програмування вимагає від неї певного підрахунку або автоматичного оновлення, але вам байдуже щодо її значення - назвіть цю змінну _. Це не змінить коректність програми, але це є сигнал колегам, які дивляться на ваш код. Це означає, що вам не потрібно буде звертати увагу на цю змінну, коли ви читаєте код:\n\nfor _ in range(3):\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nЧи можна зробити цей код ще більш пітонічним? Так, можна. Оскільки ми використовуємо рядки, які повторюються, ми можемо скористатися операцією множення рядків на число. При цьому слід не забувати, що ми хочемо виводити кожне \"Няв!\" у новому рядку (за допомогою \\n та end=\"\"). Таким чином, ми можемо переписати наш код наступним чином:\n\nprint(\"Няв!\\n\" * 3, end=\"\")\n\nНяв!\nНяв!\nНяв!\n\n\nДавайте запитаємо користувача, скільки разів цей кіт має нявкнути. Але в цьому випадку слід врахувати, що користувач має вказати позитивне число. Якщо користувач введе неправильне значення, ми маємо попросити його ввести число ще раз. Для цього ми можемо скористатися циклом while True, який буде виконуватися доти, доки не буде введено коректне значення. Таким чином, ми можемо переписати наш код наступним чином:\n\nwhile True:\n    n = int(input(\"Скільки разів кіт має нявкнути? \")) # 3\n        if n &gt; 0:\n            break\n\nfor _ in range(n):\n    print(\"Няв!\")\n\n\n\nНяв!\nНяв!\nНяв!\n\n\nЦикл while буде виконуватися доти, доки не буде введено коректне значення. Якщо користувач введе число, яке менше або дорівнює нулю, то цикл while буде виконуватися знову і знову. Якщо користувач введе коректне значення, то цикл while буде припинено за допомогою інструкції break і виконано цикл for.\nДавайте ще трошки попрактикуємо писати власні функції. Напишемо функцію cat(), яка буде нявкати задану кількість разів. Для цього нам потрібно передати цю кількість як аргумент функції. Таким чином, ми можемо переписати наш код наступним чином:\n\ndef main():\n    number = get_number()\n    cat(number)\n\ndef get_number():\n    while True:\n        n = int(input(\"Скільки разів кіт має нявкнути? \"))\n        if n &gt; 0:\n            break\n    return n\n\ndef cat(n):\n    for _ in range(n):\n        print(\"Няв!\")\n\nmain()\n\n\n3.2.1 Індексація списків\nПотренуємося працювати з індексами списків. До будь-якого елемента списку можна звернутися за його індексом. Запам’ятайте, що індексація починається з нуля.\n\nfruits = ['apple', 'banana', 'orange']\nprint(fruits[0])\n\napple\n\n\nТакож ми можемо робити зрізи:\n\nfruits = ['apple', 'banana', 'orange']\nprint(fruits[0:2])\n\n['apple', 'banana']\n\n\nДавайте створимо файл hogwarts.py в якому створимо список учнів Гоґвортсу:\n\n\nTerminal\n\ncode hogwarts.py\n\nЗмінну назвемо students і помістимо у неї список із трьох учнів:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nЯк мені роздрукувати список студентів? Для цього я можу скористатися індексом, який вказує на позицію елемента у списку за допомогою квадратних [] дужок після назви змінної. Індекси у списку починаються з нуля. Таким чином, якщо я хочу вивести першого студента, я можу використати індекс 0:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nprint(students[0])\n\nГаррі Поттер\n\nprint(students[1])\n\nГерміона Грейнджер\n\nprint(students[2])\n\nРон Уізлі\n\n\nАле ж має бути кращий спосіб, чи не так? Особливо, якщо я не знаю заздалегідь, хто буде в цьому списку. Якщо наступного року в Гоґвортсі з’являться нові учні, ми можемо використати цикл for для того, щоб вивести їх імена:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor student in students:\n    print(student)\n\nГаррі Поттер\nГерміона Грейнджер\nРон Уізлі\n\n\nДозвольте продемонструвати альтернативний варіант вирішення цієї задачі. Ми можемо використати комбінацію функції range() для визначення діапазону та функції len() для того, щоб отримати довжину списку. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor i in range(len(students)):\n    print(students[i])\n\nГаррі Поттер\nГерміона Грейнджер\nРон Уізлі\n\n\nА що, якщо я хочу крім імені студента вивести його номер у списку? Для цього я можу скористатися функцією enumerate(), яка дозволяє мені отримати індекс елемента у списку. Таким чином, я можу переписати наш код наступним чином:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor i, student in enumerate(students):\n    print(f\"{i + 1}: {student}\")\n\n1: Гаррі Поттер\n2: Герміона Грейнджер\n3: Рон Уізлі\n\n\n\n3.2.2 Методи списків\nПогляньмо на всі методи списку. Не треба заучувати їх напам’ять. Але якщо ви зіткнетеся із завданням, в якому треба буде щось зробити зі списком, то перед тим, як намагатися самому придумати рішення, подивіться, може бути потрібний метод.\n\n\nappend() - додає елемент у кінець списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.append('melon')\nprint(fruits)\n\n['apple', 'banana', 'orange', 'melon']\n\n\n\n\nclear() - видаляє всі елементи списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.clear()\nprint(fruits)\n\n[]\n\n\n\n\ncopy() - повертає копію списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits_copy = fruits.copy()\nprint(fruits_copy)\n\n['apple', 'banana', 'orange']\n\n\n\n\ncount(item) - повертає кількість елементів із заданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange', 'banana']\nprint(fruits.count('banana'))\n\n2\n\n\n\n\nextend(iterable) - додає елементи іншого списку до поточного. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.extend(['melon', 'watermelon'])\nprint(fruits)\n\n['apple', 'banana', 'orange', 'melon', 'watermelon']\n\n\n\n\nindex(item, start, end) - повертає індекс першого елемента, який збігається із заданим значенням (item) у діапазоні індексів від start до end. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange', 'banana']\nprint(fruits.index('banana'))\n\n1\n\n\n\n\ninsert(index, item) - додає елемент item на позицію index. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.insert(1, 'melon')\nprint(fruits)\n\n['apple', 'melon', 'banana', 'orange']\n\n\n\n\npop(index) - видаляє та повертає елемент із заданим індексом. Якщо індекс не вказано, видаляє та повертає останній елемент списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop(1)\nprint(removed_fruit)\n\nbanana\n\n\n\n\nremove(item) - видаляє перший елемент із заданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.remove('banana')\nprint(fruits)\n\n['apple', 'orange']\n\n\n\n\nreverse() - змінює порядок елементів у списку на зворотній. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.reverse()\nprint(fruits)\n\n['orange', 'banana', 'apple']\n\n\n\n\nsort(key, reverse) - сортує елементи списку. Наприклад:\n\n\nfruits = ['banana', 'orange', 'apple']\nfruits.sort()\nprint(fruits)\n\n['apple', 'banana', 'orange']",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_loops.html#словники",
    "href": "python_loops.html#словники",
    "title": "\n3  Цикли\n",
    "section": "\n3.3 Словники",
    "text": "3.3 Словники\nРозглянемо ще один тип структури даних в Python - словники dict. Словники в Python створюються за допомогою фігурних дужок {} і містять пари ключ-значення. Ключі у словниках мають бути унікальними, тобто не можуть повторюватися. Значення у словниках можуть бути будь-якого типу, в тому числі інші словники.\nПрипустимо, що ми хочемо відстежувати, хто до якого гуртожитку відноситься в Гоґвортсі. Для прикладу візьмемо чотирьох учнів:\n\n\n\n\n\n\n\n\nГерміона Грейнджер\nГаррі Поттер\nРон Уізлі\nДрако Малфой\n\n\nҐрифіндор\nҐрифіндор\nҐрифіндор\nСлизерин\n\n\nТож давайте додамо ще один створимо словник students:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nТепер давайте виведемо на екран ім’я та гуртожиток кожного учня. Для цього ми можемо скористатися циклом for. Але якщо ми спробуємо використати цикл for таким чином, як ми це робили раніше, то ми отримаємо лише імена учнів:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nfor student in students:\n    print(student)\n\nГерміона Грейнджер\nГаррі Поттер\nРон Уізлі\nДрако Малфой\n\n\nЩоб вивести ім’я та гуртожиток кожного учня, ми можемо скористатися індексацією словника за ключем. Індексація словника за ключем відбувається за допомогою квадратних дужок [] після назви змінної. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nfor student in students:\n    print(f\"{student}: {students[student]}\")\n\nГерміона Грейнджер: Ґрифіндор\nГаррі Поттер: Ґрифіндор\nРон Уізлі: Ґрифіндор\nДрако Малфой: Слизерин\n\n\nДавайте ускладнимо задачу і додамо ще одину характеристику до кожного учня - його Патронуса:\n\n\nІм’я\nГуртожиток\nПатронус\n\n\n\nГерміона Грейнджер\nҐрифіндор\nВидра\n\n\nГаррі Поттер\nҐрифіндор\nОлень\n\n\nРон Уізлі\nҐрифіндор\nТер’єр\n\n\nДрако Малфой\nСлизерин\n\n\n\n\nДля цього ми можемо використати список, який містить словники. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = [\n    {\n        \"ім'я\": \"Герміона Грейнджер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    {\n        \"ім'я\": \"Гаррі Поттер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    {\n        \"ім'я\": \"Рон Уізлі\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    {\n        \"ім'я\": \"Драко Малфой\",\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n]\n\nЗверніть увагу, що згідно канонічного варіанту Драко Малфой не має Патронуса. Тому ми вказали його значення як None - це спеціальне значення, яке означає “нічого”.\nДля виводу інформації про учнів ми можемо скористатися циклом for:\n\nstudents = [\n    {\n        \"ім'я\": \"Герміона Грейнджер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    {\n        \"ім'я\": \"Гаррі Поттер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    {\n        \"ім'я\": \"Рон Уізлі\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    {\n        \"ім'я\": \"Драко Малфой\",\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n]\n\nfor student in students:\n    print(student[\"ім'я\"], student[\"гуртожиток\"], student[\"патронус\"], sep=\", \")\n\nГерміона Грейнджер, Ґрифіндор, Видра\nГаррі Поттер, Ґрифіндор, Олень\nРон Уізлі, Ґрифіндор, Тер'єр\nДрако Малфой, Слизерин, None\n\n\nАльтернативний варіант створення словника students - це використання вкладених словників:\n\nstudents = {\n    \"Герміона Грейнджер\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    \"Гаррі Поттер\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    \"Рон Уізлі\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    \"Драко Малфой\": {\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n}\n\nfor student in students:\n    print(student, students[student][\"гуртожиток\"], students[student][\"патронус\"], sep=\", \")\n\nГерміона Грейнджер, Ґрифіндор, Видра\nГаррі Поттер, Ґрифіндор, Олень\nРон Уізлі, Ґрифіндор, Тер'єр\nДрако Малфой, Слизерин, None\n\n\n\n3.3.1 Створення словника\nУ Python є кілька способів створення словників. Ось деякі з них:\n\nЛітерали словника\n\nЛітерали словника являють собою список ключів і значень, укладених у фігурні дужки. Ключ і значення розділяються двокрапкою, а пари ключ-значення розділяються комою. Наприклад:\n\nmy_dict = {'ім\\'я': 'Аліса', 'вік': 25, 'місто': 'Київ'}\nprint(my_dict)\n\n{\"ім'я\": 'Аліса', 'вік': 25, 'місто': 'Київ'}\n\n\n\nВбудована функція dict()\n\nФункцію dict() можна використовувати для створення словників з інших послідовностей або для створення порожнього словника. Наприклад:\n\nempty_dict = dict()\nprint(empty_dict)\n\n{}\n\n\n\nfruit_dict = dict([('яблуко', 5), ('банан', 3), ('апельсин', 2)])\nprint(fruit_dict)\n\n{'яблуко': 5, 'банан': 3, 'апельсин': 2}\n\n\n\nГенератор словників\n\nГенератори словників дозволяють створювати словники на основі інших послідовностей. Наприклад:\n\nfruit_list = ['яблуко', 'банан', 'апельсин']\nfruit_dict = {fruit: len(fruit) for fruit in fruit_list}\nprint(fruit_dict)\n\n{'яблуко': 6, 'банан': 5, 'апельсин': 8}\n\n\n\nМетод fromkeys()\n\nМетод fromkeys() дає змогу створити словник із зазначеними ключами й одним і тим самим значенням для всіх ключів. Наприклад:\n\nfruit_list = ['яблуко', 'банан', 'апельсин']\nfruit_dict = {}.fromkeys(fruit_list, 0)\nprint(fruit_dict)\n\n{'яблуко': 0, 'банан': 0, 'апельсин': 0}\n\n\nПам’ятаєте, ми з вами говорили про frozenset (див. 10.0.2)? Одна з його корисних особливостей - frozenset можна використовувати як ключ словника. Припустимо, ми хочемо як ключ, зберігати одразу кілька значень - ім’я користувача і його вік.\n\nstudents_courses = {}\nname_age = frozenset(['Anatoly', 32])\nstudents_courses.update({name_age: ['Python', 'C++']})\nprint(students_courses)\n\n{frozenset({32, 'Anatoly'}): ['Python', 'C++']}\n\n\nЦе один із прикладів практичного застосування frozenset, якщо ми хочемо створити словник, де сам ключ - це масив із кількох елементів, то frozenset зможе нам допомогти. Список або звичайний set використовувати як ключ для словника не вийде.\nЦе лише деякі зі способів створення словників у Python. Кожен із них має свої особливості та може використовуватися залежно від конкретного завдання.\n\n3.3.2 Основні методи словників\n\n\nget() - дає змогу отримати значення за ключем, але на відміну від звернення через [], не викликає виняток KeyError, якщо ключ відсутній у словнику. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.get(\"two\"))\n\n2\n\nprint(my_dict.get(\"four\", \"Key not found\"))\n\nKey not found\n\n\n\n\nkeys() - дає змогу отримати список ключів словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.keys())\n\ndict_keys(['one', 'two', 'three'])\n\n\n\n\nvalues() - дає змогу отримати список значень словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.values())\n\ndict_values([1, 2, 3])\n\n\n\n\nitems() - дає змогу отримати список пар ключ-значення словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.items())\n\ndict_items([('one', 1), ('two', 2), ('three', 3)])\n\n\n\n\npop() - дає змогу видалити пару ключ-значення за ключем. Якщо ключ відсутній, викликає виняток KeyError або повертає другий аргумент, якщо він переданий. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.pop(\"two\"))\n\n2\n\nprint(my_dict.pop(\"four\", \"Key not found\"))\n\nKey not found\n\n\n\n\nclear() - дає змогу видалити всі пари ключ-значення зі словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nmy_dict.clear()\nprint(my_dict)\n\n{}\n\n\n\n\nupdate() - дає змогу оновити словник із іншого словника або із послідовності пар ключ-значення. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nnew_dict = {\"two\": 22, \"four\": 4}\nmy_dict.update(new_dict)\nprint(my_dict)\n\n{'one': 1, 'two': 22, 'three': 3, 'four': 4}\n\n\n\n\ncopy() - дає змогу створити копію словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nnew_dict = my_dict.copy()\nprint(new_dict)\n\n{'one': 1, 'two': 2, 'three': 3}\n\n\n\n\nsetdefault() - повертає значення за ключем. Якщо ключ відсутній, то він буде вставлений у словник із зазначеним значенням (або None, якщо значення не вказано). Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.setdefault(\"two\", 22))\n\n2\n\nprint(my_dict.setdefault(\"four\"))\n\nNone\n\nprint(my_dict)\n\n{'one': 1, 'two': 2, 'three': 3, 'four': None}\n\n\n\n3.3.3 pop() vs. remove()\n\nДавайте знову зупинимося на різниці цих методів. Методи pop() і remove() застосовуються для видалення елементів зі списків Python.\n\nМетод pop() видаляє та повертає останній елемент зі списку. Якщо в дужках вказати індекс елемента, буде видалено елемент із зазначеним індексом. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop()\nprint(fruits)\n\n['apple', 'banana']\n\n\n\nprint(removed_fruit)\n\norange\n\n\nА якщо ми хочемо видалити елемент за індексом, то потрібно вказати індекс у дужках методу:\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop(1)\nprint(fruits)\n\n['apple', 'orange']\n\n\n\nprint(removed_fruit)\n\nbanana\n\n\n\nМетод remove() видаляє перший елемент зі списку, який збігається з переданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.remove('banana')\nprint(fruits)\n\n['apple', 'orange']\n\n\nВажливо, що якщо у списку не буде елемента із зазначеним індексом або значенням, методи pop() та remove() повернуть помилки. Таким чином, основна відмінність між методами pop() і remove() полягає в тому, що pop() видаляє елемент за індексом, повертаючи його значення, а remove() видаляє перший знайдений елемент із заданим значенням.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_loops.html#цикли-та-маріо",
    "href": "python_loops.html#цикли-та-маріо",
    "title": "\n3  Цикли\n",
    "section": "\n3.4 Цикли та Маріо",
    "text": "3.4 Цикли та Маріо\nОдна з найпопулярніших ігор минулого століття - це Super Mario Bros. Це двовимірний світ, де персонажі рухаються вгору, вниз і вправо, не так часто вліво, перестрибуючи через піраміди і перешкоди на кшталт цих:\n\n\n\n\nДавайте просто реалізуємо дуже просту версію цих перешкод за допомогою Python, використовуючи просто # для позначення цеглинок.\nСтворимо програму mario.py:\n\n\nTerminal\n\ncode mario.py\n\nПочнемо з максимально простої версії, де ми просто виведемо на екран один стовпчик з трьох цеглинок:\n\nprint(\"#\")\n\n#\n\nprint(\"#\")\n\n#\n\nprint(\"#\")\n\n#\n\n\nАле ви можете собі уявити, що в грі стовпчики можуть ставати вищими або нижчими, тож було б непогано написати код, який був би трохи динамічнішим:\n\nfor _ in range(3):\n    print(\"#\")\n\n#\n#\n#\n\n\nДавайте подивимося, чи можемо ми зараз об’єднати наші знання написання власних функцій, щоб почати писати щось більш динамічне і вирішувати більш складні проблеми. Однією з приємних речей у функціях є те, що вони дозволяють нам не просто писати код, який ми можемо повторно використовувати. Вони дозволяють нам створювати абстракції, якщо хочете. Абстракція - це спрощення потенційно більш складної ідеї.\nПрипустимо, що я додумався створити функцію з назвою print_сolumn(), яка приймає один аргумент height - висота блоку, яка має бути надрукована. Таким чином, я можу переписати наш код наступним чином:\n\ndef main():\n    print_column(3)\n\ndef print_column(height):\n    for _ in range(height):\n        print(\"#\")\n\nmain()\n\n#\n#\n#\n\n\nАбо без використання циклу for:\n\ndef main():\n    print_column(3)\n\ndef print_column(height):\n    print(\"#\\n\" * height, end=\"\")\n\nmain()\n\n#\n#\n#\n\n\nУ певний момент Маріо зустрічає в небі нові цеглинки, які, якщо він підстрибне під ними, перетворяться на монети:\n\n\n\n\nДавайте спробуємо вивести ці чотири блоки у вигляді знаків питання ?. Створимо функцію print_row() з аргументом width - ширина. Таким чином, ми можемо переписати наш код наступним чином:\n\ndef main():\n    print_row(4)\n\ndef print_row(width):\n    print(\"?\" * width)\n\nmain()\n\n????\n\n\nПізніше Маріо спускається вниз, у світ лабіринтів з новими блоками, наприклад 3 на 3:\n\n\n\n\nСпробуємо відтворити цей блок за допомогою функції print_square() з аргументом size - розмір. Таким чином, ми можемо переписати наш код наступним чином:\n\ndef main():\n    print_square(3)\n\ndef print_square(size):\n    for i in range(size):\n        for j in range(size):\n            print(\"#\", end=\"\")\n        print()\n\nmain()\n\n###\n###\n###\n\n\nУ цьому коді ми використовуємо вкладені цикли for. Перший цикл for відповідає за виведення рядків, а другий цикл for відповідає за виведення стовпчиків. Таким чином, ми можемо вивести блоки, які складаються з рядків і стовпчиків.\nЯк ми можемо покращити код? Для початку ми можемо позбутися вкладеного циклу і замінити його просто функцією print():\n\ndef main():\n    print_square(3)\n\ndef print_square(size):\n    for i in range(size):\n        print(\"#\" * size)\n\nmain()\n\n###\n###\n###",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_loops.html#list-comprehension",
    "href": "python_loops.html#list-comprehension",
    "title": "\n3  Цикли\n",
    "section": "\n3.5 List comprehension",
    "text": "3.5 List comprehension\nList comprehension в Python - це компактний спосіб створення нового списку на основі наявного списку або іншої ітерованої послідовності, наприклад, рядка. Він дає змогу більш елегантно і стисло написати код, роблячи його більш читабельним і ефективним.\nЗагальний синтаксис для створення list comprehension виглядає наступним чином:\n```{python}\nnew_list = [expression for item in iterable if condition]\n```\nде:\n\n\nexpression - вираз, який застосовуватиметься до кожного елемента списку або послідовності\n\nitem - змінна, що представляє поточний елемент послідовності, що ітерується;\n\niterable - список або інша послідовність, що ітерується;\n\ncondition (необов’язково) - умова, за якою буде фільтруватися вихідна послідовність.\n\nНижче наведено кілька прикладів для кращого розуміння:\n\nПрипустимо, у нас є список із числами, ми хочемо створити новий список із квадратами цих чисел. Варіант рішення:\n\n\nnumbers = [1, 2, 3, 4, 5]\nsquares = []\nfor i in numbers:\n    squares.append(i**2)\n\nprint(squares)\n\n[1, 4, 9, 16, 25]\n\n\nА ось так виглядало б рішення за допомогою list comprehension:\n\nnumbers = [1, 2, 3, 4, 5]\nsquares = [x ** 2 for x in numbers]\n\nprint(squares)\n\n[1, 4, 9, 16, 25]\n\n\nІнакше кажучи, результат роботи нашого циклу відразу поміщається в список.\n\nСтворення нового списку, що містить тільки парні числа з вихідного списку:\n\nСтандартний розв’язок:\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = []\nfor i in numbers:\n    if i % 2 == 0:\n        even_numbers.append(i)\n\nprint(even_numbers)\n\n[2, 4]\n\n\nList comprehension:\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = [x for x in numbers if x % 2 == 0]\n\nprint(even_numbers)\n\n[2, 4]\n\n\n\nСтворення нового списку, що містить довжини слів із вихідного списку:\n\n\nwords = [\"hello\", \"world\", \"python\", \"list\"]\nword_lengths = [len(word) for word in words]\n\nprint(word_lengths)\n\n[5, 5, 6, 4]",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_loops.html#функція-enumerate",
    "href": "python_loops.html#функція-enumerate",
    "title": "\n3  Цикли\n",
    "section": "\n3.6 Функція enumerate\n",
    "text": "3.6 Функція enumerate\n\nФункція enumerate() у Python використовується для додавання індексів до елементів послідовності (наприклад, списку або рядка) під час ітерації по цій послідовності. Вона повертає об’єкт-лічильник, який містить пари (індекс, елемент).\nПрипустимо, у нас є список замовлень, кожне з яких представлено у вигляді словника з різними властивостями, такими як \"номер\", \"клієнт\", \"дата\" тощо. Наше завдання - вивести на екран інформацію за кожним замовленням, а також додати порядкові номери до кожної властивості цього замовлення.\n\norders = [\n    {\"номер\": \"001\", \"клієнт\": \"John\", \"дата\": \"2022-01-01\", \"статус\": \"в обробці\"},\n    {\"номер\": \"002\", \"клієнт\": \"Alice\", \"дата\": \"2022-01-02\", \"статус\": \"виконано\"},\n    {\"номер\": \"003\", \"клієнт\": \"Bob\", \"дата\": \"2022-01-03\", \"статус\": \"виконано\"},\n    {\"номер\": \"004\", \"клієнт\": \"Eva\", \"дата\": \"2022-01-04\", \"статус\": \"в обробці\"},\n]\nfor index, order in enumerate(orders, start=1):\n    print(f\"Замовлення {index}:\")\n    for key, value in order.items():\n        print(f\"{key}: {value}\")\n    print()\n\nЗамовлення 1:\nномер: 001\nклієнт: John\nдата: 2022-01-01\nстатус: в обробці\n\nЗамовлення 2:\nномер: 002\nклієнт: Alice\nдата: 2022-01-02\nстатус: виконано\n\nЗамовлення 3:\nномер: 003\nклієнт: Bob\nдата: 2022-01-03\nстатус: виконано\n\nЗамовлення 4:\nномер: 004\nклієнт: Eva\nдата: 2022-01-04\nстатус: в обробці\n\n\n\n\n\n\n\n\nУвага\n\n\n\nЗверніть увагу, ми явно вказали, що хочемо почати нумерацію з 1 за допомогою enumerate(orders, start=1). Функція enumerate() допомагає нам додати порядкові номери до кожного замовлення в списку ітерацією по ньому. Це може бути особливо корисно, коли нам потрібно обробляти й аналізувати дані з урахуванням їхніх позицій у структурі даних.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_loops.html#оператори-continue-та-break",
    "href": "python_loops.html#оператори-continue-та-break",
    "title": "\n3  Цикли\n",
    "section": "\n3.7 Оператори continue та break\n",
    "text": "3.7 Оператори continue та break\n\nОператор continue і оператор break є керуючими операторами в циклах, їх використовують для зміни поведінки виконання циклу.\nОператор continue використовується для пропуску частини тіла циклу, що залишилася, і переходу до наступної ітерації циклу. Якщо зустрінеться оператор continue, то код нижче за нього в поточній ітерації циклу не буде виконано, а виконання циклу продовжиться відразу з наступної ітерації.\nПриклад:\n\nfor i in range(1, 6):\n    if i == 3:\n        continue\n    print(i)\n\n1\n2\n4\n5\n\n\nУ цьому прикладі в циклі for ми перебираємо значення від 1 до 5. Якщо значення i дорівнює 3, оператор continue пропустить решту тіла циклу і перейде до наступної ітерації. У результаті у виводі буде пропущено число 3.\nОператор break використовується для переривання виконання циклу. Якщо зустрінеться оператор break, виконання циклу буде припинено і відбувається вихід із циклу.\nПриклад:\n\nfor i in range(1, 6):\n    if i == 3:\n        break\n    print(i)\n\n1\n2\n\n\nУ цьому прикладі в циклі for ми також перебираємо значення від 1 до 5. Однак, якщо значення i дорівнює 3, оператор break перериває виконання циклу. У результаті у виводі будуть тільки числа 1 і 2.\nТаким чином, оператор continue і оператор break дають змогу керувати потоком виконання циклів залежно від заданих умов. Ці оператори можуть бути дуже корисними при розв’язанні різних задач на програмування.\nДавайте розглянемо приклад їхнього спільного використання:\n\nemployees = [\n    {'name': 'John', 'qualification': 'low'},\n    {'name': 'Alice', 'qualification': 'high'},\n    {'name': 'Bob', 'qualification': 'medium'},\n    {'name': 'Eva', 'qualification': 'low'},\n    {'name': 'Mike', 'qualification': 'high'},\n    {'name': 'Lisa', 'qualification': 'medium'}\n]\nfound_high_qualification_employee = False\nfor employee in employees:\n    qualification = employee['qualification']\n    if qualification == 'low':\n        continue # Пропускаємо працівника з низькою кваліфікацією\n    elif qualification == 'high':\n        found_high_qualification_employee = True\n        high_qualification_employee = employee\n        break # Знайдено працівника з високою кваліфікацією, припиняємо пошук\nif found_high_qualification_employee:\n    print(\"Працівника з високою кваліфікацією знайдено!\")\n    print(high_qualification_employee)\nelse:\n    print(\"Працівника з високою кваліфікацією не знайдено.\")\n\nПрацівника з високою кваліфікацією знайдено!\n{'name': 'Alice', 'qualification': 'high'}\n\n\nУ цьому прикладі ми створюємо список employees, який містить дані про працівників. Потім ми проходимося по кожному працівнику в циклі for. Якщо рівень кваліфікації працівника низький (low), ми використовуємо оператор continue для пропуску поточного працівника і переходимо до наступного. Якщо рівень кваліфікації працівника високий (high), ми використовуємо оператор break для переривання циклу і запису інформації про знайденого працівника. Після виконання циклу ми перевіряємо, чи було знайдено працівника з високою кваліфікацією, і виводимо відповідну інформацію.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_loops.html#while-vs.-for",
    "href": "python_loops.html#while-vs.-for",
    "title": "\n3  Цикли\n",
    "section": "\n3.8 WHILE vs. FOR",
    "text": "3.8 WHILE vs. FOR\nwhile і for - це два основні типи циклів у мові програмування Python. Цикл while виконує набір інструкцій доти, доки вказана умова істинна. Наприклад, якщо вам потрібно виконати певну дію доти, доки користувач не введе правильне значення, ви можете використовувати цикл while. Приклад:\n```{python}\nsecret_number = 7\nguess = 0\nwhile guess != secret_number:\n    guess = int(input(\"Вгадайте число від 1 до 10: \"))\nprint(\"Вітаю, ви вгадали число!\")\n```\nЦикл for, з іншого боку, виконує набір інструкцій для кожного елемента в послідовності (наприклад, рядку, списку, кортежі тощо). Приклад:\n\nfruits = [\"яблуко\", \"банан\", \"груша\"]\nfor fruit in fruits:\n    print(fruit)\n\nяблуко\nбанан\nгруша\n\n\nЦикл while зазвичай використовується, коли невідома точна кількість повторень, а ви здебільшого покладаєтеся на перевірку умови для зупинки циклу. З іншого боку, цикл for зазвичай використовується, коли ви заздалегідь знаєте, скільки разів цикл повинен виконатися, і ви хочете працювати з елементами послідовності.\nВибір між циклом while і циклом for залежить від специфіки завдання. Якщо у вас є явно певна кількість елементів або потрібно опрацювати кожен елемент у послідовності, то цикл for може бути більш зручним вибором. Якщо ж ви чекаєте певної події або хочете повторювати дію до виконання певної умови, то цикл while буде більш підходящим.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_loops.html#завдання",
    "href": "python_loops.html#завдання",
    "title": "\n3  Цикли\n",
    "section": "\n3.9 Завдання",
    "text": "3.9 Завдання\n\n\nЗавдання 3.1  У змінних a і b збережено два цілих додатних числа, таких що a &lt;= b. Напишіть програму, яка знаходить суму всіх чисел від a до b, кратних 3 або 5. Збережіть суму у змінну result. Якщо між a і b немає таких чисел, то збережіть у result нуль.\nПриклад:\n```{python}\n# Приклад 1\na = 1\nb = 10\nresult = 33\n\n# Приклад 2\na = 9\nb = 9\nresult = 9\n\n# Приклад 3\na = 1\nb = 2\nresult = 0\n```\n\nРішенняa = 1\nb = 10\n\nresult = 0\nfor i in range(a, b + 1):\n    if i % 3 == 0 or i % 5 == 0:\n        result += i\n\n\n\n\n\n\nЗавдання 3.2  Напишіть програму на Python, яка визначає, чи є задане число num простим.\nЯкщо num - просте число, то збережіть у змінну result рядок \"це просте число\". Якщо число не просте, то збережіть у змінну result рядок \"це не просте число\".\nВикористовуйте цикл для розв’язання цієї задачі.\nПриклад:\n```{python}\n# Приклад 1\nnum = 7\nresult = \"це просте число\"\n\n# Приклад 2\nnum = 8\nresult = \"це не просте число\"\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПросте число - це число, яке ділиться тільки на 1 і на саме себе.\n\n\n\n\nРішенняnum = 7\n\nresult = \"це просте число\"\nfor i in range(2, num):\n    if num % i == 0:\n        result = \"це не просте число\"\n        break\n\n\n\n\n\n\nЗавдання 3.3  У змінній number збережено число, напишіть код, який перевірить, чи є number ступенем двійки? Ряд ступенів двійки:\n1, 2, 4, 8, 16, 32, 64 ...\nРезультат перевірки True або False збережіть у змінну is_two_power.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПросте число - це число, яке ділиться тільки на 1 і на саме себе.\n\n\n\n\nРішенняnumber = 64\n\nif number &lt; 1:\n    is_two_power = False\nelif number == 1:\n    is_two_power = True    \nelse:\n    while number % 2 == 0:\n        number = number / 2\n    is_two_power = number == 1\n\n# або\nis_two_power = False\nfor i in range(1, int(number) + 1):\n    if 2 ** i == number or number == 1:\n        is_two_power = True\n        break\n\n\n\n\n\n\nЗавдання 3.4  Для приготування однієї порції еспресо потрібно приблизно 7 г. меленої кави. Для приготування лате необхідно збити 180 мл. молока і додати до еспресо, а для приготування капучино - 100 мл. молока.\nЗадано дві змінні:\n\n\ncoffee - запас меленої кави в кав’ярні (у кілограмах);\n\nmilk - запас молока в кав’ярні (у літрах).\n\nНапишіть програму, яка порахує, скільки відвідувачів зможе обслужити кав’ярня, якщо відомо, що: 1. У кав’ярні готують три напої на вибір: американо (еспресо + вода), лате і капучино. 2. Кожен відвідувач замовляє тільки один напій. 3. Відомо, що кожен третій замовлений напій - капучино, а кожен п’ятий - лате. 4. Якщо молоко закінчилося, то кав’ярня працює, доки не прийде відвідувач, який бажає замовити каву з молоком. 5. Запас води для американо не обмежений.\nРезультат збережіть у змінну visitors.\nНе забудьте перевести кілограми в грами, а літри - в мілілітри.\nПриклад:\n```{python}\n# Приклад 1\ncoffee = 0.1\nmilk = 1\nvisitors = 14\n\n# Приклад 2\ncoffee = 0.07\nmilk = 0.1\nvisitors = 4\n```\n\nРішенняcoffee = 1\nmilk = 2\n\ncoffee *= 1000\nmilk *= 1000\nvisitors = 0\nwhile coffee &gt;=7:\n    if (visitors+1) % 3 == 0:\n        if milk &gt;=100:\n            milk -= 100\n            coffee -= 7\n            visitors += 1\n        else:\n            break\n    elif (visitors+1) % 5 == 0:\n        if milk &gt;= 180:\n            milk -= 180\n            coffee -= 7\n            visitors += 1\n        else:\n            break\n    else:\n        coffee -= 7\n        visitors += 1\n\n# або\ncoffee *= 1000\nmilk *= 1000\nvisitors = 0\nwhile True:\n    if coffee &lt; 7 or ((visitors + 1) % 3 == 0 and milk &lt; 100) or ((visitors + 1) % 5 == 0 and milk &lt; 180):\n        break\n    visitors += 1\n    coffee -= 7\n    if visitors % 3 == 0 :\n        milk -= 100\n    elif visitors % 5 == 0:\n        milk -= 180\n\n\n\n\n\n\nЗавдання 3.5  Дано список чисел a. Напишіть програму, яка поверне True, якщо у списку більше непарних чисел, і False - у всіх інших випадках. Результат збережіть у result.\nПриклад:\n```{python}\n# Приклад 1\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nresult = True\n\n# Приклад 2\na = [1, 2, 3, 4, 5, 6, 7, 8, 10]\nresult = False\n\n# Приклад 3\na = [1, 2, 3, 4]\nresult = False\n```\n\nРішенняa = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\ncount_odd = 0\ncount_even = 0\nfor i in a:\n    if i % 2 == 0:\n        count_even += 1\n    else:\n        count_odd += 1\n\nresult = count_odd &gt; count_even\n\n# або\nresult = sum(1 if int(i) % 2 else -1 for i in a) &gt; 0\n\n\n\n\n\n\nЗавдання 3.6  Є словник grades, що містить інформацію про шкільні предмети та їхні оцінки. У список good_subjects збережіть назви всіх предметів, у яких оцінка більша або дорівнює 7.\nПриклад:\n```{python}\ngrades = {\"Математика\": 9, \"Історія\": 6, \"Біологія\": 6, \"Географія\": 8}\ngood_subjects = [\"Математика\", \"Географія\"]\n\ngrades = {\"Алгебра\": 6, \"Геометрія\": 6}\ngood_subjects = []\n```\n\nРішенняgrades = {\"Математика\": 9, \"Історія\": 6, \"Біологія\": 6, \"Географія\": 8}\n\ngood_subjects = []\nfor subject, grade in grades.items():\n    if grade &gt;= 7:\n        good_subjects.append(subject)        \n\n\n\n\n\n\nЗавдання 3.7  Напишіть програму, яка прийматиме список чисел nums і повертатиме два числа, абсолютна різниця яких мінімальна. Пару чисел збережіть у змінну result у вигляді списку, відсортованого за зростанням.\nЯкщо кілька пар дають мінімальну абсолютну різницю, виберіть ту пару елементів, сума яких більша.\nПриклад:\n```{python}\n# Приклад 1\nnums = [40, 16, 8, 17, 15]\nresult = [16, 17]\n# пара 16 і 15 не підходить, оскільки сума 16 і 17 більша за\n\n# Приклад 2\nnums = [0, 2, 35, 42, 45, 14, -6, -1]\nresult = [-1, 0]\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\n\nСтворіть змінну min_diff і збережіть у неї позитивну нескінченність. Це буде змінна зі значенням мінімальної абсолютної різниці. Далі почніть рахувати абсолютну різницю між числами в списку, на кожній ітерації перевіряйте, чи менша поточна різниця, ніж значення у змінній min_diff, якщо це так, то зберігайте в min_diff поточне значення і продовжуйте пошуки.\nЗапис нескінченності у Python: float(\"inf\") або float(\"-inf\").\n\n\n\n\n\nРішенняnums = [40, 16, 8, 17, 15]\n\nmin_diff = float(\"inf\")\nresult = []\nfor i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n        diff = abs(nums[i] - nums[j])\n        if diff &lt; min_diff:\n            min_diff = diff\n            result = [nums[i], nums[j]]\n        elif diff == min_diff:\n            if sum(result) &lt; nums[i] + nums[j]:\n                result = [nums[i], nums[j]]\n\n# або\nnums.sort() \nmin_diff = float('inf')  \nresult = []\nfor i in range(len(nums) - 1):\n    diff = abs(nums[i] - nums[i+1])  \n    if diff &lt; min_diff:\n        min_diff = diff\n        result = [nums[i], nums[i+1]]\n    elif diff == min_diff and sum([nums[i], nums[i+1]]) &gt; sum(result):\n        result = [nums[i], nums[i+1]]\n\n\n\n\n\n\nЗавдання 3.8  Напишіть програму, що приймає у вигляді аргументів два списки lst_1 і lst_2 і визначає, чи є вони протилежними один одному. Результат перевірки збережіть у result у форматі True або False.\nКожна пара списків складатиметься з однакових елементів (типу a і b). Список вважається анти-списком, якщо всі елементи в ньому протилежні відповідним елементам у першому списку.\nПриклад:\n```{python}\nlst_1 = [\"1\", \"0\", \"0\", \"1\"]\nlst_2 = [\"0\", \"1\", \"1\", \"0\"]\nresult = True\n\nlst_1 = [\"1\", \"0\", \"0\", \"1\"]\nlst_2 = [\"0\", \"1\", \"1\", \"1\"]\nresult = False\n```\n\nРішенняlst_1 = [\"1\", \"0\", \"0\", \"1\"]\nlst_2 = [\"0\", \"1\", \"1\", \"0\"]\n\nresult = True\nfor i in range(len(lst_1)):\n    if lst_1[i] == lst_2[i]:\n        result = False\n        break\n\n# або\nresult = all({a, b} == set(lst_1) for a, b in zip(lst_1, lst_2))\n\n\n\n\n\n\nЗавдання 3.9  Задано змінну m - список зі списків однакової довжини. Перевірте, що суми елементів на діагоналях рівні.\nРезультат перевірки збережіть у result у форматі True або False.\nПриклад:\n```{python}\n# Приклад 1\nm = [[1, 23, 4], \n     [3, 2, 1],\n     [6, 3, 4]]\nresult = False\n\n# Приклад 2\nm = [[1, 23, 4], \n     [3, 2, 1],\n     [1, 3, 4]]\nresult = True\n```\n\nРішенняm = [[1, 23, 4], \n     [3, 2, 1],\n     [6, 3, 4]]\n\nn = len(m)\nmain_diagonal_sum = sum(m[i][i] for i in range(n))\nsecondary_diagonal_sum = sum(m[i][n-i-1] for i in range(n))\nresult = main_diagonal_sum == secondary_diagonal_sum\n\n# або\n\nresult = sum([m[i][i] for i in range(len(m))]) == sum([m[i][len(m[i]) - i - 1] for i in range(len(m))])\n\n\n\n\n\n\nЗавдання 3.10  Напишіть програму, яка приймає словник input_dict і повертає рядок вигляду: ключ=значення&ключ=значення\nРядок має бути лексикографічно відсортований за ключами вихідного словника. Збережіть отриману відповідь у result.\nПриклад:\n```{python}\ninput_dict = {'lesson': 2, 'task': 21, 'course': 'python'}\nresult = 'course=python&lesson=2&task=21'\n```\n\nРішенняinput_dict = {'lesson': 2, 'task': 21, 'course': 'python'}\n\nresult = '&'.join([f'{key}={value}' for key, value in sorted(input_dict.items())])\n\n\n\n\n\n\nЗавдання 3.11  Напишіть програму, яка приймає один рядок input_str і повертає інший result, у якому кожна буква вихідного рядка повторюється двічі.\nПриклад:\n```{python}\ninput_str = \"String\"\nresult = \"SSttrriinngg\"\n```\n\nРішенняinput_str = \"String\"\n\nresult = ''.join([char * 2 for char in input_str])\n\n\n\n\n\n\nЗавдання 3.12  Напишіть програму, яка прийматиме число n і перевірятиме, чи кратна кожна його цифра цифрі, що стоїть ліворуч від неї. Відповідь збережіть у result у вигляді масиву булевих значень результатів перевірок.\nresult завжди має починатися з False, оскільки ліворуч від першої цифри нічого немає.\nПриклад:\n```{python}\nn = 54412\nresult = [False, False, True, False, True]\n```\n\nРішенняn_str = str(n)\nresult = [False]\nfor i in range(1,len(n_str)):\n    if int(n_str[i-1]) == 0 or int(n_str[i]) % int(n_str[i-1]) != 0:\n        result.append(False)\n    else:\n        result.append(True)\n\n\n\n\n\n\nЗавдання 3.13  Уявімо, що ми організовуємо іспит, у нас є список студентів, які мають виступити з усною доповіддю. Для виступу відбираються тільки ті студенти, які набрали понад 90 балів за письмову роботу. Наше завдання зробити так, щоб студенти виступали по черзі, відсортовані за прізвищем.\nНаприклад, якщо в нас є учасники Бабак, Андющенко, Власенко, то виступати вони мають у такому порядку: Андющенко, Бабак, Власенко.\nУ словнику students збережено дані про студентів, ключ - прізвище, значення - кількість балів за іспит, створіть список students_order, у якому кожен елемент - це кортеж (tuple) з номером виступу студента та його прізвищем. У students_order мають бути тільки ті студенти, у яких понад 90 балів. Порядок визначається сортуванням за прізвищем.\nПриклад:\n```{python}\nstudents = {'Бабак': 80, 'Андющенко': 99, 'Власенко': 100}\nstudents_order = [(1, 'Андющенко'), (2, 'Власенко')]\n```\n\nРішенняstudents = {'Бабак': 80, 'Андющенко': 99, 'Власенко': 100}\n\nstudents_order = [name for name in sorted(students.keys()) if students[name] &gt; 90]\nstudents_order = list(enumerate(students_order, 1))\n\n\n\n\n\n\nЗавдання 3.14  Давайте навчимося розгадувати таємні шифри! У my_string зберігається зашифрований рядок, наприклад:\n```{python}\nmy_string = 'qircxfcgwxeciscwgwvzlfrciclibecpfvqzg'\n```\nУ словнику secret_dict зберігається ключ до шифру, набір символів, які потрібно замінити:\n```{python}\nsecret_dict = {\n 'b': 'k',\n 'c': ' ',\n 'g': 'n',\n 'q': 'h',\n 'z': 'o',\n 'v': 't',\n 'w': 'a',\n 'f': 'y',\n 'x': 'm',\n 'r': ','}\n```\nТаким чином, словник secret_dict каже нам, що в рядку my_string літеру “b” потрібно замінити на “k”, “c” на “пробіл” тощо. Якщо ми зробимо такі заміни в рядку my_string, то 'qircxfcgwxeciscwggwwvzlfrciclibecpfvvqzg' перетвориться на 'hi, my name is anatoly, i like python'.\nНапишіть програму, яка розшифровує рядок my_string за допомогою словника secret_dict. Розшифрований рядок збережіть у змінну decrypted_string.\nПриклад:\n```{python}\nmy_string = 'zis jqd qbdx qjjgsd bcd zjm fbc bvbx'\nsecret_dict = {\n'v': 'w',\n'x': 'y',\n'i': 'h',\n'q': 'l',\n'c': 'n',\n'b': 'a',\n'f': 'r',\n'j': 'o',\n's': 'e',\n'z': 't',\n'g': 'k'}\n\ndecrypted_string = 'the old lady looked and tom ran away'\n```\n\nРішенняmy_string = 'zis jqd qbdx qjjgsd bcd zjm fbc bvbx'\nsecret_dict = {\n'v': 'w',\n'x': 'y',\n'i': 'h',\n'q': 'l',\n'c': 'n',\n'b': 'a',\n'f': 'r',\n'j': 'o',\n's': 'e',\n'z': 't',\n'g': 'k'}\n\ndecrypted_string = ''\nfor letter in my_string:\n    if letter in secret_dict:\n        decrypted_string += secret_dict[letter]\n    else:\n        decrypted_string += letter\n\n\n\n\n\n\nЗавдання 3.15  У змінну cities_population збережіть словник із трьома ключами: 'Київ', 'Париж', 'Токіо'. Як значення збережіть населення цих міст у млн. осіб: 2.88, 2.16, 13.96. Ключами нашого словника будуть рядки, значеннями - числа у форматі float.\n\nРішенняcities_population = {\n    'Київ': 2.88,\n    'Париж': 2.16,\n    'Токіо': 13.96\n}\n\n\n\n\n\n\nЗавдання 3.16  Дано словник dict_input. Поміняйте ключі та значення місцями. Результат збережіть у result.\nПриклад:\n```{python}\ndict_input = {\"1\": 11, \"2\": 22, \"3\": 33}\nresult = {11: \"1\", 22:\"2\", 33:\"3\"}\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nВаріантів рішення може бути декілька. Згадайте про методи словників, які ви вивчили у цьому уроці. Також згадайте про функцію zip(), яка дозволяє об’єднати дві послідовності у послідовність пар див. 10.4. Або використайте генератор словників.\n\n\n\n\nРішенняdict_input = {\"1\": 11, \"2\": 22, \"3\": 33}\nresult = dict(zip(dict_input.values(), dict_input.keys()))\nresult = {value: key for key, value in dict_input.items()}\n\n\n\n\n\n\nЗавдання 3.17  Катя - власник невеликого кондитерського виробництва, на якому виготовляють еклери. У нас є словник data, у якому міститься інформація про собівартість одиниці товару cost_price, ціну продажу sell_price та кількість товару eclairs. Потрібно порахувати, який прибуток Катя отримує після продажу своєї продукції. Результат збережіть у змінну result, округливши суму до цілого числа.\nПриклад:\n```{python}\ndata = {\n  \"cost_price\": 225.89,\n  \"sell_price\": 550.00,\n  \"eclairs\": 100\n}\nresult = 32411\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПрибуток = продажна ціна - собівартість\n\n\n\n\nРішенняdata = {\n  \"cost_price\": 225.89,\n  \"sell_price\": 550.00,\n  \"eclairs\": 100\n}\n\nresult = round((data[\"sell_price\"] - data[\"cost_price\"]) * data[\"eclairs\"])\n\n\n\n\n\n\nЗавдання 3.18  Є словник student, у якому зберігаються ім’я студента і список його оцінок. У result збережіть словник з ім’ям студента та найвищою його оцінкою.\nПриклад:\n```{python}\nstudent = {\"name\": \"Ihor\", \"notes\": [4, 5, 4]}\nresult = {\"name\": \"Ihor\", \"max_note\": 5}\n```\n\nРішенняstudent = {\"name\": \"Ihor\", \"notes\": [4, 5, 4]}\nresult = {\"name\": student[\"name\"], \"max_note\": max(student[\"notes\"])}\n\n\n\n\n\n\nЗавдання 3.19  Антон навчається на Data Scientist. У словнику anton_courses зберігається інформація про завершені ним курси та кількість набраних балів. Дані в словнику зберігаються у форматі ключ - назва курсу, значення - кількість балів у числовому форматі. Антон завершив навчання на курсі Machine Learning і набрав 120 балів. Додайте до словника anton_courses цю інформацію. У змінну courses збережіть список пройдених курсів. У змінну DataAnalyst збережіть кількість балів, набрану Антоном на однойменному курсі, ця інформація є в словнику.\nПриклад:\n```{python}\nanton_courses = {'Python for Data Science': 56, \n                 'Statistics': 87, \n                 'Data Analyst': 140}\n# -&gt; \nanton_courses = {'Python for Data Science': 56, \n                 'Statistics': 87, \n                 'Data Analyst': 140, \n                 'Machine Learning': 120}\ncourses = ['Python for Data Science', 'Statistics', 'Data Analyst', 'Machine Learning']\nDataAnalyst = 87\n```\n\nРішенняanton_courses = {'Python for Data Science': 56, \n                 'Statistics': 87, \n                 'Data Analyst': 140}\n\nanton_courses['Machine Learning'] = 120\ncourses = list(anton_courses.keys())\nDataAnalyst = anton_courses['Data Analyst']\n\n\n\n\n\n\nЗавдання 3.20  У нас є магазин одягу LARA. У словнику shop_stock зберігається інформація про товари, наявні на складі магазину. Інформація вказана у форматі ключ - артикул товару, значення - кількість одиниць. У магазин поставили нову партію товарів, у словнику shop_new_goods записано інформацію про поставлені товари та їхню кількість. Створіть словник result, який міститиме інформацію і про товари на складі, і про товари з нової поставки. Відомо, що якщо на складі залишалася хоча б одна одиниця якогось типу товару, то товару цього типу не було в поставці.\nПриклад:\n```{python}\nshop_stock = {\"2358241350-50\": 1, \"2358000350-30\": 24, \"2358241350-00\": 3}\nshop_new_goods = {\"2358241350-60\": 10}\n# -&gt; \nresult = {\"2358241350-50\": 1, \"2358000350-30\": 24, \"2358241350-00\": 3, \"2358241350-60\": 10}\n```\n\nРішенняshop_stock = {\"2358241350-50\": 1, \"2358000350-30\": 24, \"2358241350-00\": 3}\nshop_new_goods = {\"2358241350-60\": 10}\n\nresult = shop_stock.copy()\nresult.update(shop_new_goods)\n\n\n\n\n\n\nЗавдання 3.21  Магазин Avocado зберігає інформацію про наявні фрукти та овочі у словнику input_dict у форматі ключ - назва фрукта або овоча, значення - кількість кілограмів у наявності. Порахуйте, скільки всього кілограмів фруктів і овочів є в магазині. Результат збережіть у змінну result.\nПриклад:\n```{python}\ninput_dict = {\"морква\": 10.44, \"капуста\": 5.06, \"полуниця\": 3}\n# -&gt; \nresult = 18.5\n```\n\nРішенняinput_dict = {\"морква\": 10.44, \"капуста\": 5.06, \"полуниця\": 3}\nresult = sum(input_dict.values())\n\n\n\n\n\n\nЗавдання 3.22  Є словник courses, що містить інформацію про вартість навчання в різних курсах. Інформація вказана у форматі: ключ - назва курсу, значення - вартість навчання.\nЗнайдіть ціну найдорожчого курсу. Результат збережіть у result.\nПриклад:\n```{python}\ncourses = {\"Python\": 80000, \"SQL\": 300000}\n# -&gt; \nresult = 300000\n```\n\nРішенняcourses = {\"Python\": 80000, \"SQL\": 300000}\nresult = max(courses.values())\n\n\n\n\n\n\nЗавдання 3.23  У базі даних КНЕУ інформація про студентів і кафедри, до яких вони прикріплені, зберігається в словнику kaf_sudents у форматі: ключ - ПІ студента, значення - код кафедри.\nПісля другого курсу за підсумками останніх двох сесій було складено рейтинг студентів, на основі якого стався перерозподіл студентів за кафедрами. Частина студентів продовжила навчання на своїй кафедрі, а деякі студенти перейшли з однієї кафедри на іншу. Інформація про студентів, які перейшли на нову кафедру, зберігається в словнику new_kaf_students.\nОновіть інформацію в словнику kaf_sudents, додавши в словник дані з new_kaf_students.\nПриклад:\n```{python}\nkaf_sudents = {'Дробина Юлія': 100}\nnew_kaf_students = {'Нечаєнко Георгій': 200}\n\nkaf_sudents = {'Дробина Юлія': 100, 'Нечаєнко Георгій': 200}\n```\n\nРішенняkaf_sudents = {'Дробина Юлія': 100}\nnew_kaf_students = {'Нечаєнко Георгій': 200}\n\nkaf_sudents.update(new_kaf_students)\n\n\n\n\n\n\nЗавдання 3.24 my_list зберігає список як мінімум з двома елементами.\nСтворіть змінні:\n\n\nfirst_item з першим елементом списку.\n\nlast_item з останнім елементом списку.\n\nreversed_list з елементами списку my_list у зворотному порядку.\n\neven_items з елементами списку my_list із парними індексами.\n\nПриклади:\nmy_list = ['apple', 123, True, 3.14, 'cherry', 45, 22]\n\nfirst_item = 'apple'\nlast_item = 22\nreversed_list = [22, 45, 'cherry', 3.14, True, 123, 'apple']\neven_items = ['apple', True, 'cherry', 22]\n\nРішенняmy_list = ['apple', 123, True, 3.14, 'cherry', 45, 22]\n\nfirst_item = my_list[0]\nlast_item = my_list[-1]\nreversed_list = my_list[::-1]\neven_items = my_list[::2]\n\n\n\n\n\n\nЗавдання 3.25  У змінній my_list збережено не порожній список, де є число 11.\nЗнайдіть перший індекс числа 11 my_list, збережіть індекс в змінну eleven_index.\nУ змінну ten_count збережіть скільки разів у списку my_list зустрічається число 10.\nПриклад:\n```{python}\nmy_list = [1, 10, 0, 10, 11]\neleven_index = 4\nten_count = 2\n\n\nmy_list = [11, 2, 0, 6]\neleven_index = 0\nten_count = 0\n```\n\nРішенняmy_list = [11, 2, 0, 6]\neleven_index = my_list.index(11)\nten_count = my_list.count(10)\n\n\n\n\n\n\nЗавдання 3.26  У student_names збережено список з іменами студентів, додайте до списку два імені 'Anatoly' та 'Oksana'.\nУ scores збережено список із десяти цілих чисел, видаліть із нього другий, п’ятий та останній елемент.\nУ lessons збережений список з назвою уроків, відсортуйте назви уроків у списку за абеткою.\nПриклад:\n```{python}\nstudent_names = ['Ian', 'Ivan']\nscores = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlessons = ['Python', 'Analytics']\n\n# =&gt;\n\nstudent_names = ['Ian', 'Ivan', 'Anatoly', 'Oksana']\nscores = [0, 2, 3, 5, 6, 7, 8, 9]\nlessons = ['Analytics', 'Python']\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЗверніть увагу, що потрібно видалити другий, п’ятий та останній елемент із списку. Коли ви видалили один елемент, індекси інших елементів змінились.\n\n\n\n\nРішенняstudent_names = ['Ian', 'Ivan']\nstudent_names.append('Anatoly')\nstudent_names.append('Oksana')\n\nscores = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nscores.pop(1)\n\n1\n\nРішенняscores.pop(3)\n\n4\n\nРішенняscores.pop()\n\n10\n\nРішення\nlessons = ['Python', 'Analytics']\nlessons.sort()\n\n\n\n\n\n\nЗавдання 3.27  Дано два списки list_1 і list_2. Відсортуйте list_1 за зростанням, а list_2 за спаданням. Поєднайте list_1 та list_2 в один відсортований за зростанням список list_3. У змінну list_3_len збережіть довжину list_3.\nПриклад:\n```{python}\nlist_1 = [1, 5, 3]\nlist_2 = [2, 8]\n# -&gt; \nlist_1 = [1, 3, 5]\nlist_2 = [8, 2]\nlist_3 = [1, 2, 3, 5, 8]\nlist_3_len = 5\n```\n\nРішенняlist_1 = [1, 5, 3]\nlist_2 = [2, 8]\nlist_1.sort()\nlist_2.sort(reverse=True)\nlist_3 = sorted(list_1 + list_2)\nlist_3_len = len(list_3)\n\n\n\n\n\n\nЗавдання 3.28  У змінній a зберігається список цілих невід’ємних чисел. Кількість чисел парна. Напишіть програму, яка ділитиме цей список навпіл, визначатиме суми чисел у половинах списку (sum_left і sum_right). Якщо sum_left дорівнює sum_right, то збережіть у змінну result значення True, в іншому випадку - False.\nПриклад:\n```{python}\na = [1, 2, 4, 3]\n\nsum_left = 3\nsum_right = 7\nresult = False\n```\n\nРішенняa = [1, 2, 4, 3]\nhalf = len(a) // 2\nsum_left = sum(a[:half])\nsum_right = sum(a[half:])\nresult = sum_left == sum_right\n\n\n\n\n\n\nЗавдання 3.29  Дано список цілих чисел a і число b. Видаліть з a перше й останнє входження числа b.\nПриклад:\n```{python}\na = [1, 2, 2, 1, 3, 2, 3]\nb = 1 \n# -&gt; a = [2, 2, 3, 2, 3]\n\na = [1, 2, 2, 1, 3, 2, 3]\nb = 2 \n# -&gt; a = [1, 2, 1, 3, 3]\n```\n\nРішенняa = [1, 2, 2, 1, 3, 2, 3]\nb = 1\na.remove(b)\na.reverse()\na.remove(b)\na.reverse()",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Цикли</span>"
    ]
  },
  {
    "objectID": "python_exceptions.html#syntaxerror",
    "href": "python_exceptions.html#syntaxerror",
    "title": "\n4  Помилки та винятки\n",
    "section": "\n4.1 SyntaxError",
    "text": "4.1 SyntaxError\nВинятки в Python, як і в інших мовах програмування, відносяться до проблем у вашому коді.\nПочнемо з простого прикладу: створимо файл hello.py:\n\n\nTerminal\n\ncode cat.py\n\nНапишемо простий код з помилкою:\n\nprint(\"Привіт, світ!)\n\nunterminated string literal (detected at line 1) (&lt;string&gt;, line 1)\n\n\nМи отримали помилку SyntaxError, яка означає, що Python не зміг зрозуміти наш код. Це найпростіший вид помилки, який можна виправити, виправивши помилку в коді. Запис unterminated“, як правило, означає, що я щось почав, але не зупинив. Запис string - це послідовність символів, з якою ми вже знайомі. А literal зазвичай відноситься до того, що ви буквально набрали.\nОтже вирішення цієї помилки дуже просте: додайте закриваючу лапку:\n\nprint(\"Привіт, світ!\")\n\nПривіт, світ!\n\n\nОтже, проблема з синтаксичними помилками полягає в тому, що їх вирішення повністю залежить від вас.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Помилки та винятки</span>"
    ]
  },
  {
    "objectID": "python_exceptions.html#valueerror",
    "href": "python_exceptions.html#valueerror",
    "title": "\n4  Помилки та винятки\n",
    "section": "\n4.2 ValueError",
    "text": "4.2 ValueError\nАле в Python є багато інших типів помилок, які можна назвати RuntimeError, які трапляються під час роботи вашого коду. І саме від вас залежить написання додаткового захисного коду для виявлення таких помилок.\nНаприклад, давайте створимо файл number.py, яка буде приймати число від користувача і виводити це число на екран:\n\n\nTerminal\n\ncode number.py\n\n\nnumber = int(input(\"Введіть число: \")) # 5\nprint(f'Ваше число: {number}')\n\n\n\nВаше число: 5\n\n\nАле що станеться, якщо користувач введе не число, а текст? Наприклад, введе слово п'ять:\n\nnumber = int(input(\"Введіть число: \")) # п'ять\nprint(f'Ваше число: {number}')\n\n\n\ninvalid literal for int() with base 10: \"п'ять\"\n\n\nВаше число: 5\n\n\nМи отримали помилку ValueError, яка означає, що ми передали функції int() значення, яке вона не може перетворити на число. Це вже не синтаксична помилка, а помилка, яка виникає під час виконання програми. І вирішення цієї помилки вже не залежить від вас, а від користувача, який вводить дані. Тому вам потрібно написати додатковий код, який буде перевіряти введені дані на коректність. Як це зробити у Python? Виявляється у Python є ключові слова які можуть допомогти з цим.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Помилки та винятки</span>"
    ]
  },
  {
    "objectID": "python_exceptions.html#ключові-слова-try-та-except",
    "href": "python_exceptions.html#ключові-слова-try-та-except",
    "title": "\n4  Помилки та винятки\n",
    "section": "\n4.3 Ключові слова try та except\n",
    "text": "4.3 Ключові слова try та except\n\nЯкщо ви хочете спробувати зробити щось у Python, ви можете використовувати це ключове слово try. це досить влучна назва. За рахунок нього ви можете перевірити, чи сталося щось виняткове, щось помилкове. Отже, використовуючи try, я можу спробувати щось зробити, але якщо щось піде не так, я можу замість використати ключове слово except.\nПодивимось, як це працює:\n\ntry:\n    number = int(input(\"Введіть число: \")) # п'ять\n    print(f'Ваше число: {number}')\nexcept ValueError:\n    print('Ви ввели не число')\n\n\n\nВи ввели не число",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Помилки та винятки</span>"
    ]
  },
  {
    "objectID": "python_exceptions.html#nameerror",
    "href": "python_exceptions.html#nameerror",
    "title": "\n4  Помилки та винятки\n",
    "section": "\n4.4 NameError",
    "text": "4.4 NameError\nЯкби я був впевнений, що функція print() не призведе до помилки, я міг би переписати код наступним чином і отримати нову помилку:\n\ntry:\n    number = int(input(\"Введіть число: \")) # п'ять\nexcept ValueError:\n    print('Ви ввели не число')\n\nprint(f'Ваше число: {number}')\n\n\n\nВи ввели не число\n\n\nВаше число: 5\n\n\nПомилка NameError означає, що я використовую змінну, яка не існує. Ця помилка виникла в наслідок порядку виконання операцій. Помилка виникає в частині коду int(input(\"Введіть число: \")), яка знаходиться праворуч від оператора = і це приводить до того, що змінна number не створюється.\nТо як вирішити цю проблему? Ви можете використовувати ключове слово else.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Помилки та винятки</span>"
    ]
  },
  {
    "objectID": "python_exceptions.html#ключове-слово-else",
    "href": "python_exceptions.html#ключове-слово-else",
    "title": "\n4  Помилки та винятки\n",
    "section": "\n4.5 Ключове слово else\n",
    "text": "4.5 Ключове слово else\n\nІнтуіція ключового слова else схожа на інтуїцію ключового слова else в умовних конструкціях. Якщо в блоці try не виникає помилок, то виконується блок else.\n\ntry:\n    number = int(input(\"Введіть число: \")) # п'ять\nexcept ValueError:\n    print('Ви ввели не число')\nelse:\n    print(f'Ваше число: {number}')\n\n\n\nВи ввели не число\n\n\nЗ мого боку трохи неввічливо відкидати вхідні дані користувача після того, як він не зміг ввести ціле число, і просто виходити з програми. Було б зручніше, якби я просто підказував або перепитував користувача знову і знову. І для цього я можу використовувати цикл while:\n\nwhile True:\n    try:\n        number = int(input(\"Введіть число: \")) # п'ять\n    except ValueError:\n        print('Ви ввели не число')\n    else:\n        print(f'Ваше число: {number}')\n        break\n\nУявіть ситуацію, що я буду намагатися отримати від користувача досить багато цифр. Було б непогано створити власну функцію, наприклад get_int(), яка буде повторювати запит на введення цілого числа, поки користувач не введе ціле число:\n\ndef main():\n    number = get_int()\n    print(f'Ваше число: {number}')\n\ndef get_int():\n    while True:\n        try:\n            number = int(input(\"Введіть число: \")) # п'ять\n        except ValueError:\n            print('Ви ввели не число')\n        else:\n            return number\n\nmain()",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Помилки та винятки</span>"
    ]
  },
  {
    "objectID": "python_exceptions.html#ключове-слово-pass",
    "href": "python_exceptions.html#ключове-слово-pass",
    "title": "\n4  Помилки та винятки\n",
    "section": "\n4.6 Ключове слово pass\n",
    "text": "4.6 Ключове слово pass\n\nПідемо далі, і припустимо, що ми хочемо ловити помилки, але не хочемо виводити повідомлення про помилку. Для цього ми можемо використовувати ключове слово pass:\n\ndef main():\n    number = get_int()\n    print(f'Ваше число: {number}')\n\ndef get_int():\n    while True:\n        try:\n            number = int(input(\"Введіть число: \")) # п'ять\n        except ValueError:\n            pass\n        else:\n            return number\n\nmain()\n\nЦе просто ще один механізм для обробки помилок. Іноді ви можете використовувати pass, якщо ви хочете, щоб ваш код був синтаксично правильним, але ви не хочете нічого робити, якщо виникає помилка.\nМи можемо скоротити цей код і перенести ключове слово return вище:\n\ndef main():\n    number = get_int()\n    print(f'Ваше число: {number}')\n\ndef get_int():\n    while True:\n        try:\n            return int(input(\"Введіть число: \")) # п'ять\n        except ValueError:\n            pass\n\nmain()\n\nЦе дозволить дещо скоротити код, але може бути дещо складнішим для розуміння. Який варіант обрати - це вже залежить від вас.\nТепер давайте створимо більш загальний варіант цієї програми і позбудемось від жорсткого коду. Зробимо функцію get_int() більш універсальною: було б добре, якби функція main() не знала, як функція get_int() описує свої змінні. В нашому випадку це 'Введіть число', але можна було б написати 'Введіть ціле число' або 'Введіть додатнє число' або ще щось. Для цього ми додамо параметр prompt до функції get_int(), який буде використовуватися для виведення повідомлення користувачу:\n\ndef main():\n    number = get_int('Введіть число: ')\n    print(f'Ваше число: {number}')\n\ndef get_int(prompt):\n    while True:\n        try:\n            return int(input(prompt)) # п'ять\n        except ValueError:\n            pass\n\nmain()",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Помилки та винятки</span>"
    ]
  },
  {
    "objectID": "python_exceptions.html#винятки",
    "href": "python_exceptions.html#винятки",
    "title": "\n4  Помилки та винятки\n",
    "section": "\n4.7 Винятки",
    "text": "4.7 Винятки\nВиявляється, ви можете самостійно створювати винятки за допомогою ключового слова raise у Python.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Помилки та винятки</span>"
    ]
  }
]