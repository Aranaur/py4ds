[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Від нуля до Python Data Scientist",
    "section": "",
    "text": "Вступне слово\nШановні читачі,\nЗапрошую до книги “Від нуля до Python Data Scientist”! Сьогодні ми відкриваємо двері до захоплюючого світу аналізу даних та наукових досліджень, в якому Python стає вашим найкращим другом. Завдяки своїй простоті, гнучкості та потужності, Python виходить за межі звичайної мови програмування, перетворюючись на незамінного помічника для розв’язання складних задач і виявлення прихованих закономірностей.\nУ цій книзі ми збираємося подорожувати у світі науки про дані, де Python та інші дотичні інструменти стають невід’ємною частиною процесу відкриття знань та розуміння складних систем. Ви дізнаєтеся, як за допомогою Python можна ефективно обробляти, аналізувати та візуалізувати дані, виявляти закономірності та робити передбачення. Завдяки цим інструментам ви зможете розкрити потужний потенціал ваших даних та прийняти обґрунтовані рішення на основі наукових фактів.\nЯ запрошую вас на цю захоплюючу подорож, де ми разом з вами розкриємо секрети Python у науці про дані. Незалежно від вашого досвіду в програмуванні або знань про науку про дані, ця книга надасть вам необхідні знання та інструменти для успішного впровадження Python у ваші проекти. Будьте впевнені, що по закінченні цього шляху ви будете готові до викликів, які стоять перед вами у світі науки та досліджень.\nНехай ця книга стане вашим надійним провідником у справжньому дослідницькому пригоді, де Python та його друзі стають вашими найкращими союзниками. Розпочнемо нашу подорож разом!\nЗ найкращими побажаннями, Ігор Мірошниченко"
  },
  {
    "objectID": "index.html#перелік-необхідних-пакетів",
    "href": "index.html#перелік-необхідних-пакетів",
    "title": "Від нуля до Python Data Scientist",
    "section": "Перелік необхідних пакетів",
    "text": "Перелік необхідних пакетів\n\n\nrequirements.txt\n\nduckdb\nduckdb-engine\njupysql\nmatplotlib-venn\nnotebook\npandas\nplotly\ntabulate"
  },
  {
    "objectID": "python.html#встановлення-python",
    "href": "python.html#встановлення-python",
    "title": "Python",
    "section": "Встановлення Python",
    "text": "Встановлення Python\n\nWindows\n\nЗавантажити та запустити Python актуальної версії, наприклад Python 3.9.\nВідкрити командний рядок: cmd\nВиконати у командному рядку: pip install numpy\nВиконати у командному рядку: pip install pandas\nВиконати у командному рядку: pip install jupyter\nЗапустити jupyter: виконати у командному рядку: jupyter-notebook\n\n\n\nLinux (Ubuntu LTS)\n\nВідкрити термінал\nВиконати у терміналі: sudo apt update, що оновить всі пакети.\nВиконати у терміналі: sudo apt install software-properties-common, що дозволить керувати дистрибутивами.\nВиконати у терміналі: sudo add-apt-repository ppa:deadsnakes/ppa, що додасть deadsnakes-репозиторій з пакетами Python різних версій.\nВиконати у терміналі: sudo apt install python3.9-dev, що встановить розширений Python 3.9.\nВиконати у терміналі: sudo apt install curl - консольна утиліта для роботи з URL-адресами.\nВиконати у терміналі: curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py - завантажити і встановити pip.\nВиконати у терміналі: sudo apt install python3.9-venv - встановити віртуальне середовище Python 3.9.\nВиконати у терміналі: sudo python3.9 get-pip.py - встановити pip.\nВиконати у терміналі: pip install numpy - встановити numpy для роботи з матрицями\nВиконати у терміналі: pip install pandas - встановити pandas для роботи з даними у вигляді таблиць DataFrame.\nВиконати у терміналі: pip install jupyter - встановити jupyter для роботи з ноутбуками.\nЗапустити Jupyter: python3.9 -m notebook\n\n\n\nMacOS\n\nВідкрити термінал\nВстановити Homebrew: виконати у терміналі команду із сайту https://brew.sh\nВстановити Python: brew install python@3.9\nВиконати у терміналі: python3.9 -m pip install numpy\nВиконати у терміналі: python3.9 -m pip install pandas\nВиконати у терміналі: python3.9 -m pip install jupyter\nЗапустити Jupyter: виконати у терміналі: jupyter-notebook\n\n\n\nХмарні сервіси\n\nGoogle Colab\nJupyter Notebook\nPosit.cloud\n\n\n\nIntegrated development environment (IDE)\n\nVisual Studio Code\nPyCharm\nRStudio"
  },
  {
    "objectID": "python_basics.html#функції",
    "href": "python_basics.html#функції",
    "title": "1  Функції та змінні",
    "section": "1.1 Функції",
    "text": "1.1 Функції\nШвидше за все, більшість з вас, ніколи раніше не програмували, тому давайте почнемо саме з цього. Давайте відкриємо Visual Studio Code, або VS Code, яка є дуже популярною програмою для написання коду в наш час. Вам не обов’язково писати код за допомогою саме цього інструменту. Насправді, все, що нам потрібно в кінці дня - це так званий текстовий редактор, програма для написання тексту. Внизу екрану знаходиться так зване вікно терміналу, це інтерфейс командного рядка, або інтерфейс CLI, до базового комп’ютера, будь то ваш Mac або ПК, або навіть якийсь сервер у хмарі. Давайте напишемо наступний код у вікні терміналу:\n\n\nTerminal\n\ncode hello.py\n\nЯк ми скоро побачимо, будь-яка програма, яку ви пишете на Python, зазвичай має ім’я файлу, яке закінчується на .py, щоб вказати комп’ютеру, що це дійсно програма, написана на Python.\nПісля виконання коду з’явиться нове вікно з назвою hello.py. Давайте напишемо наступний код у файлі print('Привіт, світ!'). Навіть якщо ви ніколи раніше не програмували, швидше за все, ви можете здогадатися, що буде робити ця проста програма. Для того, щоб запустити програму, натисніть на стрілку у верхньому правому куті вікна або поверніться до вікна терміналу та виконайте наступну команду:\n\n\nTerminal\n\npython hello.py\n\nЩо це означає? Виявляється, що коли я пишу код на такій мові, як Python, мені потрібно інтерпретувати код зверху вниз, зліва направо, щоб комп’ютер розумів, що необхідно робити. Зрештою, навіть якщо ви не дуже багато знаєте про комп’ютери, ви, напевно, чули, що комп’ютери розуміють лише нулі та одиниці, так звану двійкову систему числення. Що ж, якщо це так, то щось не дуже схоже, що print('Привіт, світ!') є нулями та одиницями. Ми повинні якось перевести це в нулі та одиниці, які розуміє комп’ютер. Отже, Python - це не лише мова, якою ми будемо писати код, це також програма, інакше відома як інтерпретатор, яку ви безкоштовно встановлюєте на власний комп’ютер Mac чи PC або на якийсь сервер у хмарі. І ви можете запустити цей інтерпретатор, передавши йому на вхід ім’я вашого файлу, у нашому випадку hello.py. І тоді цей інтерпретатор, займеться процесом його читання зверху вниз, зліва направо, і ефективно переведе його в ті нулі та одиниці, які комп’ютер може зрозуміти. Тож давайте виконаємо цю команду і, сподіваюся, якщо я нічого не переплутав, я побачу на екрані першу програму:\n\nprint('Привіт, світ!')\n\nПривіт, світ!\n\n\nА тепер давайте зробимо крок назад і подумаємо, що ж ми щойно зробили, і що ж ми бачимо на екрані? Перш за все, у більшості мов програмування ви маєте доступ до того, що називається функціями.\nФункція (анг. functions) - це дія або дієслово, яке дозволяє вам робити щось у програмі. Загалом, будь-яка мова постачається з певним наперед визначеним набором функцій, деяких базових дій або дієслів, які комп’ютер вже знає. А ви можете використовувати ці функції за власним бажанням, щоб змусити комп’ютер виконувати ці дії. Програма hello.py, про яку йде мова, використовує одну функцію. І ви, мабуть, можете здогадатися, що мова йде про функцію print(). Дана функція друку, звичайно, не друкує якийсь наперед визначений рядок тексту. Вона друкує те, що ви їй передаєте. І тут ми знайомимось з ще однією частиною термінології у світі програмування, а саме аргументи.\nАргументи (анг. arguments) - це вхідні дані для функції, які якимось чином впливають на її поведінку. Розробники Python, звичайно, не знали, що саме ми з вами захочемо надрукувати на екрані. Тому вони розробили цю функцію друку з можливістю приймати на вхід деякий рядок тексту щоб ця функція в кінцевому підсумку надрукувала його на екрані. Наша програма hello.py виводить на екранПривіт, світ!. І це, як правило, у програмуванні називається побічним ефектом (анг. side effects). Він може бути візуальним, звуковим, виконувати запису файл або базу даних тощо.\nОтже, я написав першу програму. Все пройшло за планом. Я не зробив жодної помилки. Але, чесно кажучи, коли ви вчитеся програмувати, і навіть коли ви навчилися програмувати, через роки ви будете робити помилки. І ці помилки відносяться до терміну, який ви, можливо, вже знаєте, а саме до багів. Баг (анг. bugs) - це помилка у програмі. Вони можуть приймати найрізноманітніші форми і наша задача навчитися виправляти їх. Ми розглянемо багато інструментів, як розумових, так і технічних, за допомогою яких ви зможете вирішити ці проблеми.\nТож дозвольте мені зараз навмисно зробити помилку: припустимо, що я забув дописати закриваючі дужки в кінці коду. Код на 99% правильний. Але навіть такі маленькі, здавалося б, незначні деталі, на які ми з вами насправді не звертаємо уваги якщо надсилаємо електронного листа чи текстове повідомлення, це просто друкарська помилка. Нічого страшного. Для комп’ютера це буде великою проблемою. Комп’ютер сприйме вас буквально. І якщо ви не закінчите свою думку так, як очікує мова програмування, вона не обов’язково запуститься взагалі:\n\nprint('Привіт, світ!'\n\nSyntaxError: incomplete input (4260497653.py, line 1)\n\n\nЦя помилка, на щастя, досить проста, вона говорить про те, що відкрита дужка ніколи не була закрита. І тепер інтуїтивно зрозуміло, що мені потрібно зробити - закрити її. На жаль, іноді повідомлення про помилки будуть не такими зручними для користувача.\nА тепер давайте розглянемо, як ми можемо покращити цю програму. Давайте почнемо вдосконалювати цю програму, щоб зробити її більш інтерактивною - чи можу я змусити програму сказати щось на кшталт \"Привіт, Гаррі\", \"Привіт, Герміоно\", \"Привіт, Рон\" або будь-яке інше ім’я користувача? Для цього я повернуся до hello.py і додам ще один рядок коду на самому початку, який просто запитає ім’я користувача.\n\nprint('Як тебе звати?')\nprint('Привіт, світ!')\n\nАле насправді мені потрібна інша функція, щоб отримати дані від користувача. І чудово, що в Python є функція з назвою input(). Якщо почитати документацію до функції цієї функції, виявляється, що вона приймає аргумент - рядок, який буде виведений на екран. Тож я можу покращити попередній код і записати наступне:\n\ninput('Як тебе звати? ') # Гаррі\nprint('Привіт, світ!')\n\n\n\nПривіт, світ!\n\n\nНа жаль, програма нічого не робить з введеним ім’ям. Гаразд, чи можу я виправити це? Я можу перейти до рядка 2 і змінити світ на Гаррі:\n\ninput('Як тебе звати? ') # Гаррі\nprint('Привіт, Гаррі')\n\n\n\nПривіт, Гаррі\n\n\nЗвичайно, програма працює не так, як передбачалося: уявімо, що наш користувач - це Герміона:\n\ninput('Як тебе звати? ') # Герміона\nprint('Привіт, Гаррі')\n\n\n\nПривіт, Гаррі\n\n\nЦе називається “закодувати” або “жорсткий код” (анг. hard-code, hard coding) - я записав буквальне ім’я в середині коду.\nОтже, нам потрібен якийсь спосіб отримати назад те, що ввів користувач, і, зрештою, щось з цим зробити. Для цього ми скористаємося ще однією особливістю програмування, а саме особливістю деяких функцій, яка полягає в тому, що вони можуть повертати значення (анг. return values). Метафорично кажучи, нам потрібно, щоб функція отримувала вхідні дані від користувача, а потім передавала їх мені, щоб я міг щось з ними зробити. Але якщо це буде передано мені, я хочу це кудись помістити, щоб потім надрукувати на екрані. Мені потрібно зробити еквівалент того, якби я взяв аркуш паперу, записав на ньому ім’я, щоб потім ввести його як вхідні дані у функцію друку. І для цього нам знадобиться ще одна особливість програмування, а саме змінні."
  },
  {
    "objectID": "python_basics.html#змінні",
    "href": "python_basics.html#змінні",
    "title": "1  Функції та змінні",
    "section": "1.2 Змінні",
    "text": "1.2 Змінні\nШвидше за все, більшість з вас знайомі зі змінними ще з уроків математики: x, y, z і тому подібне. Програмування має таку саму здатність створити змінну, в даному випадку, в пам’яті комп’ютера. І ця змінна може зберігати значення, число, якийсь текст, навіть зображення, відео чи щось інше. Змінна - це просто контейнер для якогось значення всередині комп’ютера або всередині вашої програми.\nПри виборі імені змінної давайте дотримуватись певних правил, щоб наш код виконувався без помилок та його було зручно читати:\n\nІм’я змінної починається з літери;\nДля імен змінних використовуватимемо маленькі літери з підкресленням замість пробілу;\nІм’я змінної не повинно співпадати з назвою ключових слів Python. Наприклад, назвати змінну if або True – погана ідея. Ключових слів не так багато, з частиною ми скоро познайомимося.\n\n```{python}\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n```\nТож повертаючись до попереднього прикладу я створю змінну name використовуючи оператор присвоєння =. Це означає, що ви хочете присвоїти у змінну name в лівій частині отримане значення функції input() праворуч, незалежно від того, що ввів користувач. Отже зараз десь у пам’яті комп’ютера є контейнер, що містить 'Гаррі'. Але тут легко припуститися помилки. Припустімо, я вирішу спробувати надрукувати введене ім’я. І я, наче за здогадкою, вводжу змінну name через кому, після 'Привіт' у другому рядочку коду:\n\nname = input('Як тебе звати? ') # Гаррі\nprint('Привіт, name')\n\n\n\nПривіт, name\n\n\nВочевидь це не те, що я очікував. Нам потрібен інший спосіб виводити значення всередині змінної, а не лише слово name. Дозвольте мені спробувати зробити це кількома різними способами.\nУ першому випадку я приберу запис name з другого рядка, і залишу змінну print(name) окремим рядком. Цього разу я буду більш уважним і не буду брати name у лапки, тому що ми вже бачили, що подвійні лапки означають буквально роздрукувати 'n-a-m-e':\n\nname = input('Як тебе звати? ') # Гаррі\nprint('Привіт,')\nprint(name)\n\n\n\nПривіт,\nГаррі\n\n\nГаразд, це працює, хоча і не так добре як хотілося. Принаймні, я вирішив проблему, просто поки що не дуже добре.\nАле дозвольте мені зробити крок назад і представити кілька інших концепцій, з якими ми повинні бути знайомі, оскільки наші програми стають довшими, і вони вже не обмежуються одним, двома або навіть трьома рядками. Зрештою, наші програми стануть десятками рядків, можливо, навіть сотнями рядків. Давайте закладемо основу для успіху. Виявляється, що Python та багато інших мов програмування підтримують те, що називається коментарями.\nКоментарі (анг. comments) - це примітки до вашого коду. Для включення коментарів до коду Python як правило, використовується символ хешу #. Це дозволяє вам писати еквівалент примітки до коду, але так, щоб не порушити ваш код. Комп’ютер фактично ігнорує ваші коментарі.\nТож я хочу додати кілька коментарів до попередньої програми:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт,')\nprint(name)\n\nЩойно я прокоментував кожен шматок коду. Навіщо? Ну по-перше, якщо я завтра вранці прокинусь і забуду все, що відбувалося минулого дня, зручно, маючи коментарі, зрозуміти що саме робить ця програма, щоб не читати сам код. По-друге, якщо ви допустили помилку, ви можете прочитати, що ви мали на увазі, коли писали код. А потім ви можете подивитися на код і з’ясувати, чи робить він зараз те, що ви хотіли. Це не є необхідним для такої маленької програми, як зараз. - з одного-двох-трьох рядків цілком очевидно, що робить програма. Але якщо ви звикнете коментувати свій код, це буде корисно, щоб нагадувати собі та іншим про те, що ви задумали і що робить ваш код.\nА що якщо необхідно написати коментар, який займе декілька рядків? В такому випадку можна використати спеціальну техніку використовуючи потрійні лапки (одинарні або подвійні):\n\n'''\nЗапитати користувача про ім'я\nі вивести привітання\n'''\nname = input('Як тебе звати? ') # Гаррі\nprint('Привіт,')\nprint(name)\n\nКоментарі також можуть слугувати своєрідним списком справ для вас самих. У програмуванні є таке поняття як псевдокод.\nПсевдокод (анг. pseudocode) - це неформальна форма запису. Це просто використання природної мови, щоб висловити свої думки лаконічно, методично, алгоритмічно тощо. Тож, наприклад, якби я сьогодні не був впевнений, як я хочу написати цю програму, але я знав, що я хочу зробити, я міг би просто написавши наступне в hello.py:\n\n# Запитати користувача про ім'я\n\n# Вивести привітання\n\nІ вже після цього приступити до написання повноцінного коду. Отже, псевдокод - це гарний спосіб структурувати список справ, особливо якщо ви поки не знаєте, як писати код.\nГаразд, давайте повернемося до нашої програми і спробуємо ще вдосконалити її. У програмуванні іноді існує багато способів вирішити одну і ту ж проблему. І ось один із способів вирішити цю проблему: давайте у середині функції print() “додамо” змінну name. Це не додавання як таке, я не додаю числа, очевидно, але я хочу додати ім’я людини до рядка тексту:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт,' + name)\n\n\n\nПривіт,Гаррі\n\n\nТак краще, але тут є невелика помилка, хоча і естетична. Тут не вистачає пробілу, але давайте просто скористаємося інтуїцією: якщо я пропускаю пробіл після коми, чому б мені просто не додати його вручну?\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт, ' + name) # додали пробіл після коми\n\n\n\nПривіт, Гаррі\n\n\nА тепер, якщо подивитися уважніше, ви могли помітити, що я поставив цей, здавалося б, зайвий пробіл у першому рядку мого коду після знаку питання: name = input('Як тебе звати? '). Це теж було просто для естетики. Я хотів перемістити курсор користувача на один пробіл праворуч, щоб коли користувач вводив своє ім’я, він не був одразу поруч з тим самим знаком питання.\nАле є й інші способи зробити це. Виявляється, що деякі функції, зокрема print(), приймають декілька аргументів. І виявляється, що якщо ви відокремлюєте входи у функцію, так звані аргументи функції, комою, ви можете передати декілька аргументів. Тобто я можу передати 'Привіт, ' і name як два окремих аргументи функції print():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт, ', name)\n\n\n\nПривіт,  Гаррі\n\n\nГаразд, я трохи перестарався. Тепер у мене чомусь два пробіли. Виявляється, коли ви передаєте на друк кілька аргументів, програма автоматично вставляє пробіл для вас. Тож, якщо мені не потрібен додатковий пробіл, мені не потрібно вставляти додатковий пробіл у рядок:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт,', name)\n\n\n\nПривіт, Гаррі\n\n\nТепер все виглядає граматично так, як я хотів би. Який з цих підходів кращий? Останній підхід використовує функцію print() з двома аргументами, 'Привіт,' і змінна name. Попередня версія, нагадаю, технічно використовувала один аргумент, хоча це виглядало трохи дивно. Тоді це був один аргумент в тому сенсі, що комп’ютер, як і математики, спочатку виконує те, що знаходиться всередині круглих дужок. Тож, якщо всередині дужок у вас є рядок тексту, 'Привіт,' який мені потрібно додати, то у вас є +, який означає не додавання як таке, а конкатенацію, щоб з’єднати те, що зліва, і те, що справа. І все це відбувається динамічно."
  },
  {
    "objectID": "python_basics.html#рядки",
    "href": "python_basics.html#рядки",
    "title": "1  Функції та змінні",
    "section": "1.3 Рядки",
    "text": "1.3 Рядки\nДозвольте мені повернутися до коду, про який йде мова, і подивитися, чи зможемо ми показати вам пару інших способів вирішення тієї ж проблеми, підкресливши, той факт, що ми працюємо з рядками (анг. ‘strings’). Для таких даних у Python є окремий тип даних str - послідовність тексту.\nДавайте повернемося до одного з попередніх варіантів написання програми з подвійним використанням функції print():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт, ')\nprint(name)\n\n\n\nПривіт, \nГаррі\n\n\nЦе було непогано, але був візуальний побічний ефект, який мені просто не подобався. Але є інший спосіб це виправити. Очевидно, що функція друку автоматично виводить порожній рядок, тому ми бачимо 'Привіт, ' на одному рядку, а 'Гаррі' на наступному. Як змінити таку поведінку функції print()? Тут слід згадати, що функції приймають аргументи, які впливають на їх поведінку. Виявляється, що якщо ми подивимось документацію до функції print() у Python. І одна з найкращих речей, яку ви можете зробити, вивчаючи мову програмування - це навчитися читати документацію, тому що більшість відповідей на ваші запитання можна знайти саме у документації. Тож давайте розглянемо документацію до функції print():\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\nЗ нього випливає наступне: - назва функції: print; - *objects означає, що функія може приймати будь-яку кількість об’єктів; - sep=' ' (скорочено від англ. separator) - родільник, який використовується для розділення об’єктів, які виводяться. За замовчуванням це пробіл; - end='\\n' - символ, який виводиться після останнього об’єкта. За замовчуванням це символ нового рядка (\\n).\n\n\n\n\n\n\nПримітка\n\n\n\nДокументація до Python доступна на docs.python.org.\n\n\nТепер ми знаємо, що функція print() приймає аргумент end, який використовується для визначення символу, який виводиться після останнього об’єкта. Тому, якщо ми хочемо вивести 'Привіт, ' та 'Гаррі' на одному рядку, нам потрібно використати функцію print() двічі, передаючи аргумент end у першому виклику функції print():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт, ', end='')\nprint(name)\n\n\n\nПривіт, Гаррі\n\n\nВ той же час, якщо ми хочемо використати функцію print() для виведення декількох об’єктів, ми можемо використати аргумент sep для визначення роздільника між об’єктами:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести привітання\nprint('Привіт', name, sep=', ')\n\n\n\nПривіт, Гаррі\n\n\nУ випадках, коли нам необхідно використовувати апострофи або лапки в середині тексту, ми можемо використовувати різні види лапок, щоб уникнути помилки.\n\nprint(\"Привіт, 'Гаррі'\")\nprint('Привіт, \"Гаррі\"')\n\nЩе однією технікою є використання символу \\ перед апострофом або лапками, які ми хочемо використати в тексті. Це називається екрануванням (англ. escaping).\n\nprint('Привіт, \\'Гаррі\\'')\nprint(\"Привіт, \\\"Гаррі\\\"\")\n\n\n1.3.1 f-рядки\nf-рядки (англ. formatted string) - це рядки, які містять вирази, які обчислюються. Щоб створити f-рядок, ми використовуємо літеру f перед відкриваючою лапкою або апострофом. Вирази, які ми хочемо обчислити, ми пишемо в фігурних дужках {}. Якщо повернутися до нашого прикладу, ми можемо використати f-рядки, щоб вивести ім’я разом зі словом 'Привіт':\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # Гаррі\n\n# Вивести ім'я\nprint(f'Привіт, {name}')\n\n\n\nПривіт, Гаррі\n\n\nf-рядки роблять код більш читабельним і зручним, особливо коли ви працюєте з багатьма змінними і значеннями. Якщо ви працюєте з більш ранньою версією Python, то корисно знати і про інші методи форматування.\n\nЗа допомогою оператора %\n\nЦей спосіб форматування рядків уже застарів, але все ще використовується в деяких старих проектах. Синтаксис схожий на форматування рядків у мові C, де %s використовується для вставки рядка, а %d для вставки числа:\n\nname = \"Гаррі\"\nage = 11\nprint(\"My name is %s and I am %d years old\" % (name, age))\n\nMy name is Гаррі and I am 11 years old\n\n\n\nЗа допомогою методу format\n\nЦе метод рядка, який дає змогу форматувати текст, замінюючи вхідні аргументи всередині фігурних дужок {}. Ось приклад використання методу format():\n\nname = \"Гаррі\"\nage = 11\nprint(\"Моє ім'я {}. Мені {} років.\".format(name, age))\n\nМоє ім'я Гаррі. Мені 11 років.\n\n\nЗнаки {} у рядку були замінені на змінні, які були передані в метод format(). Це дає змогу створювати динамічні рядки, які змінюються залежно від змінних, переданих у метод format(). Можна використовувати індекси для заміни змінних:\n\nname = \"Гаррі\"\nage = 11\nprint(\"Моє ім'я {1}. Мені {0} років.\".format(name, age))\n\nМоє ім'я 11. Мені Гаррі років.\n\n\nТут ми використовували індекс 1 для заміни змінної age, індекс 0 - для змінної name. Це може бути корисно, якщо потрібно змінювати порядок виведення змінних у рядку. Крім того, можна використовувати іменовані аргументи для заміни:\n\nprint(\"Моє ім'я {name}. Мені {age} років.\".format(name='Гаррі', age=11))\n\nМоє ім'я Гаррі. Мені 11 років.\n\n\n\n\n1.3.2 Методи рядків\nНавіть коли ми виконували відносно прості операції, ми, як правило, покладалися на те, що користувач буде вводити саме те, що ми хочемо, щоб він ввів. Однак, це не означає, що результат вводу буде виглядати так, як ми хочемо. Чесно кажучи, ми з вами маємо звичку на веб-сайтах і в додатках часто випадково натискати пробіл, або на початку введення, або в кінці. Можливо, через те, що пробіл дуже велика клавіша, досить часто трапляються випадкові пробіли до або після введення даних користувачем. Також, ми з вами, безумовно, маємо звичку не завжди писати слова з великої літери, як слід. Якщо ми надсилаємо текстові повідомлення, ми, ймовірно, трохи поспішаємо і просто надсилаємо все в нижньому регістрі. Ми з вами не можемо покладатися на те, що нам обов’язково вдасться надрукувати все правильно, коли ми користуємося якимось програмним забезпеченням, чи то додатком, чи то веб-сайтом, чи чимось іншим.\nАле виявляється, що рядки самі по собі мають багато вбудованих функцій. Це означає, що ми можемо маніпулювати даними, введеними користувачем, щоб зробити більше, ніж просто приєднати їх до чогось іншого. Ми можемо очистити його або переформатувати таким чином, щоб він виглядав трохи краще для нас.\nДавайте повернемося до нашого прикладу, але цього разу я спеціальну напишу ім’я користувача з маленької літери та з зайвими пробілами на початку і у кінці:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '  гаррі  '\n\n# Вивести ім'я\nprint(f'Привіт, {name}')\n\n\n\nПривіт,   гаррі  \n\n\nЯк бачите, ім’я виводиться з пробілами на початку і в кінці. Якщо ми хочемо видалити пробіли з початку і кінця рядка, ми можемо використати метод .strip():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '  гаррі  '\n\n# Вивести ім'я\nprint(f'Привіт, {name.strip()}')\n\n\n\nПривіт, гаррі\n\n\nВже краще, але що робити з ім’ям, яке введене з маленької літери? Ми можемо використати метод .capitalize(), щоб перетворити першу літеру рядка на велику:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '  гаррі  '\n\n# Вивести ім'я\nprint(f'Привіт, {name.strip().capitalize()}')\n\n\n\nПривіт, Гаррі\n\n\nТепер розглянемо приклад, коли користувач вводить не тільки ім’я, але і прізвище:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '   гаррі поттер   '\n\n# Вивести ім'я\nprint(f'Привіт, {name.strip().capitalize()}')\n\n\n\nПривіт, Гаррі поттер\n\n\nМетод .capitalize() перетворює першу літеру рядка на велику. Але якщо нам необхідно записати і ім’я, і прізвище з великої літери? Ми можемо використати метод .title():\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # '   гаррі поттер   '\n\n# Вивести ім'я\nprint(f'Привіт, {name.strip().title()}')\n\n\n\nПривіт, Гаррі Поттер\n\n\nЗ іншої сторони, якщо ми хочемо вивести тільки ім’я, а користувач ввів ім’я та прізвище, ми можемо використати метод .split(). Цього разу я не буду додавати зайвих пробілів до імені:\n\n# Запитати користувача про ім'я\nname = input('Як тебе звати? ') # 'гаррі поттер'\n\n# Розділити рядок на дві частини\nfirst, last = name.split(\" \")\n\n# Вивести ім'я\nprint(f'Привіт, {first.capitalize()}')\n\n\n\nПривіт, Гаррі\n\n\n\n\n1.3.3 Спеціальні символи в рядках\nМи вже знаємо, що для створення рядка достатньо використовувати подвійні чи одинарні лапки. Все, що знаходиться всередині лапок, сприйматиметься як рядок.\n\nstring1 = 'Привіт, світ!'\nstring2 = \"Моє ім'я Гаррі\"\n\nЯкщо ми виведемо string1 і string2 на друк за допомогою функції print(), то побачимо на екрані всі символи, які ми помістили всередині лапок. Але це завжди так. У Python, як і в більшості мов програмування, у рядках можуть бути використані спеціальні символи. Вони називаються екранованими послідовностями.\nОсь деякі з найбільш часто використовуваних екранованих послідовностей у Python:\n\n\\n — перенесення рядка\n\\t - табуляція\n\\' - одинарна лапка\n\\\" - подвійна лапка\n\\\\ — зворотний слеш\n\nРозберемо їх використання відразу на прикладі:\n\nstring1 = '\\'Ґрифіндор\\' - чемпіон з квідичу!\\n1996 – 1997'\nprint(string1)\n\n'Ґрифіндор' - чемпіон з квідичу!\n1996 – 1997\n\n\nТаким чином, коли у рядку з’являється зворотний слеш \\, програма чекає після нього спеціальний символ. Сам зворотний слеш не виводиться на друк. А символ після слеша вже інтерпретується, наприклад, як перенесення рядка чи відступ.\nПодивіться ще приклади:\n\nprint(\"Привіт\\nсвіт!\")\n\nПривіт\nсвіт!\n\n\n\nprint(\"C:\\\\Users\\\\user\\\\Desktop\\\\file.txt\")\n\nC:\\Users\\user\\Desktop\\file.txt\n\n\n\nprint(\"Ім'я:\\tГаррі\")\n\nІм'я:   Гаррі\n\n\n\nprint('Кам\\'яні стіни, як і в «Ґрінґотсі», освітлювали смолоскипи')\n\nКам'яні стіни, як і в «Ґрінґотсі», освітлювали смолоскипи\n\n\n\nprint(\"Кам'яні стіни, як і в «Ґрінґотсі», освітлювали смолоскипи\")\n\nКам'яні стіни, як і в «Ґрінґотсі», освітлювали смолоскипи\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nДокументація до методів рядків у Python доступна за посиланням."
  },
  {
    "objectID": "python_basics.html#цілі-числа",
    "href": "python_basics.html#цілі-числа",
    "title": "1  Функції та змінні",
    "section": "1.4 Цілі числа",
    "text": "1.4 Цілі числа\nЦілі числа, int (англ. integer) - це окремий тип даних у Python. Цілі числа можуть бути додатніми, від’ємними або нулем. Наприклад, 1, -1 та 0 - цілі числа. Цілі числа можна додавати, віднімати, множити та ділити. Крім того є ще декілька операцій, які можна виконувати з цілими числами, такі як піднесення до степеня, взяття остачі від ділення та інші. Давайте розглянемо їх:\n\n+: додавання\n-: віднімання\n*: множення\n**: зведення в ступінь\n/: ділення\n//: цілочислове ділення, арифметична операція, результатом якої є ціла частина частки, отриманого поділом одного цілого числа на інше ціле число\n%: залишок від ділення\n\nДавайте подивимось, чи зможемо ми створити власний маленький калькулятор. Цього разу ми створемо файл calculator.py та запишемо у нього наступний код:\n\n\nTerminal\n\ncode calculator.py\n\nДля початку ми попросимо користувача ввести перше число, а потім друге. Після цього ми виведемо результат додавання, віднімання, множення та ділення цих чисел. Давайте запустимо наш файл та перевіримо, чи працює наш калькулятор:\n\n# Запитати користувача про перше число\nfirst_number = input('Введіть перше число: ') # '1'\n\n# Запитати користувача про друге число\nsecond_number = input('Введіть друге число: ') # '2'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {first_number + second_number}')\n\n\n\nРезультат додавання: 1 + 2 = 3\n\n\nЩо тут відбувається? Чому результат додавання двох чисел дорівнює 12? Це тому, що ми використали метод input(), який завжди повертає рядок. Щоб вирішити цю проблему, нам потрібно перетворити рядок у ціле число. Для цього ми можемо використати функцію int(). Давайте виправимо наш код та перевіримо, чи працює наш калькулятор:\n\n# Запитати користувача про перше число\nfirst_number = int(input('Введіть перше число: ')) # '1'\n\n# Запитати користувача про друге число\nsecond_number = int(input('Введіть друге число: ')) # '2'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {first_number + second_number}')\n\n\n\nРезультат додавання: 1 + 2 = 3\n\n\nВзагалі то ми можемо написати весь наш калькулятор у одному рядку:\n\nprint(f'Результат додавання: {int(input(\"Введіть перше число: \")) + int(input(\"Введіть друге число: \"))}')\n\n\n\nРезультат додавання: 3\n\n\nОднак далеко не завжди перетворення типів проходить без помилок, наприклад, ми не зможемо зробити таке перетворення:\n\na = 'my number is 42'\nb = int(a) # отримаємо помилку\n\nValueError: invalid literal for int() with base 10: 'my number is 42'\n\n\nЦе означає, що рядок 'my number is 42' не може бути відразу представлена як ціле число. Ми могли б взяти з цього рядка лише число 42 і перевести його до цілого числа. Скоро ми навчимося так робити.\n\n\n\n\n\n\nПримітка\n\n\n\nЯкщо ви хочете дізнатися більше про цілі числа, то можете прочитати документацію.\n\n\n\n1.4.1 Рядки та їх незмінюваність\nРядки належать до незмінних об’єктів у Python. Які практичні наслідки виникають з того факту, що рядки, на відміну від списків, є незмінними об’єктами?\nЩоб показати, що рядки є незмінюваними об’єктами, ми можемо використати такий приклад коду:\n\nmy_string = \"abcde\"\nmy_string[0] = \"f\"\n\nTypeError: 'str' object does not support item assignment\n\n\nКоли ми запустимо цей код, ми отримаємо повідомлення про помилку TypeError, яке свідчить про те, що рядковий об’єкт не підтримує присвоєння елементу. Це відбувається тому, що в Python рядки - це незмінні об’єкти, їх не можна змінювати після створення. Якщо ми хочемо створити новий рядок на основі існуючого, то ми повинні створити новий об’єкт рядка. Наприклад, ми можемо створити новий рядок, який замінює перший символ рядка “a” на символ “f”, використовуючи такий код:\n\nmy_string = \"abcde\"\nnew_string = \"f\" + my_string[1:]\nprint(new_string)\n\nfbcde\n\n\nЦе створить новий рядок через використання рядка \"f\" і всіх символів з оригінального рядка, починаючи з індексу 1. Результатом буде рядок \"fbcde\" - новий рядок, який ми можемо використовувати далі в нашій програмі.\nЩоб остаточно закріпити відмінності в роботі зі змінюваними і незмінюваними об’єктами, давайте порівняємо списки і рядки:\n\nmy_str = \"Hello, world!\"\nprint(my_str.lower()) # поверне нам новий рядок\n\nhello, world!\n\n\n\nmy_list = [3, 2, 1]\nprint(my_list.append(4)) # нічого не поверне, змінить my_list\nprint(my_list)\n\nNone\n[3, 2, 1, 4]\n\n\nЖоден метод не змінить змінну my_str, а ось різні методи списків можуть змінити структуру списку my_list."
  },
  {
    "objectID": "python_basics.html#числа-з-плаваючою-комою",
    "href": "python_basics.html#числа-з-плаваючою-комою",
    "title": "1  Функції та змінні",
    "section": "1.5 Числа з плаваючою комою",
    "text": "1.5 Числа з плаваючою комою\nPython також підтримує числа з плаваючою комою (англ. floating point numbers). Це числа, які мають дробову частину. Наприклад, 3.14 - число з плаваючою комою. Щоб використати число з плаваючою комою, ми можемо використати тип float. Зараз наш калькулятор дещо наївно припускає, що користувач буде вводити лише цілі числа. Давайте виправимо це:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '1.2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3.4'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {first_number + second_number}')\n\n\n\nРезультат додавання: 1.2 + 3.4 = 4.6\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЯкщо ви хочете дізнатися більше про числа з плаваючою комою, то можете прочитати документацію.\n\n\nПрипустимо, що я не хочу, щоб остаточна відповідь була значенням з плаваючою комою, наприклад, 4.6. Я був би радий, якби ми просто округлили до найближчого цілого. Щоб це зробити, ми можемо використати функцію round(). Для початку давайте ознайомимося з документацією:\nround(number, ndigits=None)\n\nnumber - число, яке ми хочемо округлити\nndigits - кількість знаків після коми, до якої ми хочемо округлити число. Якщо ми не вказуємо цей аргумент, то число буде округлено до найближчого цілого.\n\nДавайте виправимо наш код та перевіримо, чи працює наш калькулятор:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '1.2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3.4'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {round(first_number + second_number)}')\n\n\n\nРезультат додавання: 1.2 + 3.4 = 5\n\n\nДавайте цього разу додамо 1 до 999:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '1'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '999'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {round(first_number + second_number)}')\n\n\n\nРезультат додавання: 1 + 999 = 1000\n\n\nВідповідь, звісно, тут має бути і є 1000, незалежно від того, округляємо ми чи ні. Це просто арифметика з цілими числами. Але в США, як правило, форматують довгі числа, ставлячи коми після або перед кожною трійкою цифр. В інших країнах все навпаки, там замість цього ставлять крапки та коми. Це системні налаштування.\nЩо, якщо я хочу, щоб це було виведено як 1,000, просто щоб було трохи зрозуміліше, що це саме тисяча? Якщо ви хочете, щоб Python вивів число з комами, для цього є спеціальна нотація з використанням двокрапки. Давайте спробуємо це:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '1'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '999'\n\n# Вивести результат додавання\nprint(f'Результат додавання: {first_number} + {second_number} = {first_number + second_number:,}')\n\n\n\nРезультат додавання: 1 + 999 = 1,000\n\n\nДавайте модифікуємо наш калькулятор, щоб він виконував ділення:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3'\n\n# Вивести результат ділення\nprint(f'Результат ділення: {first_number} / {second_number} = {first_number / second_number}')\n\n\n\nРезультат ділення: 2 / 3 = 0.6666666666666666\n\n\nЩо, якщо я хочу, щоб результат ділення був округлений до 2 знаків після коми? Ми знову повертаємось до функції round(), але цього разу ми передаємо другий аргумент, який вказує, до якого знаку після коми ми хочемо округлити. Давайте спробуємо це:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3'\n\n# Вивести результат ділення\nprint(f'Результат ділення: {first_number} / {second_number} = {round(first_number / second_number, 2)}')\n\n\n\nРезультат ділення: 2 / 3 = 0.67\n\n\nАле є інший спосіб зробити це, який може бути трохи зрозумілішим. Якщо ви хочете, щоб Python вивів число з комами, для цього є спеціальна нотація з використанням двокрапки. Для цього я додам запис 0.2f після двокрапки всередині f-рядку:\n\n# Запитати користувача про перше число\nfirst_number = float(input('Введіть перше число: ')) # '2'\n\n# Запитати користувача про друге число\nsecond_number = float(input('Введіть друге число: ')) # '3'\n\n# Вивести результат ділення\nprint(f'Результат ділення: {first_number} / {second_number} = {first_number / second_number:.2f}')\n\n\n\nРезультат ділення: 2 / 3 = 0.67\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nІноді для розв’язання задачі нам потрібно створити змінну і зберегти в ній нескінченність у математичному сенсі слова. Для цього нам допоможе така форма запису:\nx = float('inf')\nАналогічно до позитивної нескінченності float('inf'), float('-inf') є спеціальним значенням для чисел із плаваючою крапкою з негативною нескінченністю."
  },
  {
    "objectID": "python_basics.html#власні-функції",
    "href": "python_basics.html#власні-функції",
    "title": "1  Функції та змінні",
    "section": "1.6 Власні функції",
    "text": "1.6 Власні функції\nМи вже знаємо, що Python має вбудовані функції, такі як print(), input(), round() та інші. Але Python також дозволяє нам створювати власні функції. До цього моменту ми вже декілька разів писали програми, які просто казали “привіт”. І кожного разу я використовую print(), але хіба не було б чудово, якби ми могли просто викликати функцію hello(), яка б просто віталася за нас? Давайте спробуємо це зробити:\n\nname = input('Введіть ваше ім\\'я: ') # 'Гаррі'\nhello()\nprint(name)\n\n\n\nNameError: name 'hello' is not defined\n\n\nІ от ми отримали помилку, що функція hello() не визначена. Це означає, що ми не можемо викликати функцію, яку ми не визначили. Давайте визначимо функцію hello(). Для цього ми використаємо ключове слово def від англійського define (визначити). Давайте спробуємо це зробити:\n\ndef hello():\n    print('Привіт,')\n\nname = input('Введіть ваше ім\\'я: ') # 'Гаррі'\nhello()\nprint(name)\n\n\n\nПривіт,\nГаррі\n\n\nЧому б нам не подумати про те, як ми могли б параметризувати ту ж саму функцію? Тобто, чи можемо ми налаштувати hello(), щоб воно приймало ім’я користувача як вхідні дані, щоб ми могли сказати не тільки привітання, але й ім’я людини в одному рядку. Для цього нам потрібно передати ім’я як аргумент у функцію hello(). Давайте спробуємо це зробити:\n\ndef hello(name):\n    print('Привіт,', name)\n\nname = input('Введіть ваше ім\\'я: ') # 'Гаррі'\nhello(name)\n\n\n\nПривіт, Гаррі\n\n\nЗверніть увагу на відступи в нашому коді. Вони дуже важливі. Вони показують, що функція hello() належить до блоку коду, який починається з def hello(name): і закінчується з print('Привіт,', name). Відступ дорівнює 4 пробілам або одного табулятора. Це дуже важливо, оскільки в Python відступи використовуються для визначення блоків коду. Якщо ви не використовуєте правильні відступи, то ви отримаєте помилку:\n\nname = 'Гаррі'\n\ndef hello(name):\nprint('Привіт,', name)\n\nhello(name)\n\nIndentationError: expected an indented block after function definition on line 3 (2611194764.py, line 4)\n\n\nЧерговість записів у коді також важлива. Якщо ви спробуєте викликати функцію hello() до того, як ви її визначите, то ви отримаєте помилку:\n\nhello(name)\n\nname = 'Гаррі'\n\ndef hello(name):\n    print('Привіт,', name)\n\nПривіт, Гаррі\n\n\nІнтерпретатор Python сприйматиме вас буквально. І якщо ви використовуєте функцію, вона вже повинна існувати на момент її виклику.\nТепер давайте додамо значення за замовчування до функції hello(). Це означає, що якщо ми не передамо ім’я у функцію hello(), то вона використовуватиме значення за замовчуванням. Давайте спробуємо це зробити:\n\ndef hello(name='світ'):\n    print('Привіт,', name)\n\nhello()\n\nПривіт, світ\n\n\nАле ми можемо зануритися глибше і назвати свою функцію main(). Це не обов’язкова вимога, але це певна конвенція у світі програмування. Це означає, що це головна функція, яка виконується, коли ми запускаємо нашу програму. Давайте спробуємо це зробити:\n\ndef main():\n    name = input('Введіть ваше ім\\'я: ') # 'Гаррі'\n    hello(name)\n\ndef hello(name):\n    print('Привіт,', name)\n\nmain()\n\n\n\nПривіт, Гаррі\n\n\nВикликаючи головну функцію main() таким чином, це позбавляє мене від проблем з порядком записів у коді. Таким чином, я можу організувати свій код і впорядкувати його.\nА тепер дозвольте мені зробити ще одну технічну помилку. Я спробую прибрати значення name у функції hello():\n\ndef main():\n    name = 'Гаррі'\n    hello()\n\ndef hello():\n    print('Привіт,', name)\n\nmain()\n\nПривіт, Гаррі\n\n\nАле заковика в тому, що name тепер існує тільки в main(). Ця проблема називається областю видимості (англ. scope). Це означає, що змінні, які ви визначаєте всередині функції, не будуть доступні за межами цієї функції. Це означає, що name не існує всередині функції hello().\nДо цього наші функції не повертали нічого. Вони просто виводили щось на екран. Але що, якщо ми хочемо, щоб функція повертала значення? Для цього ми використовуємо ключове слово return. Давайте спробуємо це зробити на нашому калькуляторі. Напишемо функцію, яка буде повертати квадрат числа. Цю задачу можна вирішити різними шляхами, тож я пропоную паралельно познайомитися з новою функцією pow(), яка приймає два аргументи і повертає перший аргумент, піднесений до степеня, який вказаний другим аргументом. Давайте спробуємо це зробити:\n\ndef main():\n    x = int(input('Введіть число: ')) # '2'\n    print(f'Число {x} в квадраті дорівнює {square(x)}')\n\ndef square(n):\n    return pow(n, 2)\n\nmain()\n\n\n\nЧисло 2 в квадраті дорівнює 4"
  },
  {
    "objectID": "python_basics.html#інтерактивний-режим",
    "href": "python_basics.html#інтерактивний-режим",
    "title": "1  Функції та змінні",
    "section": "1.7 Інтерактивний режим",
    "text": "1.7 Інтерактивний режим\nВиявляється, у Python не обов’язково писати код у файлі на кшталт hello.py, а потім запускати його у вікні терміналу. Однією з особливостей, яка багатьом подобається в Python, є те, що він підтримує так званий інтерактивний режим (англ. interactive mode). Щоб запустити Python у інтерактивному режимі, відкрийте термінал та напишіть python:\n\n\nTerminal\n\n&gt; python\nPython 3.11.4 (tags/v3.11.4:d2340ef, Jun  7 2023, 05:45:37) [MSC v.1934 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n\nЯк бачите, з’явився новий символ &gt;&gt;&gt;. Це означає, що Python готовий приймати команди. Наприклад, якщо я напишу print('Hello, world!') та натисну Enter, то Python виведе рядок 'Hello, world!':\n\n\nTerminal\n\n&gt;&gt;&gt; print('Привіт, світ!')\nПривіт, світ!\n\nТакож, якщо я напишу 2 + 2 та натисну Enter, то Python виведе результат додавання двох чисел:\n\n\nTerminal\n\n&gt;&gt;&gt; 2 + 2\n4\n\nЩоб вийти з інтерактивного режиму, напишіть exit() та натисніть Enter:\n\n\nTerminal\n\n&gt;&gt;&gt; exit()\n&gt;"
  },
  {
    "objectID": "python_basics.html#завдання",
    "href": "python_basics.html#завдання",
    "title": "1  Функції та змінні",
    "section": "1.8 Завдання",
    "text": "1.8 Завдання\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.1  Давайте запрограмуємо кота! Створіть три змінні:\n\ncat_name з рядком як мінімум із двох символів\ncat_age з невід’ємним числом\nis_fluffy з True абоFalse`\n\n\n\nРішення\ncat_name = 'Azmodan'\ncat_age = 2\nis_fluffy = True\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.2  Давайте напишемо програму для пошуку довжини гіпотенузи. Створіть змінні a та b, в яких будуть записані довжини катетів прямокутного трикутника. Після чого розрахуйте c і збережіть у ній довжину гіпотенузи цього трикутника.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розрахунку довжини гіпотенузи використовуйте теорему Піфагора. А операція квадратного кореня аналогічна зведенню в ступінь 0.5.\n\n\n\n\n\nРішення\nc = (a**2 + b**2)**0.5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.3  У змінній father_age зберігається вік батька, а змінної son_age — вік сина. Порахуйте, через скільки років батько буде вдвічі старшим за сина. Результат збережіть змінну result.\nПриклад:\nfather_age = 20\nson_age = 3\nresult = 14\n\nfather_age = 30.5\nson_age = 5.1\nresult = 20.3\n\n\nРішення\nfather_age = 20\nson_age = 3\nresult = father_age - 2 * son_age\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.4  Задані дійсні числа a, b та с – сторони трикутника. Обчисліть периметр та площу трикутника. Результат збережіть у змінні perimeter та area відповідно.\nПриклад:\na = 3\nb = 4\nc = 5\n\nperimeter = 12\narea = 6\n\\[ S = \\sqrt{p(p-a)(p-b)(p-c)} \\] \\[ p = \\frac{a+b+c}{2} \\]\n\n\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПериметр – це сума довжин усіх сторін. Площу трикутника по трьох сторонах можна обчислити за допомогою формули Герона. Квадратний корінь - це зведення у ступінь 0.5.\nА ви знали, що Формула Герона міститься в «Метриці» Герона Олександрійського (I століття н. е.) і названа на його честь (хоча вона була відома ще Архімеду). Герон цікавився трикутниками з цілими сторонами, площі яких теж є цілими, такі трикутники звуться героновими, найпростішим героновим трикутником є єгипетський трикутник.\n\n\n\n\n\nРішення\na = 3\nb = 4\nc = 5\n\nperimeter = a + b + c\np = perimeter * 0.5\narea = (p * (p-a) * (p - b) * (p - c)) ** 0.5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.5  У змінну n збережено ціле число – кількість секунд. Напишіть програму, яка конвертує задану кількість секунд n на години, хвилини та секунди. Результат збережіть у змінні hours, minutes, seconds.\nТобто спочатку потрібно порахувати, скільки в число n помістилося цілих годин, цілих хвилин і скільки після цього залишилося секунд. Розглянемо приклад:\nn = 125\n\nhours = 0\nminutes = 2\nseconds  = 5\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nВам може допомогти цілочислове ділення // залишок від ділення %.\n\n\n\n\n\nРішення\nn = 125\nhours = n // 3600\nminutes = (n % 3600) // 60\nseconds = n % 60\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.6  У змінній price_new зберігається ціна кілограма бананів у числовому форматі, а змінної price_old — ціна кілограма бананів рік тому. Обчисліть, скільки відсотків за модулем змінилася ціна протягом року. Результат збережіть у змінну result. Результат округліть до двох знаків після коми.\nПриклад:\nprice_new = 89.99 \nprice_old = 75.50\nresult = 19.19\n\n\nprice_new = 24\nprice_old = 72\nresult = 66.67\n\n\nРішення\nprice_new = 89.99\nprice_old = 75.50\nresult = round(abs(price_new - price_old) / price_old * 100, 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.7  Створіть змінні:\n\na зі значенням 5 типу int\nb зі значенням '10' типу str\nc із значенням True типу bool.\n\nУ змінну my_sum збережіть суму трьох змінних, які ви створили, перетворивши b і з типу int.\n\n\nРішення\na = 5\nb = '10'\nc = True\nmy_sum = a + int(b) + int(c)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.8  У змінній a збережено число з десятковою частиною у форматі рядка, наприклад '3.14'. У змінну збережіть цілу частину з числа змінної a.\nПриклади:\na = '3.14'\nc = 3\n\na = '99.9'\nc = 99\n\na = '0.33'\nc = 0\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nВсе, що нам потрібно зробити, це перекласти змінну a в int. Відразу рядок '3.14' в int перекласти не вийде, подумайте, який тип потрібно перевести змінну на першому етапі?\n\n\n\n\n\nРішення\na = '3.14'\nc = int(float(a))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.9  У змінній x збережено ціле позитивне число. Обчисліть x + x0x0x. Результат збережіть змінну result.\nТобто якщо x = 2, то потрібно обчислити 2 + 20202.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nСпробуйте скласти два рядки за допомогою знака +\n\n\n\n\n\nРішення\nx = 2\nresult = x + int(str(x) + '0' + str(x) + '0' + str(x))\n\n# або\nresult = x + int(f'{x}0{x}0{x}') # але про це пізніше\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.10  Збережіть у змінний square рядок, який виводить на екран прямокутник 4 х 4, сформований із зірочок, розділених пробілом.\nprint(square)\n\n* * * *\n* * * *\n* * * *\n* * * *\n\n\nРішення\nsquare = '* * * *\\n' * 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.11  У змінній x міститься число з десятковою частиною але у форматі рядка. У змінну y збережіть ціле число, яке дорівнює десятковій частині числа x.\nПриклад:\n```{python}\nx = 3.14 \ny = 14 \n\nx = 2.02 \ny = 2\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПодумайте, які методи рядків допоможуть нам у цьому завданні.\n\n\n\n\n\nРішення\nx = 3.14\n\ny = int(str(x).split('.')[1])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.12  У змінну a збережено деяке речення, у якому можуть бути додані зайві пробіли. Напишіть програму, яка прибиратиме з a зайві пропуски і зберігатиме результат у змінну result. Усі слова мають бути розділені одним пропуском, а на початку та наприкінці речення пропусків бути не повинно.\nПриклад:\n```{python}\na = \"Я вивчаю нову мову програмування.   \"\nresult = \"Я вивчаю нову мову програмування.\"\n```\n\n\nРішення\na = \"Я вивчаю нову мову програмування.   \"\n\nresult = ' '.join(a.split())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.13  Напишіть програму, ґрунтуючись на введенні та виведенні в прикладах. Введенням буде рядок a. Результат збережіть у result.\nПриклад:\n```{python}\na = \"div*2\"\nresult = \"&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;\"\n\na = \"p*1\" \nresult = \"&lt;p&gt;&lt;/p&gt;\"\n\na = \"li*3\"\nresult = \"&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;\"\n```\n\n\nРішення\na = \"div*2\"\n\nstring, number = a.split('*')\nresult = f\"&lt;{string}&gt;&lt;/{string}&gt;\" * int(number)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.14  Напишіть програму, яка прийматиме рядок зі слів і повертатиме рядок, у якому ці слова будуть відсортовані в лексикографічному порядку. Початковий рядок міститься у змінній x, результат збережіть у result.\nПриклад:\n```{python}\nx = 'Світ надзвичайно широкий має укладисті далі'\nresult = 'Світ далі має надзвичайно широкий укладисті'\n```\n\n\nРішення\nx = 'Світ надзвичайно широкий має укладисті далі'\n\nresult = ' '.join(sorted(x.split()))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.15  Порахуйте, скільки разів у реченні x зустрічається рядок y. Результат збережіть у змінну result.\nПриклад:\n```{python}\nx = 'На підвіконні у вітальні в бабусі росли квіти, квіти були червоні та жовті, дуже гарні квіти.'\ny = 'квіти'\nresult = 3\n```\n\n\nРішення\nx = 'На підвіконні у вітальні в бабусі росли квіти, квіти були червоні та жовті, дуже гарні квіти.'\ny = 'квіти'\n\nresult = x.count(y)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.16  Напишіть програму, яка прийматиме номер кредитної картки card і повертатиме номер картки, у якому буде видно тільки останні 4 цифри. Інші цифри мають замінюватися зірочками. Результат збережіть у result.\nПриклад:\n```{python}\ncard = '5468350018455833'\nresult = '************5833'\n```\n\n\nРішення\ncard = '5468350018455833'\n\nresult = '*' * 12 + card[-4:]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 1.17  У змінній а збережено речення. Видаліть із речення всі входження слова або символу b. Результат збережіть у result.\nПриклад:\n```{python}\na = 'Вечірнє сонце, дякую за день!'\nb = 'e'\nresult = 'Вчірнє сонц, дякую за днь!'\n```\n\n\nРішення\na = 'Вечірнє сонце, дякую за день!'\nb = 'е'\n\nresult = a.replace(b, '')"
  },
  {
    "objectID": "python_conditionals.html#оператори-порівняння",
    "href": "python_conditionals.html#оператори-порівняння",
    "title": "2  Умовні оператори",
    "section": "2.1 Оператори порівняння",
    "text": "2.1 Оператори порівняння\nВиявляється, що Python постачається з великою кількістю вбудованого синтаксису. Наприклад, ось лише деякі з символів, які ви можете використовувати у Python, щоб ставити запитання, зокрема математичні.\nЗмінні та значення можна порівнювати між собою за допомогою операцій порівняння:\n\nx &lt; y: x строго менше y,\nx &lt;= y: x менше або дорівнює y,\nx &gt; y: x строго більше y,\nx &gt;= y: x більше або дорівнює y,\nx == y: x дорівнює y,\nx != y: x не дорівнює y.\n\nДля того, щоб ставити запитання з використанням цих символів нам знадобиться ще одне ключове слово в Python. І це ключове слово, досить просто, як і в англійській мові, - if. Ви можете задавати питання в Python-коді на кшталт: якщо відповідь на це питання істинна, то виконайте цей код для мене.\nДавайте створимо новий файл compare.py і спробуємо використати ці оператори порівняння:\n\n\nTerminal\n\ncode hello.py\n\nНаступний код буде порівнювати значення і приймати рішення на основі цих значень:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 2\n\nif x &lt; y:\n    print('x менше y')\nif x &gt; y:\n    print('x більше y')\nif x == y:\n    print('x дорівнює y')\n\n\n\nx менше y\n\n\nДавайте побудуємо діаграму того, як працює цей код:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x &lt; y}\n    B -- True --&gt; C[\"'x менше y'\"]\n    C --&gt; D{x &gt; y}\n    B -- False --&gt; D\n    D -- True --&gt; E[\"'x більше y'\"]\n    E --&gt; F{x == y}\n    D -- False --&gt; F\n    F -- True --&gt; G[\"'x дорівнює y'\"]\n    G --&gt; H(Кінець)\n    F -- False --&gt; H\n\n\nРисунок 2.1: Діаграма роботи коду з порівняннями\n\n\n\n\nЗа такої конфігурації коду, ми тричі викликаємо ключове слово if, щоб задати три різні запитання. Якщо відповідь на запитання є True, то виконується код, який знаходиться після нього. Якщо відповідь на запитання є False, то код, який знаходиться після нього, не виконується.\nТакий код виконує свою задачу, але він не є найкращим. Якщо ви помітите, ми використовуємо три окремі запитання, щоб визначити, яке з двох чисел є більшим. Це можна зробити краще, використовуючи ключове слово elif.\nelif - це скорочення від else if. Це означає, що якщо попередні запитання були False, то ви можете задати нове запитання. Якщо відповідь на це запитання є True, то виконується код, який знаходиться після нього. Якщо відповідь на це запитання є False, то код, який знаходиться після нього, не виконується. Давайте перепишемо наш код з використанням elif:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 2\n\nif x &lt; y:\n    print('x менше y')\nelif x &gt; y:\n    print('x більше y')\nelif x == y:\n    print('x дорівнює y')\n\n\n\nx менше y\n\n\nОтже, яке покращення я щойно зробив? Давайте подивимось на діаграму:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x &lt; y}\n    B -- True --&gt; C[\"'x менше y'\"]\n    C --&gt; H(Кінець)\n    B -- False --&gt; D{x &gt; y}\n    D -- True --&gt; E[\"'x більше y'\"]\n    E --&gt; H\n    D -- False --&gt; F{x == y}\n    F -- True --&gt; G[\"'x дорівнює y'\"]\n    G --&gt; H\n    F -- False --&gt; H\n\n\nРисунок 2.2: Діаграма роботи коду з порівняннями з elif\n\n\n\n\nЦього разу ми використовуємо три запитання, але якщо відповідь на перше запитання є True, то виконується код, який знаходиться після нього, і код, який знаходиться після наступних запитань, не виконується. Якщо відповідь на перше запитання є False, то виконується наступне запитання. Якщо відповідь на друге запитання є True, то виконується код, який знаходиться після нього, і код, який знаходиться після наступного запитання, не виконується. Якщо відповідь друге це запитання є False, то виконується наступне запитання. І так далі. Якщо відповідь на всі запитання є False, то жоден код не виконується.\nЩо це нам дає? Це дає нам можливість задавати багато запитань, але виконувати код лише одного запитання, якщо відповідь на нього є True. Це дозволяє нам писати більш читабельний код, а також економити час на виконання коду.\nАле, якщо замислитись, то чи є сенс задавати третє, останнє питання x == y? Число x може бути або меншим за y, або більшим за y, або дорівнюватиме y. Якщо виключити перші два сценарії, то логічно, що x має дорівнювати y. В таких випадках ми можемо використовувати ключове слово else і не перевіряти зайвої умови. Давайте перепишемо наш код з використанням else:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 1\n\nif x &lt; y:\n    print('x менше y')\nelif x &gt; y:\n    print('x більше y')\nelse:\n    print('x дорівнює y')\n\n\n\nx дорівнює y\n\n\nДавайте подивимось на діаграму:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x &lt; y}\n    B -- True --&gt; C[\"'x менше y'\"]\n    C --&gt; H(Кінець)\n    B -- False --&gt; D{x &gt; y}\n    D -- True --&gt; E[\"'x більше y'\"]\n    E --&gt; H\n    D -- False --&gt; F[\"'x дорівнює y'\"]\n    F --&gt; H\n\n\nРисунок 2.3: Діаграма роботи коду з порівняннями з else\n\n\n\n\nВи можете побачити на цих діаграмах відносне зменшення складності програми. Чим менше рядків коду, тим менша ймовірність того, що ви зробите помилку, і тим легше його читати іншим людям. Крім того, такий підхід дозволяє нам економити час на виконання коду, оскільки ми не будемо перевіряти зайві умови."
  },
  {
    "objectID": "python_conditionals.html#логічні-оператори-or-and-та-not",
    "href": "python_conditionals.html#логічні-оператори-or-and-та-not",
    "title": "2  Умовні оператори",
    "section": "2.2 Логічні оператори or, and та not",
    "text": "2.2 Логічні оператори or, and та not\nВи можете використовувати логічні оператори or, and та not для створення більш складних умов. Ці оператори дозволяють вам об’єднувати умови, щоб визначити, чи хочете ви виконати цей рядок коду або інший.\n\n2.2.1 Логічний оператор or\nЦього разу перевіримо, чи дорівнює x числу y. Для цього використаємо оператори or:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 2\n\nif x &lt; y or x &gt; y:\n    print('x не дорівнює y')\nelse:\n    print('x дорівнює y')\n\n\n\nx не дорівнює y\n\n\nДіаграма роботи коду з оператором or:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x &lt; y}\n    B -- True --&gt; C[\"'x не дорівнює y'\"]\n    C --&gt; H(Кінець)\n    B -- False --&gt; D{x &gt; y}\n    D -- True --&gt; C\n    D -- False --&gt; F[\"'x дорівнює y'\"]\n    F --&gt; H\n\n\nРисунок 2.4: Діаграма роботи коду з порівняннями з or\n\n\n\n\nЧи можемо ми покращити цей код? Так, можемо. Насправді нам не має потреби перевіряти дві умови щодо нерівності x та y. Значно краще одразу перевірити, чи не дорівнює x числу y. Для цього ми можемо викорситати оператор заперечення !=:\n\nx = int(input('Введіть число x: ')) # 1\ny = int(input('Введіть число y: ')) # 2\n\nif x != y:\n    print('x не дорівнює y')\nelse:\n    print('x дорівнює y')\n\n\n\nx не дорівнює y\n\n\nДіаграма роботи коду з оператором заперечення !=:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B{x != y}\n    B -- True --&gt; C[\"'x не дорівнює y'\"]\n    C --&gt; H(Кінець)\n    B -- False --&gt; D[\"'x дорівнює y'\"]\n    D --&gt; H\n\n\nРисунок 2.5: Діаграма роботи коду з оператором заперечення !=\n\n\n\n\nТакий код працює так само, як і попередній, але він є більш читабельним і ефективним.\n\n\n2.2.2 Логічний оператор and\nДавайте розберемо роботу ще одного оператора - and. Цей оператор дозволяє нам перевірити, чи виконуються обидві умови. Цього разу я пропоную створити програму grade.py, яка буде визначати оцінку студента за його балами:\n\n\nTerminal\n\ncode grade.py\n\nУ змінну score будемо приймати значення балу. Система оцінювання в різних університетах може дещо відрізнятися, але в цілому вона виглядає так:\n\n90 &lt;= score &lt;= 100 - A\n80 &lt;= score &lt; 90 - B\n70 &lt;= score &lt; 80 - C\n66 &lt;= score &lt; 70 - D\n60 &lt;= score &lt; 66 - E\n21 &lt;= score &lt; 60 - FX\nscore &lt; 20 - F\n\nДавайте напишемо код, який буде визначати оцінку студента за його балами:\n\nscore = int(input('Введіть бал: ')) # 90\n\nif score &gt;= 90 and score &lt;= 100:\n    print('Оцінка: A')\nelif score &gt;= 80 and score &lt; 90:\n    print('Оцінка: B')\nelif score &gt;= 70 and score &lt; 80:\n    print('Оцінка: C')\nelif score &gt;= 66 and score &lt; 70:\n    print('Оцінка: D')\nelif score &gt;= 60 and score &lt; 66:\n    print('Оцінка: E')\nelif score &gt;= 21 and score &lt; 60:\n    print('Оцінка: FX')\nelse:\n    print('Оцінка: F')\n\n\n\nОцінка: A\n\n\nPython дозволяє поміняти місцями score і відповідний бал при порівнянні. Такий код буде працювати так само, як і попередній:\n\nscore = int(input('Введіть бал: ')) # 80\n\nif 90 &lt;= score and score &lt;= 100:\n    print('Оцінка: A')\nelif 80 &lt;= score and score &lt; 90:\n    print('Оцінка: B')\nelif 70 &lt;= score and score &lt; 80:\n    print('Оцінка: C')\nelif 66 &lt;= score and score &lt; 70:\n    print('Оцінка: D')\nelif 60 &lt;= score and score &lt; 66:\n    print('Оцінка: E')\nelif 21 &lt;= score and score &lt; 60:\n    print('Оцінка: FX')\nelse:\n    print('Оцінка: F')\n\n\n\nОцінка: B\n\n\nКрім того, Python дозволяє об’єднувати діапазони порівнянь:\n\nscore = int(input('Введіть бал: ')) # 70\n\nif 90 &lt;= score &lt;= 100:\n    print('Оцінка: A')\nelif 80 &lt;= score &lt; 90:\n    print('Оцінка: B')\nelif 70 &lt;= score &lt; 80:\n    print('Оцінка: C')\nelif 66 &lt;= score &lt; 70:\n    print('Оцінка: D')\nelif 60 &lt;= score &lt; 66:\n    print('Оцінка: E')\nelif 21 &lt;= score &lt; 60:\n    print('Оцінка: FX')\nelse:\n    print('Оцінка: F')\n\n\n\nОцінка: C\n\n\nВ даному випадку це здебільшого естетичне покращення, Python все ще виконує ті ж самі порівняння.\nЯкщо переосмислити логіку, то можна зробити це ще краще. Якщо ми знаємо, що вхідні дані на даний момент будуть в межах від 0 до 100, ми можемо зробити деякі припущення: якщо score більше або дорівнює 90, то оцінка буде A, після цього ми можемо перевірити, чи score більше або дорівнює 80, якщо так, то оцінка буде B, і так далі. Це дозволить нам зменшити кількість перевірок, які ми робимо. Давайте перепишемо наш код:\n\nscore = int(input('Введіть бал: ')) # 70\n\nif score &gt;= 90:\n    print('Оцінка: A')\nelif score &gt;= 80:\n    print('Оцінка: B')\nelif score &gt;= 70:\n    print('Оцінка: C')\nelif score &gt;= 66:\n    print('Оцінка: D')\nelif score &gt;= 60:\n    print('Оцінка: E')\nelif score &gt;= 21:\n    print('Оцінка: FX')\nelse:\n    print('Оцінка: F')\n\n\n\nОцінка: C\n\n\nТака невеличка оптимізація дозволяє нам зменшити кількість перевірок і пришвидшити виконання коду."
  },
  {
    "objectID": "python_conditionals.html#парність-та-оператор",
    "href": "python_conditionals.html#парність-та-оператор",
    "title": "2  Умовні оператори",
    "section": "2.3 Парність та оператор %",
    "text": "2.3 Парність та оператор %\nДавайте розглянемо ще один приклад. Напишемо програму parity.py, яка буде перевіряти, чи є число парним:\n\n\nTerminal\n\ncode parity.py\n\nУ змінну x будемо приймати значення числа. Якщо число ділиться на 2 без остачі, то воно є парним. Давайте напишемо код, який буде перевіряти, чи є число парним:\n\nx = int(input('Введіть число: ')) # 2\n\nif x % 2 == 0:\n    print('Число парне')\nelse:\n    print('Число непарне')\n\n\n\nЧисло парне\n\n\nЯк ми можемо покращити цей результат? Згадаймо, що у нас є можливість вигадувати власні функції. Припустимо, що нам потрібно вміти визначати, чи є число парним або непарним. Ми можемо створити функцію is_even, яка буде приймати число і повертати True, якщо число парне, і False в протилежному випадку. Це називається булевими значеннями bool - один з типів даних в Python. Давайте перепишемо наш код:\n\ndef main():\n    x = int(input('Введіть число: ')) # 2\n\n    if is_even(x):\n        print('Число парне')\n    else:\n        print('Число непарне')\n\ndef is_even(n):\n    if x % 2 == 0:\n        return True\n    else:\n        return False\n\nmain()\n\n\n\nЧисло парне\n\n\nЧи можемо ми покращити дизайн цього коду? Так, можемо. І я покажу вам дещо, що зараз широко відоме як щось “пітоничне” (англ. pythonic) - це спосіб вирішення задачі притаманний мові програмування Python. Замість того, щоб ставити питання if-else, використовуючи чотири рядки, в Python ви можете згорнути його в один більш елегантний рядок коду:\n\ndef main():\n    x = int(input('Введіть число: ')) # 2\n\n    if is_even(x):\n        print('Число парне')\n    else:\n        print('Число непарне')\n\ndef is_even(n):\n    return True if n % 2 == 0 else False\n\nmain()\n\n\n\nЧисло парне\n\n\nЗгідно з ідеєю не просто писати правильний код, а писати все кращий і кращий код, але при цьому залишати його читабельним, я можу зробити ще кращий варіант: n % 2 == 0 поверне True, якщо n парне, і False в протилежному випадку. Таким чином, я можу просто повернути результат виразу n % 2 == 0:\n\ndef main():\n    x = int(input('Введіть число: ')) # 2\n\n    if is_even(x):\n        print('Число парне')\n    else:\n        print('Число непарне')\n\ndef is_even(n):\n    return n % 2 == 0\n\nmain()\n\n\n\nЧисло парне\n\n\nМабуть, це найелегантніший спосіб реалізувати цю задачу, але він може бути не так очевидним для початківців."
  },
  {
    "objectID": "python_conditionals.html#оператор-зіставлення-з-шаблонами-match",
    "href": "python_conditionals.html#оператор-зіставлення-з-шаблонами-match",
    "title": "2  Умовні оператори",
    "section": "2.4 Оператор зіставлення з шаблонами: match",
    "text": "2.4 Оператор зіставлення з шаблонами: match\nКлючове слово, яке ви можете використовувати в останніх версіях Python, називається match - це механізм зіставлення з шаблонами. Це дозволяє вам виконувати дії в залежності від значення змінної.\nСтворимо програму house.py, яка запитує у користувача його ім’я, а потім просто виводить гуртожиток1, на якому він навчається у книгах про Гаррі Поттера.\n\n\nTerminal\n\ncode house.py\n\nДля початку у змінну name будемо приймати ім’я. Далі за допомогою конструкції if-elif-else будемо визначати до якого гуртожитку належить студент. Давайте напишемо код:\n\nname = input('Введіть ім\\'я: ') # Драко\n\nif name == 'Гаррі':\n    print('Ґрифіндор')\nelif name == 'Герміона':\n    print('Ґрифіндор')\nelif name == 'Рон':\n    print('Ґрифіндор')\nelif name == 'Драко':\n    print('Слизерин')\nelse:\n    print('Хто?')\n\n\n\nСлизерин\n\n\nУ цьому коді є певна повторюваність: Гаррі, Герміона та Рон належать до Гріфіндору. Давайте об’єднаємо ці умови в одну:\n\nname = input('Введіть ім\\'я: ') # Герміона\n\nif name == 'Гаррі' or name == 'Герміона' or name == 'Рон':\n    print('Ґрифіндор')\nelif name == 'Драко':\n    print('Слизерин')\nelse:\n    print('Хто?')\n\n\n\nҐрифіндор\n\n\nЩо ж, виявляється, є ще один підхід, який, можливо, зробить ваш код трохи менш багатослівним. Ви можете уявити, наскільки складним може стати цей код, якщо у нас будуть не тільки Гаррі, Герміона і Рон, але й ціла купа інших імен для Грифіндору, Слизерину і всіх інших гуртожитків Гоґвортсу. Якщо ви хочете зробити це більш елегантним, ви можете використовувати ключове слово match:\n\nname = input('Введіть ім\\'я: ') # Рон\n\nmatch name:\n    case 'Гаррі':\n        print('Ґрифіндор')\n    case 'Герміона':\n        print('Ґрифіндор')\n    case 'Рон':\n        print('Ґрифіндор')\n    case 'Драко':\n        print('Слизерин')\n    case _:\n        print('Хто?')\n\n\n\nҐрифіндор\n\n\nЗверніть увагу на те, що я використовую _ для визначення варіанту за замовчуванням. Це означає, що якщо жоден з варіантів не відповідає значенню name, то виконається варіант за замовчуванням. Це дозволяє нам уникнути використання else в кінці.\nТепер у нас знову є три оператори case для Гаррі, Герміони та Рона. Для об’єднання цих трьох операторів case ми можемо використовувати оператор |:\n\nname = input('Введіть ім\\'я: ') # Гаррі\n\nmatch name:\n    case 'Гаррі' | 'Герміона' | 'Рон':\n        print('Ґрифіндор')\n    case 'Драко':\n        print('Слизерин')\n    case _:\n        print('Хто?')\n\n\n\nҐрифіндор\n\n\nЯк завжди у випадку з Python і програмуванням загалом, існують різні способи розв’язання цих задач. Це просто ще один інструмент у вашому арсеналі. Можливо, він покращив ситуацію та зробив ваш код більш читабельним.\nВарто зазначити, що Вам не потрібен оператор break для виходу з case, Ви просто використовуєте _ як паличку-виручалочку в кінці коду."
  },
  {
    "objectID": "python_conditionals.html#порівняння-рядків",
    "href": "python_conditionals.html#порівняння-рядків",
    "title": "2  Умовні оператори",
    "section": "2.5 Порівняння рядків",
    "text": "2.5 Порівняння рядків\nПорівняння рядків влаштовано трохи хитріше. Почнемо з простого та розглянемо порівняння двох однакових рядків:\n\nprint('abc' == 'abc')\n\nTrue\n\n\nА якщо записати так:\n\nprint('abc' &gt; 'abc')\n\nFalse\n\n\nДавайте розберемося, чому 'abc' &gt; 'aba' поверне нам True. Порівняння рядків у Python відбувається лексикографічно, тобто посимвольно зліва направо. Якщо символи збігаються, Python переходить до наступного символу в рядку і продовжує порівняти доти, доки не знайде різниця між символами в рядку. Якщо символи в рядках різняться, то Python визначає, який рядок “більше” (за алфавітом, у прямому значенні за номером в алфавіті). Якщо символи до цієї позиції збігаються, то рядок, у якого наступний символ більший, вважається “більшим”. При цьому, якщо літери збігаються, то також враховується розмір, маленька літера більша за великий 'a' &gt; 'A' . Розглянемо приклади:\n\nstr1 = 'hello'\nstr2 = 'world'\nprint(str1 &lt; str2 ) \n\nTrue\n\n\n\nstr1 = 'apple'\nstr2 = 'banana'\nprint(str1 &gt; str2) \n\nFalse\n\n\n\nstr1 = 'abc'\nstr2 = 'aba'\nprint(str1 &gt; str2 ) \n\nTrue"
  },
  {
    "objectID": "python_conditionals.html#завдання",
    "href": "python_conditionals.html#завдання",
    "title": "2  Умовні оператори",
    "section": "2.6 Завдання",
    "text": "2.6 Завдання\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.1  Вкажіть усі порівняння, внаслідок яких ми отримаємо True.\n\n'ІВАН' &lt; 'іван'\n'Python' &lt; 'R'\n'big number' != 'bug number'\n'ЯЯЯ' == 'Я Я'\n'гірка' &gt;= 'зірка'\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЯкщо ви сумніваєтеся, виконайте ці порівняння в Python і подивіться на результат.\n\n\n\n\n\n\n\n\n\nПравильні відповіді\n\n\n\n\n\n\n'ІВАН' &lt; 'іван': розмір букв відіграє роль при порівнянні, хоч це й однакове слово, але маленький “іван” більше.\n'Python' &lt; 'R': порівняння відбувається за першим символом, 'R' стоїть в алфавіті правіше, значить 'R' &gt; 'P', отримуємо True\n'big number' != 'bug number': рядки різняться в одному символі, отримуємо True\n'ЯЯЯ' == 'Я Я': пробіли грають роль при порівнянні, пробіл буде менше будь-якого символу. Отримуємо False.\n'гірка' &gt;= 'зірка': порівняння відбувається за першим символом, 'з' більше ніж 'г', отримуємо False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.2  У змінній m зберігається ціле позитивне число – тривалість сну в хвилинах. Якщо тривалість сну становитиме від 7 до 9 години включно, то в змінну optimal_sleep_duration збережіть значення True. В іншому випадку призначте це змінною значення False.\nПриклад:\nm = 410  \noptimal_sleep_duration = False\n\nm = 500\noptimal_sleep_duration = True\n\n\nРішення\nm = 410\noptimal_sleep_duration = m / 60 &gt;= 7 and m / 60 &lt;= 9\n\n# або\noptimal_sleep_duration = 7 * 60 &lt;= m &lt;= 9 * 60\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.3  У змінній x зберігається ціле число. Перевірте, чи це число ділиться без залишку на 3 і на 7. Результат збережіть в змінну result. Змінна результат повинен мати логічний тип даних.\nПриклад: - якщо x = 7, то result = False. - якщо x = 21, то result = True.\n\n\nРішення\nx = 21\nresult = x % 3 == 0 and x % 7 == 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.4  У змінних str_1 і str_2 збережено два рядки. Якщо рядки містять однакові літери, вам потрібно зберегти у змінну is_the_same_letters значення True, якщо літери в рядках відрізняються - збережіть у змінну значення False.\nМи не враховуємо порядок букв, їхню кількість і регістр.\nПриклад:\n```{python}\nstr_1 = 'AaB'\nstr_2 = 'Ab'\nis_the_same_letters = True \n\nstr_1 = 'Aa'\nstr_2 = 'AaB'\nis_the_same_letters = False\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПодивіться, що вийде, якщо застосувати set до рядка: set(str_1), як нам може це допомогти з рішенням?\n\n\n\n\n\nРішення\nstr_1 = 'AaB'\nstr_2 = 'Ab'\n\nis_the_same_letters = set(str_1.lower()) == set(str_2.lower())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.5  Дано два рядки str_1 і str_2. Збережіть у result True, якщо str_1 є анаграмою str_2, і False в іншому випадку. Регістр літер (велика чи маленька буква) не повинен впливати на роботу програми. Тобто 'Літо' і ‘Тіло’ ’це валідна анаграма.\nАнаграма - це слово або фраза, утворена шляхом перестановки літер іншого слова або фрази, зазвичай з використанням усіх вихідних літер рівно один раз.\nПриклад:\n```{python}\nstr_1 = \"Привіт\"\nstr_2 = \"Провал\"\nresult = False\n\nstr_1 = \"Літо\"\nstr_2 = \"Тіло\"\nresult = True\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nСпробуйте застосувати функцію sorted() до рядка.\n\n\n\n\n\nРішення\nstr_1 = \"Привіт\"\nstr_2 = \"Провал\"\n\nresult = sorted(str_1.lower()) == sorted(str_2.lower())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.6  У змінних a та b задано значення довжини та ширини прямокутника відповідно. Перевірте, чи є цей прямокутник квадратом.\nЗбережіть у змінну result значення True, якщо це квадрат, інакше False.\nПриклад:\n```{python}\n# Приклад 1\na = 121 \nb = 100 \nresult = False\n\n# Приклад 2\na = 10 \nb = 10 \nresult = True\n```\n\n\nРішення\na = 121\nb = 100\nresult = a == b\n\n# або\nresult = True if a == b else False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.7  У змінних a і b задано два числа. Квадрат якого числа більший? Збережіть це число в result.\nПриклад:\n```{python}\n# Приклад 1\na = 1 \nb = 2 \nresult = 2\n\n# Приклад 2\na = 2 \nb = -3 \nresult = -3\n```\n\n\nРішення\na = 1\nb = 2\nresult = a if a ** 2 &gt; b ** 2 else b\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.8  Катя і Діма вирішили купити квартиру в Києві. Сімейний бюджет обмежений, тому їм підходять такі варіанти:\n\nВартість не більше 1.5 млн, площа не менше 50 квадратних метрів, віддаленість від метро не більше 25 хвилин пішки.\nВартість не більше 1.3 млн, площа не менше 35 квадратних метрів, віддаленість від метро не більше 5 хвилин пішки.\n\nНапишіть програму, яка отримує на вхід вартість квартири p, площу s і віддаленість від метро d, і зберігає у змінну result повідомлення про те, підходить квартира чи ні у форматі True або False.\nПриклад:\n```{python}\n#Приклад 1\np = 1295000 #вартість\ns = 32 #площа\nd = 13 #віддаленість від метро\n\nresult = False\n\n#Приклад 2\np = 1498000 #вартість\ns = 51.9 #площа\nd = 23 #віддаленість від метро\n\nresult = True\n```\n\n\nРішення\np = 1295000\ns = 32\nd = 13\n\nresult = (p &lt;= 1500000 and s &gt;= 50 and d &lt;= 25) or (p &lt;= 1300000 and s &gt;= 35 and d &lt;= 5)\n\n# або\n\nif p &lt;= 1500000 and s &gt;= 50 and d &lt;= 25:\n    result = True\nelif p &lt;= 1300000 and s &gt;= 35 and d &lt;= 5:\n    result = True\nelse: \n    result = False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.9  Катя завершила навчання на курсі Machine Learning і набрала K балів за розв’язання задач. Щоб отримати сертифікат про проходження курсу, необхідно набрати щонайменше M балів. Якщо Катя набрала від L балів, то отримає сертифікат з відзнакою.\nЗмінні K, M і L уже визначені.\nНапишіть програму, яка збереже у змінну result інформацію про результати проходження курсу в такому форматі: - \"Недостатньо балів\", якщо Каті не вистачило балів для отримання сертифіката, - \"Сертифікат видано\", якщо Катя набрала кількість балів, необхідну для отримання сертифіката, - \"Видано сертифікат з відзнакою\", якщо Катя набрала ≥ L балів.\nПриклад:\n```{python}\n# Приклад 1\nK = 121 #кількість балів, отриманих Катею\nM = 100 #кількість балів, необхідна для отримання сертифіката\nL = 150 #кількість балів, необхідна для отримання сертифіката з відзнакою\n\nresult = \"Сертифікат видано\"\n\n# Приклад 2\nK = 148 \nM = 110 \nL = 145 \n\nresult = \"Видано сертифікат з відзнакою\"\n```\n\n\nРішення\nK = 121\nM = 100\nL = 150\n\nif K &lt; M:\n    result = \"Недостатньо балів\"\nelif K &gt;= L:\n    result = \"Видано сертифікат з відзнакою\"\nelse:\n    result = \"Сертифікат видано\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.10  Компанія вирішила виплатити співробітникам премію в розмірі:\n\n2 оклади, якщо його стаж роботи ≥ 2 роки\n5 окладів, якщо стаж роботи ≥ 5 років\n10 окладів, якщо стаж роботи ≥ 15 років\n\nУ змінній x - зарплата співробітника, у змінній y - стаж. Обчисліть розмір премії, результат збережіть у змінну result.\nПриклад:\n```{python}\n# Приклад 1\nx = 150000\ny = 3\nresult = 300000\n\n# Приклад 2\nx = 100000\ny = 1\nresult = 0\n\n# Приклад 3\nx = 200000\ny = 16\nresult = 2000000\n```\n\n\nРішення\nx = 150000\ny = 3\n\nif y &gt;= 15:\n    result = 10 * x\nelif y &gt;= 5:\n    result = 5 * x\nelif y &gt;= 2:\n    result = 2 * x\nelse:\n    result = 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.11  Дано словник dict_age, у якому зберігається інформація про вік трьох братів у форматі:\n\nключ - це ім’я\nзначення - це вік, число цілих років.\n\nЯкщо вік у братів різний і виходить однозначно визначити середнього брата, збережіть ім’я середнього брата у змінну result.\nЯкщо хоча б у двох братів вік однаковий, то збережіть у змінну result порожній рядок.\nПриклад:\n```{python}\ndict_age = {'Антон': 5, \n            'Денис': 14, \n            'Борис': 9}\nresult = 'Борис'\n\ndict_age = {'Марк': 5, \n            'Авель': 5, \n            'Карп': 9}\nresult = ''\n```\n\n\nРішення\ndict_age = {'Антон': 5, \n            'Денис': 14, \n            'Борис': 9}\n\nages = list(dict_age.values())\nif len(set(ages)) == 3:\n    middle_index = ages.index(sorted(ages)[1])\n    result = list(dict_age.keys())[middle_index]    \nelse:\n    result = ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.12  Напишіть програму, яка прийматиме довжини сторін трикутника a, b і c, визначатиме, чи є він прямокутним, і зберігатиме результат перевірки в result у форматі True або False.\n\nПрямокутний трикутник - це трикутник, у якому один кут прямий (тобто 90 градусів).\nНайдовша сторона (гіпотенуза) не обов’язково буде останнім аргументом.\nУсі аргументи будуть цілими числами.\n\nПриклад:\n```{python}\na = 3\nb = 5\nc = 4\nresult = True\n\na = 70\nb = 130\nc = 110\nresult = False\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПам’ятаєте теорему Піфагора? Квадрат гіпотенузи дорівнює сумі квадратів катетів (двох інших сторін)\n\n\n\n\n\nРішення\na = 3\nb = 5\nc = 4\n\nif a &gt; b and a &gt; c:\n    if a ** 2 == b ** 2 + c ** 2:\n        result = True\n    else:\n        result = False\nelif b &gt; a and b &gt; c:\n    if b ** 2 == a ** 2 + c ** 2:\n        result = True\n    else:\n        result = False\nelse:\n    if c ** 2 == a ** 2 + b ** 2:\n        result = True\n    else:\n        result = False\n\n# або\n\nvalues_list = sorted([a, b, c])\nif values_list[-1]**2 == values_list[0]**2 + values_list[1]**2:\n    result = True\nelse:\n    result = False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 2.13  Напишіть програму, яка буде вираховувати або довжину кола, або периметр квадрата, виходячи з переданих аргументів.\nНа вхід подаються буква у змінній f і число у змінній v.\nБуква визначатиме геометричну фігуру:\n'S' - квадрат 'С' - коло\nЯкщо буквою задано квадрат, то другий аргумент, число v, вважається довжиною сторони квадрата. В іншому випадку число вважається радіусом кола.\nРезультат збережіть у result\nЧисло pi візьміть рівним 3.14.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПам’ятаєте теорему Піфагора? Квадрат гіпотенузи дорівнює сумі квадратів катетів (двох інших сторін)\n\n\n\n\n\nРішення\nf = 'S'\nv = 5\n\nif f == 'S':\n    result = v * 4\nelse:\n    result = 2 * 3.14 * v"
  },
  {
    "objectID": "python_conditionals.html#footnotes",
    "href": "python_conditionals.html#footnotes",
    "title": "2  Умовні оператори",
    "section": "",
    "text": "В оригіналі використовується слово “house”. Я вирішив притримуватись офіційного українського перекладу.↩︎"
  },
  {
    "objectID": "python_loops.html#цикл-while",
    "href": "python_loops.html#цикл-while",
    "title": "3  Цикли",
    "section": "3.1 Цикл while",
    "text": "3.1 Цикл while\nКлючове слово while - це конструкція, яка дозволяє мені ставити питання знову і знову. Кожного разу, коли ми бачили питання, воно було у формі булевого виразу, True або False. Повертаючись до нашої попередньої програми, як я можу тричі надрукувати 'Няв!' і тричі поставити запитання, відповідь на яке була б True або False? Для цього нам необхідно задати змінну, яка буде відповідати за кількість нявкань. Назвемо її i (від ітерація). Ініціалізуємо її значенням 3. Потім ми можемо поставити питання: чи менше i за 0? Якщо так, то ми надрукуємо 'Няв!' і зменшимо i на одиницю. Це буде виглядати так:\n\ni = 3\nwhile i &gt; 0:\n    print(\"Няв!\")\n    i = i - 1\n\nНяв!\nНяв!\nНяв!\n\n\nТепер давайте подивимось на блок-схему цієї програми:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B[\"i = 3\"]\n    B --&gt; C{\"i &gt; 0\"}\n    C -- True --&gt; D[\"'Няв!'\"]\n    D --&gt; E[\"i = i - 1\"]\n    E --&gt; C\n    C -- False --&gt; F(Кінець)\n\n\nРисунок 3.2: Блок-схема програми cat.py з циклом while\n\n\n\n\nЦю задачу можна вирішити дещо й іншим шляхом. Програмісти досить часто починають відлік з нуля. Це умовність, і вона має навіть свої переваги. Тож ми ініціалізуємо i значенням 0, але змінимо умову на i &lt; 3. І тепер ми можемо збільшувати i на одиницю, а не зменшувати. Але і це ще не все, у випадках коли ми збільшуємо або зменшуємо якесь число, ми можемо скористатися спеціальними операторами += і -=. Таким чином, наш код можна спростити до наступного вигляду:\n\ni = 0\nwhile i &lt; 3:\n    print(\"Няв!\")\n    i += 1\n\nНяв!\nНяв!\nНяв!\n\n\nТакий підхід називається “синтаксичним цукром” (англ. syntactic sugar), тобто це не новий функціонал, а лише спрощений синтаксис для існуючого функціоналу. Такий підхід дозволяє зробити код трошки читабельним і зрозумілим.\nДавайте подивимось на блок-схему цієї програми:\n\n\n\n\n\n%%{init:{\"theme\":\"base\", \"flowchart\": {\"htmlLabels\": true}}}%%\n\nflowchart TB\n    A(Початок) --&gt; B[\"i = 0\"]\n    B --&gt; C{\"i &lt; 3\"}\n    C -- True --&gt; D[\"'Няв!'\"]\n    D --&gt; E[\"i += 1\"]\n    E --&gt; C\n    C -- False --&gt; F(Кінець)\n\n\nРисунок 3.3: Блок-схема програми cat.py з циклом while"
  },
  {
    "objectID": "python_loops.html#списки",
    "href": "python_loops.html#списки",
    "title": "3  Цикли",
    "section": "3.2 Списки",
    "text": "3.2 Списки\nДля демонстрації можливостей циклу for, нам слід познайомитися ще з однією ідеєю в Python, а саме списками list - це структура даних, яка дозволяє зберігати декілька значень у одній змінній. Списки в Python створюються за допомогою квадратних дужок [] і можуть містити будь-які значення, в тому числі інші списки.\nПринцип роботи циклу for полягає в тому, що він дозволяє ітераційно перебирати список елементів, наприклад так:\n\nfor i in [0, 1, 2]:\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nТакий код став коротшим, ніж варіант з циклом while. Список у цій програмі - це саме [0, 1, 2]. Але що в цьому варіанті коду не так? Якщо ми захочемо змінити кількість нявкань, нам доведеться змінювати список. Це не дуже зручно. Щоб цього уникнути, ми можемо скористатися функцією range(), яка дозволяє створити список послідовності чисел. Таким чином, ми можемо переписати наш код наступним чином:\n\nfor i in range(3):\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nДозвольне показати Вам ще дещо пітонічнє: зверніть увагу, що хоча я визначаю змінну i, я ніколи не використовую її. Але в Python є угода, що якщо вам потрібна змінна тільки тому, що функція програмування вимагає від неї певного підрахунку або автоматичного оновлення, але вам байдуже щодо її значення - назвіть цю змінну _. Це не змінить коректність програми, але це є сигнал колегам, які дивляться на ваш код. Це означає, що вам не потрібно буде звертати увагу на цю змінну, коли ви читаєте код:\n\nfor _ in range(3):\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nЧи можна зробити цей код ще більш пітонічним? Так, можна. Оскільки ми використовуємо рядки, які повторюються, ми можемо скористатися операцією множення рядків на число. При цьому слід не забувати, що ми хочемо виводити кожне \"Няв!\" у новому рядку (за допомогою \\n та end=\"\"). Таким чином, ми можемо переписати наш код наступним чином:\n\nprint(\"Няв!\\n\" * 3, end=\"\")\n\nНяв!\nНяв!\nНяв!\n\n\nДавайте запитаємо користувача, скільки разів цей кіт має нявкнути. Але в цьому випадку слід врахувати, що користувач має вказати позитивне число. Якщо користувач введе неправильне значення, ми маємо попросити його ввести число ще раз. Для цього ми можемо скористатися циклом while True, який буде виконуватися доти, доки не буде введено коректне значення. Таким чином, ми можемо переписати наш код наступним чином:\n\nwhile True:\n    n = int(input(\"Скільки разів кіт має нявкнути? \")) # 3\n        if n &gt; 0:\n            break\n\nfor _ in range(n):\n    print(\"Няв!\")\n\n\n\nНяв!\nНяв!\nНяв!\n\n\nЦикл while буде виконуватися доти, доки не буде введено коректне значення. Якщо користувач введе число, яке менше або дорівнює нулю, то цикл while буде виконуватися знову і знову. Якщо користувач введе коректне значення, то цикл while буде припинено за допомогою інструкції break і виконано цикл for.\nДавайте ще трошки попрактикуємо писати власні функції. Напишемо функцію cat(), яка буде нявкати задану кількість разів. Для цього нам потрібно передати цю кількість як аргумент функції. Таким чином, ми можемо переписати наш код наступним чином:\n\ndef main():\n    number = get_number()\n    cat(number)\n\ndef get_number():\n    while True:\n        n = int(input(\"Скільки разів кіт має нявкнути? \"))\n        if n &gt; 0:\n            break\n    return n\n\ndef cat(n):\n    for _ in range(n):\n        print(\"Няв!\")\n\nmain()\n\n\n3.2.1 Індексація списків\nПотренуємося працювати з індексами списків. До будь-якого елемента списку можна звернутися за його індексом. Запам’ятайте, що індексація починається з нуля.\n\nfruits = ['apple', 'banana', 'orange']\nprint(fruits[0])\n\napple\n\n\nТакож ми можемо робити зрізи:\n\nfruits = ['apple', 'banana', 'orange']\nprint(fruits[0:2])\n\n['apple', 'banana']\n\n\nДавайте створимо файл hogwarts.py в якому створимо список учнів Гоґвортсу:\n\n\nTerminal\n\ncode hogwarts.py\n\nЗмінну назвемо students і помістимо у неї список із трьох учнів:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nЯк мені роздрукувати список студентів? Для цього я можу скористатися індексом, який вказує на позицію елемента у списку за допомогою квадратних [] дужок після назви змінної. Індекси у списку починаються з нуля. Таким чином, якщо я хочу вивести першого студента, я можу використати індекс 0:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nprint(students[0])\nprint(students[1])\nprint(students[2])\n\nГаррі Поттер\nГерміона Грейнджер\nРон Уізлі\n\n\nАле ж має бути кращий спосіб, чи не так? Особливо, якщо я не знаю заздалегідь, хто буде в цьому списку. Якщо наступного року в Гоґвортсі з’являться нові учні, ми можемо використати цикл for для того, щоб вивести їх імена:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor student in students:\n    print(student)\n\nГаррі Поттер\nГерміона Грейнджер\nРон Уізлі\n\n\nДозвольте продемонструвати альтернативний варіант вирішення цієї задачі. Ми можемо використати комбінацію функції range() для визначення діапазону та функції len() для того, щоб отримати довжину списку. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor i in range(len(students)):\n    print(students[i])\n\nГаррі Поттер\nГерміона Грейнджер\nРон Уізлі\n\n\nА що, якщо я хочу крім імені студента вивести його номер у списку? Для цього я можу скористатися функцією enumerate(), яка дозволяє мені отримати індекс елемента у списку. Таким чином, я можу переписати наш код наступним чином:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor i, student in enumerate(students):\n    print(f\"{i + 1}: {student}\")\n\n1: Гаррі Поттер\n2: Герміона Грейнджер\n3: Рон Уізлі\n\n\n\n\n3.2.2 Методи списків\nПогляньмо на всі методи списку. Не треба заучувати їх напам’ять. Але якщо ви зіткнетеся із завданням, в якому треба буде щось зробити зі списком, то перед тим, як намагатися самому придумати рішення, подивіться, може бути потрібний метод.\n\nappend() - додає елемент у кінець списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.append('melon')\nprint(fruits)\n\n['apple', 'banana', 'orange', 'melon']\n\n\n\nclear() - видаляє всі елементи списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.clear()\nprint(fruits)\n\n[]\n\n\n\ncopy() - повертає копію списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits_copy = fruits.copy()\nprint(fruits_copy)\n\n['apple', 'banana', 'orange']\n\n\n\ncount(item) - повертає кількість елементів із заданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange', 'banana']\nprint(fruits.count('banana'))\n\n2\n\n\n\nextend(iterable) - додає елементи іншого списку до поточного. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.extend(['melon', 'watermelon'])\nprint(fruits)\n\n['apple', 'banana', 'orange', 'melon', 'watermelon']\n\n\n\nindex(item, start, end) - повертає індекс першого елемента, який збігається із заданим значенням (item) у діапазоні індексів від start до end. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange', 'banana']\nprint(fruits.index('banana'))\n\n1\n\n\n\ninsert(index, item) - додає елемент item на позицію index. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.insert(1, 'melon')\nprint(fruits)\n\n['apple', 'melon', 'banana', 'orange']\n\n\n\npop(index) - видаляє та повертає елемент із заданим індексом. Якщо індекс не вказано, видаляє та повертає останній елемент списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop(1)\nprint(removed_fruit)\n\nbanana\n\n\n\nremove(item) - видаляє перший елемент із заданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.remove('banana')\nprint(fruits)\n\n['apple', 'orange']\n\n\n\nreverse() - змінює порядок елементів у списку на зворотній. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.reverse()\nprint(fruits)\n\n['orange', 'banana', 'apple']\n\n\n\nsort(key, reverse) - сортує елементи списку. Наприклад:\n\n\nfruits = ['banana', 'orange', 'apple']\nfruits.sort()\nprint(fruits)\n\n['apple', 'banana', 'orange']"
  },
  {
    "objectID": "python_loops.html#словники-dict",
    "href": "python_loops.html#словники-dict",
    "title": "3  Цикли",
    "section": "3.3 Словники dict",
    "text": "3.3 Словники dict\nРозглянемо ще один тип структури даних в Python - словники dict. Словники в Python створюються за допомогою фігурних дужок {} і містять пари ключ-значення. Ключі у словниках мають бути унікальними, тобто не можуть повторюватися. Значення у словниках можуть бути будь-якого типу, в тому числі інші словники.\nПрипустимо, що ми хочемо відстежувати, хто до якого гуртожитку відноситься в Гоґвортсі. Для прикладу візьмемо чотирьох учнів:\n\n\n\n\n\n\n\n\n\nГерміона Грейнджер\nГаррі Поттер\nРон Уізлі\nДрако Малфой\n\n\n\n\nҐрифіндор\nҐрифіндор\nҐрифіндор\nСлизерин\n\n\n\nТож давайте додамо ще один створимо словник students:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nТепер давайте виведемо на екран ім’я та гуртожиток кожного учня. Для цього ми можемо скористатися циклом for. Але якщо ми спробуємо використати цикл for таким чином, як ми це робили раніше, то ми отримаємо лише імена учнів:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nfor student in students:\n    print(student)\n\nГерміона Грейнджер\nГаррі Поттер\nРон Уізлі\nДрако Малфой\n\n\nЩоб вивести ім’я та гуртожиток кожного учня, ми можемо скористатися індексацією словника за ключем. Індексація словника за ключем відбувається за допомогою квадратних дужок [] після назви змінної. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nfor student in students:\n    print(f\"{student}: {students[student]}\")\n\nГерміона Грейнджер: Ґрифіндор\nГаррі Поттер: Ґрифіндор\nРон Уізлі: Ґрифіндор\nДрако Малфой: Слизерин\n\n\nДавайте ускладнимо задачу і додамо ще одину характеристику до кожного учня - його Патронуса:\n\n\n\nІм’я\nГуртожиток\nПатронус\n\n\n\n\nГерміона Грейнджер\nҐрифіндор\nВидра\n\n\nГаррі Поттер\nҐрифіндор\nОлень\n\n\nРон Уізлі\nҐрифіндор\nТер’єр\n\n\nДрако Малфой\nСлизерин\n\n\n\n\nДля цього ми можемо використати список, який містить словники. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = [\n    {\n        \"ім'я\": \"Герміона Грейнджер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    {\n        \"ім'я\": \"Гаррі Поттер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    {\n        \"ім'я\": \"Рон Уізлі\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    {\n        \"ім'я\": \"Драко Малфой\",\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n]\n\nЗверніть увагу, що згідно канонічного варіанту Драко Малфой не має Патронуса. Тому ми вказали його значення як None - це спеціальне значення, яке означає “нічого”.\nДля виводу інформації про учнів ми можемо скористатися циклом for:\n\nstudents = [\n    {\n        \"ім'я\": \"Герміона Грейнджер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    {\n        \"ім'я\": \"Гаррі Поттер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    {\n        \"ім'я\": \"Рон Уізлі\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    {\n        \"ім'я\": \"Драко Малфой\",\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n]\n\nfor student in students:\n    print(student[\"ім'я\"], student[\"гуртожиток\"], student[\"патронус\"], sep=\", \")\n\nГерміона Грейнджер, Ґрифіндор, Видра\nГаррі Поттер, Ґрифіндор, Олень\nРон Уізлі, Ґрифіндор, Тер'єр\nДрако Малфой, Слизерин, None\n\n\nАльтернативний варіант створення словника students - це використання вкладених словників:\n\nstudents = {\n    \"Герміона Грейнджер\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    \"Гаррі Поттер\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    \"Рон Уізлі\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    \"Драко Малфой\": {\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n}\n\nfor student in students:\n    print(student, students[student][\"гуртожиток\"], students[student][\"патронус\"], sep=\", \")\n\nГерміона Грейнджер, Ґрифіндор, Видра\nГаррі Поттер, Ґрифіндор, Олень\nРон Уізлі, Ґрифіндор, Тер'єр\nДрако Малфой, Слизерин, None\n\n\n\n3.3.1 Створення словника\nУ Python є кілька способів створення словників. Ось деякі з них:\n\nЛітерали словника\n\nЛітерали словника являють собою список ключів і значень, укладених у фігурні дужки. Ключ і значення розділяються двокрапкою, а пари ключ-значення розділяються комою. Наприклад:\n\nmy_dict = {'ім\\'я': 'Аліса', 'вік': 25, 'місто': 'Київ'}\nprint(my_dict)\n\n{\"ім'я\": 'Аліса', 'вік': 25, 'місто': 'Київ'}\n\n\n\nВбудована функція dict()\n\nФункцію dict() можна використовувати для створення словників з інших послідовностей або для створення порожнього словника. Наприклад:\n\nempty_dict = dict()\nprint(empty_dict)\n\n{}\n\n\n\nfruit_dict = dict([('яблуко', 5), ('банан', 3), ('апельсин', 2)])\nprint(fruit_dict)\n\n{'яблуко': 5, 'банан': 3, 'апельсин': 2}\n\n\n\nГенератор словників\n\nГенератори словників дозволяють створювати словники на основі інших послідовностей. Наприклад:\n\nfruit_list = ['яблуко', 'банан', 'апельсин']\nfruit_dict = {fruit: len(fruit) for fruit in fruit_list}\nprint(fruit_dict)\n\n{'яблуко': 6, 'банан': 5, 'апельсин': 8}\n\n\n\nМетод fromkeys()\n\nМетод fromkeys() дає змогу створити словник із зазначеними ключами й одним і тим самим значенням для всіх ключів. Наприклад:\n\nfruit_list = ['яблуко', 'банан', 'апельсин']\nfruit_dict = {}.fromkeys(fruit_list, 0)\nprint(fruit_dict)\n\n{'яблуко': 0, 'банан': 0, 'апельсин': 0}\n\n\nПам’ятаєте, ми з вами говорили про frozenset (див. 4.0.2)? Одна з його корисних особливостей - frozenset можна використовувати як ключ словника. Припустимо, ми хочемо як ключ, зберігати одразу кілька значень - ім’я користувача і його вік.\n\nstudents_courses = {}\nname_age = frozenset(['Anatoly', 32])\nstudents_courses.update({name_age: ['Python', 'C++']})\nprint(students_courses)\n\n{frozenset({32, 'Anatoly'}): ['Python', 'C++']}\n\n\nЦе один із прикладів практичного застосування frozenset, якщо ми хочемо створити словник, де сам ключ - це масив із кількох елементів, то frozenset зможе нам допомогти. Список або звичайний set використовувати як ключ для словника не вийде.\nЦе лише деякі зі способів створення словників у Python. Кожен із них має свої особливості та може використовуватися залежно від конкретного завдання.\n\n\n3.3.2 Основні методи словників\n\nget() - дає змогу отримати значення за ключем, але на відміну від звернення через [], не викликає виняток KeyError, якщо ключ відсутній у словнику. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.get(\"two\"))\nprint(my_dict.get(\"four\", \"Key not found\"))\n\n2\nKey not found\n\n\n\nkeys() - дає змогу отримати список ключів словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.keys())\n\ndict_keys(['one', 'two', 'three'])\n\n\n\nvalues() - дає змогу отримати список значень словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.values())\n\ndict_values([1, 2, 3])\n\n\n\nitems() - дає змогу отримати список пар ключ-значення словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.items())\n\ndict_items([('one', 1), ('two', 2), ('three', 3)])\n\n\n\npop() - дає змогу видалити пару ключ-значення за ключем. Якщо ключ відсутній, викликає виняток KeyError або повертає другий аргумент, якщо він переданий. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.pop(\"two\"))\nprint(my_dict.pop(\"four\", \"Key not found\"))\n\n2\nKey not found\n\n\n\nclear() - дає змогу видалити всі пари ключ-значення зі словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nmy_dict.clear()\nprint(my_dict)\n\n{}\n\n\n\nupdate() - дає змогу оновити словник із іншого словника або із послідовності пар ключ-значення. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nnew_dict = {\"two\": 22, \"four\": 4}\nmy_dict.update(new_dict)\nprint(my_dict)\n\n{'one': 1, 'two': 22, 'three': 3, 'four': 4}\n\n\n\ncopy() - дає змогу створити копію словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nnew_dict = my_dict.copy()\nprint(new_dict)\n\n{'one': 1, 'two': 2, 'three': 3}\n\n\n\nsetdefault() - повертає значення за ключем. Якщо ключ відсутній, то він буде вставлений у словник із зазначеним значенням (або None, якщо значення не вказано). Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.setdefault(\"two\", 22))\nprint(my_dict.setdefault(\"four\"))\nprint(my_dict)\n\n2\nNone\n{'one': 1, 'two': 2, 'three': 3, 'four': None}\n\n\n\n\n3.3.3 pop() vs. remove()\nДавайте знову зупинимося на різниці цих методів. Методи pop() і remove() застосовуються для видалення елементів зі списків Python.\n\nМетод pop() видаляє та повертає останній елемент зі списку. Якщо в дужках вказати індекс елемента, буде видалено елемент із зазначеним індексом. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop()\nprint(fruits)\n\n['apple', 'banana']\n\n\n\nprint(removed_fruit)\n\norange\n\n\nА якщо ми хочемо видалити елемент за індексом, то потрібно вказати індекс у дужках методу:\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop(1)\nprint(fruits)\n\n['apple', 'orange']\n\n\n\nprint(removed_fruit)\n\nbanana\n\n\n\nМетод remove() видаляє перший елемент зі списку, який збігається з переданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.remove('banana')\nprint(fruits)\n\n['apple', 'orange']\n\n\nВажливо, що якщо у списку не буде елемента із зазначеним індексом або значенням, методи pop() та remove() повернуть помилки. Таким чином, основна відмінність між методами pop() і remove() полягає в тому, що pop() видаляє елемент за індексом, повертаючи його значення, а remove() видаляє перший знайдений елемент із заданим значенням."
  },
  {
    "objectID": "python_loops.html#цикли-та-маріо",
    "href": "python_loops.html#цикли-та-маріо",
    "title": "3  Цикли",
    "section": "3.4 Цикли та Маріо",
    "text": "3.4 Цикли та Маріо\nОдна з найпопулярніших ігор минулого століття - це Super Mario Bros. Це двовимірний світ, де персонажі рухаються вгору, вниз і вправо, не так часто вліво, перестрибуючи через піраміди і перешкоди на кшталт цих:\n\n\n\n\n\nДавайте просто реалізуємо дуже просту версію цих перешкод за допомогою Python, використовуючи просто # для позначення цеглинок.\nСтворимо програму mario.py:\n\n\nTerminal\n\ncode mario.py\n\nПочнемо з максимально простої версії, де ми просто виведемо на екран один стовпчик з трьох цеглинок:\n\nprint(\"#\")\nprint(\"#\")\nprint(\"#\")\n\n#\n#\n#\n\n\nАле ви можете собі уявити, що в грі стовпчики можуть ставати вищими або нижчими, тож було б непогано написати код, який був би трохи динамічнішим:\n\nfor _ in range(3):\n    print(\"#\")\n\n#\n#\n#\n\n\nДавайте подивимося, чи можемо ми зараз об’єднати наші знання написання власних функцій, щоб почати писати щось більш динамічне і вирішувати більш складні проблеми. Однією з приємних речей у функціях є те, що вони дозволяють нам не просто писати код, який ми можемо повторно використовувати. Вони дозволяють нам створювати абстракції, якщо хочете. Абстракція - це спрощення потенційно більш складної ідеї.\nПрипустимо, що я додумався створити функцію з назвою print_сolumn(), яка приймає один аргумент height - висота блоку, яка має бути надрукована. Таким чином, я можу переписати наш код наступним чином:\n\ndef main():\n    print_column(3)\n\ndef print_column(height):\n    for _ in range(height):\n        print(\"#\")\n\nmain()\n\n#\n#\n#\n\n\nАбо без використання циклу for:\n\ndef main():\n    print_column(3)\n\ndef print_column(height):\n    print(\"#\\n\" * height, end=\"\")\n\nmain()\n\n#\n#\n#\n\n\nУ певний момент Маріо зустрічає в небі нові цеглинки, які, якщо він підстрибне під ними, перетворяться на монети:\n\n\n\n\n\nДавайте спробуємо вивести ці чотири блоки у вигляді знаків питання ?. Створимо функцію print_row() з аргументом width - ширина. Таким чином, ми можемо переписати наш код наступним чином:\n\ndef main():\n    print_row(4)\n\ndef print_row(width):\n    print(\"?\" * width)\n\nmain()\n\n????\n\n\nПізніше Маріо спускається вниз, у світ лабіринтів з новими блоками, наприклад 3 на 3:\n\n\n\n\n\nСпробуємо відтворити цей блок за допомогою функції print_square() з аргументом size - розмір. Таким чином, ми можемо переписати наш код наступним чином:\n\ndef main():\n    print_square(3)\n\ndef print_square(size):\n    for i in range(size):\n        for j in range(size):\n            print(\"#\", end=\"\")\n        print()\n\nmain()\n\n###\n###\n###\n\n\nУ цьому коді ми використовуємо вкладені цикли for. Перший цикл for відповідає за виведення рядків, а другий цикл for відповідає за виведення стовпчиків. Таким чином, ми можемо вивести блоки, які складаються з рядків і стовпчиків.\nЯк ми можемо покращити код? Для початку ми можемо позбутися вкладеного циклу і замінити його просто функцією print():\n\ndef main():\n    print_square(3)\n\ndef print_square(size):\n    for i in range(size):\n        print(\"#\" * size)\n\nmain()\n\n###\n###\n###"
  },
  {
    "objectID": "python_loops.html#list-comprehension",
    "href": "python_loops.html#list-comprehension",
    "title": "3  Цикли",
    "section": "3.5 List comprehension",
    "text": "3.5 List comprehension\nList comprehension в Python - це компактний спосіб створення нового списку на основі наявного списку або іншої ітерованої послідовності, наприклад, рядка. Він дає змогу більш елегантно і стисло написати код, роблячи його більш читабельним і ефективним.\nЗагальний синтаксис для створення list comprehension виглядає наступним чином:\n```{python}\nnew_list = [expression for item in iterable if condition]\n```\nде:\n\nexpression - вираз, який застосовуватиметься до кожного елемента списку або послідовності\nitem - змінна, що представляє поточний елемент послідовності, що ітерується;\niterable - список або інша послідовність, що ітерується;\ncondition (необов’язково) - умова, за якою буде фільтруватися вихідна послідовність.\n\nНижче наведено кілька прикладів для кращого розуміння:\n\nПрипустимо, у нас є список із числами, ми хочемо створити новий список із квадратами цих чисел. Варіант рішення:\n\n\nnumbers = [1, 2, 3, 4, 5]\nsquares = []\nfor i in numbers:\n    squares.append(i**2)\n\nprint(squares)\n\n[1, 4, 9, 16, 25]\n\n\nА ось так виглядало б рішення за допомогою list comprehension:\n\nnumbers = [1, 2, 3, 4, 5]\nsquares = [x ** 2 for x in numbers]\n\nprint(squares)\n\n[1, 4, 9, 16, 25]\n\n\nІнакше кажучи, результат роботи нашого циклу відразу поміщається в список.\n\nСтворення нового списку, що містить тільки парні числа з вихідного списку:\n\nСтандартний розв’язок:\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = []\nfor i in numbers:\n    if i % 2 == 0:\n        even_numbers.append(i)\n\nprint(even_numbers)\n\n[2, 4]\n\n\nList comprehension:\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = [x for x in numbers if x % 2 == 0]\n\nprint(even_numbers)\n\n[2, 4]\n\n\n\nСтворення нового списку, що містить довжини слів із вихідного списку:\n\n\nwords = [\"hello\", \"world\", \"python\", \"list\"]\nword_lengths = [len(word) for word in words]\n\nprint(word_lengths)\n\n[5, 5, 6, 4]"
  },
  {
    "objectID": "python_loops.html#функція-enumerate",
    "href": "python_loops.html#функція-enumerate",
    "title": "3  Цикли",
    "section": "3.6 Функція enumerate",
    "text": "3.6 Функція enumerate\nФункція enumerate() у Python використовується для додавання індексів до елементів послідовності (наприклад, списку або рядка) під час ітерації по цій послідовності. Вона повертає об’єкт-лічильник, який містить пари (індекс, елемент).\nПрипустимо, у нас є список замовлень, кожне з яких представлено у вигляді словника з різними властивостями, такими як \"номер\", \"клієнт\", \"дата\" тощо. Наше завдання - вивести на екран інформацію за кожним замовленням, а також додати порядкові номери до кожної властивості цього замовлення.\n\norders = [\n    {\"номер\": \"001\", \"клієнт\": \"John\", \"дата\": \"2022-01-01\", \"статус\": \"в обробці\"},\n    {\"номер\": \"002\", \"клієнт\": \"Alice\", \"дата\": \"2022-01-02\", \"статус\": \"виконано\"},\n    {\"номер\": \"003\", \"клієнт\": \"Bob\", \"дата\": \"2022-01-03\", \"статус\": \"виконано\"},\n    {\"номер\": \"004\", \"клієнт\": \"Eva\", \"дата\": \"2022-01-04\", \"статус\": \"в обробці\"},\n]\nfor index, order in enumerate(orders, start=1):\n    print(f\"Замовлення {index}:\")\n    for key, value in order.items():\n        print(f\"{key}: {value}\")\n    print()\n\nЗамовлення 1:\nномер: 001\nклієнт: John\nдата: 2022-01-01\nстатус: в обробці\n\nЗамовлення 2:\nномер: 002\nклієнт: Alice\nдата: 2022-01-02\nстатус: виконано\n\nЗамовлення 3:\nномер: 003\nклієнт: Bob\nдата: 2022-01-03\nстатус: виконано\n\nЗамовлення 4:\nномер: 004\nклієнт: Eva\nдата: 2022-01-04\nстатус: в обробці\n\n\n\n\n\n\n\n\n\nУвага\n\n\n\nЗверніть увагу, ми явно вказали, що хочемо почати нумерацію з 1 за допомогою enumerate(orders, start=1). Функція enumerate() допомагає нам додати порядкові номери до кожного замовлення в списку ітерацією по ньому. Це може бути особливо корисно, коли нам потрібно обробляти й аналізувати дані з урахуванням їхніх позицій у структурі даних."
  },
  {
    "objectID": "python_loops.html#оператори-continue-та-break",
    "href": "python_loops.html#оператори-continue-та-break",
    "title": "3  Цикли",
    "section": "3.7 Оператори continue та break",
    "text": "3.7 Оператори continue та break\nОператор continue і оператор break є керуючими операторами в циклах, їх використовують для зміни поведінки виконання циклу.\nОператор continue використовується для пропуску частини тіла циклу, що залишилася, і переходу до наступної ітерації циклу. Якщо зустрінеться оператор continue, то код нижче за нього в поточній ітерації циклу не буде виконано, а виконання циклу продовжиться відразу з наступної ітерації.\nПриклад:\n\nfor i in range(1, 6):\n    if i == 3:\n        continue\n    print(i)\n\n1\n2\n4\n5\n\n\nУ цьому прикладі в циклі for ми перебираємо значення від 1 до 5. Якщо значення i дорівнює 3, оператор continue пропустить решту тіла циклу і перейде до наступної ітерації. У результаті у виводі буде пропущено число 3.\nОператор break використовується для переривання виконання циклу. Якщо зустрінеться оператор break, виконання циклу буде припинено і відбувається вихід із циклу.\nПриклад:\n\nfor i in range(1, 6):\n    if i == 3:\n        break\n    print(i)\n\n1\n2\n\n\nУ цьому прикладі в циклі for ми також перебираємо значення від 1 до 5. Однак, якщо значення i дорівнює 3, оператор break перериває виконання циклу. У результаті у виводі будуть тільки числа 1 і 2.\nТаким чином, оператор continue і оператор break дають змогу керувати потоком виконання циклів залежно від заданих умов. Ці оператори можуть бути дуже корисними при розв’язанні різних задач на програмування.\nДавайте розглянемо приклад їхнього спільного використання:\n\nemployees = [\n    {'name': 'John', 'qualification': 'low'},\n    {'name': 'Alice', 'qualification': 'high'},\n    {'name': 'Bob', 'qualification': 'medium'},\n    {'name': 'Eva', 'qualification': 'low'},\n    {'name': 'Mike', 'qualification': 'high'},\n    {'name': 'Lisa', 'qualification': 'medium'}\n]\nfound_high_qualification_employee = False\nfor employee in employees:\n    qualification = employee['qualification']\n    if qualification == 'low':\n        continue # Пропускаємо працівника з низькою кваліфікацією\n    elif qualification == 'high':\n        found_high_qualification_employee = True\n        high_qualification_employee = employee\n        break # Знайдено працівника з високою кваліфікацією, припиняємо пошук\nif found_high_qualification_employee:\n    print(\"Працівника з високою кваліфікацією знайдено!\")\n    print(high_qualification_employee)\nelse:\n    print(\"Працівника з високою кваліфікацією не знайдено.\")\n\nПрацівника з високою кваліфікацією знайдено!\n{'name': 'Alice', 'qualification': 'high'}\n\n\nУ цьому прикладі ми створюємо список employees, який містить дані про працівників. Потім ми проходимося по кожному працівнику в циклі for. Якщо рівень кваліфікації працівника низький (low), ми використовуємо оператор continue для пропуску поточного працівника і переходимо до наступного. Якщо рівень кваліфікації працівника високий (high), ми використовуємо оператор break для переривання циклу і запису інформації про знайденого працівника. Після виконання циклу ми перевіряємо, чи було знайдено працівника з високою кваліфікацією, і виводимо відповідну інформацію."
  },
  {
    "objectID": "python_loops.html#while-vs.-for",
    "href": "python_loops.html#while-vs.-for",
    "title": "3  Цикли",
    "section": "3.8 WHILE vs. FOR",
    "text": "3.8 WHILE vs. FOR\nwhile і for - це два основні типи циклів у мові програмування Python. Цикл while виконує набір інструкцій доти, доки вказана умова істинна. Наприклад, якщо вам потрібно виконати певну дію доти, доки користувач не введе правильне значення, ви можете використовувати цикл while. Приклад:\n```{python}\nsecret_number = 7\nguess = 0\nwhile guess != secret_number:\n    guess = int(input(\"Вгадайте число від 1 до 10: \"))\nprint(\"Вітаю, ви вгадали число!\")\n```\nЦикл for, з іншого боку, виконує набір інструкцій для кожного елемента в послідовності (наприклад, рядку, списку, кортежі тощо). Приклад:\n\nfruits = [\"яблуко\", \"банан\", \"груша\"]\nfor fruit in fruits:\n    print(fruit)\n\nяблуко\nбанан\nгруша\n\n\nЦикл while зазвичай використовується, коли невідома точна кількість повторень, а ви здебільшого покладаєтеся на перевірку умови для зупинки циклу. З іншого боку, цикл for зазвичай використовується, коли ви заздалегідь знаєте, скільки разів цикл повинен виконатися, і ви хочете працювати з елементами послідовності.\nВибір між циклом while і циклом for залежить від специфіки завдання. Якщо у вас є явно певна кількість елементів або потрібно опрацювати кожен елемент у послідовності, то цикл for може бути більш зручним вибором. Якщо ж ви чекаєте певної події або хочете повторювати дію до виконання певної умови, то цикл while буде більш підходящим."
  },
  {
    "objectID": "python_loops.html#завдання",
    "href": "python_loops.html#завдання",
    "title": "3  Цикли",
    "section": "3.9 Завдання",
    "text": "3.9 Завдання\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.1  У змінних a і b збережено два цілих додатних числа, таких що a &lt;= b. Напишіть програму, яка знаходить суму всіх чисел від a до b, кратних 3 або 5. Збережіть суму у змінну result. Якщо між a і b немає таких чисел, то збережіть у result нуль.\nПриклад:\n```{python}\n# Приклад 1\na = 1\nb = 10\nresult = 33\n\n# Приклад 2\na = 9\nb = 9\nresult = 9\n\n# Приклад 3\na = 1\nb = 2\nresult = 0\n```\n\n\nРішення\na = 1\nb = 10\n\nresult = 0\nfor i in range(a, b + 1):\n    if i % 3 == 0 or i % 5 == 0:\n        result += i\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.2  Напишіть програму на Python, яка визначає, чи є задане число num простим.\nЯкщо num - просте число, то збережіть у змінну result рядок \"це просте число\". Якщо число не просте, то збережіть у змінну result рядок \"це не просте число\".\nВикористовуйте цикл для розв’язання цієї задачі.\nПриклад:\n```{python}\n# Приклад 1\nnum = 7\nresult = \"це просте число\"\n\n# Приклад 2\nnum = 8\nresult = \"це не просте число\"\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПросте число - це число, яке ділиться тільки на 1 і на саме себе.\n\n\n\n\n\nРішення\nnum = 7\n\nresult = \"це просте число\"\nfor i in range(2, num):\n    if num % i == 0:\n        result = \"це не просте число\"\n        break\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.3  У змінній number збережено число, напишіть код, який перевірить, чи є number ступенем двійки? Ряд ступенів двійки:\n1, 2, 4, 8, 16, 32, 64 ...\nРезультат перевірки True або False збережіть у змінну is_two_power.\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПросте число - це число, яке ділиться тільки на 1 і на саме себе.\n\n\n\n\n\nРішення\nnumber = 64\n\nif number &lt; 1:\n    is_two_power = False\nelif number == 1:\n    is_two_power = True    \nelse:\n    while number % 2 == 0:\n        number = number / 2\n    is_two_power = number == 1\n\n# або\nis_two_power = False\nfor i in range(1, int(number) + 1):\n    if 2 ** i == number or number == 1:\n        is_two_power = True\n        break\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.4  Для приготування однієї порції еспресо потрібно приблизно 7 г. меленої кави. Для приготування лате необхідно збити 180 мл. молока і додати до еспресо, а для приготування капучино - 100 мл. молока.\nЗадано дві змінні:\n\ncoffee - запас меленої кави в кав’ярні (у кілограмах);\nmilk - запас молока в кав’ярні (у літрах).\n\nНапишіть програму, яка порахує, скільки відвідувачів зможе обслужити кав’ярня, якщо відомо, що: 1. У кав’ярні готують три напої на вибір: американо (еспресо + вода), лате і капучино. 2. Кожен відвідувач замовляє тільки один напій. 3. Відомо, що кожен третій замовлений напій - капучино, а кожен п’ятий - лате. 4. Якщо молоко закінчилося, то кав’ярня працює, доки не прийде відвідувач, який бажає замовити каву з молоком. 5. Запас води для американо не обмежений.\nРезультат збережіть у змінну visitors.\nНе забудьте перевести кілограми в грами, а літри - в мілілітри.\nПриклад:\n```{python}\n# Приклад 1\ncoffee = 0.1\nmilk = 1\nvisitors = 14\n\n# Приклад 2\ncoffee = 0.07\nmilk = 0.1\nvisitors = 4\n```\n\n\nРішення\ncoffee = 1\nmilk = 2\n\ncoffee *= 1000\nmilk *= 1000\nvisitors = 0\nwhile coffee &gt;=7:\n    if (visitors+1) % 3 == 0:\n        if milk &gt;=100:\n            milk -= 100\n            coffee -= 7\n            visitors += 1\n        else:\n            break\n    elif (visitors+1) % 5 == 0:\n        if milk &gt;= 180:\n            milk -= 180\n            coffee -= 7\n            visitors += 1\n        else:\n            break\n    else:\n        coffee -= 7\n        visitors += 1\n\n# або\ncoffee *= 1000\nmilk *= 1000\nvisitors = 0\nwhile True:\n    if coffee &lt; 7 or ((visitors + 1) % 3 == 0 and milk &lt; 100) or ((visitors + 1) % 5 == 0 and milk &lt; 180):\n        break\n    visitors += 1\n    coffee -= 7\n    if visitors % 3 == 0 :\n        milk -= 100\n    elif visitors % 5 == 0:\n        milk -= 180\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.5  Дано список чисел a. Напишіть програму, яка поверне True, якщо у списку більше непарних чисел, і False - у всіх інших випадках. Результат збережіть у result.\nПриклад:\n```{python}\n# Приклад 1\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nresult = True\n\n# Приклад 2\na = [1, 2, 3, 4, 5, 6, 7, 8, 10]\nresult = False\n\n# Приклад 3\na = [1, 2, 3, 4]\nresult = False\n```\n\n\nРішення\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\ncount_odd = 0\ncount_even = 0\nfor i in a:\n    if i % 2 == 0:\n        count_even += 1\n    else:\n        count_odd += 1\n\nresult = count_odd &gt; count_even\n\n# або\nresult = sum(1 if int(i) % 2 else -1 for i in a) &gt; 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.6  Є словник grades, що містить інформацію про шкільні предмети та їхні оцінки. У список good_subjects збережіть назви всіх предметів, у яких оцінка більша або дорівнює 7.\nПриклад:\n```{python}\ngrades = {\"Математика\": 9, \"Історія\": 6, \"Біологія\": 6, \"Географія\": 8}\ngood_subjects = [\"Математика\", \"Географія\"]\n\ngrades = {\"Алгебра\": 6, \"Геометрія\": 6}\ngood_subjects = []\n```\n\n\nРішення\ngrades = {\"Математика\": 9, \"Історія\": 6, \"Біологія\": 6, \"Географія\": 8}\n\ngood_subjects = []\nfor subject, grade in grades.items():\n    if grade &gt;= 7:\n        good_subjects.append(subject)        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.7  Напишіть програму, яка прийматиме список чисел nums і повертатиме два числа, абсолютна різниця яких мінімальна. Пару чисел збережіть у змінну result у вигляді списку, відсортованого за зростанням.\nЯкщо кілька пар дають мінімальну абсолютну різницю, виберіть ту пару елементів, сума яких більша.\nПриклад:\n```{python}\n# Приклад 1\nnums = [40, 16, 8, 17, 15]\nresult = [16, 17]\n# пара 16 і 15 не підходить, оскільки сума 16 і 17 більша за\n\n# Приклад 2\nnums = [0, 2, 35, 42, 45, 14, -6, -1]\nresult = [-1, 0]\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\n\nСтворіть змінну min_diff і збережіть у неї позитивну нескінченність. Це буде змінна зі значенням мінімальної абсолютної різниці. Далі почніть рахувати абсолютну різницю між числами в списку, на кожній ітерації перевіряйте, чи менша поточна різниця, ніж значення у змінній min_diff, якщо це так, то зберігайте в min_diff поточне значення і продовжуйте пошуки.\nЗапис нескінченності у Python: float(\"inf\") або float(\"-inf\").\n\n\n\n\n\n\nРішення\nnums = [40, 16, 8, 17, 15]\n\nmin_diff = float(\"inf\")\nresult = []\nfor i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n        diff = abs(nums[i] - nums[j])\n        if diff &lt; min_diff:\n            min_diff = diff\n            result = [nums[i], nums[j]]\n        elif diff == min_diff:\n            if sum(result) &lt; nums[i] + nums[j]:\n                result = [nums[i], nums[j]]\n\n# або\nnums.sort() \nmin_diff = float('inf')  \nresult = []\nfor i in range(len(nums) - 1):\n    diff = abs(nums[i] - nums[i+1])  \n    if diff &lt; min_diff:\n        min_diff = diff\n        result = [nums[i], nums[i+1]]\n    elif diff == min_diff and sum([nums[i], nums[i+1]]) &gt; sum(result):\n        result = [nums[i], nums[i+1]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.8  Напишіть програму, що приймає у вигляді аргументів два списки lst_1 і lst_2 і визначає, чи є вони протилежними один одному. Результат перевірки збережіть у result у форматі True або False.\nКожна пара списків складатиметься з однакових елементів (типу a і b). Список вважається анти-списком, якщо всі елементи в ньому протилежні відповідним елементам у першому списку.\nПриклад:\n```{python}\nlst_1 = [\"1\", \"0\", \"0\", \"1\"]\nlst_2 = [\"0\", \"1\", \"1\", \"0\"]\nresult = True\n\nlst_1 = [\"1\", \"0\", \"0\", \"1\"]\nlst_2 = [\"0\", \"1\", \"1\", \"1\"]\nresult = False\n```\n\n\nРішення\nlst_1 = [\"1\", \"0\", \"0\", \"1\"]\nlst_2 = [\"0\", \"1\", \"1\", \"0\"]\n\nresult = True\nfor i in range(len(lst_1)):\n    if lst_1[i] == lst_2[i]:\n        result = False\n        break\n\n# або\nresult = all({a, b} == set(lst_1) for a, b in zip(lst_1, lst_2))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.9  Задано змінну m - список зі списків однакової довжини. Перевірте, що суми елементів на діагоналях рівні.\nРезультат перевірки збережіть у result у форматі True або False.\nПриклад:\n```{python}\n# Приклад 1\nm = [[1, 23, 4], \n     [3, 2, 1],\n     [6, 3, 4]]\nresult = False\n\n# Приклад 2\nm = [[1, 23, 4], \n     [3, 2, 1],\n     [1, 3, 4]]\nresult = True\n```\n\n\nРішення\nm = [[1, 23, 4], \n     [3, 2, 1],\n     [6, 3, 4]]\n\nn = len(m)\nmain_diagonal_sum = sum(m[i][i] for i in range(n))\nsecondary_diagonal_sum = sum(m[i][n-i-1] for i in range(n))\nresult = main_diagonal_sum == secondary_diagonal_sum\n\n# або\n\nresult = sum([m[i][i] for i in range(len(m))]) == sum([m[i][len(m[i]) - i - 1] for i in range(len(m))])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.10  Напишіть програму, яка приймає словник input_dict і повертає рядок вигляду: ключ=значення&ключ=значення\nРядок має бути лексикографічно відсортований за ключами вихідного словника. Збережіть отриману відповідь у result.\nПриклад:\n```{python}\ninput_dict = {'lesson': 2, 'task': 21, 'course': 'python'}\nresult = 'course=python&lesson=2&task=21'\n```\n\n\nРішення\ninput_dict = {'lesson': 2, 'task': 21, 'course': 'python'}\n\nresult = '&'.join([f'{key}={value}' for key, value in sorted(input_dict.items())])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.11  Напишіть програму, яка приймає один рядок input_str і повертає інший result, у якому кожна буква вихідного рядка повторюється двічі.\nПриклад:\n```{python}\ninput_str = \"String\"\nresult = \"SSttrriinngg\"\n```\n\n\nРішення\ninput_str = \"String\"\n\nresult = ''.join([char * 2 for char in input_str])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.12  Напишіть програму, яка прийматиме число n і перевірятиме, чи кратна кожна його цифра цифрі, що стоїть ліворуч від неї. Відповідь збережіть у result у вигляді масиву булевих значень результатів перевірок.\nresult завжди має починатися з False, оскільки ліворуч від першої цифри нічого немає.\nПриклад:\n```{python}\nn = 54412\nresult = [False, False, True, False, True]\n```\n\n\nРішення\nn_str = str(n)\nresult = [False]\nfor i in range(1,len(n_str)):\n    if int(n_str[i-1]) == 0 or int(n_str[i]) % int(n_str[i-1]) != 0:\n        result.append(False)\n    else:\n        result.append(True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.13  Уявімо, що ми організовуємо іспит, у нас є список студентів, які мають виступити з усною доповіддю. Для виступу відбираються тільки ті студенти, які набрали понад 90 балів за письмову роботу. Наше завдання зробити так, щоб студенти виступали по черзі, відсортовані за прізвищем.\nНаприклад, якщо в нас є учасники Бабак, Андющенко, Власенко, то виступати вони мають у такому порядку: Андющенко, Бабак, Власенко.\nУ словнику students збережено дані про студентів, ключ - прізвище, значення - кількість балів за іспит, створіть список students_order, у якому кожен елемент - це кортеж (tuple) з номером виступу студента та його прізвищем. У students_order мають бути тільки ті студенти, у яких понад 90 балів. Порядок визначається сортуванням за прізвищем.\nПриклад:\n```{python}\nstudents = {'Бабак': 80, 'Андющенко': 99, 'Власенко': 100}\nstudents_order = [(1, 'Андющенко'), (2, 'Власенко')]\n```\n\n\nРішення\nstudents = {'Бабак': 80, 'Андющенко': 99, 'Власенко': 100}\n\nstudents_order = [name for name in sorted(students.keys()) if students[name] &gt; 90]\nstudents_order = list(enumerate(students_order, 1))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.14  Давайте навчимося розгадувати таємні шифри! У my_string зберігається зашифрований рядок, наприклад:\n```{python}\nmy_string = 'qircxfcgwxeciscwgwvzlfrciclibecpfvqzg'\n```\nУ словнику secret_dict зберігається ключ до шифру, набір символів, які потрібно замінити:\n```{python}\nsecret_dict = {\n 'b': 'k',\n 'c': ' ',\n 'g': 'n',\n 'q': 'h',\n 'z': 'o',\n 'v': 't',\n 'w': 'a',\n 'f': 'y',\n 'x': 'm',\n 'r': ','}\n```\nТаким чином, словник secret_dict каже нам, що в рядку my_string літеру “b” потрібно замінити на “k”, “c” на “пробіл” тощо. Якщо ми зробимо такі заміни в рядку my_string, то 'qircxfcgwxeciscwggwwvzlfrciclibecpfvvqzg' перетвориться на 'hi, my name is anatoly, i like python'.\nНапишіть програму, яка розшифровує рядок my_string за допомогою словника secret_dict. Розшифрований рядок збережіть у змінну decrypted_string.\nПриклад:\n```{python}\nmy_string = 'zis jqd qbdx qjjgsd bcd zjm fbc bvbx'\nsecret_dict = {\n'v': 'w',\n'x': 'y',\n'i': 'h',\n'q': 'l',\n'c': 'n',\n'b': 'a',\n'f': 'r',\n'j': 'o',\n's': 'e',\n'z': 't',\n'g': 'k'}\n\ndecrypted_string = 'the old lady looked and tom ran away'\n```\n\n\nРішення\nmy_string = 'zis jqd qbdx qjjgsd bcd zjm fbc bvbx'\nsecret_dict = {\n'v': 'w',\n'x': 'y',\n'i': 'h',\n'q': 'l',\n'c': 'n',\n'b': 'a',\n'f': 'r',\n'j': 'o',\n's': 'e',\n'z': 't',\n'g': 'k'}\n\ndecrypted_string = ''\nfor letter in my_string:\n    if letter in secret_dict:\n        decrypted_string += secret_dict[letter]\n    else:\n        decrypted_string += letter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.15  У змінну cities_population збережіть словник із трьома ключами: 'Київ', 'Париж', 'Токіо'. Як значення збережіть населення цих міст у млн. осіб: 2.88, 2.16, 13.96. Ключами нашого словника будуть рядки, значеннями - числа у форматі float.\n\n\nРішення\ncities_population = {\n    'Київ': 2.88,\n    'Париж': 2.16,\n    'Токіо': 13.96\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.16  Дано словник dict_input. Поміняйте ключі та значення місцями. Результат збережіть у result.\nПриклад:\n```{python}\ndict_input = {\"1\": 11, \"2\": 22, \"3\": 33}\nresult = {11: \"1\", 22:\"2\", 33:\"3\"}\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nВаріантів рішення може бути декілька. Згадайте про методи словників, які ви вивчили у цьому уроці. Також згадайте про функцію zip(), яка дозволяє об’єднати дві послідовності у послідовність пар див. 4.4. Або використайте генератор словників.\n\n\n\n\n\nРішення\ndict_input = {\"1\": 11, \"2\": 22, \"3\": 33}\nresult = dict(zip(dict_input.values(), dict_input.keys()))\nresult = {value: key for key, value in dict_input.items()}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.17  Катя - власник невеликого кондитерського виробництва, на якому виготовляють еклери. У нас є словник data, у якому міститься інформація про собівартість одиниці товару cost_price, ціну продажу sell_price та кількість товару eclairs. Потрібно порахувати, який прибуток Катя отримує після продажу своєї продукції. Результат збережіть у змінну result, округливши суму до цілого числа.\nПриклад:\n```{python}\ndata = {\n  \"cost_price\": 225.89,\n  \"sell_price\": 550.00,\n  \"eclairs\": 100\n}\nresult = 32411\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nПрибуток = продажна ціна - собівартість\n\n\n\n\n\nРішення\ndata = {\n  \"cost_price\": 225.89,\n  \"sell_price\": 550.00,\n  \"eclairs\": 100\n}\n\nresult = round((data[\"sell_price\"] - data[\"cost_price\"]) * data[\"eclairs\"])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.18  Є словник student, у якому зберігаються ім’я студента і список його оцінок. У result збережіть словник з ім’ям студента та найвищою його оцінкою.\nПриклад:\n```{python}\nstudent = {\"name\": \"Ihor\", \"notes\": [4, 5, 4]}\nresult = {\"name\": \"Ihor\", \"max_note\": 5}\n```\n\n\nРішення\nstudent = {\"name\": \"Ihor\", \"notes\": [4, 5, 4]}\nresult = {\"name\": student[\"name\"], \"max_note\": max(student[\"notes\"])}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.19  Антон навчається на Data Scientist. У словнику anton_courses зберігається інформація про завершені ним курси та кількість набраних балів. Дані в словнику зберігаються у форматі ключ - назва курсу, значення - кількість балів у числовому форматі. Антон завершив навчання на курсі Machine Learning і набрав 120 балів. Додайте до словника anton_courses цю інформацію. У змінну courses збережіть список пройдених курсів. У змінну DataAnalyst збережіть кількість балів, набрану Антоном на однойменному курсі, ця інформація є в словнику.\nПриклад:\n```{python}\nanton_courses = {'Python for Data Science': 56, \n                 'Statistics': 87, \n                 'Data Analyst': 140}\n# -&gt; \nanton_courses = {'Python for Data Science': 56, \n                 'Statistics': 87, \n                 'Data Analyst': 140, \n                 'Machine Learning': 120}\ncourses = ['Python for Data Science', 'Statistics', 'Data Analyst', 'Machine Learning']\nDataAnalyst = 87\n```\n\n\nРішення\nanton_courses = {'Python for Data Science': 56, \n                 'Statistics': 87, \n                 'Data Analyst': 140}\n\nanton_courses['Machine Learning'] = 120\ncourses = list(anton_courses.keys())\nDataAnalyst = anton_courses['Data Analyst']\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.20  У нас є магазин одягу LARA. У словнику shop_stock зберігається інформація про товари, наявні на складі магазину. Інформація вказана у форматі ключ - артикул товару, значення - кількість одиниць. У магазин поставили нову партію товарів, у словнику shop_new_goods записано інформацію про поставлені товари та їхню кількість. Створіть словник result, який міститиме інформацію і про товари на складі, і про товари з нової поставки. Відомо, що якщо на складі залишалася хоча б одна одиниця якогось типу товару, то товару цього типу не було в поставці.\nПриклад:\n```{python}\nshop_stock = {\"2358241350-50\": 1, \"2358000350-30\": 24, \"2358241350-00\": 3}\nshop_new_goods = {\"2358241350-60\": 10}\n# -&gt; \nresult = {\"2358241350-50\": 1, \"2358000350-30\": 24, \"2358241350-00\": 3, \"2358241350-60\": 10}\n```\n\n\nРішення\nshop_stock = {\"2358241350-50\": 1, \"2358000350-30\": 24, \"2358241350-00\": 3}\nshop_new_goods = {\"2358241350-60\": 10}\n\nresult = shop_stock.copy()\nresult.update(shop_new_goods)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.21  Магазин Avocado зберігає інформацію про наявні фрукти та овочі у словнику input_dict у форматі ключ - назва фрукта або овоча, значення - кількість кілограмів у наявності. Порахуйте, скільки всього кілограмів фруктів і овочів є в магазині. Результат збережіть у змінну result.\nПриклад:\n```{python}\ninput_dict = {\"морква\": 10.44, \"капуста\": 5.06, \"полуниця\": 3}\n# -&gt; \nresult = 18.5\n```\n\n\nРішення\ninput_dict = {\"морква\": 10.44, \"капуста\": 5.06, \"полуниця\": 3}\nresult = sum(input_dict.values())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.22  Є словник courses, що містить інформацію про вартість навчання в різних курсах. Інформація вказана у форматі: ключ - назва курсу, значення - вартість навчання.\nЗнайдіть ціну найдорожчого курсу. Результат збережіть у result.\nПриклад:\n```{python}\ncourses = {\"Python\": 80000, \"SQL\": 300000}\n# -&gt; \nresult = 300000\n```\n\n\nРішення\ncourses = {\"Python\": 80000, \"SQL\": 300000}\nresult = max(courses.values())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.23  У базі даних КНЕУ інформація про студентів і кафедри, до яких вони прикріплені, зберігається в словнику kaf_sudents у форматі: ключ - ПІ студента, значення - код кафедри.\nПісля другого курсу за підсумками останніх двох сесій було складено рейтинг студентів, на основі якого стався перерозподіл студентів за кафедрами. Частина студентів продовжила навчання на своїй кафедрі, а деякі студенти перейшли з однієї кафедри на іншу. Інформація про студентів, які перейшли на нову кафедру, зберігається в словнику new_kaf_students.\nОновіть інформацію в словнику kaf_sudents, додавши в словник дані з new_kaf_students.\nПриклад:\n```{python}\nkaf_sudents = {'Дробина Юлія': 100}\nnew_kaf_students = {'Нечаєнко Георгій': 200}\n\nkaf_sudents = {'Дробина Юлія': 100, 'Нечаєнко Георгій': 200}\n```\n\n\nРішення\nkaf_sudents = {'Дробина Юлія': 100}\nnew_kaf_students = {'Нечаєнко Георгій': 200}\n\nkaf_sudents.update(new_kaf_students)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.24  my_list зберігає список як мінімум з двома елементами.\nСтворіть змінні:\n\nfirst_item з першим елементом списку.\nlast_item з останнім елементом списку.\nreversed_list з елементами списку my_list у зворотному порядку.\neven_items з елементами списку my_list із парними індексами.\n\nПриклади:\nmy_list = ['apple', 123, True, 3.14, 'cherry', 45, 22]\n\nfirst_item = 'apple'\nlast_item = 22\nreversed_list = [22, 45, 'cherry', 3.14, True, 123, 'apple']\neven_items = ['apple', True, 'cherry', 22]\n\n\nРішення\nmy_list = ['apple', 123, True, 3.14, 'cherry', 45, 22]\n\nfirst_item = my_list[0]\nlast_item = my_list[-1]\nreversed_list = my_list[::-1]\neven_items = my_list[::2]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.25  У змінній my_list збережено не порожній список, де є число 11.\nЗнайдіть перший індекс числа 11 my_list, збережіть індекс в змінну eleven_index.\nУ змінну ten_count збережіть скільки разів у списку my_list зустрічається число 10.\nПриклад:\n```{python}\nmy_list = [1, 10, 0, 10, 11]\neleven_index = 4\nten_count = 2\n\n\nmy_list = [11, 2, 0, 6]\neleven_index = 0\nten_count = 0\n```\n\n\nРішення\nmy_list = [11, 2, 0, 6]\neleven_index = my_list.index(11)\nten_count = my_list.count(10)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.26  У student_names збережено список з іменами студентів, додайте до списку два імені 'Anatoly' та 'Oksana'.\nУ scores збережено список із десяти цілих чисел, видаліть із нього другий, п’ятий та останній елемент.\nУ lessons збережений список з назвою уроків, відсортуйте назви уроків у списку за абеткою.\nПриклад:\n```{python}\nstudent_names = ['Ian', 'Ivan']\nscores = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlessons = ['Python', 'Analytics']\n\n# =&gt;\n\nstudent_names = ['Ian', 'Ivan', 'Anatoly', 'Oksana']\nscores = [0, 2, 3, 5, 6, 7, 8, 9]\nlessons = ['Analytics', 'Python']\n```\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЗверніть увагу, що потрібно видалити другий, п’ятий та останній елемент із списку. Коли ви видалили один елемент, індекси інших елементів змінились.\n\n\n\n\n\nРішення\nstudent_names = ['Ian', 'Ivan']\nstudent_names.append('Anatoly')\nstudent_names.append('Oksana')\n\nscores = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nscores.pop(1)\nscores.pop(3)\nscores.pop()\n\nlessons = ['Python', 'Analytics']\nlessons.sort()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.27  Дано два списки list_1 і list_2. Відсортуйте list_1 за зростанням, а list_2 за спаданням. Поєднайте list_1 та list_2 в один відсортований за зростанням список list_3. У змінну list_3_len збережіть довжину list_3.\nПриклад:\n```{python}\nlist_1 = [1, 5, 3]\nlist_2 = [2, 8]\n# -&gt; \nlist_1 = [1, 3, 5]\nlist_2 = [8, 2]\nlist_3 = [1, 2, 3, 5, 8]\nlist_3_len = 5\n```\n\n\nРішення\nlist_1 = [1, 5, 3]\nlist_2 = [2, 8]\nlist_1.sort()\nlist_2.sort(reverse=True)\nlist_3 = sorted(list_1 + list_2)\nlist_3_len = len(list_3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.28  У змінній a зберігається список цілих невід’ємних чисел. Кількість чисел парна. Напишіть програму, яка ділитиме цей список навпіл, визначатиме суми чисел у половинах списку (sum_left і sum_right). Якщо sum_left дорівнює sum_right, то збережіть у змінну result значення True, в іншому випадку - False.\nПриклад:\n```{python}\na = [1, 2, 4, 3]\n\nsum_left = 3\nsum_right = 7\nresult = False\n```\n\n\nРішення\na = [1, 2, 4, 3]\nhalf = len(a) // 2\nsum_left = sum(a[:half])\nsum_right = sum(a[half:])\nresult = sum_left == sum_right\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 3.29  Дано список цілих чисел a і число b. Видаліть з a перше й останнє входження числа b.\nПриклад:\n```{python}\na = [1, 2, 2, 1, 3, 2, 3]\nb = 1 \n# -&gt; a = [2, 2, 3, 2, 3]\n\na = [1, 2, 2, 1, 3, 2, 3]\nb = 2 \n# -&gt; a = [1, 2, 1, 3, 3]\n```\n\n\nРішення\na = [1, 2, 2, 1, 3, 2, 3]\nb = 1\na.remove(b)\na.reverse()\na.remove(b)\na.reverse()"
  },
  {
    "objectID": "python_list_set.html#корисні-функції",
    "href": "python_list_set.html#корисні-функції",
    "title": "4  Множини",
    "section": "4.1 Корисні функції",
    "text": "4.1 Корисні функції\nТакож давайте подивимося на різні функції, які допомагають нам працювати зі списками та множинами:\n\nlen() - повертає кількість елементів у списку або множині. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nprint(len(fruits))\n\n3\n\n\n\nfruits = {'apple', 'banana', 'banana', 'apple'}\nprint(len(fruits))\n\n2\n\n\n\nmax() - повертає найбільший елемент у списку або множині. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nprint(max(fruits))\n\norange\n\n\n\nnumbers = [5, 2, 8, 1, 9]\nprint(max(numbers))\n\n9\n\n\n\nmy_set = {5, 2, 8, 1, 8}\nprint(max(my_set))\n\n8\n\n\n\nmin() - повертає найменший елемент у списку або множині. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nprint(min(fruits))\n\napple\n\n\n\nnumbers = [5, 2, 8, 1, 9]\nprint(min(numbers))\n\n1\n\n\n\nsorted() - повертає відсортований список або множину. Вона може приймати параметр reverse=True, щоб відсортувати послідовність у зворотному порядку (за спаданням). Наприклад:\n\n\nfruits = ['banana', 'orange', 'apple']\nprint(sorted(fruits))\n\n['apple', 'banana', 'orange']\n\n\n\nnumbers = [5, 2, 8, 1, 9]\nprint(sorted(numbers, reverse=True))\n\n[9, 8, 5, 2, 1]\n\n\nА от якщо відсортувати множину, то вийде список!\n\nmy_set = {1, 1, 2, 2}\nprint(sorted(my_set))\n\n[1, 2]\n\n\n\n4.1.1 range()\nФункція range() дозволяє створити послідовність чисел.\nrange(start, stop, step)\n# start - з цього числа починаємо за замовчуванням 0\n# stop - кінець послідовності, але саме число stop не включено до результату.\n# step - крок переходу між числами за замовчуванням 1\nФункція дозволяє нам генерувати послідовність цілих чисел із заданим початком, кінцем та кроком. Після виконання функція повертає спеціальний тип даних – range. Для зручнішої роботи з послідовністю можна перевести range до списку. Обов’язково потрібно вказати лише аргумент stop, початок та крок за умовчанням дорівнюють 0 і 1 відповідно. Розглянемо приклади:\n\n# від 0 до 4 з кроком 1\nlist(range(5))\n\n[0, 1, 2, 3, 4]\n\n\n\n# від 2 до 9 з кроком 2\nlist(range(2, 10, 2))\n\n[2, 4, 6, 8]\n\n\n\n# від 10 до 2 з кроком 1\nlist(range(10, 1, -1))\n\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 4.7  У змінну var_1 збережіть список з числами від -100 до 100 включно з кроком 1.\nУ змінну var_2 збережіть список з числами від 250 до 0 включно з кроком 2.\nУ змінну var_3 збережіть список з усіма непарними числами від 100 до 200.\n\n\nРішення\nvar_1 = list(range(-100, 101, 1))\nvar_2 = list(range(250, -1, -2))\nvar_3 = list(range(101, 200, 2))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 4.8  У змінних a та b зберігаються числа - початок і кінець діапазону. Напишіть програму, яка поверне суму всіх чисел із цього діапазону. Збережіть значення змінної result.\nПриклад:\n```{python}\na = 1\nb = 3 \n\nresult = 6\n```\n\n\nРішення\na = 1\nb = 3\nresult = sum(range(a, b + 1))"
  },
  {
    "objectID": "python_list_set.html#sec-mutable-immutable",
    "href": "python_list_set.html#sec-mutable-immutable",
    "title": "4  Множини",
    "section": "4.2 Змінювані та незмінювані об’єкти",
    "text": "4.2 Змінювані та незмінювані об’єкти\nНастав час розібратися з досить складною для початківців концепцією змінних і незмінних об’єктів у Python. Ми вже знаємо, що можемо змінювати створені списки, наприклад, замінити або видалити один із елементів у списку. Однак ця особливість списку, його змінність призводить до несподіваних на перший погляд наслідків:\n\n# збережемо список у змінну my_list_1\nmy_list_1 = [3, 1, 2]\n\n# у змінну my_list_2 збережемо список my_list_1\nmy_list_2 = my_list_1\n\n# змінимо список my_list_1\nmy_list_1.append(4)\nmy_list_1.sort()\nmy_list_1[0] = 100\n\n# подивимося на обидва списки\nprint(\"Результат списку my_list_1:\", my_list_1)\nprint(\"Результат списку my_list_2:\", my_list_2)\n\nРезультат списку my_list_1: [100, 2, 3, 4]\nРезультат списку my_list_2: [100, 2, 3, 4]\n\n\nДивно, адже ми відсортували лише перший список, але другий також змінився! Вся справа в тому, що списки, масиви та словники — це об’єкти, що змінюються. Замість того, щоб створити ще одну коробочку в пам’яті з ім’ям my_list_2 та покласти в неї список із коробочки my_list_1, Python просто запам’ятав, що тепер на вихідну коробочку посилаються дві змінні. Коли змінюємо список my_list_1, змінюється і my_list_2. І навпаки, при зміні my_list_2 зміниться і my_list_1.\nСаме тому список має метод copy(). Він дозволяє створити копію першого списку у новій змінній. У такому разі зміни першого списку вже не вплинуть на копію цього списку.\n\n# збережемо список у змінну my_list_1\nmy_list_1 = [3, 1, 2]\n\n# у змінну my_list_2 збережемо список my_list_1 з методом copy()\nmy_list_2 = my_list_1.copy()\n\n# змінимо список my_list_1\nmy_list_1.append(4)\nmy_list_1.sort()\nmy_list_1[0] = 100\n\n# подивимося на обидва списки\nprint(\"Результат списку my_list_1:\", my_list_1)\nprint(\"Результат списку my_list_2:\", my_list_2)\n\nРезультат списку my_list_1: [100, 2, 3, 4]\nРезультат списку my_list_2: [3, 1, 2]\n\n\nТому при роботі з об’єктами в Python важливо розуміти, чи змінюємо ми вихідний об’єкт чи створюємо новий. Уважно читайте документацію функцій та методів. Припустимо, ми маємо список my_list, ми хочемо завести новий список my_list_ordered з відсортованими елементами зі списку my_list:\n\nmy_list = [1, 2, 3, -2]\n\n# так правильно\nmy_list_ordered = sorted(my_list) # функція sorted повертає новий список, не змінює список my_list\nprint(\"Результат списку my_list_ordered:\", my_list_ordered)\nprint(\"Результат списку my_list:\", my_list)\n\nРезультат списку my_list_ordered: [-2, 1, 2, 3]\nРезультат списку my_list: [1, 2, 3, -2]\n\n\n\n# так неправильно\nmy_list_ordered = my_list.sort() # метод sort нічого не повертає, а лише змінює список my_list\nprint(\"Результат списку my_list_ordered:\", my_list_ordered)\nprint(\"Результат списку my_list:\", my_list)\n\nРезультат списку my_list_ordered: None\nРезультат списку my_list: [-2, 1, 2, 3]\n\n\nА ось вже знайомі нам числа int і float, рядки та логічні значення - це незмінні об’єкти. Тобто після створення об’єкта не можна змінити його значення, лише створити новий об’єкт із зміненим значенням."
  },
  {
    "objectID": "python_list_set.html#кортежі",
    "href": "python_list_set.html#кортежі",
    "title": "4  Множини",
    "section": "4.3 Кортежі",
    "text": "4.3 Кортежі\nНезважаючи на деякі підводні камені, можливість змінювати списки та множини робить їх дуже зручними структурами для роботи. У процесі виконання програми ми можемо додавати, змінювати чи видаляти елементи.\nІноді можуть виникнути ситуації, коли хочемо зберігати набір елементів без можливості змінювати його. Тому у списків існує їхній незмінний аналог - кортежі (tuple). Кортежі створюються за допомогою круглих дужок (), а елементи розділені комами. Кортежі не можна змінювати після створення, тобто не можна додавати, видаляти чи змінювати елементи в кортежі. Тому кортежі краще використовувати, коли треба зберігати значення, які не змінюватимуться. Наприклад, назви місяців:\n\n# створимо кортеж\nmonths = ('January', 'February', 'March', 'April', 'May',\n           'June', 'July', 'August', 'September', 'October', 'November', 'December')\n\n# спробуємо додати тринадцятий місяць\nmonths[12] = 'Undecimber'\n\n# або змінити другий місяць\nmonths[1] = 'Лютий'\n\nTypeError: 'tuple' object does not support item assignment\n\n\nПри виконанні коду отримаємо помилку TypeError: 'tuple' object does no support item assignment. Помилка говорить про те, що кортеж не підтримує зміну чи додавання елементів, тому спроба привласнення нового значення елементу викликає помилку TypeError.\nКортежі в основному використовуються в тих місцях, де потрібна ефективність та продуктивність. Кортежі займають менше місця, ніж списки, та обробляються швидше. При цьому кортежі, як і списки, підтримують індексацію. Наприклад, якщо ми хочемо отримати назву першого місяця, можемо використовувати вже звичний запис:\n\nmonth_index = 0\nmonth_name = months[month_index] \nprint(month_name)\n\nJanuary\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 4.9  Створіть кортеж із назвами днів тижня та збережіть його у змінну days_of_the_week.\n'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'\n\n\nРішення\ndays_of_the_week = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')"
  },
  {
    "objectID": "python_list_set.html#sec-list-zip",
    "href": "python_list_set.html#sec-list-zip",
    "title": "4  Множини",
    "section": "4.4 Функція zip() для об’єднання послідовностей",
    "text": "4.4 Функція zip() для об’єднання послідовностей\nДуже часто нам доводиться працювати одразу з двома наборами даних, наприклад, з двома списками або множинами. Функція zip() у Python об’єднує елементи з декількох послідовностей. Давайте розглянемо приклад:\n\nx = [1, 2, 3]\ny = ['a', 'b', 'c']\n\n# Використовуємо функцію zip() для об'єднання елементів із двох списків\nresult = zip(x, y)\n\n# Перетворюємо результат на список\nresult_list = list(result)\n\nprint(result_list)\n\n[(1, 'a'), (2, 'b'), (3, 'c')]\n\n\nУ цьому прикладі ми створюємо два списки x і y, що містять числа і букви відповідно. Потім ми використовуємо функцію zip() для об’єднання елементів із цих двох списків. Результатом є складніший тип даних, але ми легко можемо перейти до вже знайомого нам формату за допомогою функції list().\nЗараз важливо запам’ятати, що за допомогою зв’язки list(zip(x, y)) ми можемо швидко й ефективно об’єднувати кілька списків.\nВажливо зазначити, що результат zip() матиме довжину, що дорівнює довжині найкоротшої з вихідних послідовностей. Якщо довжини послідовностей відрізняються, то зайві елементи будуть проігноровані. Функція zip() може використовуватися в таких ситуаціях, як ітерація за кількома послідовностями одночасно або поєднання елементів з декількох списків."
  },
  {
    "objectID": "python_functions.html#синтаксис",
    "href": "python_functions.html#синтаксис",
    "title": "5  Функції",
    "section": "5.1 Синтаксис",
    "text": "5.1 Синтаксис\nСтворення функцій: для створення функції використовується ключове слово def, після якого вказується ім’я функції, а потім у круглих дужках вказуються параметри функції. Тіло функції починається з відступу і може містити необхідний код.\n\ndef add_numbers(a, b):\n    sum = a + b\n    return sum\n\nПовернення значення: використовуйте ключове слово return для повернення значення з функції. Якщо у функції немає оператора return, вона все одно завершить своє виконання, але поверне значення None за замовчуванням.\nОсь приклади використання функцій:\n\nПриклад 5.1 (Проста функція, що обчислює суму двох чисел)  \n\ndef add_numbers(a, b):\n    sum = a + b\n    return sum\nresult = add_numbers(2, 3)\nprint(result)\n\n5\n\n\n\n\nПриклад 5.2 (Функція з вкладеними умовами для визначення часу доби)  \n\ndef get_time_of_day(hour):\n    if hour &lt; 12:\n        return \"Ранок\"\n    elif hour &lt; 18:\n        return \"День\"\n    else:\n        return \"Вечір\"\ntime = get_time_of_day(15)\nprint(time)\n\nДень\n\n\n\n\nПриклад 5.3 (Функція з параметром за замовчуванням)  \n\ndef greet_person(name=\"гість\"):\n    print(\"Привіт,\", name)\n\ngreet_person()\ngreet_person(\"Аліса\")\n\nПривіт, гість\nПривіт, Аліса"
  },
  {
    "objectID": "python_functions.html#глобальні-змінні",
    "href": "python_functions.html#глобальні-змінні",
    "title": "5  Функції",
    "section": "5.2 Глобальні змінні",
    "text": "5.2 Глобальні змінні\nМожна змінювати змінну всередині функції так, що і за межами функції ця змінна теж зміниться. Це вже досить просунута тема, яка навряд чи знадобиться вам на старті, але корисно знати про такий спосіб роботи зі змінними.\nУ Python глобальні змінні оголошуються поза всіма функціями, вони доступні з будь-якого місця в програмі. Глобальні змінні можуть бути ініціалізовані та змінені всередині функцій за допомогою ключового слова global.\n\nПриклад 5.4 (Використання глобальних змінних у Python)  \n\nx = 10 # глобальна змінна\ndef some_function():\n    global x\n    x += 5 # зміна глобальної змінної\n    print(x)\nsome_function()\nprint(x)\n\n15\n15\n\n\n\nУ цьому випадку змінна x оголошена в глобальній області видимості, за межами функції some_function(). За допомогою ключового слова global всередині функції ми можемо змінювати значення глобальної змінної x.\nОсь приклад реальної задачі, де буде потрібно використовувати глобальну змінну.\nПрипустимо, що ми створюємо програму для відстеження замовлень в інтернет-магазині. У нас є функція make_order(), яка приймає на вхід кількість товарів і обробляє замовлення. Нам потрібно відстежувати загальну кількість замовлень, зроблених у магазині.\n\ntotal_orders = 0 # глобальна змінна для зберігання загальної кількості замовлень\n\ndef make_order(num_items):\n    global total_orders\n    total_orders += 1\n    print(f\"Замовлення зроблено! Усього замовлень: {total_orders}. Товарів у замовленні: {num_items}\")\n\nmake_order(5) # Замовлення зроблено! Усього замовлень: 1. Товарів у замовленні: 5\nmake_order(3) # Замовлення зроблено! Усього замовлень: 2. Товарів у замовленні: 3\nprint(f\"Усього замовлень: {total_orders}\") # Висновок: Усього замовлень: 2\n\nЗамовлення зроблено! Усього замовлень: 1. Товарів у замовленні: 5\nЗамовлення зроблено! Усього замовлень: 2. Товарів у замовленні: 3\nУсього замовлень: 2\n\n\nУ цьому прикладі у нас є глобальна змінна total_orders, яка зберігає загальну кількість замовлень. Функція make_order() використовує ключове слово global, щоб оголосити, що ми хочемо змінити значення глобальної змінної total_orders. При кожному виклику функції make_order() ми збільшуємо значення total_orders на 1 і виводимо повідомлення про замовлення, зокрема поточну кількість товарів і загальну кількість замовлень. Наприкінці програми ми виводимо загальну кількість замовлень.\nГлобальна змінна total_orders допомагає нам відстежувати загальну кількість замовлень у нашому інтернет-магазині.\nВарто бути обережним під час використання глобальних змінних, оскільки вони можуть ускладнити розуміння і підтримку коду. Якщо можливо, слід надавати перевагу передачі значень через аргументи функцій або використанню локальних змінних."
  },
  {
    "objectID": "python_functions.html#лямбда-функції",
    "href": "python_functions.html#лямбда-функції",
    "title": "5  Функції",
    "section": "5.3 Лямбда-функції",
    "text": "5.3 Лямбда-функції\nДавайте ще познайомимося з більш компактною формою створення та використання функцій. Лямбда-функція - це анонімна функція, яка може бути визначена без використання стандартного оператора def. Вона зазвичай використовується в тих випадках, коли необхідно визначити просту функцію, яка буде використовуватися тільки в одному місці програми. Ось приклади, які ілюструють використання лямбда-функцій:\n\nПриклад 5.5 (Найпростіший приклад лямбда-функції)  \n\nadd = lambda x, y: x + y\nprint(add(5, 3))\n\n8\n\n\n\nУ цьому прикладі створюється лямбда-функція add, яка приймає два аргументи x і y і повертає їхню суму. Потім ми викликаємо функцію, передаючи їй аргументи 5 і 3.\n\nПриклад 5.6 (Сортування списку)  \n\nnumbers = [2, 5, 1, 9, 3, 7]\nsorted_numbers = sorted(numbers, key=lambda x: x % 3)\nprint(sorted_numbers)\n\n[9, 3, 1, 7, 2, 5]\n\n\n\nУ цьому прикладі ми використовували лямбда-функцію як ключ для сортування списку чисел. Лямбда-функція повертає залишок від ділення числа на 3, за цим значенням відбувається сортування списку.\n\nПриклад 5.7 (Фільтрація списку) Функція filter() - це вбудована функція в Python, яка використовується для фільтрації елементів ітерованого об’єкту на основі заданої умови.\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter(lambda x: x % 2 == 0, numbers)\nprint(list(even_numbers))\n\n[2, 4, 6, 8, 10]\n\n\n\nУ цьому прикладі ми використовуємо лямбда-функцію разом із функцією filter() для фільтрації списку чисел. Лямбда-функція перевіряє, чи є число парним, і функція filter() залишає тільки числа, що задовольняють цій умові.\nЛямбда-функції мають кілька переваг порівняно зі звичайними функціями. Ось деякі з них:\n\nСтислість і компактність: лямбда-функції дозволяють визначити функцію в одному рядку коду без використання оператора def. Вони корисні, коли вам потрібна проста функція, яка буде використовуватися тільки в одному місці програми. Використання лямбда-функцій робить код більш компактним і зосередженим на самій функції.\nАнонімність: лямбда-функції - це анонімні функції, тобто вони не мають імені. Це корисно, коли вам потрібно передати функцію як аргумент в іншу функцію або використовувати її разом з іншими конструкціями, такими як filter() або map(). Ви можете визначити функцію прямо всередині виклику іншої функції, без необхідності створювати окреме ім’я для функції.\nЗручність у використанні: лямбда-функції зручно використовувати для виконання простих операцій, таких як математичні обчислення, фільтрація або перетворення елементів у списку тощо. Вони надають спосіб визначення функцій більш лаконічним чином і дають змогу скоротити кількість коду.\n\nВарто зазначити, що лямбда-функції також мають свої обмеження. Вони не можуть містити багаторядкові вирази або мати складні логічні конструкції. Якщо вам потрібно визначити більш складну функцію з безліччю операцій, умов і циклів, звичайна функція може бути кращою.\nВикористання лямбда-функцій або звичайних функцій залежить від контексту і вимог вашого завдання. Вам варто обирати найзручніше і найзручніше для читання рішення в кожній конкретній ситуації."
  },
  {
    "objectID": "python_functions.html#змінна-кількість-аргументів",
    "href": "python_functions.html#змінна-кількість-аргументів",
    "title": "5  Функції",
    "section": "5.4 Змінна кількість аргументів",
    "text": "5.4 Змінна кількість аргументів\nРозглянемо ще одну більш просунуту тему - як створювати функції із заздалегідь невизначеним набором аргументів. Це може бути корисно, коли ви не знаєте заздалегідь, скільки аргументів буде передано у функцію, або коли вам необхідно обробляти різну кількість аргументів у різних ситуаціях. Для створення функції зі змінною кількістю аргументів використовується оператор * (зірочка) перед іменем аргументу. Давайте розглянемо приклади:\n\nПриклад 5.8 (Функція з довільною кількістю позиційних аргументів) args (Positional Arguments) - це спеціальний параметр у функціях Python, який дозволяє передавати аргументи у вигляді кортежу.\n\ndef sum_numbers(*args):\n    total = 0\n    for num in args:\n        total += num\n    return total\nprint(sum_numbers(1, 2, 3))\nprint(sum_numbers(4, 5, 6, 7))\n\n6\n22\n\n\nУ цьому прикладі функція sum_numbers приймає довільну кількість позиційних аргументів, які передаються у вигляді кортежу args. Функція додає всі числа і повертає їхню суму.\n\n\nПриклад 5.9 (Функція з довільною кількістю іменованих аргументів) kwargs (Keyword Arguments)- це спеціальний параметр у функціях Python, який дозволяє передавати аргументи у вигляді словника.\n\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name='John', age=25)\nprint_info(country='USA', occupation='Engineer')\n\nname: John\nage: 25\ncountry: USA\noccupation: Engineer\n\n\nТут функція print_info приймає довільну кількість іменованих аргументів, які передаються у вигляді словника kwargs. Функція виводить на екран ключі та значення переданих аргументів.\n\n\nПриклад 5.10 (Функція з комбінованим використанням позиційних та іменованих аргументів)  \n\ndef process_data(*args, **kwargs):\n    for num in args:\n        print(f\"Number: {num}\")\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\nprocess_data(1, 2, 3, name='John', age=25)\n\nNumber: 1\nNumber: 2\nNumber: 3\nname: John\nage: 25\n\n\nУ цьому прикладі функція process_data приймає довільну кількість позиційних аргументів і довільну кількість іменованих аргументів. Функція виводить на екран значення позиційних аргументів, а потім ключі та значення іменованих аргументів.\n\nДавайте розглянемо приклад із реальним завданням:\nУявіть, що ви розробляєте систему керування базами даних, де користувачі можуть створювати таблиці з різним набором стовпців. Вам необхідно реалізувати функцію, яка зберігатиме дані в таблицю.\n\ndef save_data(table_name, **columns):\n    # Тут може бути ваш код для збереження даних у таблицю\n    print(f\"Data saved to table '{table_name}':\")\n    for column, value in columns.items():\n        print(f\"- {column}: {value}\")\n# Приклад використання функції save_data\nsave_data('students', name='John', age=25, grade='A')\nsave_data('products', name='Apple', price=1.99)\n\nData saved to table 'students':\n- name: John\n- age: 25\n- grade: A\nData saved to table 'products':\n- name: Apple\n- price: 1.99\n\n\nТут функція save_data приймає першим аргументом назву таблиці, а потім довільну кількість іменованих аргументів, які являють собою назви стовпців і значення, які потрібно зберегти в таблицю. Функція може бути використана для збереження даних у різні таблиці з різним набором стовпців.\nЦе всього лише приклад. У реальному завданні, звісно, може знадобитися складніша і специфічніша реалізація функції зі змінною кількістю аргументів залежно від вимог проєкту."
  },
  {
    "objectID": "python_functions.html#завдання",
    "href": "python_functions.html#завдання",
    "title": "5  Функції",
    "section": "5.5 Завдання",
    "text": "5.5 Завдання\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 5.1  Ми розробляємо софт для магазину програмістів. Покупці вводять назви товарів у термінал і таким чином здійснюють покупки.\nУ словнику products зберігаються назви та вартість товарів.\n```{python}\nproducts = {\n    \"ноутбук\": 5000,\n    \"смартфон\": 20000,\n    \"навушники\": 1000,\n    \"монітор\": 10000,\n    \"клавіатура\": 500,\n    \"миша\": 200,\n    \"роутер\": 1500,\n    \"принтер\": 5000,\n    \"флешка\": 1000,\n    \"жорсткий диск\": 3000\n}\n```\nНапишіть функцію calculate_order_cost, яка отримує на вхід словник із товарами, а далі необмежену кількість аргументів: назва товарів, які вибрав покупець. Якщо товару немає в products, просто не враховуємо цей товар. Функція повертає два значення: сумарну вартість замовлення, словник куплених товарів, де ключ - назва товару, значення - число одиниць товару.\nПриклад:\n```{python}\ntotal_cost, orders_info = calculate_order_cost(products, 'ноутбук', 'роутер') \nprint(total_cost) # 6500\nprint(orders_info) # {'ноутбук': 1, 'роутер': 1}\n\ntotal_cost, orders_info = calculate_order_cost(products , 'миша', 'флешка', 'монітор', 'кабель', 'миша') \nprint(total_cost) # 11400\nprint(orders_info) # {'миша': 2, 'флешка': 1, 'монітор': 1}\n```\n\n\nРішення\ndef calculate_order_cost(products, *args):\n    total_cost = 0\n    orders_info = {}\n    for product in args:\n        if product in products:\n            total_cost += products[product]\n            if product in orders_info:\n                orders_info[product] += 1\n            else:\n                orders_info[product] = 1\n    return total_cost, orders_info\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 5.2  Напишіть функцію calculator, що приймає три аргументи: перший - операція, другі два - числа, над якими має бути здійснено операцію.\nНаприклад: якщо перший аргумент +, то потрібно скласти числа a і b; якщо -, то відняти.\nФункція повинна повернути одне число - результат виконання операції. Якщо операцію виконати не вдалося - повернути рядок \"Error\".\nПриклад:\n```{python}\ncalculator('+', 2, 4) # -&gt; 6\ncalculator('^', 2, 4) # -&gt; 16\ncalculator('', 2, 4) # -&gt; 'Error'\n```\n\n\nРішення\ndef calculator(op, a, b):\n    if op in ['+', '-', '*', '/', '%', '//', '**'] and b != 0:\n        return eval(f'{a}{op}{b}')\n    elif op == '^':\n        return a ** b\n    elif op in ['/', '//', '%'] and b == 0:\n        return 'Error'\n    else:\n        return 'Error'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 5.3  У Гоґвортсі починається новий навчальний рік, триває церемонія розподілу. На голову кожного нового учня надягають розподільчий капелюх. Залежно від якостей, які капелюх побачить у дитині, вона буде зарахована на відповідний факультет:\n\nГриффіндор - хоробрість, благородство, честь;\nРейвенклов - розум, допитливість, творчість;\nСлізерин - хитрість, амбітність, винахідливість;\nГафелпаф - працьовитість, вірність, чесність.\n\nНапишіть функцію sorting_hat(), яка як аргумент прийматиме словник вигляду: new_students = {'Сіріус Блек': 'хоробрість'}, де ключ - ім’я учня, значення - якість, якою він володіє.\nФункція має повернути 2 змінні:\n\nsorted_students - словник виду: ключ - ім’я учня, значення - факультет, на який його було зараховано. Дані в словнику мають бути відсортовані за назвою факультету та за ім’ям учня.\ndepartment - словник виду: ключ - факультет, значення - кількість зарахованих на нього учнів. Відсортуйте словник за ключем.\n\nПриклад:\n```{python}\ndef sorting_hat(new_students):\n    ...\n    return sorted_students, departments\n\nnew_students = {\n    'Сіріус Блек': 'хоробрість',\n    'Аманда Коршун': 'допитливість',\n    'Пенелопа Вулпінголд': 'винахідливість',\n    'Артур Поттер': 'хоробрість',\n    'Тесая Блек': 'розум'\n}\n\nsorting_hat(new_students) # -&gt; -&gt;\n# sorted_students = {'Аманда Коршун': 'Рейвенклов', 'Артур Поттер': 'Гриффіндор', 'Пенелопа Вулпінголд': 'Слізерин', 'Сіріус Блек': 'Гриффіндор', 'Тесая Блек': 'Рейвенклов'}\n# departments = {'Гафелпаф': 0, 'Гриффіндор': 2, 'Рейвенклов': 2, 'Слізерин': 1}\n```\n\n\nРішення\ndef sorting_hat(new_students):\n    departments = {'Гриффіндор': 0, 'Рейвенклов': 0, 'Гафелпаф': 0, 'Слізерин': 0}\n    sorted_students = {}\n    for student, quality in new_students.items():\n        if quality in ['хоробрість', 'благородство', 'честь']:\n            departments['Гриффіндор'] += 1\n            sorted_students[student] = 'Гриффіндор'\n        elif quality in ['розум', 'допитливість', 'творчість']:\n            departments['Рейвенклов'] += 1\n            sorted_students[student] = 'Рейвенклов'\n        elif quality in ['хитрість', 'амбітність', 'винахідливість']:\n            departments['Слізерин'] += 1\n            sorted_students[student] = 'Слізерин'\n        elif quality in ['працьовитість', 'вірність', 'чесність']:\n            departments['Гафелпаф'] += 1\n            sorted_students[student] = 'Гафелпаф'\n    sorted_students = dict(sorted(sorted_students.items(), key=lambda x: x[0]))\n    departments = dict(sorted(departments.items(), key=lambda x: x[0]))\n    return sorted_students, departments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 5.4  Дано список кортежів input_list. Відсортуйте input_list за 2 елементом кортежу в порядку убування. Відфільтруйте список так, щоб залишилися тільки ті елементи, друге значення в кортежі в яких кратне 5.\nРезультат збережіть у result.\nДля розв’язання задачі використовуйте lambda-функцію.\nПриклад:\n```{python}\ninput_list = [('Anna', 13), ('Ivan', 20), ('Irina', 23), ('Olga', 25), \n              ('Ivan', 30), ('Oleg', 24), ('Olga', 26)]\nresult = [('Ivan', 30), ('Olga', 25), ('Ivan', 20)]\n```\n\n\nРішення\ninput_list = [('Anna', 13), ('Ivan', 20), ('Irina', 23), ('Olga', 25), \n              ('Ivan', 30), ('Oleg', 24), ('Olga', 26)]\n\nresult = list(filter(lambda x: x[1] % 5 == 0, sorted(input_list, key=lambda x: x[1], reverse=True)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 5.5  Гіпотеза Коллатца: яке б початкове натуральне число n ми не взяли, рано чи пізно ми отримаємо одиницю, якщо виконуємо такі перетворення:\n\nякщо n парне, то ділимо його на 2;\nякщо n непарне, то множимо на 3 і додаємо 1 (отримуємо 3n + 1).\n\nНапишіть функцію collatz_conjecture(), яка прийматиме натуральне число n і повертатиме послідовність чисел, отриманих зазначеними вище перетвореннями.\nПриклад:\n```{python}\ndef collatz_conjecture(n):\n    ...\n\ncollatz_conjecture(8) # -&gt; [8, 4, 2, 1]\ncollatz_conjecture(3) # -&gt; [3, 10, 5, 16, 8, 4, 2, 1]\n```\n\n\nРішення\ndef collatz_conjecture(n):\n    result = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n        result.append(n)\n    return result\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 5.6  Напишіть функцію reverse_tuple(), яка прийматиме список цілих чисел. У результаті виконання цієї функції буде отримано кортеж унікальних елементів списку у зворотному порядку.\nПриклад:\n```{python}\ndef reverse_tuple(lst):\n    ...\n\nreverse_tuple([1, 3, 4]) # -&gt; (4, 3, 1)\nreverse_tuple([1, 3, 4, 4, 5, 2]) # -&gt; (2, 5, 4, 3, 1)\n```\n\n\nРішення\ndef reverse_tuple(lst: list):\n    lst = lst[::-1]\n    return tuple(sorted(set(lst), key=lst.index))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 5.7  Напишіть функцію update_tuple(), яка прийматиме кортеж input_tuple, видалятиме першу появу певного елемента el_del із кортежу за значенням і повертатиме кортеж без нього.\nВидаляємого елементу в кортежі може не бути, в цьому випадку кортеж повернеться в початковому вигляді.\nПриклад:\n```{python}\ndef update_tuple(input_tuple, el_del):\n    ...\n\nupdate_tuple((1, 2, 3), 1) #-&gt; (2, 3)\nupdate_tuple((1, 2, 3, 3, 9, 5), 3) #-&gt; (1, 2, 3, 9, 5)\nupdate_tuple((1, 2, 3), 9) #-&gt; (1, 2, 3)\n```\n\n\nРішення\ndef update_tuple(input_tuple, el_del):\n    if el_del in input_tuple:\n        input_tuple = list(input_tuple)\n        input_tuple.remove(el_del)\n        return tuple(input_tuple)\n    return input_tuple"
  },
  {
    "objectID": "python_exercises.html",
    "href": "python_exercises.html",
    "title": "6  Задачі",
    "section": "",
    "text": "Завдання 6.1  Давайте уявимо, що у нас є місто, 5 на 5 районів, кожен район - це квадрат зі стороною 1. Частина районів являє собою річку - 0, частина землю - 1. Тоді ми могли б зберегти карту такого міста, використовуючи список зі списків:\n\ncity_map_list = [\n[1, 1, 0, 0, 1], \n[1, 1, 0, 0, 1],\n[1, 1, 1, 1, 1],\n[0, 0, 0, 0, 1],\n[0, 0, 0, 0, 1]\n]\n\nІ ось такий би вигляд мало наше місто:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.heatmap(np.array(city_map_list), cmap='YlGnBu_r', cbar=False)\nplt.show()\n\n\n\n\nЯк на уроках геометрії, ми могли б розташувати наше місто на координатах x і y. Для запису координат будемо використовувати формат (x, y). Район у верхньому лівому кутку має координати (0, 0) city_map[0][0]. А правий нижній район мав би координати (4, 4) city_map[4][4]. Таким чином кожен район закодований двома індексами, які відповідають його координатам. Наприклад, район (0, 2) це земля city_map[2][0], а район (3, 4) вода city_map[4][3].\nТаким чином, щоб отримати значення карти за індексами x і y, потрібно використовувати запис: city_map[y][x]\nСподіваюся, ми розібралися, як можна закодувати карту міста за допомогою списку зі списків, і тепер вирушаймо у справжній мегаполіс 100 на 100. У нашому місті є велика річка з 4-ма мостами. Карта міста також закодована за допомогою списку зі списків. Щоб завантажити карту на ваш комп’ютер, виконайте наступний код:\n\nimport pandas as pd\n\nurl='https://raw.githubusercontent.com/Aranaur/py4ds/main/00_data/python/city_map.csv'\ndf = pd.read_csv(url, names=list(range(0, 100, 1)))\ncity_map_list = df.values.tolist()\n\nsns.heatmap(np.array(city_map_list), cmap='YlGnBu_r', cbar=False)\nplt.show()\n\n\n\n\nТепер у змінній city_map_list список зі списків 100 на 100 - карта міста. Нещодавно в місті запустилася служба доставки, але кур’єри скаржаться, що через складну географію мостів і вулиць важко знайти дорогу. Тому нам потрібно написати програму для навігатора.\nЗавдання:\nУ змінних courier_location, orders_location, city_map_list збережені позиції кур’єра, координати доставок і карта міста.\n\ncourier_location - кортеж із двох цілих чисел. Координати стартового місця розташування кур’єра у форматі (x, y). Де x і y - це цілі числа від 0 до 99.\n\nПриклад: courier_location = (10, 10)\n\norders_location - список щонайменше з одного кортежу з координатами. Координати, за якими кур’єр має доставити замовлення. У списку зберігається довільне число кортежів з координатами точок призначення, які повинен відвідати кур’єр.\n\nПриклад: orders_location = [(1, 1), (92, 13), (46, 33)]\n\ncity_map_list - список зі списків 100 на 100, карта міста, яку ми завантажили вище.\n\nВам відомо місце розташування кур’єра, набір координат місць призначення і карта міста. Тепер потрібно написати скрипт, який створить змінну route і збереже в неї маршрут, за яким має пройти кур’єр, щоб рознести всі доставки. Під час формування маршруту необхідно виконати такі умови:\n\nМаршрут має проходити тільки по землі, по воді ходити не можна.\nКур’єри можуть переміщатися на один крок із поточного району вправо, вліво, вниз або вгору.\nМаршрут має бути збережений у список, де кожен елемент - це кортеж з координатами кожного кроку кур’єра.\nКур’єр проходить один крок за 10 хвилин і може доставляти замовлення в будь-якому порядку.\n\nПриклад роботи навігатора на нашому місті 5 на 5:\n```{python}\ncity_map_list = [\n[1, 1, 0, 0, 1], \n[1, 1, 0, 0, 1],\n[1, 1, 1, 1, 1],\n[0, 0, 0, 0, 1],\n[0, 0, 0, 0, 1]\n]\n\ncourier_location = (2, 2) # стартова позиція кур'єра\norders_location = [(4, 0), (0, 2), (4, 3)] # координати для доставки трьох товарів\n\nroute = [\n(3, 2),\n(4, 2),\n(4, 1),\n(4, 0), # адреса доставки\n(4, 1),\n(4, 2),\n(3, 2),\n(2, 2),\n(1, 2),\n(0, 2), # адреса доставки\n(1, 2),\n(2, 2),\n(3, 2),\n(4, 2),\n(4, 3) # адреса доставки\n]\n```\n\n\nРішення\n# Імпортуємо чергу\nfrom collections import deque\n\n# Функція для пошуку маршруту\ndef find_path(city_map, start, end):\n    # Створюємо масив відвіданих позицій\n    visited = [[False for _ in range(len(city_map[0]))] for _ in range(len(city_map))]\n    # Створюємо чергу, яка містить поточну позицію та маршрут\n    queue = deque([(start, [])])\n\n    # Поки черга не пуста - шукаємо маршрут\n    while queue:\n        # Беремо перший елемент з черги\n        current, path = queue.popleft()\n        # Розпаковуємо координати поточної позиції\n        x, y = current\n\n        # Якщо поточна позиція - ціль, то повертаємо маршрут\n        if current == end:\n            # Додаємо останню позицію до маршруту\n            return path + [end]\n\n        # Якщо поточна позиція не належить межам міста, або її вже відвідали, то пропускаємо\n        if x &lt; 0 or x &gt;= len(city_map[0]) or y &lt; 0 or y &gt;= len(city_map) or city_map[y][x] == 0 or visited[y][x]:\n            continue\n\n        # Позначаємо поточну позицію як відвідану\n        visited[y][x] = True\n\n        # Додаємо можливі наступні позиції до черги\n        queue.append(((x + 1, y), path + [current]))\n        queue.append(((x - 1, y), path + [current]))\n        queue.append(((x, y + 1), path + [current]))\n        queue.append(((x, y - 1), path + [current]))\n\n    # Якщо маршрут не знайдено, повертаємо None\n    return None\n\n# Вхідні дані\nroute = []\n\n# Початкова позиція кур'єра\ncourier_location = (10, 87) \n# Координати замовлень\norders_location = [(83, 38), (94, 56), (72, 75), (74, 64), (62, 15), (83, 99), (84, 25), (66, 7), (71, 41), (2, 40)]\n\n# Перебираємо всі замовлення та шукаємо маршрут до кожної з них\nfor order in orders_location:\n    # Знаходимо маршрут до наступної доставки\n    path = find_path(city_map_list, courier_location, order)\n    # Якщо маршрут не знайдено, виводимо повідомлення та завершуємо роботу\n    if path is None:\n        print(\"Route not found\")\n        break\n    # Додаємо маршрут до списку маршрутів\n    route.extend(path)\n    # Поточна позиція - остання позиція маршруту\n    current_position = order\n    # \n    route.append(order)"
  },
  {
    "objectID": "python_questions.html#основи",
    "href": "python_questions.html#основи",
    "title": "7  Популярні питання",
    "section": "7.1 Основи",
    "text": "7.1 Основи\n\n7.1.1 Що таке PEP-8?\nPEP або Python Enhancement Proposal – це пропозиція щодо розвитку мови Python. Ці документи є механізмом для пропонування нових можливостей або для документування вже готових рішень, які увійшли до мови Python.\nPEP-8 — це style guide того, як повинен бути оформлений код, написаний мовою Python, і яку повинні слідувати всі розробники, які пишуть цією мовою.\n\n\n7.1.2 Які типи даних є в Python? Які типи даних є змінними, а які є незмінними?\nТипи даних у Python можна розділити на змінні та незмінні.\nДо незмінних можна віднести: рядки, байти, цілі числа, числа з плаваючою точкою, комплексні числа, булеві значення, none, картежі та frozenset.\nДо змінюваних типів даних можна віднести списки, сети, словники, байт-масиви та memoryview.\n\n\n\nЗмінні\nНезмінні\n\n\n\n\nstr\nlist\n\n\nbytes\nset\n\n\nint\ndict\n\n\nfloat\nbytearray\n\n\ncomplex\nmemoryview\n\n\nbool\n\n\n\nNone\n\n\n\ntuple\n\n\n\nfrozenset\n\n\n\n\n\n\n7.1.3 Що таке віртуальне оточення?\nУявімо ситуацію, що на одному комп’ютері нам потрібно запустити два Python-проекти, які використовують одну бібліотеку, тільки різних версій. Саме такі віртуальні оточення допомагають нам вирішити цей конфлікт. Коли ми використовуємо віртуальне оточення, ми створюємо щось на кшталт пісочниці, де ми ізолюємо локальний Python від глобального Python. Це дозволяє нам ставити різні бібліотеки локально, не впливаючи на Python, який встановлений глобально у нас на комп’ютері.\n\n\n7.1.4 Чи можна змінити елемент у кортежі, якщо кортеж незмінний тип даних?\nХоча по собі картеж — це незмінний тип даних, але може містити змінюване значення. Припустимо, у нас є картеж a, який містить список і одиницю.\n\na = ([], 1)\n\nХоча картеж і незмінний - це означає, що ми не можемо змінювати його структуру, але якщо він містить елементи, що змінюються, то ми можемо їх змінювати. Наприклад, якщо ми спробуємо додати до картежу третім елементом двійку, то ми отримаємо помилку, тому що картеж - це незмінний тип даних.\n\na[3] = 2\n\nTypeError: 'tuple' object does not support item assignment\n\n\nАле якщо ми візьмемо нульовий елемент, це список, і спробуємо додати до нього двійку в кінець, знову виведемо на екран наш картеж, то побачимо, що нам вдалося змінити нульовий елемент.\n\na[0].append(2)\nprint(a)\n\n([2], 1)\n\n\nТобто картеж незмінний тип даних, змінювати структуру його не можна, але якщо є елементи, що змінюються всередині, то їх можна змінювати.\n\n\n7.1.5 Що таке List, Set та Dict comprehensions?\nList, Set та Dict comprehensions – це скорочення для наступного запису:\n\na = []\n\nfor i in range(5):\n    a.append(i)\n\nprint(a)\n\n[0, 1, 2, 3, 4]\n\n\nЩоб отримати той самий результат, ми можемо скористатися List Comprehensions:\n\nl = [i for i in range(5)]\nprint(l)\n\n[0, 1, 2, 3, 4]\n\n\nТакож у List, Set та Dict Comprehensions можна використовувати умови. Для цього потрібно після колекції або після генератора вказати ключове слово if і вказати умови, за якими ми вибиратимемо елементи, які вставлятимемо в цей список:\n\n# виведемо парні числа\n\nl = [i for i in range(5) if i % 2 == 0]\nprint(l)\n\n[0, 2, 4]\n\n\nРізниця між List і Set Comprehension у тому, що в List Comprehension використовуються квадратні дужки, Set Comprehension використовуються круглі дужки:\n\ns = {i for i in range(5) if i % 2 == 0}\nprint(s)\n\n{0, 2, 4}\n\n\nЩоб отримати Dict Comprehension, у нас повинен бути тут не один елемент, а має бути два елементи. Тобто один для ключа, другий для значення. Ми також використовуємо фігурні дужки:\n\nd = {i: i ** 2 for i in range(5) if i % 2 == 0}\nprint(d)\n\n{0: 0, 2: 4, 4: 16}\n\n\nВ якості прикладів використання List Set та Dict Comprehension можна навести розпакування якихось колекцій, або якихось генераторів, або просто заміна якогось дуже простого циклу, коли це не заважає читабельності коду.\n\n\n7.1.6 Яка різниця між операторами == та is?\nОператор == порівнює два операнди за їх значеннями:\n\na = [1, 2, 3]\nb = [1, 2, 3]\n\nprint(a == b)\n\nTrue\n\n\nОператор is перевіряє, що дві змінні, тобто a і b посилаються на один об’єкт. В даному випадку у нас a посилається на один список, b посилається на інший список, відповідно ми повинні отримати false:\n\na = [1, 2, 3]\nb = [1, 2, 3]\n\nprint(a is b)\n\nFalse\n\n\nЩо буде, якщо b надамо не новий список, а передамо a? Ми отримаємо true, тому що і a, і b посилаються на той самий об’єкт:\n\na = [1, 2, 3]\nb = a\n\nprint(a is b)\n\nTrue\n\n\n\n\n7.1.7 Що таке глибока (deep) та поверхнева (shallow) копія?\nПоверхнева копія копіює сам об’єкт. Всі внутрішні об’єкти вона не копіює, вони доступні за тими самими посиланнями. Глибока копія, мало того, що копіює зовнішній об’єкт, вона рекурсивно копіює всі внутрішні об’єкти в нову пам’ять. Якщо ми змінюємо новий об’єкт, то попередній стає незмінним.\nРозглянемо приклад:\n\na = [1, [2]]\nb = a\nb.append(3) # додаємо 3 до b\nb[1].append(4) # додаємо 4 до списку, який знаходиться всередині b\n\nprint(a)\n\n[1, [2, 4], 3]\n\n\nОскільки змінні a і b посилаються на один і той самий об’єкт, то і a зміниться. Не завжди це та поведінка, яку ми очікуємо. Для цього у нас є два види копії, відповідно, глибока та поверхнева.\nНайпростіший спосіб це імпортувати модуль copy і скористатися методом copy(). В такому випадку ми отримаємо поверхневу копію. Поверхнева копія створює копію самого об’єкта, але посилання на всі внутрішні об’єкти будуть збережені, вони не будуть скопійовані.\n\nimport copy\n\na = [1, [2]]\nb = copy.copy(a)\nb.append(3)\nb[1].append(4)\n\nprint(a)\n\n[1, [2, 4]]\n\n\nДля створення глибокої копії ми можемо скористатися методом deepcopy():\n\nimport copy\n\na = [1, [2]]\nb = copy.deepcopy(a)\nb.append(3)\nb[1].append(4)\n\nprint(a)\n\n[1, [2]]\n\n\nЯкщо ж ми розглядаємо список, то існує багато способів, як ще можна створити поверхневу копію:\n\na = [1, [2]]\n\nb = list(a) # поверхнева копія через list()\nb = a[:] # поверхнева копія через зріз\nb = [i for i in a] # поверхнева копія через List Comprehension\nb = a.copy() # поверхнева копія через вбудовану функцію copy()\n\n\n\n7.1.8 Як працюють оператори and, or та not?\nОператор not приводить свій операнд до типу bool і повертає його інверсію:\n\n# not\n\nprint(not [])\n\nTrue\n\n\n\n# not\n\nprint(not {1, 2, 3})\n\nFalse\n\n\nОператори and та or не приводять об’єкти до булевих значень, вони повертають самі об’єкти.\nЯкщо перший операнд повертає False, то and поверне його:\n\nprint([] and 123)\n\n[]\n\n\nЯкщо перший операнд повертає True, то and поверне другий операнд:\n\nprint([1, 2, 3] and 123)\n\n123\n\n\nЯкщо перший операнд повертає True, то or поверне його:\n\nprint([1, 2, 3] or 123)\n\n[1, 2, 3]\n\n\nЯкщо перший операнд повертає False, то or поверне другий операнд:\n\nprint([] or 123)\n\n123\n\n\n\n\n7.1.9 Як працює простір імен у Python? Як працює правило LEGB (Local, Enclosing, Global, Built-in)?\nПростір імен у Python працює за правилом LEGB. Це означає, що спочатку інтерпретатор шукає змінну в локальному просторі імен, потім в необов’язковому просторі імен зовнішньої функції, потім в глобальному просторі імен і, нарешті, в просторі імен вбудованих функцій.\nРозглянемо приклад, в якому повертається локальна змінна str:\n\nstr = 'global'\n\ndef outer():\n    str = 'enclosing'\n    \n    def inner():\n        str = 'local' # локальна змінна\n        print(str)\n    \n    inner()\n\nouter()\n\nlocal\n\n\nЯкщо цієї змінної не має в локальному просторі імен, то інтерпретатор буде шукати її в зовнішньому просторі імен:\n\nstr = 'global'\n\ndef outer():\n    str = 'enclosing' # зовнішній простір імен\n    \n    def inner():\n        print(str)\n    \n    inner()\n\nouter()\n\nenclosing\n\n\nЯкщо цієї змінної не має в зовнішньому просторі імен, то інтерпретатор буде шукати її в глобальному просторі імен:\n\nstr = 'global' # глобальний простір імен\n\ndef outer():\n\n    def inner():\n        print(str)\n    \n    inner()\n\nouter()\n\nglobal\n\n\nЯкщо цієї змінної не має в глобальному просторі імен, то інтерпретатор буде шукати її в просторі імен вбудованих функцій:\n\ndef outer():\n\n    def inner():\n        print(str)\n    \n    inner()\n\nouter()\n\n&lt;class 'str'&gt;\n\n\nЯкщо ми спробуємо звернутися до змінної, якої немає ні в одному з просторів імен, то інтерпретатор викине помилку:\n\ndef outer():\n    def inner():\n        print(variable) # змінна, якої немає ні в одному з просторів імен\n    \n    inner()\n\nouter()\n\nNameError: name 'variable' is not defined\n\n\n\n\n7.1.10 Як працюють оператори global та nonlocal?\nРозглянемо приклад:\n\na = 1 # глобальна змінна\n\ndef outer():    # зовнішня функція\n    b = 1       # змінна зовнішньої функції\n    \n    def inner():    # вкладена функція\n        a = 2       # локальна змінна\n        b = 2       # локальна змінна\n\n    inner()             # виклик вкладеної функції\n    print(\"a = \", a)    # виведення локальної змінної\n    print(\"b = \", b)    # виведення змінної зовнішньої функції\n\nouter() # виклик зовнішньої функції\n\na =  1\nb =  1\n\n\nЯк бачимо з результату, змінні a та b використовуються відповідно до правила LEGB. Щоб змінити глобальну змінну a в локальній функції inner, потрібно використати оператор global, а для зміни змінної зовнішньої функції b в локальній функції inner потрібно використати оператор nonlocal:\n\na = 1\n\ndef outer():\n    b = 1\n    \n    def inner():\n        global a # глобальна змінна\n        a = 2\n\n        nonlocal b # змінна зовнішньої функції\n        b = 2\n\n    inner()\n    print(\"a = \", a)\n    print(\"b = \", b)\n\n\n\n7.1.11 Чи знайомі тобі такі функції, як map, filter, zip?\n\nФункція map()може бути застосована до колекції, вона застосовує деяку функцію до кожного елемента нашої колекції:\n\n\na = [i for i in range(6)]\n\nb = map(lambda x: x ** 2, a)\n\nprint(list(b))\n\n[0, 1, 4, 9, 16, 25]\n\n\n\nФункція filter() може бути застосована до колекції, вона застосовує деяку функцію до кожного елемента нашої колекції і повертає лише ті елементи, для яких функція повертає True:\n\n\na = [i for i in range(6)]\n\nb = filter(lambda x: x % 2 == 0, a)\n\nprint(list(b))\n\n[0, 2, 4]\n\n\n\nФункція zip() приймає декілька колекцій і повертає колекцію кортежів, в яких перший елемент - перший елемент першої колекції, другий елемент - другий елемент другої колекції і так до того моменту, поки не закінчаться елементи в одній з колекцій:\n\n\na = [1, 2, 3]\nb = [4, 5, 6, 7]\nc = [8, 9]\n\nfor i in zip(a, b, c):\n    print(i)\n\n(1, 4, 8)\n(2, 5, 9)\n\n\n\n\n7.1.12 Як оцінюється складність алгоритмів та чому? Що таке Big-O notation?\nАлгоритмічна складність оцінюється в Big-O notation.\nBig-O notation – це метод оцінки, який визначає, як змінюються витрати виконання залежно від величини вхідних даних.\n\n\n\n\n\n\nПримітка\n\n\n\nШпаргалка з Big-O notation: https://www.bigocheatsheet.com/\n\n\n\n\n\n\n                                                \nРисунок 7.1: Діаграма складності Big-O\n\n\n\n\n\n7.1.13 Яка алгоритмічна складність основних операцій на колекціях?\nЯкщо ми говоримо про list, переважно це буде лінійна складність, за виключенням тих операцій, які виконуються наприкінці списку. Якщо ми говоримо про set та dict, то в основному це буде складність за одиницю, тому що set та dict під капотом є хеш-таблицями."
  },
  {
    "objectID": "python_questions.html#функції",
    "href": "python_questions.html#функції",
    "title": "7  Популярні питання",
    "section": "7.2 Функції",
    "text": "7.2 Функції\n\n7.2.1 Що таке функція та які переваги використання функції?\nФункція - це набір інструкцій, які виконуються після її виклику. Функції дозволяють нам уникнути дублювання коду, а також зробити код більш читабельним.\n\n\n7.2.2 Яким буде результат виконання функції, якщо в ній немає оператора return?\nЯкщо в функції немає оператора return, то результатом виконання функції буде None:\n\ndef func():\n    pass\n\na = func()\n\nprint(a)\n\nNone\n\n\n\n\n7.2.3 Що таке анотації типів? Навіщо вони потрібні? Коли виконуються анотації типів?\nАнотації типів - це спосіб вказати типи аргументів та тип, який повертає функція. Анотації типів не впливають на роботу програми, але допомагають IDE та іншим інструментам аналізувати код та виявляти помилки.\nАнотації типів виконуються під час виконання програми, тому їх можна використовувати для написання документації.\n\ndef func(a: int, b: int) -&gt; int:\n    return a ** b\n\nprint(func(2, 3))\n\n8\n\n\nНасправді в Python анотації не працюють в рантаймі, тобто вони не використовуються для перевірки типів. Ми у будь-якому разі можемо передати аргумент будь-якого типу. У прикладі нижче отримаємо помилку, тому що рядок не підтримує зведення в квадрат\n\ndef func(a: int, b: int) -&gt; int:\n    return a ** b\n\nprint(func('2', '3'))\n\nTypeError: unsupported operand type(s) for ** or pow(): 'str' and 'str'\n\n\nАле якщо я передати float, то вже нічого поганого не станеться, тому що float можна звести в квадрат, хоча це не int:\n\ndef func(a: int, b: int) -&gt; int:\n    return a ** b\n\nprint(func(2.2, 3.3))\n\n13.489468760533386\n\n\nКрім того є низка винятків. Наприклад, це бібліотека pydentic, яка може використовувати анотації типів у рантаймі для перевірки типу даних, наприклад атрибута класу.\n\n\n7.2.4 Як Python передає аргументи в функцію?\nЄ два типи передачі аргументу на функцію: за посиланням та за значенням.\nPython передає аргументи в функцію за посиланням. Це означає, що якщо ми передаємо змінну в функцію, то функція отримує посилання на цю змінну, а не її копію. Якщо ми змінюємо змінну в функції, то змінна буде змінена і в глобальному просторі імен.\nРозглянемо приклад:\n\na = [1, 2, 3]\n\ndef func(arg):\n    print(arg is a)\n\nfunc(a)\n\nTrue\n\n\nМи отримали True, тому що arg та a - це один і той же об’єкт.\n\n\n7.2.5 Що буде, якщо використовувати значення змінного типу як аргумент за замовчуванням функції? І як цього уникнути?\nЯкщо ми використовуємо змінну типу як аргумент за замовчуванням функції, то це може призвести до непередбачуваної поведінки. Наприклад, якщо ми використовуємо список як аргумент за замовчуванням, то цей список буде створений лише один раз, а не кожного разу, коли функція викликається без аргументів.\n\ndef func(a=[]):\n    a.append(1)\n    return a\n\nprint(func())\nprint(func([]))\nprint(func())\nprint(func([]))\n\n[1]\n[1]\n[1, 1]\n[1]\n\n\nКоли Python читає код і натикається на сигнатуру функції нашої func(), ми маємо значення порожній список. Це значення він обчислює не коли ми викликаємо цю функцію щоразу, але в момент, коли ця функція готується до виконання. Тобто коли Python вперше читає цю функцію, він обчислює значення, які ми задали за умовчанням, кладе їх у пам’ять, і в подальшому вони будуть використані щоразу, коли ми будемо викликати цю функцію. Тобто не задаватимуться щоразу, а щоразу використовуватимуться ті самі, які були обчислені спочатку.\nЯк цього уникнути? Стандартний варіант – це використовувати None, як значення за замовчуванням, тому що це значення незмінного типу. І всередині поставити умову if a is None: a = []. Тобто створювати змінне значення всередині функції, а не в сигнатурі функції:\n\ndef func(a=None):\n    if a is None:\n        a = []\n    a.append(1)\n    return a\n\nprint(func())\nprint(func([]))\nprint(func())\nprint(func([]))\n\n[1]\n[1]\n[1]\n[1]\n\n\n\n\n7.2.6 Що таке *args та **quarks?\n*args та **quarks – це спеціальні аргументи, які можна використовувати в сигнатурі функції. *args – це аргументи, які передаються в функцію позиційно. **quarks – це аргументи, які передаються в функцію по ключу.\n\ndef func(*args, **quarks):\n    print(locals())\n\nfunc(1, 2, 3, a=1, b=2, c=3)\n\n{'args': (1, 2, 3), 'quarks': {'a': 1, 'b': 2, 'c': 3}}\n\n\n*args – це кортеж, **quarks – це словник.\n\n\n7.2.7 Що таке lambda функція та наведіть приклади їх використання?\nФункція lambda це функція, яка не має імені. Як правило, це якась коротка функція, яка виконує деяку одну дію, і нам просто не потрібно виділяти для цього окреме ім’я.\nЗнайдемо ключ у якого найбільше значення в словнику. Якщо ми захочемо використати функцію max() для словника, то вона буде шукати максимальне значення серед ключів, а не серед значень:\n\na = {\n    1: 30,\n    2: 20,\n    3: 10\n}\n\nprint(max(a))\n\n3\n\n\nТому ми можемо використати lambda функцію, яка буде використовувати значення, а не ключі. Якщо я хочу знайти ключ, у якого найбільше значення, то в max() можна передати ще й key - це може бути лямбда функція, яка буде приймати кожен ключ і повертати значення цього ключа:\n\nprint(max(a, key=lambda x: a[x]))\n\n1\n\n\n\n\n7.2.8 Що таке рекурсія? Які обмеження мають рекурсія в Python?\nРекурсія – це механізм коли функція викликає сама себе. Це може бути корисно, коли ми маємо якусь задачу, яку можна розбити на більш прості задачі, і ці задачі можна розв’язати за допомогою тієї ж функції, яка викликає сама себе.\nЯкі можуть бути плюси? Плюси це те, що код буде просто виглядати. Мінуси це те, що рекурсія використовує більше пам’яті, ніж якщо ми вирішуватимемо задачу за допомогою використання циклу. Як правило, більшість рекурсій можна замінити рішенням із циклом.\nПриведемо приклад вирішення задачі через рекурсію та цикл, а також виміряємо використанням пам’яті.\nНапишемо функцію, яка буде рахувати факторіал числа. Факторіал числа – це добуток всіх чисел від 1 до n. Наприклад, факторіал 5 – це 1 * 2 * 3 * 4 * 5 = 120.\n\nРекурсіяЦикл\n\n\n\ndef factorial_rec(n):\n    if n == 1:\n        return n\n    else:\n        return n * factorial_rec(n - 1)\n\nprint(factorial_rec(5))\n\n120\n\n\n\n\n\ndef factorial_loop(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\nprint(factorial_loop(5))\n\n120\n\n\n\n\n\nPython накладає обмеження на 3000 викликів на рекурсію:\n\nimport sys\n\nprint(sys.getrecursionlimit())\n\n3000\n\n\nЦе означає, що якщо ми будемо викликати функцію factorial_rec() з аргументом 3001, то ми отримаємо помилку:\n\nprint(factorial_rec(3001))\n\nRecursionError: maximum recursion depth exceeded\n\n\nТакож за допомогою модуля sys ми можемо встановити обмеження на рекурсію:\n\nimport sys\n\nsys.setrecursionlimit(4000)"
  },
  {
    "objectID": "python_questions.html#класи",
    "href": "python_questions.html#класи",
    "title": "7  Популярні питання",
    "section": "7.3 Класи",
    "text": "7.3 Класи\n\n7.3.1 Що таке клас?\nКлас - це модель для створення об’єктів певного типу, яка описує їх структуру та поведінку. Клас – це шаблон, за яким створюються об’єкти. Клас – це як план будинку, за яким будується будинок.\n\n\n7.3.2 Що таке об’єкт класу?\nОб’єкт класу – це певна унікальна сутність певного типу, тобто класу, який має структуру та поведінку. Об’єкт – це будинок, який ми будуємо за планом.\n\n\n7.3.3 Як реалізувати метод об’єкта та що таке self?\nМетод об’єкта – це функція, яка виконується в контексті об’єкта. Це означає, що в методі ми можемо використовувати атрибути об’єкта, а також інші методи об’єкта.\nself – це посилання на об’єкт, який викликав метод. Це означає, що якщо ми створимо два об’єкти, то в кожному з них буде свій self.\n\nclass Person: # клас\n    name: str # атрибут класу, анотація типу\n\n    def __init__(self, name): # ініціалізатор класу, який приймає аргумент name\n        self.name = name # атрибут об'єкта\n\n    def say_hello(self): # метод класу\n        print(f'Hello, my name is {self.name}!') # використання атрибуту об'єкта\n\np = Person('John')  # створення об'єкта\np.say_hello()       # виклик методу об'єкта\n\nHello, my name is John!\n\n\nМетоди об’єкта першим аргументом приймають self, який є посиланням на об’єкт, який викликав метод. self – це посилання сам об’єкт, який ми створили."
  },
  {
    "objectID": "sql.html#схема-бази-даних",
    "href": "sql.html#схема-бази-даних",
    "title": "SQL",
    "section": "Схема бази даних",
    "text": "Схема бази даних\nУ цьому розділі ми будемо використовувати набори даних, які представляють сервіс з доставки продуктів. Тут зберігається документація, котра допоможе розібратися з ними.\nДля запуску бази даних, я використовую DuckDB. Самі файли з даними можна знайти в репозиторії. Для локального запуску бази даних необхідно виконати наступний код:\n\n# Встановлення та імпорт необхідних пакетів\n!pip install --quiet duckdb\n!pip install --quiet jupysql \n!pip install --quiet duckdb-engine\n!pip install --quiet pandas\n!pip install --quiet matplotlib\n\nimport duckdb\nimport pandas as pd\n\n# Імпорт Jupyter-розширення jupysql для створення SQL комірок\n%load_ext sql\n\n# Налаштування jupysql, щоб дані поверталися у вигляді DataFrame Pandas з меншим виводом\n%config SqlMagic.autopandas = True\n%config SqlMagic.feedback = False\n%config SqlMagic.displaycon = False\n\n# Підключення до DuckDB в режимі \"in-memory\"\nconn = duckdb.connect()\nconn.execute(\"INSTALL 'httpfs';\")\n%sql conn --alias duckdb-native\n\n# Завантаження даних з файлів\n%sql CREATE OR REPLACE TABLE user_actions AS SELECT * FROM read_csv('https://raw.githubusercontent.com/Aranaur/py4ds/main/00_data/sql/user_actions.csv', header=True, columns={'user_id': 'INT', 'order_id': 'INT', 'action': 'VARCHAR', 'time': 'TIMESTAMP'}, timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE courier_actions AS SELECT * FROM read_csv('https://raw.githubusercontent.com/Aranaur/py4ds/main/00_data/sql/courier_actions.csv', header=True, columns={'courier_id': 'INT', 'order_id': 'INT', 'action': 'VARCHAR', 'time': 'TIMESTAMP'}, timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE orders AS SELECT * FROM read_csv('https://raw.githubusercontent.com/Aranaur/py4ds/main/00_data/sql/orders.csv', header=True, columns={'order_id': 'INT', 'creation_time': 'TIMESTAMP', 'product_ids': 'INT[]'}, timestampformat='%d/%m/%y %H:%M');\n%sql CREATE OR REPLACE TABLE users AS SELECT * FROM read_csv('https://raw.githubusercontent.com/Aranaur/py4ds/main/00_data/sql/users.csv', header=True, columns={'user_id': 'INT', 'birth_date': 'DATE', 'sex': 'VARCHAR'}, dateformat='%d/%m/%y');\n%sql CREATE OR REPLACE TABLE couriers AS SELECT * FROM read_csv('https://raw.githubusercontent.com/Aranaur/py4ds/main/00_data/sql/couriers.csv', header=True, columns={'courier_id': 'INT', 'birth_date': 'DATE', 'sex': 'VARCHAR'}, dateformat='%d/%m/%y');\n%sql CREATE OR REPLACE TABLE products AS SELECT * FROM read_csv('https://raw.githubusercontent.com/Aranaur/py4ds/main/00_data/sql/products.csv', header=True, columns={'product_id': 'INT', 'name': 'VARCHAR', 'price': 'DOUBLE'});\n\nНа схемі продемонстровані зв’язки між таблицями, а також опис даних:\n\n\n\n\nerDiagram\n    orders }|..|{ products : product_ids-product_id\n    orders }|..|{ courier_actions : order_id\n    users }|..|{ user_actions : user_id\n    user_actions }|..|{ orders : order_id\n    user_actions }|..|{ courier_actions : time\n    courier_actions }|..|{ courier : product\n    \n    users {\n        DATE birth_date\n        VARCHAR sex\n        INT user_id\n    }\n    user_actions {\n        INT user_id\n        VARCHAR actions\n        INT order_id\n        TIMESTAMP time\n    }\n    orders {\n        INT order_id\n        ARRAY product_ids\n        TIMESTAMP creation_time\n    }\n    products {\n        INT product_id\n        NUMERIC price\n        VARCHAR name\n    }\n    courier_actions {\n        INT courier_id\n        VARCHAR action\n        INT order_id\n        TIMESTAMP time\n    }\n    courier {\n        INT courier_id\n        VARCHAR sex\n        DATE birth_date\n    }"
  },
  {
    "objectID": "sql.html#типи-даних",
    "href": "sql.html#типи-даних",
    "title": "SQL",
    "section": "Типи даних",
    "text": "Типи даних\nВ таблицях можуть зберігатися різні типи даних: цілі і дробові числа, текст, дати, масиви чисел. У цих даних ви зустрінетесь з наступними типами:\n\n\n\n\n\n\n\n\n\nТипи даних\nОпис\nПриклад\n\n\n\n\n0\nINT\nЦіле число\nid користувача: 123\n\n\n1\nNUMERIC / DECIMAL\nДійсне число\nВартість товару: 120.55\n\n\n2\nVARCHAR\nТекст\nДія із замовленням: «create_order»\n\n\n3\nDATE\nДата з точністю до дня\nДата народження користувача: 25/03/91\n\n\n4\nTIMESTAMP\nДата з точністю до секунди\nЧас реєстрації у додатку: 24/08/22 01:52:24\n\n\n5\n[]\nМасив\nСписок id товаров у замовленні: [1, 13, 22]\n\n\n\n\n\n\n\nБільш детально почитати про типи даних можна за посиланням"
  },
  {
    "objectID": "sql.html#структура-та-наповнення-таблиць",
    "href": "sql.html#структура-та-наповнення-таблиць",
    "title": "SQL",
    "section": "Структура та наповнення таблиць",
    "text": "Структура та наповнення таблиць\nuser_actions – дії користувачів із замовленнями.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\nuser_id\nINT\nid користувача\n\n\n1\norder_id\nINT\nid замовлення\n\n\n2\naction\nVARCHAR(50)\nдія користувача із замовленням; \"create_order\"...\n\n\n3\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\n\ncourier_actions – дії кур’єрів із замовленнями.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\norder_id\nINT\nid замовлення\n\n\n2\naction\nVARCHAR(50)\nдія кур'єра із замовленням; 'accept order' - п...\n\n\n3\ntime\nTIMESTAMP\nчас дії\n\n\n\n\n\n\n\norders - інформація про замовлення.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\norder_id\nINT\nid замовлення\n\n\n1\ncreation_time\nTIMESTAMP\nчас створення замовлення\n\n\n2\nproduct_ids\ninteger[]\nсписок id товарів у замовленні\n\n\n\n\n\n\n\nusers - інформація про користувачів.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\nuser_id\nINT\nid користувача\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\ncouriers - інформація про кур’єрів.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\nproducts - інформація про товари, які доставляє сервіс.\n\n\n\n\n\n\n\n\n\nСтовпчик\nТип даних\nОпис\n\n\n\n\n0\ncourier_id\nINT\nid кур'єра\n\n\n1\nbirth_date\nDATE\nдата народження\n\n\n2\nsex\nVARCHAR(50)\nстать\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ дужках типу VARCHAR вказано максимально допустиму кількість символів у тексті. У типу даних NUMERIC у дужках вказано загальну кількість символів."
  },
  {
    "objectID": "sql_basics.html#відбір-select",
    "href": "sql_basics.html#відбір-select",
    "title": "8  Базові запити",
    "section": "8.1 Відбір: SELECT",
    "text": "8.1 Відбір: SELECT\nДавайте спочатку напишемо найпростіший запит і подивимося, як виглядає таблиця products.\nЩоб вивести всі записи зі значеннями у всіх колонках, необхідно або перерахувати всі колонки в операторі SELECT або вказати після оператора спеціальний символ “*”:\nSELECT column_1, column_2, ...\nFROM table\n\n\nSELECT *\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nОператор FROM завжди вказується після оператора SELECT. У зворотному порядку їх записувати не можна – база даних поверне помилку.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.1 Виведіть усі записи з таблиці products.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n1\nsugar\n150.0\n\n\n1\n2\ngreen tea bags\n50.0\n\n\n2\n3\nstill water\n80.0\n\n\n3\n4\nlollipops\n46.0\n\n\n4\n5\ncoffee 3 in 1\n15.0\n\n\n...\n...\n...\n...\n\n\n82\n83\nwaffles\n55.0\n\n\n83\n84\ntangerines\n90.0\n\n\n84\n85\njam\n200.0\n\n\n85\n86\ncold coffee\n70.0\n\n\n86\n87\nveal\n398.0\n\n\n\n\n87 rows × 3 columns\n\n\n\nНа практиці таблиці можуть бути дуже великими, тому дуже бажано використовувати оператор LIMIT для того щоб не виводити всю таблицю, що може займати багато часу. Крім того, можливо такий запит навіть не буде виконано, оскільки розумні дата інженери заборонили виконувати такі запити."
  },
  {
    "objectID": "sql_basics.html#впорядкування-order-by",
    "href": "sql_basics.html#впорядкування-order-by",
    "title": "8  Базові запити",
    "section": "8.2 Впорядкування: ORDER BY",
    "text": "8.2 Впорядкування: ORDER BY\nДля сортування значень по будь-якій колонці SQL використовується оператор ORDER BY з ключовими словами ASC (за зростанням) або DESC (за спаданням).\nПри цьому за умовчанням сортування відбувається за зростанням, тобто ASC не обов’язково вказувати. Для сортування за спаданням після ORDER BY необхідно явно вказати DESC:\nSELECT column_1, column_2\nFROM table\nORDER BY column_1           -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 ASC       -- сортування за зростанням\n\n\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC      -- сортування за спаданням\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.2 Виведіть всі записи з таблиці products, відсортувавши їх за найменуванням товарів у алфавітному порядку, тобто за зростанням. Для сортування використовуйте оператор ORDER BY.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nСортування можна робити не тільки по полях зі значеннями, вираженими числами, але й по полях, значення яких представлені у вигляді тексту, як у нашому випадку.\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nORDER BY name\nLIMIT 5\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n62\napple juice\n120.0\n\n\n1\n71\napples\n75.0\n\n\n2\n39\nbagels\n45.0\n\n\n3\n65\nbananas\n100.0\n\n\n4\n66\nbeef\n370.0\n\n\n\n\n\n\n\nСортувати результат SQL-запиту можна відразу за декількома колонками, вказуючи їх після ORDER BY через кому разом із напрямком сортування (ASC або DESC):\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2    -- спочатку сортування по першій колонці (за спаданням),\n                                    -- потім по другій (за зростанням)\n\n\n\n\n\n\nПримітка\n\n\n\nВажливо пам’ятати, що при роботі з великими таблицями потрібно по можливості обмежувати кількість виведених записів, щоб не створювати зайве навантаження на базу даних.\n\n\nОператори ORDER BY та LIMIT можна поєднувати в одному запиті, при цьому оператор LIMIT записується та виконується після оператора ORDER BY, обмежуючи кількість записів у вже відсортованому результаті:\nSELECT column_1, column_2\nFROM table\nORDER BY column_1 DESC, column_2\nLIMIT 5\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.3 Відсортуйте таблицю courier_actions спочатку по колонці courier_id за зростанням id кур’єра, потім по колонці action (знову за зростанням), а потім по колонці time, але вже за спаданням — від останньої дії до першої. Не забудьте включити колонку order_id.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: courier_id, order_id, action, time.\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЯк ви вже здогадалися, сортувати таблиці можна навіть по полях з датами та часом.\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       order_id,\n       action,\n       time\nFROM   courier_actions\nORDER BY courier_id, action, time DESC limit 5\n\n\n\n\n\n\n\n\n\ncourier_id\norder_id\naction\ntime\n\n\n\n\n0\n1\n23149\ncreate_order\n2022-09-02 02:36:00\n\n\n1\n1\n22901\ncreate_order\n2022-09-02 00:58:00\n\n\n2\n1\n4683\ncreate_order\n2022-08-27 20:56:00\n\n\n3\n1\n1\ncreate_order\n2022-08-24 01:52:00\n\n\n4\n2\n7114\ncreate_order\n2022-08-28 18:11:00\n\n\n\n\n\n\n\nЗараз важливо запам’ятати порядок запису всіх відомих нам ключових слів:\n\nSELECT\nFROM\nORDER BY\nLIMIT\n\nТакож важливо зрозуміти, що порядок їх виконання дещо відрізняється від того, в якій послідовності вони вказуються в SQL-запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nПотім SELECT - відбираються вказані стовпці.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.4 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, визначте 5 найдорожчих товарів у таблиці products, які доставляє наш сервіс. Виведіть їх найменування та ціну.\nПоля у результуючій таблиці: name, price.\n\n\n\n\n\nРішення\n%%sql\nSELECT name,\n       price\nFROM   products\nORDER BY price desc limit 5\n\n\n\n\n\n\n\n\n\nname\nprice\n\n\n\n\n0\ncaviar\n800.0\n\n\n1\nmutton\n559.0\n\n\n2\nolive oil\n450.0\n\n\n3\npork\n450.0\n\n\n4\ndecaffeinated coffee\n400.0"
  },
  {
    "objectID": "sql_basics.html#зміна-назви-as",
    "href": "sql_basics.html#зміна-назви-as",
    "title": "8  Базові запити",
    "section": "8.3 Зміна назви: AS",
    "text": "8.3 Зміна назви: AS\nПри складанні SQL-запитів колонкам у результуючій таблиці можна надавати будь-які інші імена (їх ще називають «аліасами»). Це можна робити за допомогою оператора AS:\nSELECT name AS new_name\nFROM table\nЯкщо раптом вам здасться, що на написання оператора AS йде занадто багато часу і сил, його можна опустити, вказавши нове ім’я колонки без нього. Наступний запис також спрацює:\nSELECT name new_name\nFROM table\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.5 Повторіть запит із з попереднього прикладу (Завдання 8.3), але тепер колонки name і price перейменуйте відповідно на product_name і product_price.\nПоля у результуючій таблиці: product_name, product_price\n\n\n\n\n\nРішення\n%%sql\n\nSELECT name AS product_name,\n       price AS product_price\nFROM   products\nORDER BY price desc limit 5\n\n\n\n\n\n\n\n\n\nproduct_name\nproduct_price\n\n\n\n\n0\ncaviar\n800.0\n\n\n1\nmutton\n559.0\n\n\n2\nolive oil\n450.0\n\n\n3\npork\n450.0\n\n\n4\ndecaffeinated coffee\n400.0"
  },
  {
    "objectID": "sql_basics.html#кількість-символів-length",
    "href": "sql_basics.html#кількість-символів-length",
    "title": "8  Базові запити",
    "section": "8.4 Кількість символів: LENGTH",
    "text": "8.4 Кількість символів: LENGTH\nУ SQL-запитах до колонок таблиць можна використовувати різні функції, наприклад, як в Excel.\nУ загальному вигляді синтаксис функцій виглядає приблизно так:\nSELECT function(a, b, c, ...)\nFROM table\nЗамість function вказується назва функції, а дужках — її аргументи. Як аргументи можуть виступати як колонки зі значеннями, так і окремі значення. Залежно від функції кількість аргументів може відрізнятися.\nЯкщо ви коли-небудь працювали в Excel, то вам, напевно, знайомі різні функції на кшталт SUM, MIN, MAX тощо, які роблять деякі обчислення по стовпцях. У SQL вони називаються агрегуючими функціями.\nЗараз як приклад розглянемо функцію LENGTH. Вона виконує досить просте завдання — підраховує кількість символів у поданому їй на вхід значенні текстового типу (текстовий тип даних часто називають рядком — від англ. «string»). Іншими словами, функція LENGTH вимірює довжину деякого рядка у символах:\n\n%%sql\nSELECT LENGTH('I.love.Python') as py_love\n\n\n\n\n\n\n\n\npy_love\n\n\n\n\n0\n13\n\n\n\n\n\n\n\nФункція LENGTH також може застосовуватись до всього стовпця. У такому випадку довжина символів буде порахована для кожного значення в стовпці. Відповідний запит виглядатиме так:\nSELECT LENGTH(column) AS column_length\nFROM table\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.6 Використовуючи оператори SELECT, FROM, ORDER BY та LIMIT, а також функцію LENGTH, визначте товар із найдовшою назвою у таблиці products. Виведіть його найменування, довжину найменування у символах, а також ціну цього товару. Назвіть колонку з довжиною найменування в символах name_length.\nПоля у результуючій таблиці: name, name_length, price.\n\n\n\n\n\nРішення\n%%sql\nSELECT name,\n       length(name) as name_length,\n       price\nFROM   products\nORDER BY name_length desc limit 1\n\n\n\n\n\n\n\n\n\nname\nname_length\nprice\n\n\n\n\n0\nfruit drink blueberry\n21\n170.0\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що в цьому прикладі ви сортуєте результуючу таблицю по розрахунковій колонці name_length, якої спочатку не було таблиці products.\nТаке сортування за новими колонками можливе, оскільки це узгоджується з порядком виконання операторів у запиті: спочатку виконується вибір колонок і всі перетворення над ними в операторі SELECT — і тільки потім проводиться сортування за вказаними в ORDER BY стовпчиками. Тобто на момент сортування всі розрахункові поля вже існують, а значить, їх можна вказувати в ORDER BY.\nТакож зверніть увагу, що ми двічі вказуємо колонку name в операторі SELECT: вперше просто звертаємося до неї за ім’ям, а вдруге - використовуємо її як аргумент функції LENGTH. У цьому випадку теж немає жодних протиріч - ми можемо вибирати колонку стільки разів, скільки необхідно, причому для цього навіть необов’язково надавати цим колонкам різні аліаси (база даних сама перейменує дублікат колонки).\n\n\nУ SQL, як й у багатьох інших мовах, функції можна застосовувати до інших функцій, тобто. послідовно:\nSELECT function_one(function_two(a, b), c)\nУ наведеній вище конструкції a, b, c аргументи функцій. При цьому одним із аргументів функції function_one є результат виконання функції function_two.\nТаким чином, спочатку буде виконана функція function_two, а потім її результат буде поданий на вхід функції function_one як один з аргументів.\nРозглянемо такий випадок на прикладі функцій UPPER та LEFT. Функція UPPER наводить подане їй на вхід текстове значення до верхнього регістру:\nSELECT \n    UPPER('I.love.Python') AS upper_all\n\nРезультат:\nI.LOVE.PYTHON\nФункція LEFT повертає перші n символів у рядку:\nSELECT \n    LEFT('I.love.Python', 6) AS first_n\n\nРезультат:\nI.love\nМи можемо застосувати ці функції послідовно і в результаті отримаємо перші три символів верхнього регістру:\nSELECT \n    UPPER(LEFT('I.love.Python', 6))\n\nРезультат:\nI.LOVE\n\n\n\n\n\n\nЗастереження\n\n\n\nЗверніть увагу, що у блоці SELECT не можна виконати дві операції окремо, тобто. ми не можемо спочатку створити розрахункову колонку з першими шістьма символами, а потім відразу ж звернутися до цієї нової колонки, застосувавши до неї функцію UPPER.\n\n\nНаступний запит не буде виконано, база даних поверне помилку:\nSELECT \n    LEFT('I.love.Python', 3) AS first_n,\n    UPPER(first_n) AS upper_first_n\n\nРезультат:\nError running query: column \"new_name\" does not exist\nВ межах одного запиту колонки створюються не по черзі, а разом, тому в межах одного запиту колонки upper_first_n не існує, поки блок SELECT не буде повністю виконаний. Дуже важливо враховувати цю особливість мови.\nОднак на практиці до нових колонок доводиться звертатися досить часто — саме для цього є підзапити (запити до інших запитів). А поки що нам достатньо розуміти, що застосовувати функції до розрахункових колонок у тому ж запиті не можна."
  },
  {
    "objectID": "sql_basics.html#поділ-та-повернення-split_part",
    "href": "sql_basics.html#поділ-та-повернення-split_part",
    "title": "8  Базові запити",
    "section": "8.5 Поділ та повернення: SPLIT_PART",
    "text": "8.5 Поділ та повернення: SPLIT_PART\nФункція SPLIT_PART розбиває поданий їй на вхід рядок на кілька частин відповідно до зазначеного роздільника та повертає одну з частин.\nКрім самого рядка (або колонки зі значеннями рядкового типу), функція приймає ще два аргументи — роздільник і порядковий номер частини, яку необхідно повернути. Подивіться наступний приклад:\nSELECT SPLIT_PART('I.love.Python', '.', 3)\n\nРезультат:\nPython\nУ прикладі вище рядок 'I.love.Python' було розбито на три частини ('I', 'love' та 'Python') по роздільнику “.”. Функція повернула 'Python', оскільки третім аргументом ми вказали частину із порядковим номером 3.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з іншими функціями для роботи з рядками можна ознайомитись за посиланням.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.7 Застосуйте послідовно функції UPPER та SPLIT_PART до колонки name та перетворіть найменування товарів у таблиці products так, щоб від назв залишилося тільки перше слово, записане у верхньому регістрі. Колонку з новою назвою, що складається із першого слова, назвіть first_word.\nУ результаті виведіть вихідні найменування товарів, нові найменування з першого слова, а також ціну товарів. Результат відсортуйте за зростанням початкового найменування товару в колонці name.\nПоля у результуючій таблиці: name, first_word, price\n\n\n\n\n\nРішення\n%%sql\nSELECT\n    name,\n    UPPER(SPLIT_PART(name, ' ', 1)) AS first_word,\n    price\nFROM\n    products\nORDER BY\n    name\n\n\n\n\n\n\n\n\n\nname\nfirst_word\nprice\n\n\n\n\n0\napple juice\nAPPLE\n120.0\n\n\n1\napples\nAPPLES\n75.0\n\n\n2\nbagels\nBAGELS\n45.0\n\n\n3\nbananas\nBANANAS\n100.0\n\n\n4\nbeef\nBEEF\n370.0\n\n\n...\n...\n...\n...\n\n\n82\nwaffles\nWAFFLES\n55.0\n\n\n83\nwatermelon\nWATERMELON\n120.0\n\n\n84\nwhite chocolate\nWHITE\n60.0\n\n\n85\nyogurt\nYOGURT\n45.0\n\n\n86\nсowberry juice\nСOWBERRY\n190.0\n\n\n\n\n87 rows × 3 columns"
  },
  {
    "objectID": "sql_basics.html#зміна-типу-cast",
    "href": "sql_basics.html#зміна-типу-cast",
    "title": "8  Базові запити",
    "section": "8.6 Зміна типу: CAST",
    "text": "8.6 Зміна типу: CAST\nІноді виникає необхідність змінити тип даних у якійсь колонці результуючої таблиці, не змінюючи при цьому властивості вихідної таблиці, наприклад, перетворити число на текст (тип даних VARCHAR). І тому існує функція CAST.\nНа вхід функції CAST необхідно подати ім’я колонки, вказавши через AS тип даних, до якого потрібно привести всі значення:\nSELECT CAST(column AS VARCHAR)\nFROM table\nТакож можна змінити тип даних за допомогою спеціального синтаксису з двома двокрапками («::»):\nSELECT column::VARCHAR\nFROM table\nНаприклад, переведемо текст ‘100’ у число 100:\nSELECT CAST('100' AS INTEGER)\n\nРезультат:\n100\nЗверніть увагу, що для успішної конвертації значення повинні бути конвертованими у вказаний тип. Наприклад, текст, який не виглядає як число, перевести до числового типу даних не вийде:\nSELECT CAST('text' AS INTEGER)\n\nРезультат:\nError running query: invalid input syntax for type integer: \"text\"\nАналогічним чином можна, наприклад, перетворити текст на дату (якщо він виглядає як дата):\nSELECT '2022-12-31'::DATE as date\n\nРезультат:\n2022-12-31\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з функцією CAST та перетворенням типів даних можна ознайомитись за цим посиланням.\nПро самі типи даних можна почитати тут.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.8 Змініть тип колонки price з таблиці products на VARCHAR. Виведіть колонки з найменуванням товарів, ціною у вихідному форматі та ціною у форматі VARCHAR. Нову колонку з ціною у новому форматі назвіть price_char.\nРезультат відсортуйте за зростанням початкового найменування товару в колонці name. Кількість записів, що виводяться, не обмежуйте.\nПоля в результуючій таблиці: name, price, price_char\n\n\n\n\n\nРішення\n%%sql\nSELECT \n    name,\n    price,\n    CAST(price as VARCHAR) as price_char\nFROM\n    products\nORDER BY\n    name\n\n\n\n\n\n\n\n\n\nname\nprice\nprice_char\n\n\n\n\n0\napple juice\n120.0\n120.0\n\n\n1\napples\n75.0\n75.0\n\n\n2\nbagels\n45.0\n45.0\n\n\n3\nbananas\n100.0\n100.0\n\n\n4\nbeef\n370.0\n370.0\n\n\n...\n...\n...\n...\n\n\n82\nwaffles\n55.0\n55.0\n\n\n83\nwatermelon\n120.0\n120.0\n\n\n84\nwhite chocolate\n60.0\n60.0\n\n\n85\nyogurt\n45.0\n45.0\n\n\n86\nсowberry juice\n190.0\n190.0\n\n\n\n\n87 rows × 3 columns"
  },
  {
    "objectID": "sql_basics.html#обєднання-concat",
    "href": "sql_basics.html#обєднання-concat",
    "title": "8  Базові запити",
    "section": "8.7 Об’єднання: CONCAT",
    "text": "8.7 Об’єднання: CONCAT\nУ цьому підрозділі ми ще трохи попрацюємо з текстовими даними та розглянемо функцію CONCAT, за допомогою якої можна з’єднувати в один рядок значення кількох стовпців.\nФункція CONCAT приймає на вхід кілька аргументів і повертає результат їхньої послідовної складання один з одним. Хороша аналогія - складання речень з різних карток зі словами:\nSELECT CONCAT('SQL', ' ', 'Python ', 2023)\n\nРезультат:\nSQL Python 2023\nПри цьому аргументи не обов’язково мають бути виражені текстовими значеннями — головне, вони мають бути конвертованими в текст. У прикладі вище число 2023 можна конвертувати в текст ‘2023’, тому запит працює без помилок.\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції CONCAT можна за посиланням.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.9 Для перших 200 записів з таблиці orders виведіть інформацію у такому вигляді (зверніть увагу на пробіли):\nЗамовлення № [id_замовлення] створено [дата]\nОтриману колонку назвіть order_info.\nПриклад результату:\nЗамовлення № 65 створено 2022-09-01\n\n\n\n\n\nРішення\n%%sql\nSELECT \n    CONCAT(\n        'Замовлення № ',\n        order_id,\n        ' створено ',\n        creation_time::DATE\n        ) as order_info\nFROM   \n    orders\nLIMIT 200\n\n\n\n\n\n\n\n\n\norder_info\n\n\n\n\n0\nЗамовлення № 1 створено 2022-08-24\n\n\n1\nЗамовлення № 2 створено 2022-08-24\n\n\n2\nЗамовлення № 3 створено 2022-08-24\n\n\n3\nЗамовлення № 4 створено 2022-08-24\n\n\n4\nЗамовлення № 5 створено 2022-08-24\n\n\n...\n...\n\n\n195\nЗамовлення № 196 створено 2022-08-25\n\n\n196\nЗамовлення № 197 створено 2022-08-25\n\n\n197\nЗамовлення № 198 створено 2022-08-25\n\n\n198\nЗамовлення № 199 створено 2022-08-25\n\n\n199\nЗамовлення № 200 створено 2022-08-25\n\n\n\n\n200 rows × 1 columns"
  },
  {
    "objectID": "sql_basics.html#частина-дати-date_part",
    "href": "sql_basics.html#частина-дати-date_part",
    "title": "8  Базові запити",
    "section": "8.8 Частина дати: DATE_PART",
    "text": "8.8 Частина дати: DATE_PART\nЯк ви вже помітили, у наших таблицях значення деяких колонках представлені у форматі дати (DATE) і часу (TIMESTAMP). Давайте трохи попрацюємо з такими даними.\nНасправді часто зустрічаються завдання, коли потрібна, наприклад, не вся дата, а якась її частина: рік, місяць, день, година тощо. Витягти цю частину вихідних даних дозволяє функція DATE_PART. Її синтаксис наступний:\nSELECT DATE_PART(part, column)\nНа місці part необхідно в лапках вказати ту частину, яку потрібно витягти: 'year', 'month', 'day', 'hour' тощо. На місці column слід вказати потрібну колонку чи конкретну дату чи час. Наприклад:\nSELECT DATE_PART('day', DATE '2022-01-12')\n\nРезультат:\n12.00\n\n\nSELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')\n\nРезультат:\n31.00\nВище ми вказали конкретну дату. На її місці міг бути, наприклад, стовпчик з датами dates. Тоді запит виглядав би так:\nSELECT DATE_PART('day', dates)\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з іншими прикладами використання функції DATE_PART можна за посиланням.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.10 Виведіть id всіх кур’єрів та їхні роки народження з таблиці couriers.\nРік народження необхідно одержати з колонки birth_date. Нову колонку з роком назвіть birth_year. Результат відсортуйте спочатку за спаданням року народження кур’єра (тобто від наймолодших до найстарших), потім за зростанням id кур’єра.\nПоля у результуючій таблиці: courier_id, birth_year\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       date_part('year', birth_date) as birth_year\nFROM   couriers\nORDER BY birth_year desc, courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_year\n\n\n\n\n0\n1592\n2007.0\n\n\n1\n2557\n2007.0\n\n\n2\n1885\n2006.0\n\n\n3\n946\n2005.0\n\n\n4\n1741\n2005.0\n\n\n...\n...\n...\n\n\n2818\n2233\nNaN\n\n\n2819\n2239\nNaN\n\n\n2820\n2656\nNaN\n\n\n2821\n2867\nNaN\n\n\n2822\n2963\nNaN\n\n\n\n\n2823 rows × 2 columns"
  },
  {
    "objectID": "sql_basics.html#перше-ненульове-значення-coalesce",
    "href": "sql_basics.html#перше-ненульове-значення-coalesce",
    "title": "8  Базові запити",
    "section": "8.9 Перше ненульове значення: COALESCE",
    "text": "8.9 Перше ненульове значення: COALESCE\nВи могли помітити, що в минулому прикладі (Завдання 8.10) для окремих рядків функція DATE_PART не повернула рік народження кур’єра, а замість них утворилися порожні значення. Якщо не помітили, уважно подивіться на результат запиту.\nНасправді це сталося тому, що в наших даних у колонці birth_date є перепустки — так звані значення NULL (у виводі результату це NA). Іншими словами, для окремих кур’єрів просто не вказано їхні дні народження. Є безліч варіантів, чому так могло статися, але ми зараз не маємо часу все це з’ясовувати — нам просто потрібно навчитися якось обробляти такі випадки.\nДавайте зробимо так, щоб замість порожніх значень функція DATE_PART повертала якесь інше значення. У цьому нам допоможе функція COALESCE, яка повертає перше не NULL значення зі списку поданих на вхід аргументів.\nРоботу COALESCE можна описати так: вона буквально читає список значень зліва направо і, як тільки бачить значення, яке не є NULL, відразу ж повертає його та припиняє читання списку. Подивіться уважно на такі приклади:\nSELECT COALESCE(NULL, 'I am not NULL' , 'I.love.Python')\n\nРезультат:\nI am not NULL\n\n\nSELECT COALESCE(NULL, 25, 100, 150)\n\nРезультат:\n25\n\n\nSELECT COALESCE('NULL', 'I am not NULL', 'I.love.Python')\n\nРезультат:\nNULL\nОдним із аргументів функції COALESCE може бути результат виконання іншої функції:\nSELECT COALESCE(NULL, LOWER('I am not NULL'), 'I.love.Python')\n\nРезультат:\ni am not null\nЩоб заповнити пропуски в колонці, достатньо застосувати функцію COALESCE до колонки з пропусками та вказати як другий аргумент те значення, яке ми хочемо бачити замість NULL:\nSELECT COALESCE(column, 'filler value')\nFROM table\nФункція COALESCE застосовується до кожного значення колонки. Якщо це значення виявиться NULL, вона замінить його значення, вказане другим аргументом. Якщо значення колонці, навпаки, виявиться не NULL, то функція просто поверне це значення.\nПри цьому до колонки з перепустками можна заздалегідь застосовувати різні інші функції:\nSELECT COALESCE(LEFT(column, 5), 'filler value')\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nЗ іншими прикладами використання функції COALESCE можна за посиланням.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.11 Як і в попередньому прикладі (Завдання 8.10), знову виведіть id десяти відсотків кур’єрів та їх роки народження, тільки тепер до вилученого року застосуйте функцію COALESCE. Вкажіть параметри функції так, щоб замість значення NULL в результат потрапляло текстове значення unknown. Назви полів залиште колишніми.\nПоля у результуючій таблиці: courier_id, birth_year\n\n\n\n\n\nРішення\n%%sql\nSELECT\n    courier_id,\n    COALESCE(date_part('year', birth_date)::VARCHAR, 'unknown') birth_year\nFROM\n    couriers\nUSING SAMPLE 10 PERCENT (bernoulli, 123)\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_year\n\n\n\n\n0\n17\n1997\n\n\n1\n24\n1986\n\n\n2\n40\n1993\n\n\n3\n49\n1996\n\n\n4\n52\n1995\n\n\n...\n...\n...\n\n\n278\n3103\n1991\n\n\n279\n3124\n1992\n\n\n280\n3128\n1997\n\n\n281\n3162\n1996\n\n\n282\n3166\n1994\n\n\n\n\n283 rows × 2 columns"
  },
  {
    "objectID": "sql_basics.html#арифметичні-оператори",
    "href": "sql_basics.html#арифметичні-оператори",
    "title": "8  Базові запити",
    "section": "8.10 Арифметичні оператори",
    "text": "8.10 Арифметичні оператори\nДля роботи з числовими значеннями в DuckDB доступны різні арифметичні оператори. Нижче наведена таблиця з найбільш вживаними операторами:\n\n\n\nОператор\nОпис\nПриклад\nРезультат\n\n\n\n\n+\nДодавання\n2 + 3\n5\n\n\n-\nВіднімання\n2 - 3\n-1\n\n\n*\nМноження\n2 * 3\n6\n\n\n/\nДілення\n4 / 2\n2\n\n\n%\nЗалишок від ділення\n5 % 4\n1\n\n\n^\nПіднесення до степеня\n2 ^ 3\n8\n\n\n\nЯкби ми захотіли перевести 7600 гривен у долари за курсом 1 долар = 40 гривень, то операція виглядала б так:\nSELECT 7500 / 40\n\nРезультат:\n190\nЯкби нам потрібно було відняти з кожного значення в одній із колонок нашої таблиці якесь число (наприклад, 100), то запит виглядав би так:\nSELECT column - 100\nFROM table\nКрім того, в арифметичних операціях можуть брати участь одразу кілька колонок. Наприклад, для кожного рядка таблиці можна обчислити середнє арифметичне двох чисел, які містяться у двох різних колонках:\nSELECT (column_1 + column_2) / 2 AS average\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з усіма арифметичними операторами можна за посиланням.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.12 Давайте уявимо, що з якоїсь незрозумілої причини ми раптом вирішили відразу підвищити ціну всіх товарів у таблиці products на 5%.\nВиведіть id та найменування всіх товарів, їх стару та нову ціну. Колонку зі старою ціною назвіть old_price, а колонку з новою – new_price.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       price*1.05 as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n840.00\n\n\n1\n37\nmutton\n559.0\n586.95\n\n\n2\n15\nolive oil\n450.0\n472.50\n\n\n3\n57\npork\n450.0\n472.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n26.25\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.75\n\n\n84\n73\ncake\n15.0\n15.75\n\n\n85\n10\nseeds\n12.0\n12.60\n\n\n86\n54\npaper bag\n1.0\n1.05\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_basics.html#математичні-функції",
    "href": "sql_basics.html#математичні-функції",
    "title": "8  Базові запити",
    "section": "8.11 Математичні функції",
    "text": "8.11 Математичні функції\nПоряд з арифметичними операторами DuckDB також доступні різні математичні функції. Наприклад, для округлення чисел можна використовувати функцію ROUND:\nSELECT ROUND(100.5454, 2)\n\nРезультат:\n100.55\n\n\nSELECT ROUND(100.551, 1)\n\nРезультат:\n100.6\n\n\nSELECT ROUND(100.5511)\n\nРезультат:\n101.0\nПершим аргументом вказується саме значення, яке хочемо округлити. Другим число знаків після точки, до якої хочемо округлити. Другий аргумент вказувати не обов’язково: якщо його не вказати, відбудеться округлення до цілого числа (проте тип даних при цьому не зміниться).\n\n\n\n\n\n\nПримітка\n\n\n\nОзнайомитись з усіма арифметичними операторами можна за посиланням.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.13 Знову, як і в минулому завданні (Завдання 8.12), підвищите ціну всіх товарів на 5%, тільки тепер до колонки з новою ціною застосуйте функцію ROUND. Виведіть id та найменування товарів, їх стару ціну, а також нову ціну із округленням. Нову ціну округліть до десятих, але тип даних не змінюйте.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       round(price * 1.05, 1) as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n840.0\n\n\n1\n37\nmutton\n559.0\n587.0\n\n\n2\n15\nolive oil\n450.0\n472.5\n\n\n3\n57\npork\n450.0\n472.5\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.0\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n26.3\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.8\n\n\n84\n73\ncake\n15.0\n15.8\n\n\n85\n10\nseeds\n12.0\n12.6\n\n\n86\n54\npaper bag\n1.0\n1.1\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_basics.html#умовна-конструкція-case-when",
    "href": "sql_basics.html#умовна-конструкція-case-when",
    "title": "8  Базові запити",
    "section": "8.12 Умовна конструкція: CASE WHEN",
    "text": "8.12 Умовна конструкція: CASE WHEN\nА якби ми захотіли підвищити ціну не на всі товари, а, скажімо, тільки на дорогі?\nДля цього нам потрібно було б створити деяку функцію, яка перевіряла б кожне значення в колонці price і порівнювала б його з якимось пороговим значенням. Якби ціна виявлялася вищою за цей поріг, то функція підвищувала б ціну, а якщо ні — залишала б без змін.\nІ таку функцію можна задати за допомогою умовної конструкції CASE. Вона має наступний синтаксис:\nCASE  \nWHEN logical_expression_1 THEN expression_1\nWHEN logical_expression_2 THEN expression_2\n...\nELSE expression_else\nEND AS case_example\nЦя конструкція може бути громіздкою, але насправді в ній немає нічого складного. Логіка роботи оператора CASE досить проста:\n\nНа кожному етапі WHEN - THEN обчислюється деякий логічний вираз logical_expression, що стоїть після WHEN. Якщо воно виявляється істинним (TRUE), то в якості результату оператор повертає вираз expression, що стоїть після THEN, і закінчує свою роботу.\nЯкщо вираз виявляється помилковим (FALSE), то оператор продовжує роботу та перевіряє наступну умову.\nЯкщо жодна з умов не проходить перевірку на істинність, повертається вираз, вказаний після ELSE. При цьому ELSE вказувати не обов’язково - якщо його не вказати, то повернеться порожнє значення NULL (у разі, якщо всі перевірки після WHEN виявилися помилковими).\nНасамкінець обов’язково вказується ключове слово END, яке говорить про закінчення конструкції CASE. Також після END новому розрахунковому полю за допомогою AS можна надати деяке ім’я, але це робити не обов’язково. Обов’язковими є лише ключові слова CASE, WHEN, THEN та END.\n\nНаступна конструкція розіб’є весь список найменувань на три категорії: «м’ясо», «риба» та «інше». Відповідно, якщо у перших двох умовах ми не врахуємо якісь назви з колонки name (наприклад, «телятину»), то вони потраплять до категорії «інше».\nSELECT name,\n       CASE \n       WHEN name='свинина' OR name='баранина' OR name='курка' THEN \"м'ясо\"\n       WHEN name='тріска' OR name='форель' OR name='окунь' THEN 'риба'\n       ELSE 'інше'\n       END AS сategory\nFROM table\nТепер трохи про логічні вирази: SQL можуть включати оператори порівняння і логічні операції.\nДо операторів порівняння належать:\n\n= («рівно»)\n&lt;&gt; або != («не дорівнює»)\n&lt; («менше»)\n&gt; («більше»)\n&lt;= («менше або дорівнює»)\n&gt;= («більше чи дорівнює»)\n\nРезультатом роботи операторів порівняння можуть бути три стани:\n\nTRUE («істина»)\nFALSE (помилка)\nNULL («невизначений стан» - коли одне з порівнюваних значень NULL)\n\nЗ цими трьома станами можна проводити такі логічні операції:\n\nAND («І»)\nOR («АБО»)\nNOT («НЕ»)\n\nРезультатом цих логічних операцій також можуть бути три вищевказані логічні стани (TRUE, FALSE або NULL):\n\n\n\na\nb\na AND b\na OR b\n\n\n\n\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nNULL\nNULL\nTRUE\n\n\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nFALSE\nNULL\nFALSE\nNULL\n\n\nNULL\nNULL\nNULL\nNULL\n\n\n\n\n\n\na\nNOT a\n\n\n\n\nTRUE\nFALSE\n\n\nFALSE\nTRUE\n\n\nNULL\nNULL\n\n\n\nТаким чином, оператори порівняння та логічні операції дозволяють писати комплексні логічні вирази.\nЗапам’ятати всі ці таблиці та комбінації не обов’язково. Головне, завжди тримайте цю пам’ятку під рукою.\nПрипустимо, відомо, що \\(a=10\\) і \\(b=5\\). Тоді наступний логічний вираз поверне TRUE:\na &gt;= 10 OR b &gt; 10\nТакож важливо розуміти, що є пріоритети виконання операцій:\n\nмноження та ділення (* та /)\nдодавання та віднімання (+ та -)\nоператори порівняння (=, !=, &gt;, &lt;, &gt;=, &lt;=)\nNOT\nAND\nOR\n\nНа порядок виконання операторів можна також впливати за допомогою дужок. Вирази, поміщені в дужки, матимуть найвищий пріоритет — як у математиці.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.14 Підвищіть ціну на 5% тільки на товари, вартість яких перевищує 100 одиниць. Ціну решти товарів залиште без змін. Також не підвищуйте ціну на ікру (caviar), яка й так коштує 800 одиниць. Виведіть id та найменування всіх товарів, їх стару та нову ціну. Ціну округляти не потрібно.\nРезультат відсортуйте спочатку за спаданням нової ціни, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       case when price &lt;= 100 or\n                 name = 'caviar' then price\n            else price * 1.05 end as new_price\nFROM   products\nORDER BY new_price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n800.00\n\n\n1\n37\nmutton\n559.0\n586.95\n\n\n2\n15\nolive oil\n450.0\n472.50\n\n\n3\n57\npork\n450.0\n472.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n420.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n25.00\n\n\n83\n5\ncoffee 3 in 1\n15.0\n15.00\n\n\n84\n73\ncake\n15.0\n15.00\n\n\n85\n10\nseeds\n12.0\n12.00\n\n\n86\n54\npaper bag\n1.0\n1.00\n\n\n\n\n87 rows × 4 columns\n\n\n\nУявіть, що до вас звернувся менеджер із сусіднього відділу із проханням порахувати ПДВ кожного товару. Жодних додаткових даних він вам не надав, тому ви вирішили виконати завдання на власний розсуд, вважаючи, що ПДВ єдиний для всіх товарів і становить 20%.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 8.15 Обчисліть ПДВ кожного товару у таблиці products та розрахуйте ціну без урахування ПДВ. Виведіть всю інформацію про товари, включаючи суму податку та ціну без його врахування. Колонки із сумою податку та ціною без ПДВ назвіть відповідно tax та price_before_tax. Округліть значення у цих колонках до двох знаків після коми.\nРезультат відсортуйте спочатку за спаданням ціни товару без урахування ПДВ, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, tax, price_before_tax.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       round((price * 0.2) / 1.2, 2) as tax,\n       round(price / 1.2, 2) as price_before_tax\nFROM   products\nORDER BY price_before_tax desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ntax\nprice_before_tax\n\n\n\n\n0\n13\ncaviar\n800.0\n133.33\n666.67\n\n\n1\n37\nmutton\n559.0\n93.17\n465.83\n\n\n2\n15\nolive oil\n450.0\n75.00\n375.00\n\n\n3\n57\npork\n450.0\n75.00\n375.00\n\n\n4\n43\ndecaffeinated coffee\n400.0\n66.67\n333.33\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n4.17\n20.83\n\n\n83\n5\ncoffee 3 in 1\n15.0\n2.50\n12.50\n\n\n84\n73\ncake\n15.0\n2.50\n12.50\n\n\n85\n10\nseeds\n12.0\n2.00\n10.00\n\n\n86\n54\npaper bag\n1.0\n0.17\n0.83\n\n\n\n\n87 rows × 5 columns"
  },
  {
    "objectID": "sql_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "href": "sql_basics.html#типові-помилки-при-написанні-sql-запитів.",
    "title": "8  Базові запити",
    "section": "8.13 Типові помилки при написанні SQL-запитів.",
    "text": "8.13 Типові помилки при написанні SQL-запитів.\n\nНеправильний порядок або помилки у ключових словах. Правильний порядок операторів у запиті виглядає так:\n\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- угруповання даних\nHAVING      -- фільтрація даних після угруповання\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\nНеправильно названі функції та оператори, що використовуються в запиті (наприклад, DATEPART, а не DATE_PART).\nНеправильно вказано імена стовпців.\nНеправильно виконано сортування записів.\nНеправильно проведено розрахунки.\nПропущена кома при перерахуванні стовпців у SELECT\nЗайва кома після імені останнього стовпця в SELECT\nНе закриті дужки (перевірте, що кількість дужок дорівнює кількості закривають).\nДопущено помилку в підзапиті (перед виконанням всього запиту перевірте, чи працюють окремі підзапити).\nЗапущено відразу кілька запитів, не розділених крапкою з комою."
  },
  {
    "objectID": "sql_filter.html#базова-фільтрація-where",
    "href": "sql_filter.html#базова-фільтрація-where",
    "title": "9  Фільтрація даних",
    "section": "9.1 Базова фільтрація: WHERE",
    "text": "9.1 Базова фільтрація: WHERE\nВ SQL для фільтрації даних використовується оператор WHERE. Після оператора WHERE вказується логічний вираз, результат якого визначає, чи буде рядок включений до результуючої таблиці. Якщо умова виявляється істинною (TRUE), то рядок включається до результату, якщо хибним (FALSE) — рядок виключається.\nТаким чином, кожен рядок у таблиці проходить перевірку на відповідність певній умові, і в результаті цих перевірок формується таблиця, над якою проводяться операції, зазначені в блоці SELECT.\nОператор WHERE та логічний вираз вказуються після блоку FROM:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 0\nНаприклад, у результаті зазначеного вище запиту у вибірці попадуть лише записи з невід’ємними значеннями в колонці column_2.\nУ свою чергу оператори ORDER BY і LIMIT записуються вже після оператора WHERE. Якщо додати їх у приклад вище, запит виглядатиме так:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 0\nORDER BY column_1\nLIMIT 100\nУ результаті ми спочатку відфільтруємо необхідні нам рядки, потім виберемо стовпчики, виділені в SELECT, а потім сортуємо результуючу таблицю, обмеживши число виведених записів.\nТаким чином порядок запису відомих нам на поточний момент ключових слів виглядає так:\n\nSELECT\nFROM\nWHERE\nORDER BY\nLIMIT\n\nЗнову звернемо увагу, що порядок виконання відрізняється від того, в якій послідовності вони вказуються в запиті:\n\nСпочатку виконується оператор FROM – відбувається вибір потрібної таблиці.\nДалі WHERE - відфільтровуються рядки, що відповідають умові.\nПотім SELECT - відбираються зазначені стовпці та застосовуються функції.\nПотім ORDER BY - проводиться сортування результуючої таблиці.\nІ наприкінці LIMIT — обмежується кількість записів, що виводяться.\n\nІншими словами, в результаті виконання запиту спочатку відбувається підготовка таблиці до роботи, а потім над нею виконуються різні операції.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про оператор WHERE можна за посиланням.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.1 Напишіть SQL-запит до таблиці products та виведіть всю інформацію про товари, ціна яких не перевищує 100 одиниць. Результат відсортуйте за зростанням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT \n    product_id,\n    name,\n    price\nFROM   products\nWHERE  price &lt;= 100\nORDER BY product_id\nLIMIT  10;\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n2\ngreen tea bags\n50.0\n\n\n1\n3\nstill water\n80.0\n\n\n2\n4\nlollipops\n46.0\n\n\n3\n5\ncoffee 3 in 1\n15.0\n\n\n4\n6\ncrackers\n25.0\n\n\n5\n8\ndrying\n30.0\n\n\n6\n9\nblack leaf tea\n84.0\n\n\n7\n10\nseeds\n12.0\n\n\n8\n14\nmayonnaise\n60.0\n\n\n9\n18\nketchup\n58.0\n\n\n\n\n\n\n\nФільтрувати дані в таблицях можна не тільки по полях з числовими значеннями, але і по полях зі значеннями, представленими у вигляді тексту:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 = 'text'\nУ прикладі вище в результуючу таблицю потраплять лише рядки, значення в яких повністю збігаються із зазначеним у WHERE рядком 'text'.\nПри порівнянні рядків також допускається використовувати нерівності:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt; 'text'\nВтім, така операція використовується рідше, оскільки не цілком очевидно, що означає «один рядок більше за інший».\nНасправді порядок сортування даних рядкового типу зазвичай визначається заздалегідь встановленими правилами сортування, у яких значення мають довжина рядка в символах, порядок букв відповідно до алфавіту, наявність особливих символів, регістр тощо. Ми не будемо докладно зупинятись на цій темі — за бажання про це можна додатково прочитати у документації.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про правила сортування даних рядкового типу можна за посиланням.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.2 Виберіть користувачів жіночої статі з таблиці users. Виведіть лише id цих користувачів. Результат відсортуйте за зростанням id.\nДодайте в запит оператор LIMIT і виведіть лише 10 перших ID з відсортованого списку.\nПоле у результуючій таблиці: user_id\n\n\n\n\n\nРішення\n%%sql\nSELECT \n    user_id\nFROM   \n    users\nWHERE  \n    sex = 'female'\nORDER BY \n    user_id \nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n5\n7\n\n\n6\n8\n\n\n7\n11\n\n\n8\n12\n\n\n9\n13\n\n\n\n\n\n\n\nЯк значення для фільтрації можна також використовувати дати та час:\nSELECT column_1\nFROM table\nWHERE column_2 &lt;= '2022-12-31'\n\n\nSELECT column_1\nFROM table\nWHERE column_2 &lt;= '2022-12-31 00:00:00'\nОднак при цьому важливо заздалегідь переконатися, що в колонці, за якою фільтруватимуться дані, знаходяться саме дати або мітки часу, а не дані рядкового типу, зовні схожі на дати. Якщо в колонці виявляться рядки, то як такої помилки не відбудеться, проте результат сильно відрізнятиметься від очікуваного.\nТакож в операціях порівняння дат важливо враховувати, що дата завжди інтерпретується опівночі (початок дня), тобто '2022-12-31' насправді означає '2022-12-31 00:00:00'.\nДо речі, ніщо не забороняє нам комбінувати в блоці WHERE різні умови з різними типами даних і створювати складніші логічні вирази:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_1 &gt;= 0 \n      AND column_2 = 'some text' \n      AND column_3 = '2022-12-31'\nДавайте якраз вирішимо завдання одразу з кількома умовами!\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.3  Виберіть з таблиці user_actions усі дії користувачів зі створення замовлень, які були зроблені ними після опівночі 6 вересня 2022 року. Виведіть колонки з id користувачів, id створених замовлень та часом їх створення.\nРезультат має бути відсортований за зростанням id замовлення.\nПоля в результуючій таблиці: user_id, order_id, time\nПояснення: зверніть увагу, що в таблиці user_actions у кожного користувача можуть бути записи не тільки з часом створення замовлення, а й часом його скасування. Нам необхідно отримати лише записи із створенням замовлень.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       time\nFROM   user_actions\nWHERE  action = 'create_order' and time &gt; '2022-09-06'\nORDER BY order_id\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\ntime\n\n\n\n\n0\n16721\n45201\n2022-09-06 00:01:00\n\n\n1\n17299\n45202\n2022-09-06 00:01:00\n\n\n2\n7957\n45203\n2022-09-06 00:01:00\n\n\n3\n17300\n45204\n2022-09-06 00:02:00\n\n\n4\n14723\n45205\n2022-09-06 00:03:00\n\n\n...\n...\n...\n...\n\n\n14390\n21402\n59591\n2022-09-08 23:58:00\n\n\n14391\n20859\n59592\n2022-09-08 23:58:00\n\n\n14392\n15131\n59593\n2022-09-08 23:59:00\n\n\n14393\n10881\n59594\n2022-09-08 23:59:00\n\n\n14394\n19774\n59595\n2022-09-08 23:59:00\n\n\n\n\n14395 rows × 3 columns\n\n\n\nВ операторі WHERE можна використовувати не тільки колонки, які вже є в таблиці, але й розрахункові колонки. При цьому вказувати їх у SELECT знову ж таки не обов’язково:\nSELECT column_1, column_2, (column_1 + column_2) * 0.5 AS average\nFROM table\nWHERE (column_1 + column_2) * 0.5 = 10\n\n\nSELECT column_1, column_2\nFROM table\nWHERE (column_1 + column_2) * 0.5 = 10 \nУ прикладі вище ми відфільтруємо тільки ті записи, для яких середнє арифметичне двох чисел, що містяться в колонках column_1 і column_2, дорівнюватиме 10.\nТакож важливо враховувати, що використовувати в блоці WHERE аліаси, які присвоєно новим розрахунковим колонкам, не можна. Зверніть увагу на приклади наступних запитів, які вважають частку значень колонки column_1 у відповідних їм значеннях колонки column_2. Перший запит спрацює, а другий поверне помилку:\n-- Цей запит спрацює:\n\nSELECT column_1, column_2, \n       column_1 / column_2 AS share\nFROM table\nWHERE column_1 / column_2 &gt; 50\n\n\n-- Цей запит поверне помилку:\n\nSELECT column_1, column_2, \n       column_1 / column_2 AS share\nFROM table\nWHERE share &gt; 50\nЦе пов’язано всі з тією ж послідовністю виконання операторів у запиті: на момент виконання оператора WHERE аліас колонці ще не присвоєно, і тому база даних поки не знає про існування колонки з новим ім’ям.\nМожна розглянути ще більш тривіальний приклад: навіть якщо ми просто зробимо дублікат колонки з іншим ім’ям і спробуємо використати це ім’я в WHERE, все одно отримаємо помилку:\n-- Цей запит поверне помилку:\n\nSELECT column, column AS same_column\nFROM table\nWHERE same_column &gt; 0\nПри вказівці фільтрів у блоці WHERE важливо враховувати розглянуті особливості. Можете керуватися наступним правилом: якщо збираєтеся фільтрувати дані по розрахунковій колонці, то дублюйте розрахунки WHERE і не використовуйте аліаси, присвоєні новим колонкам.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.4 Призначте знижку 20% на всі товари з таблиці products та відберіть ті, ціна на які з урахуванням знижки перевищує 100. Виведіть id товарів, їх найменування, колишню ціну та нову ціну з урахуванням знижки. Колонку зі старою ціною назвіть old_price, новою — new_price.\nРезультат має бути відсортований за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, old_price, new_price\nПояснення: будьте уважні, коли вказуватимете фільтр після оператора WHERE.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price as old_price,\n       price * 0.8 as new_price\nFROM   products\nWHERE  price * 0.8 &gt; 100\nORDER BY product_id\nLIMIT 10 -- для скорочення виводу\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nold_price\nnew_price\n\n\n\n\n0\n1\nsugar\n150.0\n120.0\n\n\n1\n7\ngrain coffee\n351.0\n280.8\n\n\n2\n11\nlinseed oil\n200.0\n160.0\n\n\n3\n12\ngrape\n278.0\n222.4\n\n\n4\n13\ncaviar\n800.0\n640.0\n\n\n5\n15\nolive oil\n450.0\n360.0\n\n\n6\n17\nсowberry juice\n190.0\n152.0\n\n\n7\n19\nsalted fish\n180.0\n144.0\n\n\n8\n21\nground coffee\n283.0\n226.4\n\n\n9\n25\ninstant coffee\n150.0\n120.0\n\n\n\n\n\n\n\nПісля оператора WHERE до колонок можна також застосовувати різні функції:\nSELECT column_1, column_2\nFROM table \nWHERE LOWER(column_1) = 'i.love.python'\nУ прикладі вище кожне значення колонки column_1 спочатку буде приведено до нижнього регістру, а потім зіставлено зі значенням ‘i.love.python’. При цьому результат буде включено вихідні значення в колонці column_1. Таким чином, функція послужить тільки для фільтрації записів, але самі значення в колонках ніяк не вплине.\nЗверніть увагу, що використовувати аліаси, присвоєні колонкам в операторі SELECT, так само не можна. Наступний запит поверне помилку:\n-- Цей запит поверне помилку:\n\nSELECT column_1 AS new_column_1, column_2\nFROM table \nWHERE LOWER(new_column_1) = 'i.love.python'\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.5 Відберіть із таблиці products всі товари, назви яких або починаються зі слова «tea», або складаються з п'яти символів. Виведіть дві колонки: id товарів та їх найменування.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\nПояснення: для вирішення завдання вам знадобляться функції SPLIT_PART та LENGTH, які ми розглядали раніше.\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля вирішення завдання в операторі WHERE до колонки з назвами товарів необхідно застосувати функцію SPLIT_PART, розділивши по пробілу на окремі слова і відібравши тільки ті, в яких перше слово - «tea». Також через OR необхідно додати другу умову з функцією LENGTH для перевірки, що найменування складається з 5 символів.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name\nFROM   products\nWHERE  split_part(name, ' ', 1) = 'tea'\n    or length(name) = 5\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n1\nsugar\n\n\n1\n10\nseeds\n\n\n2\n12\ngrape\n\n\n3\n26\nchips\n\n\n4\n28\ncream\n\n\n5\n34\npasta\n\n\n6\n36\ntea mushroom\n\n\n7\n40\nbread\n\n\n8\n52\nkvass\n\n\n9\n53\nflour\n\n\n10\n61\nhoney\n\n\n11\n72\npears"
  },
  {
    "objectID": "sql_filter.html#пошук-за-шаблоном-like",
    "href": "sql_filter.html#пошук-за-шаблоном-like",
    "title": "9  Фільтрація даних",
    "section": "9.2 Пошук за шаблоном: LIKE",
    "text": "9.2 Пошук за шаблоном: LIKE\nУявіть, що із загального списку найменувань товарів нам раптом знадобилося відібрати певні позиції, які містять певні слова і навіть символи. Але при цьому ми точно не знаємо, в якій частині назви їх можна зустріти.\nНаприклад, нам потрібні всі “tea”, але вони необов’язково повинні починатися зі слова “tea”.\nАле як це зробити? Невже нам доведеться переглядати всю таблицю, вручну складати список товарів і писати довгий логічний вираз, що враховує всі можливі сценарії?\nЗрозуміло, що ні. Для фільтрації по колонках з текстовими значеннями в SQL передбачений оператор LIKE.\nОператор LIKE не просто порівнює рядки на повний збіг (або розбіжність), а перевіряє їх на відповідність заданому шаблону: якщо рядок йому відповідає, то повертається TRUE, інакше — FALSE. Як можна здогадатися, конструкція NOT LIKE працює з точністю навпаки.\nШаблони можуть містити як звичайні символи, так і символи-шаблони: знак відсотка (%) та підкреслення (_). Підкреслення підміняє будь-який одиночний символ, а знак відсотка - будь-яку (у тому числі порожню) послідовність символів:\nSELECT 'love.python' LIKE 'love%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE 'love_'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE '%love%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE '_love%'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE '%.%'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE '_._'\n\nРезультат:\nfalse\n\nSELECT 'love.python' LIKE 'Love%'\n\nРезультат:\nfalse\nЗверніть увагу на останній приклад: оператор LIKE чутливий до регістру.\nЯкщо шаблон не містить знаків відсотка та підкреслень, тоді шаблон є рядком і LIKE працює як оператор порівняння, перевіряючи рядки на точний збіг.\nSELECT 'love.python' LIKE 'love.python'\n\nРезультат:\ntrue\n\nSELECT 'love.python' LIKE 'love'\n\nРезультат:\nfalse\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про оператор LIKE та шаблони можна почитати тут.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.6 Відберіть із таблиці products всі товари, що містять у своїй назві послідовність символів «tea» (без лапок). Виведіть дві колонки: id продукту та його назву.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\n\n\n\n\n\nРішення\n%%sql\nSELECT  product_id,\n        name\nFROM    products\nWHERE   name LIKE '%tea%'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n2\ngreen tea bags\n\n\n1\n9\nblack leaf tea\n\n\n2\n27\nherbal leaf tea\n\n\n3\n36\ntea mushroom\n\n\n4\n45\nleaf green tea\n\n\n5\n48\nivan-tea in bags\n\n\n6\n50\ncold tea\n\n\n7\n76\nblack tea bags\n\n\n8\n79\nherbal tea bags\n\n\n\n\n\n\n\nТепер зробимо наш фільтр трохи цікавішим.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.7 Виберіть із таблиці products id та найменування лише тих товарів, назви яких починаються на букву “c” і містять лише одне слово.\nРезультат має бути відсортований за зростанням id товару.\nПоля у результуючій таблиці: product_id, name\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЯкщо з буквою «c» все зрозуміло, то з фільтром на одне слово ситуація трохи складніша: подумайте, яким символом принципово відрізняються рядки з одним і двома словами. Складіть шаблон для пошуку рядка, що складається з двох слів і виключіть такі рядки з результату.\nТакож будьте уважні мовою введення: латинська літера “c” та кирилична “с” виглядають однаково, але для бази даних це різні символи.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name\nFROM   products\nWHERE  name like 'c%'\n   and name not like '% %'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\n\n\n\n\n0\n6\ncrackers\n\n\n1\n13\ncaviar\n\n\n2\n26\nchips\n\n\n3\n28\ncream\n\n\n4\n46\ncookie\n\n\n5\n73\ncake\n\n\n6\n77\nchicken\n\n\n7\n78\ncupcakes\n\n\n\n\n\n\n\nУявіть, що напередодні Нового року до вас звернувся менеджер, якому на думку спала ідея зробити знижку на найдорожчий чай. Він попросив вас надати йому вивантаження з бази даних з усіма чаями та новими цінами на них з урахуванням знижки.\nЩо він далі робитиме з цими даними, вам невідомо, але завдання є завдання, до того ж не таке вже й складне. Спробуймо його вирішити!\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.8 Складіть SQL-запит, який вибирає з таблиці products всі чаї вартістю більше 60 і нараховує їм знижку 25%.\nЗнижку в % менеджер попросив вказати в окремому стовпці у форматі тексту, тобто так: «25%» (без лапок). Стовпці зі знижкою та новою ціною назвіть відповідно discount та new_price.\nТакож необхідно будь-яким відомим способом позбавитися «tea mushroom»: навряд чи менеджер мав на увазі і його, коли ставив нам завдання.\nРезультат має бути відсортований за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, discount, new_price\nПояснення:\nЩоб вказати стовпець з одним значенням для всіх записів (у нашому випадку це стовпець зі знижкою), достатньо просто ввести потрібне значення і дати стовпцю якусь назву - вказане значення автоматично проставиться у всіх рядках результуючої таблиці:\nSELECT column_1, 'text' AS column_2\nFROM table\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       '25%' as discount,\n       price * 0.75 as new_price\nFROM   products\nWHERE  price &gt; 60\n   and name != 'tea mushroom'\n   and name like '%tea%'\nORDER BY product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ndiscount\nnew_price\n\n\n\n\n0\n9\nblack leaf tea\n84.0\n25%\n63.00\n\n\n1\n27\nherbal leaf tea\n121.0\n25%\n90.75\n\n\n2\n45\nleaf green tea\n78.0\n25%\n58.50\n\n\n3\n79\nherbal tea bags\n65.0\n25%\n48.75"
  },
  {
    "objectID": "sql_filter.html#in-та-between-для-фільтрації",
    "href": "sql_filter.html#in-та-between-для-фільтрації",
    "title": "9  Фільтрація даних",
    "section": "9.3 IN та BETWEEN для фільтрації",
    "text": "9.3 IN та BETWEEN для фільтрації\nАле якщо ми все-таки не хочемо перевіряти наші дані на відповідність якомусь шаблону, а просто хочемо відібрати значення з деякого списку або навіть діапазону? У цьому випадку у логічному виразі після ключового слова WHERE можна використовувати оператори IN та BETWEEN.\nОператор IN перевіряє, чи відповідає значення в колонці одному із значень із заданого списку. Іншими словами, він перевіряє, чи входить значення до цього списку:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IN ('product_1', 'product_2', 'product_3')\nУ свою чергу, оператор BETWEEN дозволяє відібрати дані, що відносяться до деякого інтервалу. При цьому межі інтервалу включаються:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 BETWEEN 5 AND 10\nЗапит вище відповідає наступному запиту:\nSELECT column_1, column_2\nFROM table\nWHERE column_2 &gt;= 5 AND column_2 &lt;= 10\nОператор BETWEEN можна використовувати і для фільтрації по колонках з датами та часом:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_3 BETWEEN '2022-11-20' AND '2022-12-31'\nОднак, в такому випадку, треба враховувати, що дата завжди інтерпретується опівночі (початок дня), тобто. ‘2022-12-31’ насправді означає ‘2022-12-31 00:00:00’. Тож заданий вище інтервал не потраплять записи пізніше опівночі ‘2022-12-31’, тобто цей день практично не буде враховано в інтервалі.\nПри цьому, запит вище буде рівносильний наступному запиту:\nSELECT column_1, column_2, column_3\nFROM table\nWHERE column_3 &gt;= '2022-11-20' AND column_3 &lt;= '2022-12-31'\nДля отримання зворотного результату у поєднанні з операторами IN та BETWEEN можна використовувати оператор NOT:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 NOT IN ('product_1', 'product_2', 'product_3')\n\n\nSELECT column_1, column_2\nFROM table\nWHERE column_2 NOT BETWEEN 5 AND 10\n\n\n\n\n\n\nПримітка\n\n\n\nДетальніше про оператори IN та BETWEEN можна прочитати тут і тут.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.9 З таблиці user_actions виведіть всю інформацію про дії користувачів з id 170, 200 та 230 за період з 25 серпня до 4 вересня 2022 року включно. Результат відсортуйте за зменшенням id замовлення - тобто від останніх до найпізніших.\nПоля у результуючій таблиці: user_id, order_id, action, time\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       action,\n       time\nFROM   user_actions\nWHERE  user_id in (170, 200, 230)\n   and time &gt;= '2022-08-25'\n   and time &lt; '2022-09-05' -- уважно з датами!\nORDER BY order_id desc\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\naction\ntime\n\n\n\n\n0\n170\n34428\ncreate_order\n2022-09-04 01:43:00\n\n\n1\n170\n34424\ncreate_order\n2022-09-04 01:42:00\n\n\n2\n230\n24675\ncreate_order\n2022-09-02 12:21:00\n\n\n3\n200\n24538\ncreate_order\n2022-09-02 11:50:00\n\n\n4\n230\n22887\ncreate_order\n2022-09-02 00:54:00\n\n\n5\n230\n22878\ncreate_order\n2022-09-02 00:50:00\n\n\n6\n230\n19543\ncreate_order\n2022-09-01 07:21:00\n\n\n7\n170\n14894\ncreate_order\n2022-08-30 22:04:00\n\n\n8\n230\n14466\ncreate_order\n2022-08-30 19:51:00\n\n\n9\n170\n4194\ncreate_order\n2022-08-27 17:28:00\n\n\n10\n170\n4190\ncreate_order\n2022-08-27 17:27:00\n\n\n11\n200\n3416\ncreate_order\n2022-08-27 09:36:00\n\n\n12\n200\n3413\ncreate_order\n2022-08-27 09:34:00\n\n\n13\n170\n1234\ncreate_order\n2022-08-25 23:35:00\n\n\n14\n230\n263\ncreate_order\n2022-08-25 02:54:00\n\n\n15\n200\n229\ncreate_order\n2022-08-25 01:52:00\n\n\n16\n200\n226\ncreate_order\n2022-08-25 01:50:00\n\n\n17\n170\n188\ncreate_order\n2022-08-25 00:49:00"
  },
  {
    "objectID": "sql_filter.html#фільтрація-з-null",
    "href": "sql_filter.html#фільтрація-з-null",
    "title": "9  Фільтрація даних",
    "section": "9.4 Фільтрація з NULL",
    "text": "9.4 Фільтрація з NULL\nРаніше Завдання 8.11 ми зіткнулися з пропущеними значеннями в таблиці couriers — у деяких кур’єрів не було зазначено їхні дні народження.\nДля перевірки на NULL значення SQL є оператор IS NULL. У поєднанні з WHERE записується він так:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IS NULL\nЯкщо ж, навпаки, необхідно відібрати значення не NULL, то додатково використовується оператор NOT:\nSELECT column_1, column_2\nFROM table\nWHERE column_1 IS NOT NULL\nЯк ми знаємо, у світі даних NULL означає відсутність інформації. NULL - це не якась величина і тому її не можна порівняти з чимось ще. Результатом порівняння NULL з будь-яким іншим значенням буде той самий NULL. Більше того, NULL не вдасться порівняти і з іншим NULL, тому що в такому випадку порівнюватимуться дві невизначеності і не можна напевно сказати, рівні вони чи ні.\nСпробуйте виконати наступні запити:\nSELECT NULL = NULL\n\nРезультат:\nNULL\n\nSELECT NULL IS NULL\n\nРезультат:\ntrue\n\nSELECT 100 = NULL\n\nРезультат:\nNULL\n\nSELECT 100 IS NULL\n\nРезультат:\nfalse\n\n\n\n\n\n\nПримітка\n\n\n\nДетальніше про значення NULL можна прочитати тут.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.10 Напишіть SQL-запит до таблиці couriers та виведіть всю інформацію про кур’єрів, у яких не вказано їх день народження.\nРезультат має бути відсортований за зростанням id кур’єра.\nПоля в результуючій таблиці: birth_date, courier_id, sex\n\n\n\n\n\nРішення\n%%sql\nSELECT birth_date,\n       courier_id,\n       sex\nFROM   couriers\nWHERE  birth_date is null\nORDER BY courier_id\nLIMIT 10 -- для скорочення виводу\n\n\n\n\n\n\n\n\n\nbirth_date\ncourier_id\nsex\n\n\n\n\n0\nNaT\n83\nmale\n\n\n1\nNaT\n187\nmale\n\n\n2\nNaT\n200\nmale\n\n\n3\nNaT\n232\nmale\n\n\n4\nNaT\n411\nmale\n\n\n5\nNaT\n450\nmale\n\n\n6\nNaT\n467\nmale\n\n\n7\nNaT\n481\nmale\n\n\n8\nNaT\n726\nmale\n\n\n9\nNaT\n790\nmale"
  },
  {
    "objectID": "sql_filter.html#додаткові-завдання",
    "href": "sql_filter.html#додаткові-завдання",
    "title": "9  Фільтрація даних",
    "section": "9.5 Додаткові завдання",
    "text": "9.5 Додаткові завдання\nДавайте вирішимо ще кілька завдань, щоб переконатися, що ми розібралися з фільтрацією даних.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.11  Визначте id та дати народження 10 наймолодших користувачів чоловічої статі з таблиці users. Не враховуйте користувачів, у яких не вказано дату народження.\nПоле в результуючій таблиці: user_id, birth_date\nПояснення: будьте уважні і пам’ятайте про значення NULL.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       birth_date\nFROM   users\nWHERE  birth_date IS NOT NULL\n   AND sex = 'male'\nORDER BY birth_date DESC\nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\nbirth_date\n\n\n\n\n0\n11419\n2003-09-02\n\n\n1\n11461\n2002-11-05\n\n\n2\n9257\n2002-07-11\n\n\n3\n20804\n2002-01-09\n\n\n4\n14956\n2001-08-09\n\n\n5\n7047\n2001-06-11\n\n\n6\n11725\n2001-05-27\n\n\n7\n4374\n2001-04-29\n\n\n8\n15102\n2001-04-21\n\n\n9\n14571\n2001-03-31\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.12  Напишіть SQL-запит до таблиці courier_actions, щоб дізнатися ID та час доставки останніх 10 замовлень, доставлених кур’єром з ID 100.\nПоля у результуючій таблиці: order_id, time\nПояснення: Зверніть увагу, що у вихідній таблиці є записи не лише з часом доставки, а й з часом прийняття замовлення.\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       time\nFROM   courier_actions\nWHERE  courier_id = 100\n   AND action = 'deliver_order'\nORDER BY order_id desc limit 10\n\n\n\n\n\n\n\n\n\norder_id\ntime\n\n\n\n\n0\n57791\n2022-09-08 18:18:00\n\n\n1\n55095\n2022-09-08 07:51:00\n\n\n2\n53500\n2022-09-07 23:05:00\n\n\n3\n49779\n2022-09-07 07:34:00\n\n\n4\n48406\n2022-09-06 22:13:00\n\n\n5\n44546\n2022-09-05 21:13:00\n\n\n6\n42258\n2022-09-05 11:49:00\n\n\n7\n41606\n2022-09-05 09:00:00\n\n\n8\n41440\n2022-09-05 08:14:00\n\n\n9\n38536\n2022-09-04 18:57:00"
  },
  {
    "objectID": "sql_filter.html#фільтрація-по-даті-та-часу",
    "href": "sql_filter.html#фільтрація-по-даті-та-часу",
    "title": "9  Фільтрація даних",
    "section": "9.6 Фільтрація по даті та часу",
    "text": "9.6 Фільтрація по даті та часу\nІ ще кілька завдань на роботу з датами та часом.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.13  З таблиці user_actions отримаєте id всіх замовлень, зроблених користувачами сервісу у серпні 2022 року.\nРезультат відсортуйте за зростанням id замовлення.\nПоле у результуючій таблиці: order_id\nПояснення: зверніть увагу, що у вихідній таблиці є записи не лише з часом оформлення, а й часом скасування замовлення.У цій задачі може стати в нагоді функція DATE_PART. Ми розглядали її в Завдання 8.10.\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id\nFROM   user_actions\nWHERE  action = 'create_order'\n   AND DATE_PART('month', time) = 8\n   AND DATE_PART('year', time) = 2022\nORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n18794\n18795\n\n\n18795\n18796\n\n\n18796\n18797\n\n\n18797\n18798\n\n\n18798\n18799\n\n\n\n\n18799 rows × 1 columns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.14  З таблиці couriers відберіть id всіх кур’єрів, що народилися в період з 1990 по 1995 включно.\nРезультат відсортуйте за зростанням id кур’єра.\nПоле у результуючій таблиці: courier_id\nПояснення: у цьому завдання знову може стати в нагоді функція DATE_PART.\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id\nFROM   couriers\nWHERE  date_part('year', birth_date) BETWEEN 1990\n   AND 1995\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\n\n\n\n\n0\n2\n\n\n1\n3\n\n\n2\n8\n\n\n3\n9\n\n\n4\n10\n\n\n...\n...\n\n\n1522\n3153\n\n\n1523\n3160\n\n\n1524\n3161\n\n\n1525\n3166\n\n\n1526\n3167\n\n\n\n\n1527 rows × 1 columns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.15  З таблиці user_actions отримайте інформацію про всі скасування замовлень, які користувачі здійснювали протягом серпня 2022 по середах з 12:00 до 15:59.\nРезультат відсортуйте за зменшенням id скасованих замовлень.\nПоля у результуючій таблиці: user_id, order_id, action, time\nПояснення: будьте уважні при роботі з датами та часом. Для вирішення задачі вам знадобиться функція DATE_PART. Для отримання дня тижня можна вказати аргумент 'dow' (“day of week”):\nSELECT DATE_PART('dow', DATE '2022-12-31')\n\nРезультат:\n6.00\nВ DuckDB дні тижня рахуються з неділі (0) до суботи (6).\n\n\n\n\n\nРішення\n%%sql\nSELECT  user_id,\n        order_id,\n        action,\n        time\nFROM   user_actions\nWHERE  action = 'cancel_order'\n    AND DATE_PART('dow', time) = 03\n    AND DATE_PART('month', time) = 08\n    AND DATE_PART('year', time) = 2022\n    AND DATE_PART('h', time) BETWEEN 12\n    AND 15\nORDER BY order_id DESC\nLIMIT 10\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\naction\ntime\n\n\n\n\n0\n8117\n17307\ncancel_order\n2022-08-31 15:59:00\n\n\n1\n8107\n17282\ncancel_order\n2022-08-31 15:50:00\n\n\n2\n1495\n17272\ncancel_order\n2022-08-31 15:46:00\n\n\n3\n7427\n17252\ncancel_order\n2022-08-31 15:38:00\n\n\n4\n3207\n17231\ncancel_order\n2022-08-31 15:33:00\n\n\n5\n8077\n17218\ncancel_order\n2022-08-31 15:30:00\n\n\n6\n3446\n17216\ncancel_order\n2022-08-31 15:28:00\n\n\n7\n8076\n17214\ncancel_order\n2022-08-31 15:26:00\n\n\n8\n6116\n17190\ncancel_order\n2022-08-31 15:17:00\n\n\n9\n8057\n17151\ncancel_order\n2022-08-31 15:02:00"
  },
  {
    "objectID": "sql_filter.html#фільтрація-з-case-when",
    "href": "sql_filter.html#фільтрація-з-case-when",
    "title": "9  Фільтрація даних",
    "section": "9.7 Фільтрація з CASE WHEN",
    "text": "9.7 Фільтрація з CASE WHEN\nІ насамкінець давайте повернемося до наших податків.\nМинулого разу ми вирішили завдання для одного з менеджерів та порахували ПДВ кожного товару. Ви довго дивилися на розрахунки, що вийшли, і вас все-таки замучила совість: адже ви точно знаєте, що на окремі групи товарів ПДВ становить не 20%, а 10%.\nОскільки менеджер раптово перестав відповідати на ваші повідомлення, ви вирішили написати безпосередньо бухгалтеру та запросили список товарів, на які поширюється ПДВ 10%.\nОсь який список ви отримали:\n'sugar', 'crackers', 'drying', 'seeds',\n'linseed oil', 'grapes', 'olive oil',\n'watermelon', 'baton', 'yogurt', 'cream', 'buckwheat',\n'oatmeal', 'pasta', 'mutton', 'oranges',\n'bagels', 'bread', 'peas', 'sour cream', 'smoked fish',\n'flour', 'sprats', 'sausages', 'pork', 'rice',\n'sesame oil', 'condensed milk', 'pineapple', 'beef',\n'salt', 'dried fish', 'sunflower oil', 'apples',\n'pears', 'flatbread', 'milk', 'chicken', 'lavash', 'waffles', 'tangerines'\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 9.16  Як і у минулому завданні (Завдання 8.15), обчисліть ПДВ кожного товару в таблиці products і розрахуйте ціну без урахування ПДВ. Однак тепер врахуйте, що для товарів зі списку податок становить 10%. Для решти товарів ПДВ той самий — 20%.\nВиведіть всю інформацію про товари, включаючи суму податку та ціну без його врахування. Колонки із сумою податку та ціною без ПДВ назвіть відповідно tax та price_before_tax. Округліть значення у цих колонках до двох знаків після коми.\nРезультат відсортуйте спочатку за спаданням ціни товару без урахування ПДВ, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, tax, price_before_tax\nПояснення: порядок розрахунку податку той самий, що й у Завдання 8.15. Для вирішення завдання вам можуть стати в нагоді конструкція CASE та оператор IN. Конструкцію CASE ми розглядали у Завдання 8.14.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       ROUND(price * (CASE WHEN name IN ('sugar', 'crackers', 'drying', 'seeds',\n                                         'linseed oil', 'grapes', 'olive oil',\n                                         'watermelon', 'baton', 'yogurt', 'cream',\n                                         'buckwheat', 'oatmeal', 'pasta', 'mutton',\n                                         'oranges', 'bagels', 'bread', 'peas',\n                                         'sour cream', 'smoked fish', 'flour', 'sprats',\n                                         'sausages', 'pork', 'rice', 'sesame oil',\n                                         'condensed milk', 'pineapple', 'beef', 'salt',\n                                         'dried fish', 'sunflower oil', 'apples',\n                                         'pears', 'flatbread', 'milk', 'chicken',\n                                         'lavash', 'waffles', 'tangerines')\n                      THEN 0.1 / 1.1\n                      ELSE 0.2 / 1.2 end), 2) AS tax,\n       ROUND(price / (CASE WHEN name IN ('sugar', 'crackers', 'drying', 'seeds',\n                                         'linseed oil', 'grapes', 'olive oil',\n                                         'watermelon', 'baton', 'yogurt', 'cream',\n                                         'buckwheat', 'oatmeal', 'pasta', 'mutton',\n                                         'oranges', 'bagels', 'bread', 'peas',\n                                         'sour cream', 'smoked fish', 'flour', 'sprats',\n                                         'sausages', 'pork', 'rice', 'sesame oil',\n                                         'condensed milk', 'pineapple', 'beef', 'salt',\n                                         'dried fish', 'sunflower oil', 'apples',\n                                         'pears', 'flatbread', 'milk', 'chicken',\n                                         'lavash', 'waffles', 'tangerines')\n                      THEN 1.1\n                      ELSE 1.2 END), 2) AS price_before_tax\nFROM   products\nORDER BY price_before_tax DESC, product_id asc;\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\ntax\nprice_before_tax\n\n\n\n\n0\n13\ncaviar\n800.0\n133.33\n666.67\n\n\n1\n37\nmutton\n559.0\n50.82\n508.18\n\n\n2\n15\nolive oil\n450.0\n40.91\n409.09\n\n\n3\n57\npork\n450.0\n40.91\n409.09\n\n\n4\n66\nbeef\n370.0\n33.64\n336.36\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n2.27\n22.73\n\n\n83\n5\ncoffee 3 in 1\n15.0\n2.50\n12.50\n\n\n84\n73\ncake\n15.0\n2.50\n12.50\n\n\n85\n10\nseeds\n12.0\n1.09\n10.91\n\n\n86\n54\npaper bag\n1.0\n0.17\n0.83\n\n\n\n\n87 rows × 5 columns"
  },
  {
    "objectID": "sql_agg.html#унікальні-значення-distinct",
    "href": "sql_agg.html#унікальні-значення-distinct",
    "title": "10  Агрегація даних",
    "section": "10.1 Унікальні значення: DISTINCT",
    "text": "10.1 Унікальні значення: DISTINCT\nКлючове слово DISTINCT дає змогу відбирати унікальні записи, тобто позбавлятися всіх дублікатів у таблиці.\nВказується DISTINCT одразу після SELECT. Для виведення унікальних значень в одній колонці можна скласти наступний запит:\nSELECT DISTINCT column\nFROM table\nДавайте спершу вирішимо просте завдання.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.1  Виведіть ID всіх унікальних користувачів з таблиці user_actions. Результат відсортуйте за зростанням id.\nПоле у результуючій таблиці: user_id\n\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT user_id\nFROM   user_actions\nORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n21396\n21398\n\n\n21397\n21399\n\n\n21398\n21400\n\n\n21399\n21401\n\n\n21400\n21402\n\n\n\n\n21401 rows × 1 columns\n\n\n\nКлючове слово DISTINCT можна застосовувати не тільки до однієї колонки, а й одразу до кількох.\nНаприклад, запит для двох колонок виглядатиме так:\nSELECT DISTINCT column_1, column_2\nFROM table\nУ такому випадку запит поверне унікальні комбінації значень в колонках.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.2  Застосуйте DISTINCT відразу до двох колонок таблиці courier_actions та відберіть унікальні пари значень courier_id та order_id.\nРезультат відсортуйте спочатку за зростанням id кур’єра, потім за зростанням id замовлення.\nПоля у результуючій таблиці: courier_id, order_id\n\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT courier_id,\n                order_id\nFROM   courier_actions\nORDER BY courier_id, order_id\n\n\n\n\n\n\n\n\n\ncourier_id\norder_id\n\n\n\n\n0\n1\n98\n\n\n1\n1\n194\n\n\n2\n1\n233\n\n\n3\n1\n522\n\n\n4\n1\n1251\n\n\n...\n...\n...\n\n\n59590\n3166\n56165\n\n\n59591\n3166\n56940\n\n\n59592\n3167\n56176\n\n\n59593\n3167\n58039\n\n\n59594\n3167\n58774\n\n\n\n\n59595 rows × 2 columns"
  },
  {
    "objectID": "sql_agg.html#базова-агрегація-count-sum-avg-min-max",
    "href": "sql_agg.html#базова-агрегація-count-sum-avg-min-max",
    "title": "10  Агрегація даних",
    "section": "10.2 Базова агрегація: COUNT, SUM, AVG, MIN, MAX",
    "text": "10.2 Базова агрегація: COUNT, SUM, AVG, MIN, MAX\nАгрегатними функціями називають функції, які обробляють певний набір спостережень і повертають одне узагальнююче значення. Якщо ви коли-небудь працювали в Excel, то, напевно, стикалися з підрахунком суми або максимального/мінімального значення по стовпцю — йдеться саме про це.\nОсь кілька прикладів таких функцій у SQL:\n\nCOUNT: повертає кількість значень у колонці;\nSUM: обчислює суму значень;\nAVG: обчислює середнє значення;\nMAX: обчислює максимальне значення;\nMIN: обчислює мінімальне значення.\n\nПриклад:\nSELECT COUNT(column) AS count\nFROM table\n\n\nSELECT SUM(column_1) AS sum,\n       AVG(column_2) AS average\nFROM table\nЗверніть увагу, що деякі з вищезгаданих функцій не можна застосовувати до колонок з текстом, датами та часом, оскільки не цілком зрозуміло, що, наприклад, означає знайти середнє значення або суму найменувань товарів.\nУ той самий час «максимальне» найменування товару обчислити можна — функція MAX шукатиме найбільше значення упорядкованої послідовності (відповідно до встановлених правил сортування значень рядкового типу).\nВтім, заучувати межі застосування цих функцій не потрібно — просто керуйтеся здоровим глуздом.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про агрегатні функції в DuckDB можна ознайомитися тут.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.3  Порахуйте максимальну та мінімальну ціни товарів у таблиці products. Поля назвіть відповідно max_price, min_price.\nПоля у результуючій таблиці: max_price, min_price\nПояснення: в одному запиті можна використовувати відразу кілька агрегаційних функцій — якщо необхідно, то навіть по кількох різних колонках.\n\n\n\n\n\nРішення\n%%sql\nSELECT max(price) as max_price,\n       min(price) as min_price\nFROM   products\n\n\n\n\n\n\n\n\n\nmax_price\nmin_price\n\n\n\n\n0\n800.0\n1.0"
  },
  {
    "objectID": "sql_agg.html#count-vs-countcolumn",
    "href": "sql_agg.html#count-vs-countcolumn",
    "title": "10  Агрегація даних",
    "section": "10.3 COUNT(*) vs COUNT(column)",
    "text": "10.3 COUNT(*) vs COUNT(column)\nТакож при підрахунку кількості записів іноді замість найменування колонки як атрибут функції COUNT використовують зірочку «*»:\nSELECT COUNT(*)\nFROM table\nОднак важливо враховувати один нюанс: запит із зірочкою повертає кількість взагалі всіх записів у таблиці, а запит із зазначенням стовпця — кількість тих записів, де в заданому стовпці значення не є NULL.\nТаким чином, якщо в деякій колонці column є перепустки, вирази COUNT(*) і COUNT(column) повернуть різні значення.\nДавайте перевіримо!\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.4  Як ви пам’ятаєте, у таблиці users в деяких користувачів не було зазначено їх дати народження.\nПорахуйте в одному запиті кількість усіх записів у таблиці та кількість лише тих записів, для яких у колонці birth_date вказана дата народження.\nКолонку із загальним числом записів назвіть dates, а колонку із записами без перепусток — dates_not_null.\nПоля у результуючій таблиці: dates, dates_not_null\n\n\n\n\n\nРішення\n%%sql\nSELECT count(*) as dates,\n       count(birth_date) as dates_not_null\nFROM   users\n\n\n\n\n\n\n\n\n\ndates\ndates_not_null\n\n\n\n\n0\n20331\n20281\n\n\n\n\n\n\n\nІ ще один важливий момент: агрегатні функції можна застосовувати в поєднанні з ключовим словом DISTINCT. У такому випадку розрахунки будуть проводитися лише за унікальними значеннями.\nЯкщо у випадку з MIN та MAX це не має особливого сенсу, то при розрахунку AVG, SUM та COUNT іноді це буває корисно:\nSELECT SUM(DISTINCT column) AS sum_distinct\nFROM table\nПри цьому досить часто DISTINCT використовується саме в поєднанні з COUNT для підрахунку числа унікальних користувачів, унікальних замовлень тощо.\nSELECT COUNT(DISTINCT column) AS count_distinct\nFROM table\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.5  Порахуйте кількість всіх значень у колонці user_id у таблиці user_actions, а також кількість унікальних значень у цій колонці (тобто кількість унікальних користувачів сервісу).\nКолонку з першим отриманим значенням назвіть users, а колонку з другим – unique_users.\nПоля у результуючій таблиці: users, unique_users\n\n\n\n\n\nРішення\n%%sql\nSELECT count(user_id) as users,\n       count(distinct user_id) as unique_users\nFROM   user_actions\n\n\n\n\n\n\n\n\n\nusers\nunique_users\n\n\n\n\n0\n62574\n21401"
  },
  {
    "objectID": "sql_agg.html#фільтрація-та-агрегація",
    "href": "sql_agg.html#фільтрація-та-агрегація",
    "title": "10  Агрегація даних",
    "section": "10.4 Фільтрація та агрегація",
    "text": "10.4 Фільтрація та агрегація\nА якщо для розрахунків нам потрібні не всі дані в стовпці, а тільки якась частина? Тоді в запит з агрегатними функціями можна включити оператор WHERE, вказавши умову для відбору записів:\nSELECT COUNT(column_1) AS count\nFROM table\nWHERE column_2 &gt; 100\nУ такому випадку спочатку буде виконана фільтрація таблиці і тільки потім буде проведена агрегація по записах, що залишилися.\nПро всяк випадок нагадаємо порядок виконання у запиті відомих нам ключових операторів:\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.6  Порахуйте кількість кур’єрів жіночої статі у таблиці couriers. Отриманий стовпець з одним значенням назвіть couriers.\nПоле в результуючій таблиці: couriers\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct courier_id) as couriers\nFROM   couriers\nWHERE  sex = 'female'\n\n\n\n\n\n\n\n\n\ncouriers\n\n\n\n\n0\n1149\n\n\n\n\n\n\n\nІ ще одне завдання на агрегацію із фільтрацією. На цей раз проведемо розрахунки по колонці з даними у форматі TIMESTAMP.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.7  Розрахуйте час, коли було здійснено першу та останню доставку замовлень у таблиці courier_actions.\nКолонку з часом першої доставки назвіть first_delivery, а колонку з часом останньої – last_delivery.\nПоля у результуючій таблиці: first_delivery, last_delivery\nПояснення: зауважте, що в таблиці з діями кур’єрів є не тільки записи з часом доставки замовлень, але й записи з часом їх прийняття.\n\n\n\n\n\nРішення\n%%sql\nSELECT min(time) as first_delivery,\n       max(time) as last_delivery\nFROM   courier_actions\nWHERE  action = 'deliver_order'\n\n\n\n\n\n\n\n\n\nfirst_delivery\nlast_delivery\n\n\n\n\n0\n2022-08-24 02:15:00\n2022-09-08 23:59:00\n\n\n\n\n\n\n\nУ поєднанні з агрегатними функціями можна використовувати ті ж умовні конструкції, які ми розглядали раніше.\nДавайте додамо до нашого запиту більш цікаву фільтрацію.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.8  Уявіть, що один із користувачів сервісу зробив замовлення, до якого увійшли одна пачка крекерів (crackers), одна пачка чіпсів (chips) та один енергетичний напій (energy drink). Порахуйте вартість такого замовлення.\nКолонку із розрахованою вартістю замовлення назвіть order_price.\nДля розрахунків використовуйте таблицю products.\nПоле в результуючій таблиці: order_price\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля вирішення завдання необхідно «сформувати» описане замовлення, відібравши з таблиці products зазначені товари та порахувавши їхню сумарну вартість.\n\n\n\n\n\nРішення\n%%sql\nSELECT sum(price) as order_price\nFROM   products\nWHERE  name in ('crackers', 'chips', 'energy drink')\n\n\n\n\n\n\n\n\n\norder_price\n\n\n\n\n0\n235.0"
  },
  {
    "objectID": "sql_agg.html#довжина-списку-array_length",
    "href": "sql_agg.html#довжина-списку-array_length",
    "title": "10  Агрегація даних",
    "section": "10.5 Довжина списку: ARRAY_LENGTH",
    "text": "10.5 Довжина списку: ARRAY_LENGTH\nЯк пам’ятаєте, у таблиці orders вміст замовлень представлено вигляді списків товарів (масивів). Щоб порахувати кількість товарів у кожному замовленні, можна скористатися функцією array_length.\nФункція array_length обчислює кількість елементів у масиві (довжину масиву) і записується так:\nSELECT array_length(ARRAY['first', 'second', 'third'], 1)\n\nРезультат:\n3\nСинтаксис може здатися вам трохи складним, але це лише на перший погляд! Давайте розбиратися.\nARRAY['first', 'second', 'third'] – це деякий список із трьох значень: 'first', 'second', 'third’.\nОдиниця як другий аргумент — це розмірність масиву, за якій рахується його довжина. Так як список у нас одновимірний (просто значення, записані в один рядок), то вибір у нас невеликий – можемо вказати лише першу розмірність.\nЯкби в нас була таблиця N x N, в якій були б і рядки, і стовпці, то розмірності було б дві: перша відповідала кількості рядків, а друга — числу стовпців. У такому випадку ми могли б вказати або першу, або другу розмірність.\nДавайте уявімо, що у нас є проста таблиця наступного виду:\n _______\n| 1 | 2 |\n| 3 | 4 |\n| 5 | 6 |\n ‾‾‾‾‾‾‾\nУ цій таблиці 3 рядки та 2 стовпці, тому її можна описати у вигляді наступного списку з трьох вкладених у нього списків:\nARRAY[[1,2], [3,4], [5,6]]\nУ прикладі вище кількість списків усередині основного списку — кількість рядків у таблиці, а кількість елементів усередині кожного внутрішнього списку — кількість стовпців.\nЗверніть увагу на результат обчислень функції array_length для першої та другої розмірності:\nSELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)\n\nРезультат:\n3\n\nSELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)\n\nРезультат:\n2\nУ це досить складно повірити, але значеннями в основній таблиці справді можуть бути інші таблиці (матриці). На щастя, у нас не такі дані, тому ми працюватимемо із простими однорозмірними списками значень.\nВ якості аргументу функції array_length на місці масиву можна вказувати ім’я колонки, яка містить масиви (у нашому випадку це колонка product_ids):\nSELECT array_length(column, 1)\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nДізнатися більше про функції для роботи з масивами можна у документації. З деякими з них ми познайомимося далі.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.9  Порахуйте кількість замовлень у таблиці orders із дев’ятьма і більше товарами. Для цього скористайтесь функцією array_length, відфільтруйте дані щодо кількості товарів у замовленні та проведіть агрегацію. Отриманий стовпець назвіть orders.\nПоле в результуючій таблиці: orders\nПояснення: у наших даних у колонці product_ids містяться звичайні списки товарів лише з однією розмірністю.\n\n\n\n\n\nРішення\n%%sql\nSELECT count(order_id) as orders\nFROM   orders\nWHERE  array_length(product_ids, 1) &gt;= 9\n\n\n\n\n\n\n\n\n\norders\n\n\n\n\n0\n5"
  },
  {
    "objectID": "sql_agg.html#різниця-часу-age",
    "href": "sql_agg.html#різниця-часу-age",
    "title": "10  Агрегація даних",
    "section": "10.6 Різниця часу: AGE",
    "text": "10.6 Різниця часу: AGE\nВ якості агрегатних функцій можуть виступати не тільки стовпці, але також розрахункові колонки або результат іншої функції:\nSELECT AVG(some_function(column))\nFROM table\n\n\nSELECT AVG(column_1 + column_2)\nFROM table\nСпробуємо розрахувати середній вік користувачів чоловічої статі. Для цього скористаємось новою для нас функцією AGE.\nФункція AGE повертає різницю між двома значеннями, наведеними у форматі TIMESTAMP. При цьому від першого значення віднімається друге, а сама різниця повертається у форматі INTERVAL:\nSELECT AGE('2022-12-12', '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nТаким чином, з '2021-11-10' до '2022-12-12' пройшло рівно 397 днів.\nЯкщо в якості першого аргументу нічого не вказати, то на місце першої дати автоматично підставиться поточна дата (опівніч поточного дня, тобто початок дня).\nЯкщо сьогодні '2022-12-12', то з '2021-11-10' пройшло рівно стільки ж днів, скільки у прикладі вище:\nSELECT AGE(TIMESTAMP '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nНасправді поточній даті відповідає значення current_date, яке можна вказувати як аргумент функції AGE:\nSELECT AGE(TIMESTAMP '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nМожете самостійно запустити два запити - з current_date і без - і порівняти отримані результати. У вашому випадку це будуть нові результати, але вони мають збігтися.\nА саме значення current_date можна викликати так:\nSELECT current_date\n\nРезультат:\n2023-06-01  \nДля того щоб результат відображався не у кількості днів, а в зручнішому форматі, можна переводити результат обчислень у тип VARCHAR:\nSELECT AGE(current_date, '2021-11-10')::VARCHAR\n\nРезультат:\n1 year 1 mon 2 days\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.10  За допомогою функції AGE і агрегатної функції розрахуйте вік наймолодшого кур’єра чоловічої статі в таблиці couriers.\nВік виведіть через кількість років, місяців і днів (як у прикладі вище), перевівши їх у тип VARCHAR.\nВ якості дати, відносно якої необхідно розрахувати вік кур’єрів, використовуйте свою поточну дату (або не вказуйте її на місці першого аргументу, як показано в прикладах).\nОтриману колонку зі значенням віку назвіть min_age.\nПоле у результуючій таблиці: min_age\nПояснення: оскільки в якості дати, щодо якої проводиться розрахунок віку, ми використовуємо поточну дату, кожен новий день ми отримуватимемо новий результат.\nЗрозуміло, що рахувати вік у такий спосіб не зовсім коректно. Ми навчимося робити це правильно в розділі «Підзапити».\n\n\n\n\n\nРішення\n%%sql\nSELECT age(max(birth_date))::varchar as min_age\nFROM   couriers\nWHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nmin_age\n\n\n\n\n0\n17 years 8 months 28 days 13:03:18.214"
  },
  {
    "objectID": "sql_agg.html#агрегація-з-case-when",
    "href": "sql_agg.html#агрегація-з-case-when",
    "title": "10  Агрегація даних",
    "section": "10.7 Агрегація з CASE WHEN",
    "text": "10.7 Агрегація з CASE WHEN\nАргументом агрегатної функції може бути і складніша розрахункова колонка - наприклад, отримана в результаті роботи конструкції CASE.\nУ такому випадку сама конструкція CASE поміщається всередину дужок агрегатної функції:\nAVG(\n    CASE  \n    WHEN logical_expression_1 THEN expression_1\n    WHEN logical_expression_2 THEN expression_2\n    ELSE expression_else\n    END\n)\nТак, якби в нашій таблиці всі товари були розбиті за категоріями і ми захотіли б порахувати середню ціну товарів з урахуванням підвищувальних чи знижувальних коефіцієнтів для кожної категорії, то ми могли б зробити це, наприклад, так:\nSELECT AVG(\n    CASE \n    WHEN category=\"м'ясо\" THEN price*0.95\n    WHEN category=\"риба\" THEN price*0.9\n    WHEN category=\"напої\" THEN price*1.05\n    ELSE price\n    END\n    ) AS avg_price\nFROM products\nДавайте ускладнимо одне з попередніх завдань і розрахуємо вартість ще одного замовлення.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.11  Порахуйте вартість замовлення, в якому будуть три пачки крекерів ('crackers'), дві пачки чіпсів ('chips') та один енергетичний напій ('energy drink'). Колонку із розрахованою вартістю замовлення назвіть order_price.\nДля розрахунків використовуйте таблицю products.\nПоле в результуючій таблиці: order_price\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розв’язання задачі необхідно за допомогою конструкції CASE створити розрахункову колонку, в якій навпроти кожного товару, який увійшов у замовлення, проставити ціну, помножену на кількість таких товарів у замовленні. Для товарів, які не увійшли у замовлення, необхідно вказати ціну, що дорівнює 0 або NULL. Потім за допомогою агрегатної функції достатньо порахувати суму значень у новій розрахунковій колонці.\n\n\n\n\n\nРішення\n%%sql\nSELECT sum(case when name = 'crackers' then price * 3\n                when name = 'chips' then price * 2\n                when name = 'energy drink' then price\n                else 0 end) as order_price\nFROM   products\n\n\n\n\n\n\n\n\n\norder_price\n\n\n\n\n0\n355.0"
  },
  {
    "objectID": "sql_agg.html#агрегатні-вирази-з-фільтрацією",
    "href": "sql_agg.html#агрегатні-вирази-з-фільтрацією",
    "title": "10  Агрегація даних",
    "section": "10.8 Агрегатні вирази з фільтрацією",
    "text": "10.8 Агрегатні вирази з фільтрацією\nМи розглянули кілька прикладів, коли в якості агрументу агрегатних функцій виступає результат виконання іншої функції.\nАле агрегатна функція може і сама опинитися на місці аргументу якоїсь функції:\nSELECT some_function(SUM(column)) AS result\nFROM table\nНаочний приклад — застосування функції ROUND до результату агрегації:\nSELECT ROUND(SUM(column)) AS rounded_sum\nFROM table\nДавайте вирішимо схоже завдання і заразом ненадовго повернемося до наших напоїв та оператора LIKE.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.12  Розрахуйте середню ціну товарів у таблиці products, у назвах яких є слова 'tea' чи 'coffee'. Виключіть з розрахунку товари, що містять «іван-чай» ('ivan-tea') або «чайний гриб» ('tea mushroom').\nСередню ціну округліть до двох знаків після коми. Стовпець із отриманим значенням назвіть avg_price.\nПоле у результуючій таблиці: avg_price\nПояснення: пам’ятайте, що виконання логічних виразів можна керувати за допомогою дужок. Це може стати в нагоді.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(price), 2) as avg_price\nFROM   products\nWHERE  (name like '%tea%'\n    or name like '%coffee%')\n   and name not like '%ivan-tea%'\n   and name not like '%mushroom%'\n\n\n\n\n\n\n\n\n\navg_price\n\n\n\n\n0\n135.23\n\n\n\n\n\n\n\nВтім, бувають і випадки, коли як аргументи деякої функції виступають відразу кілька агрегатних функцій:\nSELECT some_function(SUM(column_1), SUM(column_2)) AS result\nFROM table\nНаприклад, нам уже знайома функція AGE, яка може приймати одразу два аргументи - дату кінця та дату початку деякого періоду часу.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.13  Скористайтеся функцією AGE та розрахуйте різницю у віці між найстарішим та наймолодшим користувачами чоловічої статі у таблиці users.\nРізницю у віці висловіть кількістю років, місяців та днів, перевівши її у тип VARCHAR.\nНазвіть колонку з порахованим значенням age_diff.\nПоле у результуючій таблиці: age_diff\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЦе завдання можна вирішити різними способами: можна просто знайти різницю між датами народження наймолодшого і найстарішого користувачів, а можна порахувати різницю між їх віком. Можете піти будь-яким шляхом. Якщо рахуватимете вік, то в якості першої дати використовуйте свою поточну дату (current_date).\n\n\n\n\n\nРішення\n%%sql\nSELECT age(max(birth_date), min(birth_date))::varchar as age_diff\nFROM   users\nWHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nage_diff\n\n\n\n\n0\n21 years 9 months 27 days\n\n\n\n\n\n\n\nА тепер розглянемо приклад, коли агрегатна функція приймає в якості аргументу одну функцію і при цьому сама є аргументом іншої функції.\nВиглядати це може так:\nSELECT function_two(SUM(funtion_one(column))) AS result\nFROM table\nУ цьому прикладі спочатку до колонки column застосовується функція funtion_one, потім за допомогою функції SUM буде пораховано суму отриманих значень, і тільки потім до результату агрегації застосовується функція funtion_two.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.14  Розрахуйте середню кількість товарів у замовленнях з таблиці orders, які користувачі оформляли у вихідні дні (субота та неділя) протягом усього часу роботи сервісу.\nОтримане значення округліть до двох знаків після коми. Назвіть колонку з ним avg_order_size.\nПоле у результуючій таблиці: avg_order_size\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розрахунку кількості товарів у замовленнях скористайтесь функцією array_length. Для фільтрації таблиці у вихідні дні можна використовувати функцію DATE_PART з параметром 'dow'.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(array_length(product_ids, 1)), 2) as avg_order_size\nFROM   orders\nWHERE  date_part('dow', creation_time) in (6, 0)\n\n\n\n\n\n\n\n\n\navg_order_size\n\n\n\n\n0\n3.39\n\n\n\n\n\n\n\nРезультати декількох агрегатних функцій можна використовувати в одному запиті для проведення над ними арифметичних операцій:\nSELECT (SUM(column_1) + SUM(column_2)) / 2\nFROM table\nУ запиті вище буде пораховано середнє арифметичне двох сум — значень колонки column_1 і значень колонки column_2.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.15  На основі даних у таблиці user_actions порахуйте: - кількість унікальних користувачів сервісу; - кількість унікальних замовлень - скільки замовлень припадає на одного користувача.\nУ результуючій таблиці відобразіть усі три значення – поля назвіть відповідно unique_users, unique_orders, orders_per_user.\nПоказник числа замовлень користувача округліть до двох знаків після коми.\nПоля у результуючій таблиці: unique_users, unique_orders, orders_per_user\n\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nЩоб отримати коректний результат поділу, необхідно хоча б одне із значень попередньо привести до типу DECIMAL (або помножити на 1.0). Інакше результатом розподілу цілого числа інше ціле число буде теж ціле число.\nДо речі, з подібною проблемою можна ознайомитись на stackoverflow. Це дуже корисний ресурс для пошуку відповідей на свої запитання. Навіть досвідчені програмісти часто ним користуються. Можете вже зараз почати виробляти звичку звертатися до нього за необхідності.\nТакож пам’ятайте, що використовувати в розрахунках аліаси нових колонок не можна.\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct user_id) as unique_users,\n       count(distinct order_id) as unique_orders,\n       round(count(distinct order_id) * 1.0 / count(distinct user_id),\n             2) as orders_per_user\nFROM   user_actions\n\n-- Рішення через DECIMAL\n-- SELECT count(distinct user_id) as unique_users,\n--        count(distinct order_id) as unique_orders,\n--        round(count(distinct order_id)::DECIMAL / count(distinct user_id),\n--              2) as orders_per_user\n-- FROM   user_actions\n\n\n\n\n\n\n\n\n\nunique_users\nunique_orders\norders_per_user\n\n\n\n\n0\n21401\n59595\n2.78\n\n\n\n\n\n\n\nІ насамкінець познайомимося з більш просунутим функціоналом — агрегатними виразами з фільтрацією.\nЯкщо після агрегатної функції вказати ключове слово FILTER і помістити в дужках деяку умову condition після WHERE, то агрегатній функції на вхід будуть подані тільки ті рядки, для яких умова фільтра виявиться істинною.\nЗагалом ця конструкція виглядає так:\nSELECT agg_function(column) FILTER (WHERE condition)\nFROM table\nНаприклад, якби ми захотіли порахувати середню ціну тільки для товарів категорії 'fish', то запит виглядав би так:\nSELECT AVG(price) FILTER (WHERE category = 'fish') AS avg_fish_price\nFROM table\nЗверніть увагу: це дуже схоже на звичайну фільтрацію з агрегацією, яку ми розглядали в попередніх завданнях, тільки в даному випадку умова відбору записів вказується відразу в блоці SELECT.\nПеревага такого запису в тому, що він дозволяє проводити розрахунки без проміжних запитів з умовами у блоці WHERE.\nРозглянемо ще один приклад.\nУ нашому випадку досить зрозуміло, як порахувати загальну кількість користувачів. Також зрозуміло, як порахувати кількість користувачів, які хоча б раз скасовували замовлення — досить просто вказати потрібну умову в операторі WHERE. Але як у рамках одного запиту порахувати тих, хто ніколи не скасовував своє замовлення?\nОскільки об’єднувати кілька запитів разом ми поки що не вміємо, нам допоможе прийти агрегатний вираз.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.16  Порахуйте скільки користувачів ніколи не скасовували своє замовлення. Для цього із загальної кількості всіх унікальних користувачів відніміть кількість унікальних користувачів, які хоча б раз скасовували замовлення. Подумайте, яку умову необхідно вказати у FILTER, щоб отримати коректний результат.\nОтриманий стовпець назвіть users_count.\nПоле в результуючій таблиці: users_count\n\n\n\n\n\nРішення\n%%sql\n-- Рішення через різницю\nSELECT count(distinct user_id) - count(distinct user_id) filter (WHERE action = 'cancel_order') as users_count\nFROM   user_actions\n\n-- Рішення через вкладений запит\n-- SELECT count(distinct user_id) filter (WHERE user_id not in (SELECT DISTINCT user_id\n--                                                              FROM   user_actions\n--                                                              WHERE  action = 'cancel_order')) as users_count\n-- FROM   user_actions\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n\n\n\n\n\nДавайте вирішимо ще одне завдання на агрегатні вирази з фільтрацією - цього разу з більш складними розрахунками.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 10.17  Порахуйте:\n\nзагальну кількість замовлень у таблиці orders\nкількість замовлень із п’ятьма та більше товарами\nчастку замовлень із п’ятьма та більше товарами у загальній кількості замовлень.\n\nУ результуючій таблиці відобразіть усі три значення - поля назвіть відповідно orders, large_orders, large_orders_share.\nЧастку замовлень із п’ятьма та більше товарами у загальній кількості товарів округліть до двох знаків після коми.\nПоля в результуючій таблиці: orders, large_orders, large_orders_share\nПояснення: при розрахунку частки не забудьте хоча б одне із значень попередньо привести до типу DECIMAL (або домножити на 1.0). Також пам’ятайте, що використовувати в розрахунках аліаси нових колонок не можна.\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct order_id) as orders,\n       count(distinct order_id) filter (WHERE array_length(product_ids, 1) &gt;= 5) as large_orders,\n       round(count(distinct order_id) filter (WHERE array_length(product_ids, 1) &gt;= 5)::decimal / count(distinct order_id),\n             2) as large_orders_share\nFROM   orders\n\n\n\n\n\n\n\n\n\norders\nlarge_orders\nlarge_orders_share\n\n\n\n\n0\n59595\n11498\n0.19"
  },
  {
    "objectID": "sql_groupby.html#оператор-group-by",
    "href": "sql_groupby.html#оператор-group-by",
    "title": "11  Групування даних",
    "section": "11.1 Оператор GROUP BY",
    "text": "11.1 Оператор GROUP BY\nДля групування даних в SQL використовується оператор GROUP BY. Він дозволяє групувати дані по одному або декільком стовпцям таблиці. При цьому вибірка даних буде містити лише унікальні значення з вказаних стовпців:\n\nСпочатку в таблиці визначаються рядки, в яких у вказаному в GROUP BY стовпці є однакові значення.\nДалі за цими значеннями записи об’єднуються у групи, причому у групі може бути навіть один запис.\nПісля цього над елементами цих груп, як правило, проводяться якісь операції за допомогою агрегатних функцій: наприклад, за допомогою SUM() обчислюється сума значень в якому-небудь стовпці в кожній групі:\n\nSELECT column_1, SUM(column_2)\nFROM table\nGROUP BY column_1\n\nПотім у результуючий запит потрапляє по одному унікальному запису зі стовпця, по якому здійснювалося групування. При цьому навпроти кожного такого значення відображається результат агрегації по відповідній групі, якщо агрегація проводилася.\n\nТут важливо зробити кілька уточнень:\n\nПо-перше, групування виконується після фільтрації, тобто спочатку виконуються інструкції WHERE і лише потім дані групуються через GROUP BY.\nПо-друге, до груп, що утворилися в результаті застосування GROUP BY, можна застосовувати відразу кілька агрегатних функцій (у тому числі до різних колонок).\nПо-третє, групування можна робити відразу за новими полями, порахованими в SELECT: при цьому допускається використання в GROUP BY аліасу колонки, зазначеного в SELECT. Наступні два запити дадуть однаковий результат:\n\nSELECT DATE(column_1) AS date, SUM(column_2)\nFROM table\nGROUP BY DATE(column_1)\n\n\nSELECT DATE(column_1) AS date, SUM(column_2)\nFROM table\nGROUP BY date\n\nПо-четверте, робити агрегацію після групування необов’язково. Якщо не вказувати агрегатну функцію, то запит поверне унікальні значення в стовпці, тобто той самий результат, як і оператор DISTINCT. Можете самостійно запустити наступний запит та переконатися:\n\nSELECT user_id\nFROM user_actions\nGROUP BY user_id\n\nSELECT DISTINCT user_id\nFROM user_actions\nДо речі, питання про те, як можна відібрати унікальні значення, досвідчені аналітики люблять ставити на співбесідах своїм менш досвідченим колегам.\nІ нарешті, останнє важливе уточнення: під час використання групування колонки, вказаних у SELECT, повинні бути і GROUP BY, якщо вони використовуються у агрегатних функціях. Це обов’язкова умова, і якщо вона не буде виконана, база даних поверне помилку.\nНаступний запит не працюватиме, оскільки в GROUP BY вказані не всі неагреговані колонки з блоку SELECT:\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY column_1\nВодночас такий запит спрацює:\nSELECT SUM(column_2)\nFROM table\nGROUP BY column_1\nЗверніть увагу, що у цьому запиті у блоці SELECT немає колонки, вказаної у GROUP BY, тобто у зворотний бік правило не працює: якщо ми щось вказали в GROUP BY, це не обов’язково вказувати в SELECT. Інакше кажучи, виводити найменування груп необов’язково.\nІ ще: замість назв колонок у блоці GROUP BY можна використовувати номер колонки, вказаної у SELECT. Наприклад, наступні два запити еквівалентні:\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY column_1, column_2\n\n\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY 1, 2\nПри цьому номери колонок із SELECT також можна використовувати при сортуванні в операторі ORDER BY. Можете самі поекспериментувати із цим у наступних завданнях.\nЗ теорією начебто розібралися, тепер приступимо до практики. Минулого разу ми вже рахували кількість кур’єрів жіночої статі та використовували для цього фільтрацію. Групування дозволить нам провести розрахунки відразу для двох статей.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.1  За допомогою групування порахуйте кількість кур’єрів чоловічої та жіночої статі у таблиці couriers. Нову колонку з числом кур’єром назвіть couriers_count. Результат відсортуйте по цій колонці за зростанням.\nПоля у результуючій таблиці: sex, couriers_count\n\n\n\n\n\nРішення\n%%sql\nSELECT sex,\n       count(courier_id) as couriers_count\nFROM   couriers\nGROUP BY sex\nORDER BY couriers_count\n\n\n\n\n\n\n\n\n\nsex\ncouriers_count\n\n\n\n\n0\nfemale\n1149\n\n\n1\nmale\n1674\n\n\n\n\n\n\n\n\nТепер давайте аналогічним чином з’ясуємо, скільки всього було зроблено замовлень і скільки було скасовано за весь час роботи нашого сервісу.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.2  Порахуйте кількість створених та скасованих замовлень у таблиці user_actions.\nНову колонку з кількістю замовлень назвіть orders_count.\nРезультат відсортуйте за кількістю замовлень щодо зростання.\nПоля у результуючій таблиці: action, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT action,\n       count(order_id) as orders_count\nFROM   user_actions\nGROUP BY action\nORDER BY orders_count\n\n\n\n\n\n\n\n\n\naction\norders_count\n\n\n\n\n0\ncancel_order\n2979\n\n\n1\ncreate_order\n59595\n\n\n\n\n\n\n\n\nЗ простими завданнями на групування впоралися, тепер спробуємо зробити щось цікавіше: згрупуємо наші дані не по колонці, що є в таблиці, а по розрахунковій.\nЩоб зрозуміти, як це працює, просто уявіть, що спочатку ви створюєте якусь нову колонку на основі вже наявної, застосовуючи до неї якусь функцію, а потім відразу в цьому ж запиті здійснюйте групування за новою колонкою.\nНа першому кроці ми вже розглядали приклад із DATE — давайте розглянемо ще один:\nSELECT UPPER(column_1) AS upper_column, SUM(column_2) AS sum\nFROM table\nGROUP BY UPPER(column_1)\nТут спочатку розрахували колонку upper_column, застосувавши функцію UPPER до колонки column_1, а потім відразу ж згрупувалися по ній, порахувавши суму всіх значень в колонці column_2 в кожній групі.\nНагадаємо, що такий варіант запиту також спрацює:\nSELECT UPPER(column_1) AS upper_column, SUM(column_2) AS sum\nFROM table\nGROUP BY upper_column\nА тепер, використовуючи всі ці знання, давайте порахуємо, скільки замовлень було зроблено кожного місяця. Зрозуміло, для цього нам потрібно якось отримати місяць із кожної дати. Це можна було б зробити за допомогою функції DATE_PART, але на цей раз для роботи з датами спробуємо нову функцію DATE_TRUNC.\nФункція DATE_TRUNC використовується усічення дат і часу, тобто вона працює аналогічно округленню ROUND, тільки для типів даних TIMESTAMP та INTERVAL.\nСинтаксис у неї такий самий, як і у DATE_PART:\nSELECT DATE_TRUNC(part, column)\nНа місці part у лапках вказується, до якої точності слід округляти передане значення часу: 'year', 'month', 'day', 'hour' тощо.\nЗначення, що повертається, має тип TIMESTAMP або INTERVAL, а всі «частини» вхідного значення, менш значущі, ніж задана «частина», прирівнюються до нуля (або одиниці, якщо це номер дня або місяця):\nSELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n01/01/22 00:00\n\nSELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n12/01/22 00:00  \n\nSELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n12/01/22 08:00  \n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.3  Використовуючи групування та функцію DATE_TRUNC, приведіть усі дати до початку місяця та порахуйте, скільки замовлень було зроблено у кожному з них.\nРозрахунки проведіть по таблиці orders. Колонку з усіченою датою назвіть month, колонку з кількістю замовлень - orders_count.\nРезультат відсортуйте за місяцями – за зростанням.\nПоля у результуючій таблиці: month, orders_count\nПояснення:\nЗверніть увагу, що у цій задачі вам необхідно провести групування за новим розрахунковим полем.\nУ цій ситуації важливо пам’ятати, що колонки, вказані в SELECT, повинні знаходитись і в GROUP BY (якщо вони не використовуються в агрегаційних функціях). При цьому GROUP BY допускається використання аліасу колонки, зазначеного в блоці SELECT, тобто повторно проводити обчислення у GROUP BY не обов’язково.\n\n\n\n\n\nРішення\n%%sql\nSELECT date_trunc('month', creation_time) as month,\n       count(order_id) as orders_count\nFROM   orders\nGROUP BY month\nORDER BY month\n\n\n\n\n\n\n\n\n\nmonth\norders_count\n\n\n\n\n0\n2022-08-01\n18799\n\n\n1\n2022-09-01\n40796\n\n\n\n\n\n\n\n\nТепер давайте аналогічним чином порахуємо максимальний вік користувачів чоловічої та жіночої статі. Тільки на цей раз виведемо не повний вік, а лише кількість повних років. Для цього до результату обчислень можна застосувати вже знайому нам функцію DATE_PART з аргументом 'year'.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.4  Порахуйте максимальний вік користувачів чоловічої та жіночої статі у таблиці users. Вік виміряйте кількістю повних років. Нову колонку з віком назвіть max_age. Результат відсортуйте за новою колонкою за зростанням віку.\nПоля у результуючій таблиці: sex, max_age\n\n\n\n\n\nРішення\n%%sql\nSELECT sex,\n       date_part('year', max(age(birth_date))) as max_age\nFROM   users\nGROUP BY sex\nORDER BY max_age\n\n\n\n\n\n\n\n\n\nsex\nmax_age\n\n\n\n\n0\nfemale\n40\n\n\n1\nmale\n41\n\n\n\n\n\n\n\n\nРозрахункові колонки можна використовувати не тільки для того, щоб групувати дані. Їх також можна використовувати як поля, якими робиться агрегація всередині груп.\nІншими словами, агрегацію не обов’язково проводити за наявними колонками — колонки можна «створювати» в рамках того ж запиту, в якому відбувається групування:\nSELECT column_1, MIN(DATE_TRUNC('month', column_2)) AS min_month\nFROM table\nGROUP BY column_1\nУ прикладі вище за допомогою функції DATE_TRUNC ми спочатку привели всі дати в колонці column_2 до початку місяця (отримавши по суті нову колонку), а потім відразу ж провели агрегацію по новій колонці, порахувавши мінімальну заокруглену дату в кожній групі, сформованій на основі колонки column_1.\nЗверніть увагу, що той самий результат ми могли б отримати і за допомогою такого запиту:\nSELECT column_1, DATE_TRUNC('month', MIN(column_2)) AS min_month\nFROM table\nGROUP BY column_1\nВиходить, що і до результату агрегатної функції можна відразу ж застосовувати інші функції.\nПри цьому в прикладах вище не має значення, в якому порядку проводити обчислення: ми можемо спочатку округлити дати, а потім знайти серед них мінімальну, або спочатку знайти мінімальну дату і потім округлити її.\nАле потрібно бути уважними: часто результат залежить від того, в якому порядку застосовуються звичайні та агрегатні функції. Наприклад, наступні два запити дадуть різний результат:\nSELECT column_1, MIN(DATE_PART('month', column_2)) AS min_month\nFROM table\nGROUP BY column_1\n\n\nSELECT column_1, DATE_PART('month', MIN(column_2)) AS min_month\nFROM table\nGROUP BY column_1\nУ першому запиті з кожної дати в колонці column_2 ми спочатку виділяємо всі порядкові номери місяців, а потім у кожній групі знаходимо серед них мінімальний. У другому запиті спочатку визначається мінімальна дата у кожній групі, а потім обчислюється порядковий номер місяця у цій даті.\nЗрозуміло, що результат може відрізнятися, оскільки в даних можуть бути дати за різні роки — в самому ранньому році можуть не виявитися дати з деякими місяцями, тоді як у пізніших роках дати з цими місяцями будуть. Через це і можлива ситуація, коли запити даватимуть різний результат.\nДавайте розглянемо такі випадки на практиці.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.5  За даними таблиці users порахуйте максимальний порядковий номер місяця серед усіх порядкових номерів місяців народження користувачів сервісу. За допомогою групування проведіть розрахунки окремо у двох групах – для користувачів чоловічої та жіночої статі.\nНову колонку з максимальним номером місяця народження у групах назвіть max_month. Перетворіть значення у новій колонці у формат INTEGER, щоб порядковий номер був виражений цілим числом.\nРезультат відсортуйте по колонці зі статтю користувачів.\nПоля у результуючій таблиці: sex, max_month\nПояснення:\nДля отримання порядкового номера місяця з дати стане в нагоді функція DATE_PART.\n\n\n\n\n\nРішення\n%%sql\nSELECT sex,\n       max(date_part('month', birth_date))::integer as max_month\nFROM   users\nGROUP BY sex\nORDER BY sex\n\n\n\n\n\n\n\n\n\nsex\nmax_month\n\n\n\n\n0\nfemale\n12\n\n\n1\nmale\n12\n\n\n\n\n\n\n\n\nА тепер давайте трохи змінимо логіку попереднього запиту.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.6  За даними у таблиці users порахуйте порядковий номер місяця народження наймолодшого користувача сервісу. За допомогою групування проведіть розрахунки окремо у двох групах – для користувачів чоловічої та жіночої статі.\nНову колонку з максимальним номером місяця народження у групах назвіть max_month. Перетворіть значення у новій колонці у формат INTEGER, щоб порядковий номер був виражений цілим числом.\nРезультат відсортуйте по колонці зі статтю користувачів.\nПоля у результуючій таблиці: sex, max_month\nПояснення:\nДля отримання порядкового номера місяця з дати стане в нагоді функція DATE_PART.\nПісля того як розв’яжете завдання, зверніть увагу на отриманий результат. Чи співпаде він із результатом попереднього запиту? Чи це схоже на той випадок, який був описаний на попередньому кроці?\n\n\n\n\n\nРішення\n%%sql\nSELECT sex,\n       date_part('month', max(birth_date))::integer as max_month\nFROM   users\nGROUP BY sex\nORDER BY sex\n\n\n\n\n\n\n\n\n\nsex\nmax_month\n\n\n\n\n0\nfemale\n6\n\n\n1\nmale\n9\n\n\n\n\n\n\n\nМаркетологи знову звернулися до нас із завданням: цього разу вони просять провести невеликий аналіз нашої аудиторії та порахувати, скільки клієнтів певного віку користуються нашим сервісом. Давайте допоможемо нашим колегам!\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.7  Розбийте користувачів з таблиці users на групи віком (вік вимірюємо кількістю повних років) і порахуйте кількість користувачів кожного віку. Колонку з віком назвіть age, а колонку з кількістю користувачів users_count. Відсортуйте отриманий результат за зростанням по віку. Не забудемо і про тих користувачів, у яких замість віку буде перепустки, для цієї групи також підрахуємо кількість користувачів.\nПоля у результуючій таблиці: age, users_count\nПояснення: зверніть увагу, що у цій задачі вам необхідно провести групування за новим розрахунковим полем з віком. У цій ситуації важливо пам’ятати, що колонки, вказані в SELECT, повинні знаходитись і в GROUP BY (якщо вони не використовуються в агрегатних функціях). При цьому GROUP BY допускається використання аліасу колонки, зазначеного в блоці SELECT, тобто повторно проводити обчислення у GROUP BY не обов’язково.\n\n\n\n\n\nРішення\n%%sql\nSELECT date_part('year', age(birth_date)) as age,\n       count(user_id) as users_count\nFROM   users\nGROUP BY age\nORDER BY age\nLIMIT 10\n\n\n\n\n\n\n\n\n\nage\nusers_count\n\n\n\n\n0\n19\n1\n\n\n1\n20\n1\n\n\n2\n21\n7\n\n\n3\n22\n26\n\n\n4\n23\n78\n\n\n5\n24\n195\n\n\n6\n25\n421\n\n\n7\n26\n840\n\n\n8\n27\n1397\n\n\n9\n28\n2077\n\n\n\n\n\n\n\nВи могли помітити, що результат попереднього запиту для однієї з груп повернув пусте значення віку. Ми знову зіткнулися з значеннями NULL — цього разу в колонці birth_date. Давайте позбавимося їх перед групуванням і заодно зробимо наш аналіз ще більш детальним: додамо до групування стать користувачів.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.8  Знову розбийте користувачів із таблиці users на групи за віком (вік вимірюємо кількістю повних років), тільки тепер додайте до групування стать користувача. В результаті в кожній віковій групі має з’явитися ще по дві підгрупи зі статтю. У кожній такій підгрупі порахуйте кількість користувачів.\nУсі значення NULL у колонці birth_date заздалегідь відфільтруйте за допомогою WHERE. Колонку з віком назвіть age, а колонку з числом користувачів -users_count`, ім’я колонки зі статтю залиште без змін. Відсортуйте отриману таблицю спочатку по колонці з віком по зростанню, потім по колонці з підлогою теж по зростанню.\nПоля у результуючій таблиці: age, sex, users_count\n\n\n\n\n\nРішення\n%%sql\nSELECT date_part('year', age(birth_date)) as age,\n       sex,\n       count(user_id) as users_count\nFROM   users\nWHERE  birth_date is not null\nGROUP BY age, sex\nORDER BY age, sex\nLIMIT 10\n\n\n\n\n\n\n\n\n\nage\nsex\nusers_count\n\n\n\n\n0\n19\nmale\n1\n\n\n1\n20\nmale\n1\n\n\n2\n21\nfemale\n4\n\n\n3\n21\nmale\n3\n\n\n4\n22\nfemale\n10\n\n\n5\n22\nmale\n16\n\n\n6\n23\nfemale\n39\n\n\n7\n23\nmale\n39\n\n\n8\n24\nfemale\n105\n\n\n9\n24\nmale\n90\n\n\n\n\n\n\n\nА тепер, використовуючи наші знання про групування, давайте порахуємо скільки замовлень було зроблено і скільки скасовано в кожному окремому місяці. На цей раз для роботи з датами будемо використовувати не DATE_PART, а нову функцію DATE_TRUNC.\nФункція DATE_TRUNC використовується усічення дат і часу, тобто вона працює аналогічно округленню ROUND, тільки для типів даних TIMESTAMP та INTERVAL.\nСинтаксис у неї такий самий, як і у DATE_PART:\nSELECT DATE_TRUNC(part, column)\nНа місці part у лапках вказується, до якої точності слід обрізати передане значення часу: 'year', 'month', 'day', 'hour’ тощо.\nОтримані значення мають тип TIMESTAMP або INTERVAL, а всі «частини» вихідного значення, менш значущі, ніж задана «частина», прирівнюються до нуля (або одиниці, якщо це номер дня або місяця):\nSELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-01 00:00\n\nSELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-12 00:00    \n\nSELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-12 08:00\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з функцією DATE_TRUNC можна ознайомитись тут.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.9  Використовуючи функцію DATE_TRUNC, порахуйте, скільки замовлень було зроблено та скільки було скасовано кожного місяця. Розрахунки проводьте за таблицею user_actions. Колонку з усіченою датою назвіть month, колонку з кількістю замовлень - orders_count. Результат відсортуйте спочатку за місяцями – за зростанням, потім за типом дії – також за зростанням.\nПоля в результуючій таблиці: month, action, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT date_trunc('month', time) as month,\n       action,\n       count(order_id) as orders_count\nFROM   user_actions\nGROUP BY month, action\nORDER BY month, action\n\n\n\n\n\n\n\n\n\nmonth\naction\norders_count\n\n\n\n\n0\n2022-08-01\ncancel_order\n967\n\n\n1\n2022-08-01\ncreate_order\n18799\n\n\n2\n2022-09-01\ncancel_order\n2012\n\n\n3\n2022-09-01\ncreate_order\n40796\n\n\n\n\n\n\n\nУ Завдання 10.9 ми навчилися працювати з функцією array_length і навіть порахували з її допомогою кількість товарів у кожному замовленні. Давайте для кожного розміру замовлення, яке зустрічається у даних, порахуємо загальну кількість замовлень такого розміру.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.10  Порахуйте кількість товарів у кожному замовленні з таблиці orders, застосуйте до цих значень групування та порахуйте кількість замовлень у кожній групі. Виведіть дві колонки: кількість товарів у замовленні та кількість замовлень з такою кількістю. Колонки назвіть відповідно order_size та orders_count. Результат відсортуйте за зростанням кількості товарів у замовленні.\nПоля у результуючій таблиці: order_size, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT array_length(product_ids, 1) as order_size,\n       count(order_id) as orders_count\nFROM   orders\nGROUP BY order_size\nORDER BY order_size\n\n\n\n\n\n\n\n\n\norder_size\norders_count\n\n\n\n\n0\n1\n3333\n\n\n1\n2\n11851\n\n\n2\n3\n17856\n\n\n3\n4\n15057\n\n\n4\n5\n8065\n\n\n5\n6\n2774\n\n\n6\n7\n583\n\n\n7\n8\n71\n\n\n8\n9\n5"
  },
  {
    "objectID": "sql_groupby.html#фільтрація-після-групування-having",
    "href": "sql_groupby.html#фільтрація-після-групування-having",
    "title": "11  Групування даних",
    "section": "11.2 Фільтрація після групування: HAVING",
    "text": "11.2 Фільтрація після групування: HAVING\nHAVING використовується для фільтрації даних після групування. Він працює аналогічно WHERE, тільки використовується після GROUP BY і фільтрує вже групи, а не окремі записи.\nАле треба обговорити одну важливу особливість роботи з HAVING: у цьому блоці не можна вказувати аліаси розрахункових полів із блоку SELECT. Справа в тому, що відповідно до порядку виконання запиту оператор SELECT виконується після оператора HAVING. Тому агрегацію необхідно також вказувати і HAVING.\nНаприклад, такий запит не спрацює:\nSELECT column_1, SUM(column_2) AS new_column\nFROM table\nGROUP BY column_1\nHAVING new_column = 10\nА такий спрацює:\nSELECT column_1, SUM(column_2) AS new_column\nFROM table\nGROUP BY column_1\nHAVING SUM(column_2) = 10\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.11  Доповніть попередній запит оператором HAVING та відберіть лише ті розміри замовлень, загальна кількість яких перевищує 5000. Знову виведіть дві колонки: кількість товарів у замовленні та кількість замовлень з такою кількістю. Колонки назвіть відповідно order_size та orders_count. Результат відсортуйте за зростанням кількості товарів у замовленні.\nПоля у результуючій таблиці: order_size, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT array_length(product_ids, 1) as order_size,\n       count(order_id) as orders_count\nFROM   orders\nGROUP BY order_size\nHAVING count(order_id) &gt; 5000\nORDER BY order_size\n\n\n\n\n\n\n\n\n\norder_size\norders_count\n\n\n\n\n0\n2\n11851\n\n\n1\n3\n17856\n\n\n2\n4\n15057\n\n\n3\n5\n8065\n\n\n\n\n\n\n\nПеред тим, як рухатися далі, пропонуємо вам вирішити ще кілька завдань на групування.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.12  З таблиці courier_actions відберіть id трьох кур’єрів, які доставили найбільшу кількість замовлень у серпні 2022 року. Виведіть дві колонки – id кур’єра та кількість доставлених замовлень. Назвіть колонку з кількістю доставлених замовлень delivered_orders. Відсортуйте результат за спаданням delivered_orders.\nПоля у результуючій таблиці: courier_id, delivered_orders\nПояснення: пам’ятайте, що у таблиці courier_actions є інформація як про прийняті, так і про доставлені замовлення.\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       count(courier_id) as delivered_orders\nFROM   courier_actions\nWHERE  action = 'deliver_order'\n   and date_part('year', time) = 2022\n   and date_part('month', time) = 08\nGROUP BY courier_id\nORDER BY delivered_orders desc\nLIMIT 3\n\n\n\n\n\n\n\n\n\ncourier_id\ndelivered_orders\n\n\n\n\n0\n179\n36\n\n\n1\n329\n34\n\n\n2\n103\n31\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.13  А тепер відберіть лише тих кур’єрів, які у вересні 2022 року встигли доставити тільки за одне замовлення. Таблиця та сама - courier_actions. Знову виведіть дві колонки – id кур’єра та кількість доставлених замовлень. Назвіть колонку з числом замовлень delivered_orders. Результат відсортуйте за зростанням id кур’єра.\nПоля у результуючій таблиці: courier_id, delivered_orders\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       count(distinct courier_id) as delivered_orders\nFROM   courier_actions\nWHERE  action = 'deliver_order'\n   and date_part('year', time) = 2022\n   and date_part('month', time) = 09\nGROUP BY courier_id having count(distinct courier_id) = 1\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\ndelivered_orders\n\n\n\n\n0\n1\n1\n\n\n1\n2\n1\n\n\n2\n3\n1\n\n\n3\n4\n1\n\n\n4\n5\n1\n\n\n...\n...\n...\n\n\n2817\n3163\n1\n\n\n2818\n3164\n1\n\n\n2819\n3165\n1\n\n\n2820\n3166\n1\n\n\n2821\n3167\n1\n\n\n\n\n2822 rows × 2 columns\n\n\n\nОй, до нас у кабінет знову постукали! Це знову маркетологи: кажуть, що хочуть розіслати пуш-повідомлення зі спеціальною пропозицією. Аудиторія – користувачі, які давно не робили у нас замовлення.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.14  З таблиці user_actions відберіть користувачів, у яких останнє замовлення було створено до 8 вересня 2022 року. Виведіть тільки їх ID, дату створення замовлення виводити не потрібно. Результат відсортуйте за зростанням id користувача.\nПоле у результуючій таблиці: user_id\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЩоб розв’язати завдання, потрібно спочатку для кожного користувача знайти останній TIMESTAMP, коли він робив замовлення, а потім відібрати тих, хто робив це занадто давно. Враховуйте, що в таблиці є не лише час створення, а й час скасування замовлення.\n\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT user_id\nFROM   user_actions\nWHERE  action = 'create_order'\nGROUP BY user_id\nHAVING max(time) &lt; '2022-09-08'\nORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n17368\n19727\n\n\n17369\n19728\n\n\n17370\n19729\n\n\n17371\n19730\n\n\n17372\n19731\n\n\n\n\n17373 rows × 1 columns\n\n\n\nВ якості поля для групування може виступати і складніша розрахункова колонка — наприклад, результат виконання умовної конструкції CASE:\nSELECT name,\n       CASE \n       WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'\n       WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'\n       ELSE 'другое'\n       END AS сategory,\n       AVG(price) AS average_price\nFROM table\nGROUP BY сategory\nЗапит вище спочатку поділить всі товари на групи, потім групує їх і для кожної групи рахуватиме середню ціну всіх продуктів, що потрапили до неї.\nВиходить, що таким чином ми можемо додатково управляти групуванням наших даних — спочатку ми самі задаємо правила, за якими визначаємо належність записів до деяких категорій, а потім групуємо дані і проводимо необхідні розрахунки.\nДавайте за допомогою групування та умовної конструкції CASE з’ясуємо, чи відрізняється середній розмір замовлення у будні та вихідні дні.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.15  За даними з таблиці orders розрахуйте середній розмір замовлення у вихідні та будні.\nГрупу з вихідними днями (субота та неділя) назвіть \"weekend\", а групу з будними днями (з понеділка по п’ятницю) - \"weekdays\" (без лапок).\nУ результаті включіть дві колонки: колонку з групами назвіть week_part, а колонку із середнім розміром замовлення - avg_order_size.\nСередній розмір замовлення округліть до двох знаків після коми.\nРезультат відсортуйте по колонці із середнім розміром замовлення за зростанням.\nПоля у результуючій таблиці: week_part, avg_order_size\n\n\n\n\n\nРішення\n%%sql\nSELECT case when extract('dow'\nFROM   creation_time) in (0, 6) then 'weekend' else 'weekdays' end as week_part, round(avg(array_length(product_ids, 1)), 2) as avg_order_size\nFROM   orders\nGROUP BY week_part\nORDER BY avg_order_size\n\n--або\n-- SELECT case when to_char(creation_time, 'Dy') in ('Sat', 'Sun') then 'weekend'\n--             else 'weekdays' end as week_part,\n--       round(avg(array_length(product_ids, 1)), 2) as avg_order_size\n-- FROM   orders\n-- GROUP BY week_part\n-- ORDER BY avg_order_size\n\n\n\n\n\n\n\n\n\nweek_part\navg_order_size\n\n\n\n\n0\nweekend\n3.39\n\n\n1\nweekdays\n3.40\n\n\n\n\n\n\n\nА тепер спробуємо вирішити складніше завдання. Для нього нам знову знадобиться агрегатний вираз із фільтрацією, який ми розглядали у Завдання 10.16. Цю конструкцію можна застосовувати не лише до всієї таблиці, а й окремо до кожної групи, сформованої внаслідок застосування оператора GROUP BY. Загалом вона виглядатиме так:\nSELECT column_1, agg_function(column_2) FILTER (WHERE [condition])\nFROM table\nGROUP BY column_1\nПриклад:\nSELECT column_1, AVG(column_2) FILTER (WHERE column_3 &gt; 100)\nFROM table\nGROUP BY column_1\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.16  Для кожного користувача в таблиці user_actions порахуйте частку скасованих замовлень. Виведіть дві колонки: ID користувача та розрахований показник. Нову колонку з показником округліть до двох знаків після коми та назвіть cancel_rate. Результат відсортуйте за зростанням id користувача.\nПоля у результуючій таблиці: user_id, cancel_rate\nПояснення: щоб порахувати частку скасованих замовлень, необхідно поділити кількість скасованих замовлень на загальну кількість унікальних замовлень користувача. Пам’ятайте, що для отримання коректного результату поділу потрібно хоча б одне із значень привести до типу DECIMAL.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       round(count(action) filter (WHERE action = 'cancel_order')::decimal / count(action) filter (WHERE action = 'create_order'),\n             2) as cancel_rate\nFROM   user_actions\nGROUP BY user_id\nORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\ncancel_rate\n\n\n\n\n0\n1\n0.0\n\n\n1\n2\n0.0\n\n\n2\n3\n0.0\n\n\n3\n4\n0.0\n\n\n4\n5\n0.0\n\n\n...\n...\n...\n\n\n21396\n21398\n0.0\n\n\n21397\n21399\n0.0\n\n\n21398\n21400\n0.0\n\n\n21399\n21401\n0.0\n\n\n21400\n21402\n0.0\n\n\n\n\n21401 rows × 2 columns\n\n\n\nПовернімося до запиту з групуванням користувачів за віком, який робили у завданні 10.3.\nМи порахували кількість користувачів кожного віку, але дивитися на дані саме в такому угрупованні не дуже цікаво. Давайте перейдемо від конкретних значень віку до вікових груп.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.17  Розбийте користувачів із таблиці users на 4 вікові групи:\n\nвід 19 до 24 років;\nвід 25 до 29 років;\nвід 30 до 35 років;\nвід 36 до 41 року.\n\nПорахуйте кількість користувачів, які потрапили до кожної вікової групи. Групи назвіть відповідно 19-24, 25-29, 30-35, 36-41. Виведіть найменування груп та кількість користувачів у них. Назвіть колонку з найменуванням груп group_age, а колонку з числом користувачів — users_count. Відсортуйте отриману таблицю по колонці з найменуванням груп за зростання.\nПоля у результуючій таблиці: group_age, users_count\nПояснення: для вирішення цього завдання підійде конструкція CASE. Як і минулого разу, вік розглядайте, як кількість повних років.\n\n\n\n\n\nРішення\n%%sql\nSELECT case when date_part('year', age(birth_date)) between 19 and\n                 24 then '19-24'\n            when date_part('year', age(birth_date)) between 25 and\n                 29 then '25-29'\n            when date_part('year', age(birth_date)) between 30 and\n                 35 then '30-35'\n            when date_part('year', age(birth_date)) between 36 and\n                 41 then '36-41' end as group_age,\n       count(user_id) as users_count\nFROM   users\nWHERE  birth_date is not null\nGROUP BY group_age\nORDER BY group_age\n\n\n\n\n\n\n\n\n\ngroup_age\nusers_count\n\n\n\n\n0\n19-24\n308\n\n\n1\n25-29\n7367\n\n\n2\n30-35\n12002\n\n\n3\n36-41\n604\n\n\n\n\n\n\n\nІ насамкінець ще одне цікаве завдання.\nСпробуймо з’ясувати, чи відрізняється success rate (частка невідмінених замовлень) у різні дні тижня. Для цього порахуємо, скільки всього було оформлено замовлень у кожен із днів, скільки з цих замовлень було скасовано та скільки фактично було успішно доставлено до користувачів.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 11.18  Для кожного дня тижня у таблиці user_actions порахуйте:\n\nЗагальна кількість оформлених замовлень.\nЗагальна кількість скасованих замовлень.\nЗагальна кількість невідмінених замовлень (тобто доставлених).\nЧастку невідмінених замовлень у загальній кількості замовлень (success rate).\n\nНові колонки назвіть відповідно created_orders, canceled_orders, actual_orders та success_rate. Колонку з часткою невідмінених замовлень округліть до трьох знаків після коми.\nУсі розрахунки проводьте за період з 24 серпня по 6 вересня 2022 року включно, щоб до часового інтервалу потрапила рівна кількість різних днів тижня.\nГрупи сформуйте таким чином: виділіть день тижня з дати за допомогою функції функції DATE_PART з параметром 'isodow'. Далі згрупуйте дані за двома полями та проведіть усі необхідні розрахунки.\nВ результаті має вийти групування за двома колонками: з порядковим номером днів тижня та їх скороченими найменуваннями.\nРезультат відсортуйте за зростанням порядкового номера тижня тижня.\nПоля в результуючій таблиці: weekday_number, weekday, created_orders, canceled_orders, actual_orders, success_rate\nПояснення:\nЗ метою спрощення розрахунків у рамках цього завдання вважаємо, що скасування замовлення відбувається практично відразу після його створення. Випадками, коли замовлення створюється незадовго до півночі, а скасування випадає наступного дня, ми нехтуємо.\nНомер дня тижня ми додатково виділяємо для того, щоб одночасно вивести найменування та відсортувати всі записи відповідно до порядку днів тижня.\nПам’ятайте, що при розрахунку відносних показників для отримання коректного результату поділу потрібно хоча б одне із значень привести до типу DECIMAL.\n\n\n\n\n\nРішення\n%%sql\nSELECT \n       date_part('isodow', time)::int as weekday_number,\n       count(order_id) filter (WHERE action = 'create_order') as created_orders,\n       count(order_id) filter (WHERE action = 'cancel_order') as canceled_orders,\n       count(order_id) filter (WHERE action = 'create_order') - count(order_id) filter (WHERE action = 'cancel_order') as actual_orders,\n       round((count(order_id) filter (WHERE action = 'create_order') - count(order_id) filter (WHERE action = 'cancel_order'))::decimal / count(order_id) filter (WHERE action = 'create_order'),\n             3) as success_rate\nFROM   user_actions\nWHERE  time &gt;= '2022-08-24'\n   and time &lt; '2022-09-07'\nGROUP BY weekday_number\nORDER BY weekday_number\n\n\n\n\n\n\n\n\n\nweekday_number\ncreated_orders\ncanceled_orders\nactual_orders\nsuccess_rate\n\n\n\n\n0\n1\n8374\n434\n7940\n0.948\n\n\n1\n2\n7193\n370\n6823\n0.949\n\n\n2\n3\n3758\n210\n3548\n0.944\n\n\n3\n4\n5004\n258\n4746\n0.948\n\n\n4\n5\n6800\n352\n6448\n0.948\n\n\n5\n6\n8249\n399\n7850\n0.952\n\n\n6\n7\n9454\n443\n9011\n0.953"
  },
  {
    "objectID": "sql_subquery.html#порядок-виконання-запитів",
    "href": "sql_subquery.html#порядок-виконання-запитів",
    "title": "12  Підзапити",
    "section": "12.1 Порядок виконання запитів",
    "text": "12.1 Порядок виконання запитів\nПерш ніж переходити до підзапитів, давайте трохи поговоримо про порядок виконання запитів у SQL.\nДо цього моменту ми вже встигли познайомитися з основними операторами, які складають “скелет” стандартного SQL-запиту: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY та LIMIT.\nМи вже знаємо, що порядок їх написання у запиті наступний:\nSELECT      -- перелік полів результуючої таблиці\nFROM        -- вказівник джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- групування даних\nHAVING      -- фільтрація даних після групування\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів у виводі\nПроте важливо розуміти, що порядок виконання операторів у базах даних дещо відрізняється від порядку їх написання у запиті. У спрощеному вигляді порядок виконання запиту такий:\nFROM       -- вказівник джерела даних\nWHERE      -- фільтрація даних\nGROUP BY   -- групування даних\nHAVING     -- фільтрація даних після групування\nSELECT     -- перелік полів результуючої таблиці\nORDER BY   -- сортування результуючої таблиці\nLIMIT      -- бмеження кількості записів у виводі\nТаким чином:\n\nСпочатку з допомогою FROM визначається таблиця.\nПотім відповідно до зазначеної у WHERE умові з цієї таблиці відбираються записи.\nПотім вибрані дані групуються та агрегуються за допомогою GROUP BY.\nДалі з агрегованих записів відбираються ті, які задовольняють умову HAVING.\nТільки після цього відповідно до зазначених у SELECT інструкціях формується результуюча таблиця — проводяться всі необхідні обчислення, надаються нові імена тощо.\nПотім результуюча таблиця сортується відповідно до ORDER BY.\nІ нарешті спрацьовує обмеження кількості рядків, вказане в LIMIT.\n\nНасправді це дуже важлива інформація, яку слід пам’ятати при складанні будь-яких SQL-запитів.\nМожливо, ви вже зіткнулися з помилками, коли намагалися в блоці WHERE використовувати фільтрацію по нових полях, розрахованих у SELECT. Така операція не відповідає порядку виконання операторів і тому так робити не можна. Також ви могли потрапити в ситуацію, коли при фільтрації у HAVING у вас не приймався аліас колонки, розрахованої в SELECT. Це відбувалося з тієї ж причини – база даних просто ще не знала про те, що ви надали колонці нове ім’я.\nІ ще одна важлива порада. Зверніть увагу, що фільтрацію даних за неагрегованими значеннями можна робити як у блоці WHERE, так і в блоці HAVING. Уважно подивіться на такі запити:\nSELECT sex, COUNT(user_id)\nFROM users\nWHERE sex != 'male'\nGROUP BY sex\n\n\nSELECT sex, COUNT(user_id)\nFROM users\nGROUP BY sex\nHAVING sex != 'male'\nЇх результат буде однаковим (можете переконатися в цьому самі).\nПроте робити фільтрацію за неагрегованими даними рекомендується саме у блоці WHERE, тобто заздалегідь. У такому разі ви ще до угруповання прибираєте з розрахунків непотрібні вам дані і таким чином не витрачаєте обчислювальні ресурси на підрахунок значень, які будуть відфільтровані вами пізніше.\nЦе важливий момент щодо оптимізації SQL-запитів, тому рекомендуємо вам взяти до уваги інформацію."
  },
  {
    "objectID": "sql_subquery.html#підзапити",
    "href": "sql_subquery.html#підзапити",
    "title": "12  Підзапити",
    "section": "12.2 Підзапити",
    "text": "12.2 Підзапити\nПідзапити це потужним інструментом в мові SQL, який дозволяє нам виконувати запити в середині інших запитів. Вони дають можливість створювати складніші і більш гнучкі запити, які вимагають доступу до даних з кількох таблиць або виконання додаткових обчислень.\nОдин із сценаріїв використання підзапитів - це пошук даних в одній таблиці на основі значень з іншої таблиці. Наприклад, ми можемо створити запит, що повертає всіх клієнтів, які зробили замовлення на товари з певної категорії, використовуючи підзапит для вибірки ідентифікаторів цих товарів з таблиці товарів.\nНаприклад у нас є дві таблиці: clients і orders. Нам потрібно отримати список клієнтів, які зробили замовлення після певної дати. Для цього ми можемо скористатися підзапитом:\nSELECT *\nFROM clients\nWHERE ID IN (SELECT client_id\n             FROM orders\n             WHERE data &gt; '2023-01-01');\n)\nІншими словами, підзапит — це лише запит усередині іншого запиту.\nПідзапити можуть застосовуватись у таких частинах основного запиту:\n\nв операторі FROM;\nв операторі SELECT (якщо запит повертає один стовпець з одним значенням);\nв операторах WHERE та HAVING (якщо запит повертає один стовпець з одним або декількома значеннями).\n\nАле давайте про все по порядку.\nНасамперед важливо зрозуміти, що з результату виконання підзапиту можна звертатися також як і до таблиць у базі даних, тобто використовувати їх у блоці FROM замість наявних таблиць:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM table\n) AS subquery_1\nВ межах даного запиту спочатку буде виконано підзапит, який відбере колонки column_1 і column_2 з таблиці table, а потім вже з таблиці, що утворилася, основний запит вибере колонку column_1.\nВажливий момент: при використанні підзапиту в блоці FROM сформованій на основі підзапиту таблиці необхідно привласнити якийсь аліас, інакше основний запит не спрацює. У прикладі вище ми позначили результат підзапиту subquery_1.\nКрім того, рівнів вкладеності може бути декілька:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM (\n        SELECT column_1, column_2, column_3\n        FROM table\n    ) AS subquery_1\n) AS subquery_2\nВ даному випадку послідовність роботи запиту така: спочатку буде виконано підзапит, що повертає результат subquery_1, потім підзапит, що повертає результат subquery_2, і тільки потім в результаті основного підзапиту потрапить колонка column_1. В результаті виходить щось схоже на матрьошку, при цьому до основної таблиці table звертається тільки перший підзапит subquery_1.\nНаведений приклад досить умовний і на практиці колонки в такий спосіб відбирати не варто, але загальну ідею він має передавати.\nРозуміння того, як працюють підзапити в блоці FROM, нам особливо стане в нагоді, коли ми вчитимемося об’єднувати різні таблиці.\nА зараз давайте вирішимо просте завдання.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.1  Використовуючи дані з таблиці user_actions, розрахуйте середню кількість замовлень для всіх користувачів нашого сервісу. Для цього спочатку в підзапиті порахуйте скільки замовлень зробив кожен користувач, а потім зверніться до результату підзапиту в блоці FROM і вже в основному запиті усередніть кількість замовлень по всіх користувачах. Отриману середню кількість замовлень всіх користувачів округліть до двох знаків після коми. Назвіть колонку з цим значенням orders_avg.\nПоле у результуючій таблиці: orders_avg\nПояснення: до колонок з підзапиту можна застосовувати агрегатні функції — так само, як би ми зверталися до колонок вихідних таблиць.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(orders_count), 2) as orders_avg\nFROM   (SELECT count(order_id) as orders_count\n        FROM   user_actions\n        WHERE  action = 'create_order'\n        GROUP BY user_id) as t1\n\n\n\n\n\n\n\n\n\norders_avg\n\n\n\n\n0\n2.78"
  },
  {
    "objectID": "sql_subquery.html#табличні-вирази-with",
    "href": "sql_subquery.html#табличні-вирази-with",
    "title": "12  Підзапити",
    "section": "12.3 Табличні вирази: WITH",
    "text": "12.3 Табличні вирази: WITH\nВирішуючи попереднє завдання, ви могли запитати себе: а що якщо один і той же підзапит буде використовуватися в декількох частинах основного запиту? Невже щоразу доведеться дублювати той самий підзапит? А якщо рівнів вкладеності буде кілька? Чи не вийде тоді надто складний та громіздкий запит, який буде складно читати?\nДля таких випадків SQL передбачений оператор WITH, який дозволяє створювати так звані табличні вирази (CTE, анг. common table expressions) - тимчасові таблиці, які існують тільки для одного запиту. Їхнє основне призначення полягає в розбиття складних запитів на кілька частин.\nТабличні вирази створюються так:\nWITH subquery_1 AS (\n    SELECT column_1, column_2\n    FROM table\n)\nSELECT column_1\nFROM subquery_1\nПорівняйте запит вище з результатом запиту, який ми використовували раніше:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM table\n) AS subquery_1\nОператор WITH може містити кілька табличних виразів, причому до зазначених раніше виразів можна звертатися у подальших виразах:\nWITH subquery_1 AS (\n    SELECT column_1, column_2, column_3\n    FROM table\n    ),\n     subquery_2 AS (\n    SELECT column_1, column_2\n    FROM subquery_1\n    )\n\nSELECT column_1\nFROM subquery_2\nМожете знову порівняти запит вище із запитом, який ми використовували раніше:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM (\n        SELECT column_1, column_2, column_3\n        FROM table\n    ) AS subquery_1\n) AS subquery_2\nВикористовувати у своїх запитах оператор WITH чи ні вирішувати вам, але в деяких випадках він може спростити роботу з кодом запиту.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про WITH та табличні вирази можна почитати тут.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.2  Повторіть запит із завдання 12.1, але тепер замість підзапиту використовуйте оператор WITH та табличний вираз. Умови завдання ті самі.\nПоле у результуючій таблиці: orders_avg\n\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT user_id,\n                   count(order_id) as orders_count\n            FROM   user_actions\n            WHERE  action = 'create_order'\n            GROUP BY user_id)\nSELECT round(avg(orders_count), 2) as orders_avg\nFROM   t1\n\n\n\n\n\n\n\n\n\norders_avg\n\n\n\n\n\n\n\n\n\nЩе один важливий напрямок застосування підзапитів - створення більш просунутих умовних виразів в операторах WHERE та HAVING. Але оскільки і в тому, і в іншому випадку синтаксис і призначення підзапитів приблизно однакові, у цьому уроці ми розглядатимемо все на прикладі підзапитів у WHERE.\nНасамперед важливо зрозуміти, що підзапит, який повертає одне значення, може використовуватися як звичайне значення спільно з операторами порівняння.\nУявіть, що нам потрібно порівняти значення в якомусь стовпці з максимальним, мінімальним чи середнім значенням у цьому стовпці. Зробити це в рамках одного запиту не вийде, оскільки агрегатні функції не можна використовувати в блоці WHERE.\nНаприклад, наступний запит не працюватиме (база даних повідомить про помилку):\nSELECT column\nFROM table\nWHERE column = MAX(column) \nУ той же час такий запит спрацює, тому що підзапит виконається першим і поверне одне значення:\nSELECT column\nFROM table\nWHERE column = (SELECT MAX(column) FROM table) \nВ результаті виконання такого запиту ми отримаємо всі значення в колонці column, що дорівнює максимальному значенню в цій колонці.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.3  Виведіть з таблиці products інформацію про всі товари крім найдешевшого. Результат відсортуйте за зменшенням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nWHERE  price != (SELECT min(price)\n                 FROM   products)\nORDER BY product_id desc\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n87\nveal\n398.0\n\n\n1\n86\ncold coffee\n70.0\n\n\n2\n85\njam\n200.0\n\n\n3\n84\ntangerines\n90.0\n\n\n4\n83\nwaffles\n55.0\n\n\n...\n...\n...\n...\n\n\n81\n5\ncoffee 3 in 1\n15.0\n\n\n82\n4\nlollipops\n46.0\n\n\n83\n3\nstill water\n80.0\n\n\n84\n2\ngreen tea bags\n50.0\n\n\n85\n1\nsugar\n150.0\n\n\n\n\n86 rows × 3 columns\n\n\n\nУ блоці WHERE результати підзапитів, що повертають одне значення, також можна використовувати в арифметичних операціях:\nSELECT column\nFROM table\nWHERE column = (SELECT MAX(column) FROM table) - 100\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.4  Виведіть інформацію про товари в таблиці products, ціна на які перевищує середню ціну всіх товарів на 20 і більше одиниць. Результат відсортуйте за зменшенням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nWHERE  price &gt;= (SELECT avg(price)\n                 FROM   products) + 20\nORDER BY product_id desc\nLIMIT 10\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n87\nveal\n398.0\n\n\n1\n85\njam\n200.0\n\n\n2\n77\nchicken\n298.0\n\n\n3\n69\ncranberry juice\n175.0\n\n\n4\n66\nbeef\n370.0\n\n\n5\n64\npineapple\n200.0\n\n\n6\n61\nhoney\n380.0\n\n\n7\n59\nsesame oil\n250.0\n\n\n8\n57\npork\n450.0\n\n\n9\n51\nsmoked fish\n195.0"
  },
  {
    "objectID": "sql_subquery.html#підзапит-з-інтервалом-часу-interval",
    "href": "sql_subquery.html#підзапит-з-інтервалом-часу-interval",
    "title": "12  Підзапити",
    "section": "12.4 Підзапит з інтервалом часу: INTERVAL",
    "text": "12.4 Підзапит з інтервалом часу: INTERVAL\nУ яких випадках нам може стати в нагоді підзапит в операторі WHERE?\nУявімо, що нам потрібно провести якісь розрахунки за останні N днів — скажімо, за останній тиждень. Чи будемо ми вручну відраховувати 7 днів від останньої дати в нашій таблиці? Зрозуміло, що ні. Крім того, остання дата може згодом змінитись, коли до нас надійдуть нові дані. Щоразу писати новий запит і рахувати дату вручну — заняття не для нас.\nДля вирішення такого завдання ми можемо спочатку за допомогою підзапиту обчислити останню дату наших даних, а потім відкласти від неї тиждень.\nЩоб відкласти від дати або додати до неї певний проміжок часу, можна використовувати нескладні арифметичні операції з датами. Наприклад, від поточної дати можна відібрати якийсь проміжок INTERVAL:\nSELECT NOW() - INTERVAL '1 year 2 months 1 week'\n\nРезультат:\n2022-04-24 13:10\nДо речі, NOW() — корисна функція, яка дозволяє отримувати поточну дату та час (у вашому випадку вона буде іншою):\nSELECT NOW()\n\nРезультат:\n2022-07-10 16:11\n\n\n\n\n\n\nПримітка\n\n\n\nЗ іншими прикладами роботи з INTERVAL та арифметичними операціями з датами можна ознайомитись тут.\nПро функцію NOW() можна додатково прочитати тут.\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.5  Порахуйте кількість унікальних клієнтів у таблиці user_actions, які зробили за останній тиждень хоча б одне замовлення. Отриману колонку зі значенням назвіть users_count. В якості поточної дати, від якої відкладати тиждень, використовуйте останню дату тієї ж таблиці user_actions.\nПоле у результуючій таблиці: users_count\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct user_id) as users_count\nFROM   user_actions\nWHERE  action = 'create_order'\n   and time &gt; (SELECT max(time)\n            FROM   user_actions) - interval '1 week'\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n17352\n\n\n\n\n\n\n\nВиходить, що в одному з минулих завдань (10.10) ми неправильно рахували вік кур’єрів. Дійсно, як перша дата у функції AGE() ми використовували поточну дату, а не останню дату в наших даних. Давайте виправимо це прикре непорозуміння, адже тепер у нас для цього є всі необхідні знання.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.6  За допомогою функції AGE() і агрегатної функції знову розрахуйте вік наймолодшого кур’єра чоловічої статі в таблиці couriers, але цього разу в якості першої дати використовуйте останню дату з таблиці courier_actions. Щоб вийшла саме дата, перед застосуванням функції AGE() переведіть пораховану останню дату у формат DATE, як ми робили у 8.9. Вік кур’єра виміряйте кількістю років, місяців і днів і переведіть його до типу VARCHAR. Отриману колонку зі значенням віку назвіть min_age.\nПоле у результуючій таблиці: min_age\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цій задачі результат підзапиту виступає як аргумент функції. Щоб весь запит виглядав компактнішим, для приведення даних до іншого типу можна використовувати формат запису з двома двокрапками - ::.\nТакож зверніть увагу, що для отримання необхідного результату ми звертаємось до різних таблиць у рамках одного загального запиту – так можна робити теж.\n\n\n\n\nРішення\n%%sql\n-- варіант 1\nSELECT age((SELECT max(time)::date\n            FROM   courier_actions), max(birth_date))::varchar as min_age\nFROM   couriers\nWHERE  sex = 'male'\n\n-- варіант 2\n-- SELECT min(age((SELECT max(time)::date\n--                 FROM   courier_actions), birth_date))::varchar as min_age\n-- FROM   couriers\n-- WHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nmin_age\n\n\n\n\n\n\n\n\n\nПідзапит, який повертає кілька значень, може використовуватися в блоці WHERE спільно з оператором IN — наприклад, коли нам потрібно перевірити, чи збігається значення в стовпці з одним із значень із певної множини, отриманої в результаті виконання підзапиту:\nSELECT column_1\nFROM table_1\nWHERE column_1 IN (SELECT column_2 FROM table_2) \nПри цьому, запит вище буде рівносильний запиту з табличним виразом:\nWITH subquery AS (\n    SELECT column_2\n    FROM table_2\n    )\n\nSELECT column_1\nFROM table_1\nWHERE column_1 IN (SELECT * FROM subquery) \nЗверніть увагу, що при використанні в операторі табличного виразу WHERE звернутися просто до його імені не можна - необхідно попередньо вибрати всі його записи, тобто написати підзапит. При цьому в табличному вираженні має бути лише один стовпець, інакше база даних поверне помилку.\nКрім того, в табличному вираженні можна зберігати лише одне значення (наприклад, результат агрегації) і аналогічним чином викликати його в операторі WHERE як змінну:\nWITH subquery AS (\n    SELECT MAX(column_2)\n    FROM table_2\n    )\n\nSELECT column_1\nFROM table_1\nWHERE column_1 = (SELECT * FROM subquery) \nДавайте розглянемо такий приклад.\nЗ наших даних досить легко відібрати скасовані замовлення - достатньо вказати у WHERE потрібний фільтр. Але як відібрати створені, але не скасовані замовлення? Це якраз можна зробити за допомогою підзапиту або табличного виразу.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.7  З таблиці user_actions за допомогою підзапиту або табличного виразу відберіть усі замовлення, які не було скасовано користувачами. Виведіть стовпчик з id цих замовлень. Результат запиту відсортуйте за зростанням id замовлення. Додайте в запит оператор LIMIT та виведіть лише перші 10 рядків результуючої таблиці.\nПоле у результуючій таблиці: order_id\n\n\n\n\n\nРішення\n%%sql\n-- варіант 1\nSELECT order_id\nFROM   user_actions\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order')\nORDER BY order_id limit 10\n\n-- варіант 2\n-- SELECT order_id\n-- FROM   user_actions\n-- WHERE  order_id not in (SELECT order_id\n--                         FROM   user_actions\n--                         WHERE  action = 'cancel_order')\n-- ORDER BY order_id limit 10"
  },
  {
    "objectID": "sql_subquery.html#підзапити-в-блоці-select",
    "href": "sql_subquery.html#підзапити-в-блоці-select",
    "title": "12  Підзапити",
    "section": "12.5 Підзапити в блоці SELECT",
    "text": "12.5 Підзапити в блоці SELECT\nЯк було зазначено в першому кроці, вкладений запит може бути розміщений і після оператора SELECT. Однак результатом підзапиту в такому випадку може бути тільки одне значення — наприклад, результат застосування агрегатної функції до якоїсь колонки:\nSELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1\nFROM table\nВ такому випадку з таблиці table буде обрано колонка column_1, і навпаки кожного значення у цій колонці буде виведено результат виконання вкладеного запиту, тобто максимальне значення у цій колонці. При цьому давати аліасу результату підзапиту не обов’язково.\nТакож результати підзапитів у блоці SELECT можна використовувати у обчисленнях:\nSELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2\nFROM table\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.8  Використовуючи дані з таблиці user_actions, розрахуйте скільки замовлень зробив кожен користувач і відобразіть це в стовпці orders_count. В окремому стовпці orders_avg навпроти кожного користувача вкажіть середню кількість замовлень всіх користувачів, округливши до двох знаків після коми. Також для кожного користувача порахуйте відхилення замовлень від середнього значення. Відхилення рахуйте так: число замовлень «мінус» заокруглене середнє значення. Назвіть колонку з відхиленням orders_diff. Результат відсортуйте за зростанням id користувача. Додайте в запит оператор LIMIT та виведіть лише перші 10 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, orders_count, orders_avg, orders_diff\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цій задачі можна використовувати підзапит, написаний у перших завданнях цього уроку. Щоб не довелося двічі писати той самий підзапит, можна використовувати оператор WITH.\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT user_id,\n                   count(order_id) as orders_count\n            FROM   user_actions\n            WHERE  action = 'create_order'\n            GROUP BY user_id)\nSELECT user_id,\n       orders_count,\n       round((SELECT avg(orders_count) FROM   t1), 2) as orders_avg,\n       orders_count - round((SELECT avg(orders_count) FROM   t1), 2) as orders_diff\nFROM   t1\nORDER BY user_id limit 1000\n\n\nПеред тим, як піти далі, пропонуємо вам вирішити ще кілька завдань на підзапити.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.9  Виведіть id та вміст 100 останніх доставлених замовлень із таблиці orders. Вмістом замовлень вважаються списки з id товарів, що входять у замовлення. Результат відсортуйте за зростанням id замовлення.\nПоля у результуючій таблиці: order_id, product_ids\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що вміст замовлень знаходиться у таблиці orders, а інформація про дії із замовленнями – у таблиці courier_actions.\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       product_ids\nFROM   orders\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order'\n                    ORDER BY time desc limit 100)\nORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\nproduct_ids\n\n\n\n\n0\n59466\n[71, 50, 45]\n\n\n1\n59481\n[26, 30, 84, 1]\n\n\n2\n59482\n[32, 42, 79, 56]\n\n\n3\n59487\n[9, 62, 77]\n\n\n4\n59489\n[67, 42]\n\n\n...\n...\n...\n\n\n95\n59591\n[74, 26, 69, 3]\n\n\n96\n59592\n[34, 58, 31]\n\n\n97\n59593\n[52, 46, 40]\n\n\n98\n59594\n[2, 62]\n\n\n99\n59595\n[18, 30, 67]\n\n\n\n\n100 rows × 2 columns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.10  З таблиці couriers виведіть всю інформацію про кур’єрів, які у вересні 2022 року доставили 30 і більше замовлень. Результат відсортуйте за зростанням id кур’єра.\nПоля в результуючій таблиці: courier_id, birth_date, sex\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що інформація про кур’єрів знаходиться в таблиці couriers, а інформація про дії із замовленнями - у таблиці courier_actions.\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       birth_date,\n       sex\nFROM   couriers\nWHERE  courier_id in (SELECT courier_id\n                      FROM   courier_actions\n                      WHERE  date_part('month', time) = 9\n                         and date_part('year', time) = 2022\n                         and action = 'deliver_order'\n                      GROUP BY courier_id having count(distinct order_id) &gt;= 30)\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_date\nsex\n\n\n\n\n0\n23\n1990-03-26\nmale\n\n\n1\n869\n2001-08-25\nfemale\n\n\n2\n1466\n1994-04-07\nmale\n\n\n3\n1664\n1987-12-16\nmale\n\n\n\n\n\n\n\nУ цій задачі об’єднаємо знання про конструкцію CASE та підзапити.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.11  Призначте знижку 15% на товари, ціна яких перевищує середню ціну на всі товари на 50 і більше одиниць, а також знижку 10% на товари, ціна яких нижча за середню на 50 і більше одиниць. Ціну інших товарів усередині діапазону (середнє – 50; середнє + 50) залиште без змін. При розрахунку середньої ціни округліть її до двох знаків після коми.\nВиведіть інформацію про всі товари із зазначенням старої та нової ціни. Колонку із новою ціною назвіть new_price. Результат відсортуйте спочатку за спаданням колишньої ціни в колонці price, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, new_price\n\n\n\n\n\nРішення\n%%sql\nSELECT \n  product_id,\n  name,\n  price,\n  CASE\n    WHEN price &gt; (SELECT ROUND(AVG(price), 2) + 50 FROM products) THEN ROUND(price * 0.85, 2)\n    WHEN price &lt; (SELECT ROUND(AVG(price), 2) - 50 FROM products) THEN ROUND(price * 0.9, 2)\n    ELSE price\n  END AS new_price\nFROM products\nORDER BY price DESC, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\nnew_price\n\n\n\n\n0\n13\ncaviar\n800.0\n680.00\n\n\n1\n37\nmutton\n559.0\n475.15\n\n\n2\n15\nolive oil\n450.0\n382.50\n\n\n3\n57\npork\n450.0\n382.50\n\n\n4\n43\ndecaffeinated coffee\n400.0\n340.00\n\n\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n22.50\n\n\n83\n5\ncoffee 3 in 1\n15.0\n13.50\n\n\n84\n73\ncake\n15.0\n13.50\n\n\n85\n10\nseeds\n12.0\n10.80\n\n\n86\n54\npaper bag\n1.0\n0.90\n\n\n\n\n87 rows × 4 columns"
  },
  {
    "objectID": "sql_subquery.html#розгортання-списків-unnest",
    "href": "sql_subquery.html#розгортання-списків-unnest",
    "title": "12  Підзапити",
    "section": "12.6 Розгортання списків: UNNEST()",
    "text": "12.6 Розгортання списків: UNNEST()\nДавайте знову попрацюємо з масивами і освоїмо нову функцію unnest, яка стане нам у нагоді в подальших завданнях. Функція unnest призначена для розгортання масивів та перетворення їх на набір рядків:\nSELECT unnest(ARRAY['one','two','three'])\n\nРезультат:\none\ntwo\nthree\nУ прикладі вище функція unnest перетворила вихідний список із трьох елементів на набір із трьох рядків.\nЯкби у вихідній таблиці крім списку був стовпець з будь-яким значенням, то це значення автоматично проставилося б навпроти значень у кожному рядку, що утворився:\nSELECT 'row', unnest(ARRAY['one','two','three'])\n\nРезультат:\nrow    one\nrow    two\nrow    three\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.12  Виберіть всі колонки з таблиці orders, але як останню колонку вкажіть функцію unnest, застосовану до колонки product_ids. Нову колонку назвіть product_id. Виведіть лише перші 100 записів результуючої таблиці. Подивіться результат роботи unnest і постарайтеся розібратися, що сталося з вихідною таблицею.\nПоля в результуючій таблиці: creation_time, order_id, product_ids, product_id\n\n\n\n\n\nРішення\n%%sql\nSELECT creation_time,\n       order_id,\n       product_ids,\n       unnest(product_ids) as product_id\nFROM   orders\nLIMIT 100\n\n\n\n\n\n\n\n\n\ncreation_time\norder_id\nproduct_ids\nproduct_id\n\n\n\n\n0\n2022-08-24 01:52:00\n1\n[65, 28]\n65\n\n\n1\n2022-08-24 01:52:00\n1\n[65, 28]\n28\n\n\n2\n2022-08-24 06:37:00\n2\n[35, 30, 42, 34]\n35\n\n\n3\n2022-08-24 06:37:00\n2\n[35, 30, 42, 34]\n30\n\n\n4\n2022-08-24 06:37:00\n2\n[35, 30, 42, 34]\n42\n\n\n...\n...\n...\n...\n...\n\n\n95\n2022-08-24 18:57:00\n30\n[9, 32, 42, 8]\n32\n\n\n96\n2022-08-24 18:57:00\n30\n[9, 32, 42, 8]\n42\n\n\n97\n2022-08-24 18:57:00\n30\n[9, 32, 42, 8]\n8\n\n\n98\n2022-08-24 18:58:00\n31\n[77, 67, 25, 23]\n77\n\n\n99\n2022-08-24 18:58:00\n31\n[77, 67, 25, 23]\n67\n\n\n\n\n100 rows × 4 columns\n\n\n\nА тепер застосуємо unnest для вирішення практичного завдання.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.13  Використовуючи функцію unnest, визначте 10 найпопулярніших товарів у таблиці orders. Найпопулярнішими вважатимемо ті, які зустрічалися в замовленнях найчастіше. Якщо товар зустрічається в одному замовленні кілька разів (тобто було куплено кілька одиниць товару), це теж враховується при підрахунку.\nВиведіть id товарів та скільки разів вони зустрічалися в замовленнях. Нову колонку з кількістю покупок товару назвіть times_purchased.\nПоля у результуючій таблиці: product_id, times_purchased\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цьому завданні необхідно спочатку розгорнути списки з товарами в замовленнях, а потім для кожного товару порахувати, скільки разів він зустрівся в даних. Для визначення найпопулярніших товарів використовуйте оператор LIMIT.\n\n\n\n\nРішення\n%%sql\nSELECT unnest(product_ids) as product_id,\n       count(*) as times_purchased\nFROM   orders\nGROUP BY product_id\nORDER BY times_purchased desc\nLIMIT 10\n\n\nІ насамкінець ще пара завдань зі зірочкою, щоб точно переконатися, що ми розібралися з підзапитами.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.14  З таблиці orders виведіть id та вміст замовлень, які включають хоча б один із п’яти найдорожчих товарів, доступних у нашому сервісі. Результат відсортуйте за зростанням id замовлення.\nПоля у результуючій таблиці: order_id, product_ids\n\n\n\n\n\nРішення\n%%sql\nwith    top_products as (SELECT product_id\n                      FROM   products\n                      ORDER BY price desc limit 5),\n        unnest as (SELECT order_id,\n                   product_ids,\n                   unnest(product_ids) as product_id\n                   FROM   orders)\nSELECT DISTINCT order_id,\n                product_ids\nFROM   unnest\nWHERE  product_id in (SELECT *\n                      FROM   top_products)\nORDER BY order_id\n\n-- або з `exists`\n-- SELECT order_id,\n--        product_ids\n-- FROM   orders\n-- WHERE  exists (\n--  SELECT 1\n--  FROM   unnest(product_ids) as product_id\n--  WHERE  product_id in (\n--      SELECT product_id\n--      FROM   products\n--      ORDER BY price desc\n--      LIMIT 5\n--      )\n-- )\n-- ORDER BY order_id\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 12.15  Порахуйте вік кожного користувача у таблиці users. Вік виміряйте числом повних років, як ми робили на минулих уроках. Вік рахуйте щодо останньої дати в таблиці user_actions. У результаті включіть колонки з id користувача та віком. Для тих користувачів, у яких у таблиці users не вказано дату народження, вкажіть середнє значення віку решти користувачів, округлене до цілого числа. Колонку з віком назвіть age. Результат відсортуйте за зростанням id користувача.\nПоля у результуючій таблиці: user_id, age\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цьому завдання вам доведеться написати кілька підзапитів і, можливо, використовувати табличні вирази. Придадуться функції DATE_PART, AGE та COALESCE. Основна складність полягає у заповненні перепусток середнім значенням — подумайте, як це можна зробити, та побудуйте запит навколо свого підходу.\n\n\n\n\nРішення\n%%sql\n\nwith users_age as (\n    SELECT  user_id,\n            date_part('year', age((SELECT max(time) FROM   user_actions), birth_date)) as age\n    FROM   users)\n\nSELECT user_id,\n       coalesce(age, (SELECT round(avg(age))\n               FROM   users_age)) as age\nFROM   users_age\nORDER BY user_id\n\n-- або без `coalesce`\n-- with max_time as (\n--     SELECT max(time) as max\n--     FROM user_actions \n--     ),\n--     user_age as (\n--     SELECT  user_id,\n--             DATE_PART('year', age((SELECT max FROM max_time), birth_date)) as age\n--     FROM users\n--     ),\n--     user_avg_age as (\n--     SELECT AVG(age)::integer as avg_age\n--     FROM user_age\n--     )\n--     \n-- SELECT  user_id,\n--         case when age IS NULL THEN (SELECT avg_age FROM user_avg_age)\n--     ELSE age\n--     end\n-- FROM user_age\n-- ORDER BY user_id"
  },
  {
    "objectID": "sql_join.html#основні-типи-обєднань-join",
    "href": "sql_join.html#основні-типи-обєднань-join",
    "title": "13  Об’єднання таблиць",
    "section": "13.1 Основні типи об’єднань JOIN",
    "text": "13.1 Основні типи об’єднань JOIN\nОсь ми й підібралися до однієї з найважливіших тем у SQL – об’єднання таблиць.\nSQL-запити дозволяють вибирати та обробляти дані не тільки з однієї таблиці – у цьому ми вже переконалися, коли працювали з підзапитами. Але таблиці можна об’єднувати в один результуючий набір записів, пов’язуючи їх за певними умовами. Це дозволяє робити операція з’єднання JOIN.\nМи розглянемо такі типи з’єднань таблиць:\n\nINNER JOIN\nLEFT/RIGHT JOIN\nFULL JOIN\nCROSS JOIN\n\nОператори об’єднання включаються до розділу FROM запиту. Загалом, незалежно від того, який тип об’єднання використовується, запит на об’єднання таблиць виглядає наступним чином:\nSELECT ...\nFROM table_1 \n     JOIN table_2\n     ON [condition]\nЯк правило (але далеко не завжди), в якості умови [condition], за якою відбувається об’єднання, виступає рівність значень у певних стовпцях. Такі стовпці зазвичай використовуються як ключі із зазначенням id (товару, користувача тощо), тобто значень, за якими можна однозначно ідентифікувати певну сутність:\nSELECT table_1.column_1, table_2.column_2\nFROM table_1 \n     JOIN table_2\n     ON table_1.id = table_2.id\nПри цьому рекомендується до кожної колонка через точку вказувати ім’я таблиці, яка містить цю колонку. Більше того, це стає вже не рекомендацією, а необхідністю, коли імена стовпців у таблицях збігаються - без явного вказівки джерел, база даних не зможе сама визначити, які стовпці та з яких таблиць ви маєте на увазі, і в результаті поверне помилку.\nЯкщо імена таблиць надто довгі, таблицям можна присвоїти аліаси. За цими ж аліасами можна відразу зручно звертатися до колонок:\nSELECT a.column_1, b.column_2\nFROM table_1 a \n     JOIN table_2 b\n     ON a.id = b.id\nЯкщо ім’я поля, за котрим відбувається об’єднання, збігається в обох таблицях (як у прикладах вище), можна використовувати скорочений запис з оператором USING:\nSELECT a.column_1, b.column_2\nFROM table_1 a \n     JOIN table_2 b\n     USING (id)\nПри об’єднанні таблиць можна використовувати підзапити. Їх можна поєднувати з іншими таблицями або одину з одною:\nSELECT ...\nFROM table_1\n     JOIN (\n          SELECT ...\n          FROM table_2\n     ) AS subquery\n    ON table_1.id = subquery.id\n...\n\n\nSELECT ...\nFROM (\n     SELECT ...\n     FROM table_1\n) AS subquery_1\n     JOIN (\n          SELECT ...\n          FROM table_2\n     ) AS subquery_2\n    ON subquery_1.id = subquery_2.id\n..."
  },
  {
    "objectID": "sql_join.html#як-працює-обєднання-таблиць",
    "href": "sql_join.html#як-працює-обєднання-таблиць",
    "title": "13  Об’єднання таблиць",
    "section": "13.2 Як працює об’єднання таблиць",
    "text": "13.2 Як працює об’єднання таблиць\nДобре, із записом у загальному вигляді начебто зрозуміло. Але що насправді відбувається при об’єднанні таблиць? Давайте розбиратися.\nПроцес об’єднання можна подати у вигляді наступної послідовності операцій:\n\nСпочатку кожен рядок першої таблиці зіставляється з кожним рядком другої таблиці, тобто відбувається декартів добуток вдох множин, результатом якого є нове множина, що складається з різних пар вхідних рядків. Наприклад, якщо у одній таблиці було 50 записів, а інший 10, то результаті декартового добутку вийде 500 записів. На іграшковому прикладі це можна уявити так:\n\n\n\n\nРисунок 13.1: Декартів добуток\n\n\n\nПотім для кожного об’єднаного рядка, що складається з двох вхідних таблиць, перевіряється умова з’єднання, вказана після оператора ON.\nПісля цього відповідно до обраного типу об’єднання формується результуюча таблиця.\n\nПри з’єднанні yне двох, а кількох таблиць, операція об’єднання виконується послідовно кілька разів, тобто описаний вище алгоритм запускається стільки разів, скільки зазначено з’єднань. При цьому в цій послідовності при кожному об’єднанні можна використовувати будь-який тип з’єднання (INNER, LEFT тощо).\nДля двох об’єднань запит може виглядати приблизно так:\nSELECT a.column_1, b.column_2\nFROM table_1 a \n     LEFT JOIN table_2 b\n     ON a.user_id = b.user_id\n     JOIN table_3 c\n     ON b.order_id = c.order_id\n...\nПро те, як саме вибір типу JOIN впливає на результат, ми говоритимемо далі.\nЯкщо щось на цьому кроці залишилося незрозумілим, не переживайте. Далі все прояснимо на практичних прикладах!"
  },
  {
    "objectID": "sql_join.html#inner-join",
    "href": "sql_join.html#inner-join",
    "title": "13  Об’єднання таблиць",
    "section": "13.3 INNER JOIN",
    "text": "13.3 INNER JOIN\nПерший тип об’єднання, який ми розглянемо, має назву INNER JOIN. Це оператор внутрішнього об’єднання, якому абсолютно неважливий порядок зазначення таблиць, тобто у таких випадках результат об’єднання буде однаковим:\nSELECT ...\nFROM table_1 INNER JOIN table_2\n     ON [condition]\n...\n\n\nSELECT ...\nFROM table_2 INNER JOIN table_1 \n     ON [condition]\n...\nПри цьому в запиті замість INNER JOIN можна писати просто JOIN - це те саме.\nРезультат об’єднання INNER JOIN формується так:\n\nСпочатку кожен рядок першої таблиці зіставляється з кожним рядком другої таблиці (відбувається декартів добуток).\nПотім для кожного об’єднаного рядка перевіряється умова з’єднання, вказана після оператора ON.\nПісля цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.\n\nТаким чином, в результаті об’єднання INNER JOIN із двох таблиць відкидаються усі рядки, які не пройшли перевірку на відповідність зазначеній умові. От і все!\nРозглянемо наступний приклад:\nSELECT A.id as id,\n       A.city as city,\n       B.country as country\nFROM table_A as A\n     JOIN table_B as B\n     ON A.id = B.id\nВ результаті такого запиту таблиці table_A та table_B будуть об’єднані в таблицю table_С:\n\n\nТаблиця 13.1: Приклад роботи INNER JOIN\n\n\n\n\n(a) Таблиця A\n\n\nid\ncity\n\n\n\n\n01\nLondon\n\n\n02\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\nid\ncountry\n\n\n\n\n02\nUkraine\n\n\n03\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\nid\ncity\ncountry\n\n\n\n\n02\nKyiv\nUkraine\n\n\n\n\n\n\nОскільки таблиці збігаються лише за одним значенням у стовпці id, то в результат буде включено лише одне запис.\nСхематично результат роботи об’єднань прийнято зображувати за допомогою діаграм Венна. Для INNER JOIN наведено на рисунку 13.2.\n\n\n\n\n\nРисунок 13.2: Діаграма Венна: INNER JOIN\n\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про INNER JOIN можна почитати тут.\n\n\nА тепер давайте повернемося до нашої бази даних та вирішимо завдання.\nДля початку спробуйте виконати наступні два запити та порахувати кількість унікальних користувачів у таблицях users та user_actions:\n\n%%sql\nSELECT COUNT(DISTINCT user_id) AS users_count\nFROM users\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n20331\n\n\n\n\n\n\n\n\n%%sql\nSELECT COUNT(DISTINCT user_id) as users_count\nFROM user_actions\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n21401\n\n\n\n\n\n\n\nВи помітите, що у таблиці user_actions унікальних користувачів більше. Це означає, що про частину користувачів ми щось не знаємо — у нас просто немає інформації в таблиці users. Тому в результаті об’єднання цих двох таблиць за допомогою INNER JOIN цю частину користувачів буде виключено з результату.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.1  Об’єднайте таблиці user_actions та users за ключом user_id. У результаті включіть дві колонки з user_id з обох таблиць. Ці дві колонки назвіть відповідно user_id_left та user_id_right. Також у результат включіть колонки order_id, time, action, sex, birth_date. Відсортуйте таблицю за зростанням id користувача (у будь-якій з двох колонок з id).\nПоля в результуючій таблиці: user_id_left, user_id_right, order_id, time, action, sex, birth_date\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що в результаті об’єднання колонки з ключами (у нашому випадку це user_id) не перетворюються на одну загальну колонку, а разом додаються в результуючу таблицю. Тобто скільки було сумарно колонок у двох таблицях, стільки виявиться і в результуючій таблиці після об’єднання. А вже далі в операторі SELECT можна вибирати потрібні та проводити над ними операції.\nЩоб звернутися до колонок з однаковим ім’ям (user_id), що прийшли з різних таблиць, призначте таблицям аліаси та зверніться до колонок через них. Приклад, як це можна зробити:\nSELECT A.id as id_a, \n       B.id as id_b, \n       ...\nFROM table_A as A\n     JOIN table_B as B\n     ON A.id = B.id\n...\n\n\n\n\nРішення\n%%sql\nSELECT a.user_id as user_id_left,\n       b.user_id as user_id_right,\n       order_id,\n       time,\n       action,\n       sex,\n       birth_date\nFROM   user_actions a join users b using (user_id)\nORDER BY user_id_left\n\n\n\n\n\n\n\n\n\nuser_id_left\nuser_id_right\norder_id\ntime\naction\nsex\nbirth_date\n\n\n\n\n0\n1\n1\n1\n2022-08-24 01:52:00\ncreate_order\nfemale\n1991-10-23\n\n\n1\n1\n1\n4683\n2022-08-27 20:56:00\ncreate_order\nfemale\n1991-10-23\n\n\n2\n1\n1\n22901\n2022-09-02 00:58:00\ncreate_order\nfemale\n1991-10-23\n\n\n3\n1\n1\n23149\n2022-09-02 02:36:00\ncreate_order\nfemale\n1991-10-23\n\n\n4\n2\n2\n2\n2022-08-24 06:37:00\ncreate_order\nfemale\n1993-06-18\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n59341\n21399\n21399\n59583\n2022-09-08 23:56:00\ncreate_order\nfemale\n1987-04-27\n\n\n59342\n21399\n21399\n59587\n2022-09-08 23:58:00\ncreate_order\nfemale\n1987-04-27\n\n\n59343\n21400\n21400\n59586\n2022-09-08 23:57:00\ncreate_order\nmale\n1986-12-31\n\n\n59344\n21401\n21401\n59589\n2022-09-08 23:58:00\ncreate_order\nfemale\n1993-03-20\n\n\n59345\n21402\n21402\n59591\n2022-09-08 23:58:00\ncreate_order\nfemale\n1991-05-24\n\n\n\n\n59346 rows × 7 columns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.2  А тепер спробуйте трохи переписати запит із минулого завдання та порахувати кількість унікальних id в об’єднаній таблиці. Тобто знову поєднайте таблиці, але цього разу просто порахуйте унікальні user_id в одній з колонок з id. Виведіть цю кількість як результат. Назвіть колонку з порахованим значенням users_count.\nПоле у результуючій таблиці: users_count\nПісля того, як вирішите завдання, порівняйте отримане значення з кількістю унікальних користувачів у таблицях users та user_actions, яку ми порахували раніше. З яким значенням воно збігається?\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct a.user_id) as users_count\nFROM   user_actions a \n    JOIN users b using (user_id)\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n20331"
  },
  {
    "objectID": "sql_join.html#left-та-right-join",
    "href": "sql_join.html#left-та-right-join",
    "title": "13  Об’єднання таблиць",
    "section": "13.4 LEFT та RIGHT JOIN",
    "text": "13.4 LEFT та RIGHT JOIN\nНаступний тип об’єднання, який ми розглянемо, це LEFT OUTER JOIN (або просто LEFT JOIN).\nLEFT JOIN— це оператор зовнішнього об’єднання, котрій важливий порядок таблиць у запиті, тобто на відміну від INNER JOIN, він не є симетричним.\nТому наступні два записи вже не є еквівалентними:\nSELECT ...\nFROM table_1 LEFT JOIN table_2\n     ON [condition]\n...\n\n\nSELECT ...\nFROM table_2 LEFT JOIN table_1 \n     ON [condition]\n...\nРезультат об’єднання LEFT JOIN формується так:\n\nСпочатку кожен рядок лівої таблиці зіставляється з кожним рядком правої таблиці (відбувається декартів добуток).\nПотім для кожного об’єднаного рядка перевіряється умова з’єднання, вказана після оператора ON.\nПісля цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.\nДалі в результат додаються ті записи з лівої таблиці (увага: тільки з лівої), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля правої таблиці заповнюються значеннями NULL.\n\nЯкщо уважно подивитися на описаний алгоритм, можна зрозуміти, що він легко зводиться до наступної послідовності дій:\n\nСпочатку відповідно до зазначеної умови виконується INNER JOIN першої та другої таблиць.\nПотім до результату додаються ті записи з лівої таблиці (увага: тільки з лівої), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля правої таблиці заповнюються значеннями NULL.\n\nОсь і вся магія!\nОб’єднання RIGHT JOIN працює аналогічним чином, тільки на другому етапі результат INNER JOIN додаються записи не з лівої, а з правої таблиці.\nДавайте знову розглянемо кілька простих прикладів.\nТак буде виглядати запит та його результат із LEFT JOIN:\nSELECT A.id as id,\n       A.city as city,\n       B.country as country\nFROM table_A as A\n     LEFT JOIN table_B as B\n     ON A.id = B.id\n\n\nТаблиця 13.2: Приклад роботи LEFT JOIN\n\n\n\n\n(a) Таблиця A\n\n\nid\ncity\n\n\n\n\n01\nLondon\n\n\n02\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\nid\ncountry\n\n\n\n\n02\nUkraine\n\n\n03\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\nid\ncity\ncountry\n\n\n\n\n01\nLondon\nNULL\n\n\n02\nKyiv\nUkraine\n\n\n\n\n\n\nУ цьому випадку до результату потрапить запис з id 2, оскільки вона є в обох таблицях, а також запис з id 1 з лівої таблиці.\nДіаграма Венна для LEFT JOIN наведено на рис. 13.3.\n\n\n\n\n\nРисунок 13.3: Діаграма Венна: LEFT JOIN\n\n\n\n\nА ось таким вийде результат запиту з RIGHT JOIN:\nSELECT B.id as id,\n       A.city as city,\n       B.country as country\nFROM table_A as A\n     RIGHT JOIN table_B as B\n     ON A.id = B.id\n\n\nТаблиця 13.3: Приклад роботи RIGHT JOIN\n\n\n\n\n(a) Таблиця A\n\n\nid\ncity\n\n\n\n\n01\nLondon\n\n\n02\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\nid\ncountry\n\n\n\n\n02\nUkraine\n\n\n03\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\nid\ncity\ncountry\n\n\n\n\n02\nKyiv\nUkraine\n\n\n03\nNULL\nPoland\n\n\n\n\n\n\nВсе як і у випадку з LEFT JOIN, тільки в результат вже потрапить запис з id 3 з правої таблиці.\nДіаграма Венна для RIGHT JOIN зображена на рис. 13.4\n\n\n\n\n\nРисунок 13.4: Діаграма Венна: LEFT JOIN\n\n\n\n\nА тепер розглянемо на прикладі наших даних.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.3  За допомогою LEFT JOIN об’єднайте таблиці user_actions та users за ключом user_id. Зверніть увагу на порядок таблиць – ліворуч users_actions, праворуч users. У результаті включіть дві колонки з user_id з обох таблиць. Ці дві колонки назвіть відповідно user_id_left та user_id_right. Також у результат увімкніть колонки order_id, time, action, sex, birth_date. Відсортуйте таблицю, що вийшла, за зростанням id користувача (у колонці з лівої таблиці).\nПоля в результуючій таблиці: user_id_left, user_id_right, order_id, time, action, sex, birth_date\nПісля того як розв’яжете завдання, зверніть увагу на колонки з user_id. Чи немає в якомусь із них пропущених значень?\n\n\n\n\n\nРішення\n%%sql\nSELECT a.user_id as user_id_left,\n       b.user_id as user_id_right,\n       order_id,\n       time,\n       action,\n       sex,\n       birth_date\nFROM   user_actions a\n    LEFT JOIN users b using (user_id)\nORDER BY user_id_left\n\n\n\n\n\n\n\n\n\nuser_id_left\nuser_id_right\norder_id\ntime\naction\nsex\nbirth_date\n\n\n\n\n0\n1\n1.0\n1\n2022-08-24 01:52:00\ncreate_order\nfemale\n1991-10-23\n\n\n1\n1\n1.0\n4683\n2022-08-27 20:56:00\ncreate_order\nfemale\n1991-10-23\n\n\n2\n1\n1.0\n22901\n2022-09-02 00:58:00\ncreate_order\nfemale\n1991-10-23\n\n\n3\n1\n1.0\n23149\n2022-09-02 02:36:00\ncreate_order\nfemale\n1991-10-23\n\n\n4\n2\n2.0\n2\n2022-08-24 06:37:00\ncreate_order\nfemale\n1993-06-18\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n62569\n21399\n21399.0\n59583\n2022-09-08 23:56:00\ncreate_order\nfemale\n1987-04-27\n\n\n62570\n21399\n21399.0\n59587\n2022-09-08 23:58:00\ncreate_order\nfemale\n1987-04-27\n\n\n62571\n21400\n21400.0\n59586\n2022-09-08 23:57:00\ncreate_order\nmale\n1986-12-31\n\n\n62572\n21401\n21401.0\n59589\n2022-09-08 23:58:00\ncreate_order\nfemale\n1993-03-20\n\n\n62573\n21402\n21402.0\n59591\n2022-09-08 23:58:00\ncreate_order\nfemale\n1991-05-24\n\n\n\n\n62574 rows × 7 columns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.4  Тепер знову спробуйте трохи переписати запит з минулого завдання та порахуйте кількість унікальних id у колонці user_id, що надійшла з лівої таблиці user_actions. Виведіть цю кількість як результат. Назвіть колонку з порахованим значенням users_count.\nПоле у результуючій таблиці: users_count\nПісля того, як вирішите завдання, порівняйте отримане значення з кількістю унікальних користувачів у таблицях users та user_actions. З яким значенням воно збіглося цього разу?\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct a.user_id) as users_count\nFROM   user_actions a\n    LEFT JOIN users b using (user_id)\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n21401\n\n\n\n\n\n\n\n\nВи могли помітити, що при об’єднанні таблиць user_actions і users за допомогою LEFT JOIN у стовпцях, що прийшли з правої таблиці users, утворилися значення NULL. Якщо не помітили, спробуйте відсортувати об’єднану таблицю по полях users.user_id і users.birth_date.\nЦе саме те, про що ми говорили — при формуванні об’єднаних рядків для тих id з лівої таблиці, яких не було в правій таблиці, поля з правої таблиці були заповнені порожніми значеннями.\nА тепер давайте перевернемо один трюк.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.5  Візьміть запит із завдання 13.3, де ви об’єднували таблиці user_actions і users за допомогою LEFT JOIN, додайте до запиту оператор WHERE і виключіть значення NULL в колонці user_id з правої таблиці. Включіть у результат ті самі колонки і відсортуйте таблицю, що вийшла, за зростанням id користувача в колонці з лівої таблиці.\nПоля в результуючій таблиці: user_id_left, user_id_right, order_id, time, action, sex, birth_date\nПісля того як розв’яжете завдання, спробуйте порівняти це рішення із завданням 13.1. Подумайте, який JOIN ми отримали після всіх маніпуляцій з результатом. Заодно можете порахувати кількість унікальних user_id у запиті з цього завдання, щоб розставити всі крапки над “i”.\n\n\n\n\n\nРішення\n%%sql\nSELECT a.user_id as user_id_left,\n       b.user_id as user_id_right,\n       order_id,\n       time,\n       action,\n       sex,\n       birth_date\nFROM   user_actions a\n    LEFT JOIN users b using (user_id)\nWHERE  b.user_id IS NOT NULL\nORDER BY user_id_left\n\n\n\n\n\n\n\n\n\nuser_id_left\nuser_id_right\norder_id\ntime\naction\nsex\nbirth_date\n\n\n\n\n0\n1\n1\n1\n2022-08-24 01:52:00\ncreate_order\nfemale\n1991-10-23\n\n\n1\n1\n1\n4683\n2022-08-27 20:56:00\ncreate_order\nfemale\n1991-10-23\n\n\n2\n1\n1\n22901\n2022-09-02 00:58:00\ncreate_order\nfemale\n1991-10-23\n\n\n3\n1\n1\n23149\n2022-09-02 02:36:00\ncreate_order\nfemale\n1991-10-23\n\n\n4\n2\n2\n2\n2022-08-24 06:37:00\ncreate_order\nfemale\n1993-06-18\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n59341\n21399\n21399\n59583\n2022-09-08 23:56:00\ncreate_order\nfemale\n1987-04-27\n\n\n59342\n21399\n21399\n59587\n2022-09-08 23:58:00\ncreate_order\nfemale\n1987-04-27\n\n\n59343\n21400\n21400\n59586\n2022-09-08 23:57:00\ncreate_order\nmale\n1986-12-31\n\n\n59344\n21401\n21401\n59589\n2022-09-08 23:58:00\ncreate_order\nfemale\n1993-03-20\n\n\n59345\n21402\n21402\n59591\n2022-09-08 23:58:00\ncreate_order\nfemale\n1991-05-24\n\n\n\n\n59346 rows × 7 columns"
  },
  {
    "objectID": "sql_join.html#full-join",
    "href": "sql_join.html#full-join",
    "title": "13  Об’єднання таблиць",
    "section": "13.5 FULL JOIN",
    "text": "13.5 FULL JOIN\nЩоб краще розібратися з джойнами, розглянемо ще один тип об’єднання таблиць — FULL OUTER JOIN або просто FULL JOIN. Це оператор повного зовнішнього об’єднання, для якого, як і INNER JOIN, неважливий порядок вказівки таблиць. Проте працює він зовсім інакше.\nЗапит із FULL OUTER JOIN виглядає приблизно так:\nSELECT ...\nFROM table_1 FULL JOIN table_2\n     ON [condition]\n...\n\n\nSELECT ...\nFROM table_2 FULL JOIN table_1 \n     ON [condition]\n...\nРезультат об’єднання FULL JOIN формується так:\n\nСпочатку кожен рядок лівої таблиці зіставляється з кожним рядком правої таблиці (відбувається декартів добуток).\nПотім для кожного об’єднаного рядка перевіряється умова об’єднання, вказана після оператора ON.\nПісля цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.\nДалі в результат додаються ті записи з лівої та правої таблиць (увага: з обох таблиць), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля з іншої таблиці (для лівої це поля з правої, для правої це поля з лівої) заповнюються значеннями NULL.\n\nЦей алгоритм можна звести до наступної послідовності дій:\n\nСпочатку відповідно до зазначеної умови виконується INNER JOIN лівої та правої таблиць.\nДалі в результат додаються ті записи з лівої та правої таблиць (увага: з обох таблиць), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля з іншої таблиці (для лівої це поля з правої, для правої це поля з лівої) заповнюються значеннями NULL.\n\nРозглянемо найпростіший приклад.\nТак буде виглядати запит та його результат з FULL JOIN:\nSELECT A.id as id,\n       A.city as city,\n       B.country as country\nFROM table_A as A\n     FULL JOIN table_B as B\n     ON A.id = B.id\n\n\nТаблиця 13.4: Приклад роботи FULL JOIN\n\n\n\n\n(a) Таблиця A\n\n\nid\ncity\n\n\n\n\n01\nLondon\n\n\n02\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\nid\ncountry\n\n\n\n\n02\nUkraine\n\n\n03\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\nid\ncity\ncountry\n\n\n\n\n01\nLondon\nNULL\n\n\n02\nKyiv\nUkraine\n\n\n03\nNULL\nPoland\n\n\n\n\n\n\nВ результат потрапив спільний запис з id 2, а також всі записи, до яких не було знайдено відповідності з інших таблиць. Усі невідповідності були заповнені порожніми значеннями.\nДіграма Венна для FULL JOIN наведено на рисунку 13.5.\n\n\n\n\n\nРисунок 13.5: Діаграма Венна: FULL JOIN\n\n\n\n\nА тепер розберемося з FULL JOIN на прикладі нашої бази даних.\nУ нас є дві таблиці з датами народження користувачів та кур’єрів – users та couriers. Можна припустити, що в кожній таблиці у колонці birth_date є якісь дати, яких немає в іншій таблиці. Тобто такі дати, в які народився хтось із кур’єрів, але не народився жоден користувач, і навпаки. Ну що ж, спробуємо перевірити цю гіпотезу.\nДля початку згрупуємо дві таблиці по колонці birth_date і порахуємо скільки користувачів/кур’єрів народилися в кожен з днів. Для цього можете виконати такий запит:\n\n%%sql\nSELECT birth_date, COUNT(user_id) AS users_count\nFROM users\nWHERE birth_date IS NOT NULL\nGROUP BY birth_date\n\n\n\n\n\n\n\n\nbirth_date\nusers_count\n\n\n\n\n0\n1991-05-24\n11\n\n\n1\n1994-07-21\n6\n\n\n2\n1992-01-09\n13\n\n\n3\n1997-05-05\n3\n\n\n4\n1990-08-16\n5\n\n\n...\n...\n...\n\n\n4471\n1999-12-01\n1\n\n\n4472\n1998-12-05\n1\n\n\n4473\n1987-09-24\n1\n\n\n4474\n1998-01-02\n1\n\n\n4475\n1988-07-27\n1\n\n\n\n\n4476 rows × 2 columns\n\n\n\n\n%%sql\nSELECT birth_date, COUNT(courier_id) AS couriers_count\nFROM couriers\nWHERE birth_date IS NOT NULL\nGROUP BY birth_date\n\n\n\n\n\n\n\n\nbirth_date\ncouriers_count\n\n\n\n\n0\n1981-06-11\n1\n\n\n1\n1991-06-27\n2\n\n\n2\n1994-05-04\n2\n\n\n3\n1999-06-02\n2\n\n\n4\n1998-12-22\n2\n\n\n...\n...\n...\n\n\n2169\n1999-09-19\n1\n\n\n2170\n1990-06-23\n1\n\n\n2171\n1991-02-21\n1\n\n\n2172\n1990-06-04\n1\n\n\n2173\n1997-04-15\n1\n\n\n\n\n2174 rows × 2 columns\n\n\n\nУ результаті ви отримаєте дві таблиці з унікальними датами і кількістю людей, що народилися у кожен з днів. Давайте їх об’єднаємо.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.6  За допомогою FULL JOIN об’єднайте по ключу birth_date таблиці, отримані в результаті вищезазначених запитів (тобто об’єднайте один з одним два підзапити). Не потрібно змінювати їх, просто додайте потрібний JOIN.\nУ результат включіть дві колонки з birth_date з обох таблиць. Ці дві колонки назвіть відповідно users_birth_date та couriers_birth_date. Також включіть у результат колонки з кількістю користувачів та кур’єрів - users_count та couriers_count.\nВідсортуйте таблицю спочатку по колонці users_birth_date за зростанням, потім по колонці couriers_birth_date - теж за зростанням.\nПоля в результуючій таблиці: users_birth_date, users_count, couriers_birth_date, couriers_count\nПісля того як розв’яжете завдання, проаналізуйте результат. Зверніть увагу на пропущені значення у колонках з датами народження кур’єрів та користувачів. Чи підтвердилося наше припущення?\n\n\n\n\n\nРішення\n%%sql\nWITH a AS (\n    SELECT birth_date, COUNT(user_id) AS users_count\n    FROM users\n    WHERE birth_date IS NOT NULL\n    GROUP BY birth_date\n    ),\n    b AS (\n    SELECT birth_date, COUNT(courier_id) AS couriers_count\n    FROM couriers\n    WHERE birth_date IS NOT NULL\n    GROUP BY birth_date\n    )\n    \nSELECT \n    a.birth_date AS users_birth_date,\n    a.users_count,\n    b.birth_date AS couriers_birth_date,\n    b.couriers_count\nFROM a\nFULL JOIN b on a.birth_date = b.birth_date\nORDER BY users_birth_date, couriers_birth_date"
  },
  {
    "objectID": "sql_join.html#операції-над-множинами",
    "href": "sql_join.html#операції-над-множинами",
    "title": "13  Об’єднання таблиць",
    "section": "13.6 Операції над множинами",
    "text": "13.6 Операції над множинами\nЧудово. Запит із FULL JOIN ми начебто склали, але як нам тепер визначити, що кількість записів в отриманій таблиці збігається із загальним числом унікальних дат у двох таблицях — users та couriers? Адже саме стільки рядків ми й очікували отримати, правда?\nПеревірити себе нам допоможуть операції з множинами. У мові SQL їх три:\n\nUNION\nEXCEPT\nINTERSECT\n\nВони дозволяють комбінувати результати кількох запитів один з одним та отримувати один загальний результат. Причому саме комбінувати, а не об’єднувати, як це роблять джойни.\nЦю різницю важливо розуміти: в операціях з множинами не відбувається суміщення стовпців з двох таблиць - база даних просто відбирає рядки з таблиць, що задовольняють типу операції, і додає їх до загального результату.\nОперації над множинами мають наступний синтаксис:\nSELECT column_1, column_2\nFROM table_1\nUNION\nSELECT column_1, column_2\nFROM table_2\n\n\nSELECT column_1, column_2\nFROM table_1\nEXCEPT\nSELECT column_1, column_2\nFROM table_2\n\n\nSELECT column_1, column_2\nFROM table_1\nINTERSECT\nSELECT column_1, column_2\nFROM table_2\n\nОперація EXCEPT повертає всі записи, які є у першому запиті, але відсутні у другому (різниця множин).\nОперація INTERSECT повертає всі записи, які є і в першому, і в другому запиті (перетин множин).\nОперація UNION поєднує записи із двох запитів в один загальний результат (об’єднання множин).\n\nПри цьому за замовчанням ці операції виключають із результату рядки-дублікати. Щоб дублікати не виключалися із результату, необхідно після імені операції вказати ключове слово ALL. Наприклад, так:\nSELECT column_1, column_2\nFROM table_1\nUNION ALL\nSELECT column_1, column_2\nFROM table_2\nДіаграми Венна для операцій над множинами виглядають зображено на рисунку 13.6.\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n(c)\n\n\n\n\nРисунок 13.6: Операції над множинами: діаграма Венна\n\n\nДля роботи цих операцій необхідно, щоб виконувались такі умови:\n\nУ кожному запиті SELECT має бути однакова кількість стовпців.\nТипи даних у стовпцях мають бути сумісні.\n\nПри цьому кількість стовпців в операторі SELECT може бути будь-якою — головне, щоб вона була однаковою.\nНаприклад, наступний запит поверне унікальні ID користувачів, які щось замовляли в нашому сервісі, але яких з якоїсь причини немає в таблиці users:\n\n%%sql\nSELECT user_id\nFROM user_actions\nEXCEPT\nSELECT user_id\nFROM users\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n54\n\n\n1\n86\n\n\n2\n103\n\n\n3\n116\n\n\n4\n120\n\n\n...\n...\n\n\n1065\n18352\n\n\n1066\n12713\n\n\n1067\n18246\n\n\n1068\n18015\n\n\n1069\n20398\n\n\n\n\n1070 rows × 1 columns\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про операції над множинами можна прочитати у документації DuckDB.\nПро теорію множин можна почитати у статті на Вікіпедії.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.7  Поєднайте два наступні запити один з одним так, щоб на виході вийшов набір унікальних дат із таблиць users та couriers:\nSELECT birth_date\nFROM users\nWHERE birth_date IS NOT NULL\nSELECT birth_date\nFROM couriers\nWHERE birth_date IS NOT NULL\nПомістіть у підзапит набраний після об’єднання набір дат і порахуйте їх кількість. Назвіть колонку з числом дат dates_count.\nПоле у результуючій таблиці: dates_count\nПісля того, як вирішите задачу, порівняйте отримане число дат з кількістю рядків у таблиці, яку ми отримали в минулому завданні. Чи збіглися ці значення?\n\n\n\n\n\nРішення\n%%sql\nWITH sub_union as (\n    SELECT birth_date\n    FROM users\n    WHERE birth_date IS NOT NULL\n    UNION\n    SELECT birth_date\n    FROM couriers\n    WHERE birth_date IS NOT NULL\n    )\n    \nSELECT COUNT(DISTINCT birth_date) as dates_count\nFROM sub_union\n\n\n\n\n\n\n\n\n\ndates_count"
  },
  {
    "objectID": "sql_join.html#cross-join",
    "href": "sql_join.html#cross-join",
    "title": "13  Об’єднання таблиць",
    "section": "13.7 CROSS JOIN",
    "text": "13.7 CROSS JOIN\nНасправді CROSS JOIN - це просто декартів добуток двох таблиць, тобто саме те, що відбувається на першому етапі решти джойнів. Важлива відмінність у синтаксисі CROSS JOIN полягає в тому, що для нього не потрібно вказувати умову для об’єднання:\nSELECT column_1, column_2, ...\nFROM table_1\n     CROSS JOIN table_2\nТой самий результат можна отримати за допомогою наступного запису:\nSELECT column_1, column_2, ...\nFROM table_1, table_2\nРозглянемо простий приклад:\nSELECT\n    A.city as city,\n    B.country as country\nFROM table_A as A\n     CROSS JOIN table_B as B\nЗа допомогою CROSS JOIN ми отримуємо всі можливі комбінації значень із першої та другої таблиці:\n\n\nТаблиця 13.5: Приклад роботи FULL JOIN\n\n\n\n\n(a) Таблиця A\n\n\ncity\n\n\n\n\nLondon\n\n\nKyiv\n\n\n\n\n\n\n(b) Таблиця B\n\n\ncountry\n\n\n\n\nUK\n\n\nUkraine\n\n\nPoland\n\n\n\n\n\n\n\n\n(c) Таблиця C\n\n\ncity\ncountry\n\n\n\n\nLondon\nUK\n\n\nLondon\nUkraine\n\n\nLondon\nPoland\n\n\nKyiv\nUK\n\n\nKyiv\nUkraine\n\n\nKyiv\nPoland\n\n\n\n\n\n\nА теперь давайте решим простую задачу.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.8  З таблиці users відберіть id перших 100 користувачів (просто виберіть перші 100 записів, використовуючи простий LIMIT) і за допомогою CROSS JOIN поєднайте їх з усіма найменуваннями товарів з таблиці products. Виведіть дві колонки - ID користувача та найменування товару. Результат відсортуйте спочатку за зростанням id користувача, потім на ім’я товару — теж за зростанням.\nПоля у результуючій таблиці: user_id, name\nПісля того як вирішите задачу, подивіться скільки спочатку було рядків у кожній таблиці і порівняйте з тим, скільки їх вийшло після об’єднання.\n\n\n\n\n\nРішення\n%%sql\nwith user_100 as (\n    SELECT user_id\n    from users\n    LIMIT 100\n    )\n\nSELECT  user_100.user_id,\n        products.name\nFROM user_100\nCROSS JOIN products\nORDER BY user_id, name\n\n\n\nЗдається, ми розглянули достатньо прикладів об’єднання таблиць. Час переходити до практики!\nПроведемо невелику аналітику нашого сервісу і порахуємо, скільки в середньому товарів замовляє кожен користувач.\nЗавдання може звучати досить абстрактно мовою бізнесу, але не переживайте! Вирішуватимемо її поетапно, поступово перекладаючи її на мову SQL.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.9  Спочатку об’єднайте таблиці user_actions і orders — це ви вже вмієте робити. Як ключ використовуйте поле order_id. Виведіть id користувачів та замовлень, а також список товарів у замовленні. Відсортуйте таблицю за id користувача за зростанням, потім за id замовлення теж за зростанням.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, order_id, product_ids\nПояснення: перед тим, як об’єднувати таблиці, подумайте, який тип з’єднання можна використовувати. Спробуйте різні способи та порівняйте результати.\n\n\n\n\n\nРішення\n%%sql\nSELECT  user_id,\n        order_id,\n        product_ids\nFROM user_actions\nLEFT JOIN orders using (order_id)\nORDER BY user_id, order_id\nLIMIT 1000\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\nproduct_ids\n\n\n\n\n0\n1\n1\n[65, 28]\n\n\n1\n1\n4683\n[1, 15, 40]\n\n\n2\n1\n22901\n[65, 72, 83]\n\n\n3\n1\n23149\n[6, 84, 32]\n\n\n4\n2\n2\n[35, 30, 42, 34]\n\n\n...\n...\n...\n...\n\n\n995\n227\n12572\n[76, 47, 37, 31]\n\n\n996\n227\n12578\n[58]\n\n\n997\n227\n23268\n[74, 25, 67]\n\n\n998\n227\n25873\n[74, 72, 46]\n\n\n999\n227\n25885\n[40, 58, 83]\n\n\n\n\n1000 rows × 3 columns\n\n\n\n\nТепер трохи уточнимо наш запит, оскільки нас цікавлять не всі замовлення з таблиці user_actions, а лише ті, які не були скасовані користувачами, причому унікальні.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.10  Знову об’єднайте таблиці user_actions та orders, але тепер залиште лише унікальні нескасовані замовлення (ми робили схожий запит у завданні 12.7). Інші умови завдання ті самі: вивести ID користувачів та замовлень, а також список товарів у замовленні. Відсортуйте таблицю за id користувача за зростанням, потім за id замовлення теж за зростанням.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, order_id, product_ids\n\n\n\n\n\nРішення\n%%sql\nSELECT  user_id,\n        order_id,\n        product_ids\nFROM user_actions\nLEFT JOIN orders using (order_id)\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order')\nORDER BY user_id, order_id\nLIMIT 1000\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\nproduct_ids\n\n\n\n\n0\n1\n1\n[65, 28]\n\n\n1\n1\n4683\n[1, 15, 40]\n\n\n2\n1\n22901\n[65, 72, 83]\n\n\n3\n1\n23149\n[6, 84, 32]\n\n\n4\n2\n2\n[35, 30, 42, 34]\n\n\n...\n...\n...\n...\n\n\n995\n248\n13935\n[75, 28, 86]\n\n\n996\n248\n15518\n[67, 79, 63]\n\n\n997\n249\n287\n[26, 74, 53, 23]\n\n\n998\n249\n758\n[45, 57, 78]\n\n\n999\n249\n7347\n[30, 14, 6, 9]\n\n\n\n\n1000 rows × 3 columns\n\n\n\n\nЗдається, все готове для того, щоб для кожного користувача порахувати середню кількість товарів у замовленні.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.11  Використовуючи запит із попереднього завдання, порахуйте, скільки в середньому товарів замовляє кожен користувач. Виведіть id користувача та середню кількість товарів у замовленні. Середнє значення округліть до двох знаків після коми. Колонку обчисленими значеннями назвіть avg_order_size. Результат виконання запиту відсортуйте за зростанням ID користувача.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: user_id, avg_order_size\nПояснення: для вирішення вам знадобиться функція array_length. Ми розглядали її у завданні 10.9.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nЩоб вирішити завдання, достатньо взяти запит з минулого завдання, порахувати розмір нескасованих замовлень, а потім зробити групування за користувачами і для кожного з них порахувати середній розмір замовлення.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nwith user_order_prod as (\n    SELECT  user_id,\n            order_id,\n            product_ids\n    FROM user_actions\n    LEFT JOIN orders using (order_id)\n    WHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order')\n    )\n    \nSELECT  user_id,\n        ROUND(AVG(array_length(product_ids, 1)), 2) as avg_order_size\nFROM user_order_prod\nGROUP BY user_id\nORDER BY user_id\nLIMIT 1000\n\n-- або\n-- SELECT user_id,\n--        round(avg(array_length(product_ids, 1)), 2) as avg_order_size\n-- FROM   (SELECT user_id,\n--                order_id\n--         FROM   user_actions\n--         WHERE  order_id not in (SELECT order_id\n--                                 FROM   user_actions\n--                                 WHERE  action = 'cancel_order')) t1\n--     LEFT JOIN orders using(order_id)\n-- GROUP BY user_id\n-- ORDER BY user_id limit 1000\n\n\n\nА що якби ми захотіли зробити докладнішу аналітику і, наприклад, порахувати середню вартість замовлення (середній чек) кожного клієнта? Для цього нам би знадобилася інформація про вартість кожного окремого замовлення. Давайте проведемо такі розрахунки.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.12  Для початку до таблиці із замовленнями (orders) застосуйте функцію unnest, як ми робили завданні 12.12. Колонку із id товарів назвіть product_id. Потім до розширеної таблиці, що утворилася, за ключом product_id додайте інформацію про ціни на товари (з таблиці products). Повинна вийти таблиця із замовленнями, товарами всередині кожного замовлення та цінами на ці товари. Виведіть колонки з id замовлення, id товару та ціною товару. Результат відсортуйте спочатку за зростанням id замовлення, потім за зростанням id товару.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: order_id, product_id, price\n\n\n\n\n\nРішення\n%%sql\nwith unnest_id as (SELECT order_id,\n                          unnest(orders.product_ids) as product_id\n                   FROM   orders)\nSELECT order_id,\n       product_id,\n       products.price\nFROM   unnest_id\n    LEFT JOIN products using (product_id)\nORDER BY order_id, product_id limit 1000\n\n\n\nМаючи таблицю із замовленнями, що містить список товарів та їх ціни, тепер можна легко порахувати вартість кожного замовлення.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.13  Використовуючи запит із завдання 13.12, розрахуйте сумарну вартість кожного замовлення. Виведіть колонки з id замовлень та їх вартістю. Колонку із вартістю замовлення назвіть order_price. Результат відсортуйте за зростанням id замовлення.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: order_id, order_price\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       sum(price) as order_price\nFROM   (SELECT order_id,\n               product_ids,\n               unnest(product_ids) as product_id\n        FROM   orders) t1\n    LEFT JOIN products using(product_id)\nGROUP BY order_id\nORDER BY order_id limit 1000\n\n-- або\n-- with    unnest_id as (\n--             SELECT  order_id,\n--                     unnest(orders.product_ids) as product_id\n--             FROM   orders\n--         ),\n--         price_tbl as (\n--             SELECT  order_id,\n--                     product_id,\n--                     products.price\n--             FROM   unnest_id\n--             LEFT JOIN products using (product_id)\n--                       )\n        \n-- SELECT  order_id,\n--         sum(price) as order_price\n-- FROM price_tbl\n-- GROUP BY order_id\n-- ORDER BY order_id\n-- LIMIT 1000\n\n\n\n\n\n\n\n\n\norder_id\norder_price\n\n\n\n\n0\n1\n175.0\n\n\n1\n2\n394.0\n\n\n2\n3\n493.0\n\n\n3\n4\n156.0\n\n\n4\n5\n51.0\n\n\n...\n...\n...\n\n\n995\n996\n295.0\n\n\n996\n997\n150.0\n\n\n997\n998\n358.0\n\n\n998\n999\n289.0\n\n\n999\n1000\n69.0\n\n\n\n\n1000 rows × 2 columns\n\n\n\n\nОсь тепер у нас є все необхідне, щоб зробити наш перший серйозний аналітичний запит і порахувати різні метрики користувача!\nДавайте об’єднаємо в один запит дані про кількість товарів на замовлення наших користувачів з інформацією про вартість кожного замовлення, а потім розрахуємо кілька корисних показників.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.14  Використовуючи результати попередніх завдань (завд. 13.13 та завд. 13.11), напишіть запит для отримання інформації для кожного користувача:\n\nзагальна кількість замовлень - колонку назвіть orders_count\nсередня кількість товарів у замовленні — avg_order_size\nсумарну вартість усіх покупок - sum_order_value\nсередня вартість замовлення - avg_order_value\nмінімальну вартість замовлення - min_order_value\nмаксимальну вартість замовлення - max_order_value\n\nОтриманий результат відсортуйте за зростанням id користувача.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПам’ятайте, що в розрахунках ми, як і раніше, враховуємо лише нескасовані замовлення. При розрахунку середніх значень округляйте їх до двох знаків після коми.\nПоля в результуючій таблиці: user_id, orders_count, avg_order_size, sum_order_value, avg_order_value, min_order_value, max_order_value\n\n\n\n\n\nРішення\n%%sql\nwith    unnest_id as (\n            SELECT  order_id,\n                    unnest(orders.product_ids) as product_id\n            FROM   orders\n            ),\n        price_tbl as (\n            SELECT  order_id,\n                    product_id,\n                    products.price\n            FROM   unnest_id\n            LEFT JOIN products using (product_id)\n            ),\n        user_order_prod as (\n            SELECT  user_id,\n                    order_id,\n                    product_ids\n            FROM   user_actions\n            LEFT JOIN orders using (order_id)\n            WHERE  order_id in (\n                SELECT order_id\n                FROM   courier_actions\n                WHERE  action = 'deliver_order')\n            ),\n        order_size as (\n            SELECT user_id,\n                    order_id,\n                    round(avg(array_length(product_ids, 1)), 2) as avg_order_size\n            FROM   user_order_prod\n            GROUP BY user_id, order_id\n            ),\n        order_price as (\n            SELECT  order_id,\n                    sum(price) as order_price\n            FROM   price_tbl\n            GROUP BY order_id\n            )\n            \nSELECT  user_id,\n        COUNT(user_id) as orders_count,\n        ROUND(AVG(avg_order_size), 2) as avg_order_size,\n        SUM(order_price) as sum_order_value,\n        ROUND(AVG(order_price), 2) as avg_order_value,\n        MIN(order_price) as min_order_value,\n        MAX(order_price) as max_order_value\nFROM order_size\nLEFT JOIN order_price using (order_id)\nGROUP BY user_id\nORDER BY user_id\nLIMIT 1000\n\n\n\nЗ великим завданням ми впоралися – тепер давайте вирішимо кілька додаткових завдань на закріплення нових знань.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.15  За таблицями courier_actions, orders та products визначте 10 найпопулярніших товарів, доставлених у вересні 2022 року. Найпопулярнішими товарами вважатимемо ті, що зустрічалися в замовленнях найчастіше. Якщо товар зустрічається в одному замовленні кілька разів (було куплено кілька одиниць товару), то при підрахунку враховуємо лише одну одиницю товару. Виведіть найменування товарів та скільки разів вони зустрічалися в замовленнях. Нову колонку з кількістю покупок товару назвіть times_purchased.\nПоля у результуючій таблиці: name, times_purchased\n\n\n\n\n\nРішення\n%%sql\nSELECT name,\n       count(product_id) as times_purchased\nFROM   (SELECT order_id,\n               product_id,\n               name\n        FROM   (SELECT DISTINCT order_id,\n                                unnest(product_ids) as product_id\n                FROM   orders\n                    LEFT JOIN courier_actions using (order_id)\n                WHERE  action = 'deliver_order'\n                   and date_part('month', time) = 9\n                   and date_part('year', time) = 2022) t1\n            LEFT JOIN products using (product_id)) t2\nGROUP BY name\nORDER BY times_purchased desc limit 10\n\n\n\n\n\n\n\n\n\nname\ntimes_purchased\n\n\n\n\n0\nbananas\n2632\n\n\n1\npasta\n2623\n\n\n2\nlong loaf\n2622\n\n\n3\nsugar\n2617\n\n\n4\nbread\n2605\n\n\n5\nchicken\n2585\n\n\n6\nblack tea bags\n2581\n\n\n7\nmilk\n2564\n\n\n8\ninstant coffee\n2460\n\n\n9\napple juice\n2373\n\n\n\n\n\n\n\n\nРаніше ми вважали рахували скасованих замовлень (cancel_rate) для кожного користувача. Тепер у нашому розпорядженні є всі необхідні знання, щоб порахувати цей показник у розрізі статі.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.16  Візьміть за основу запит із завдання 11.16 і підтягніть до нього з таблиці users дані про поле користувачів таким чином, щоб усі користувачі з таблиці users_actions залишилися в результаті. Потім порахуйте середнє значення cancel_rate для кожної статі, заокругливши його до трьох знаків після коми. Колонку з порахованим середнім значенням назвіть avg_cancel_rate.\nПам’ятайте про відсутність інформації про поле деяких користувачів після об’єднання таблиць, тому що не всі користувачі таблиці user_action є в таблиці users. Для цієї групи також порахуйте cancel_rate і в результуючій таблиці для порожнього значення в колонці з підлогою вкажіть ‘unknown’ (без лапок). Можливо, для цього доведеться згадати, як працює COALESCE.\nРезультат відсортуйте по колонці зі статтю користувача за зростанням.\nПоля у результуючій таблиці: sex, avg_cancel_rate\n\n\n\n\n\n\nПояснення\n\n\n\n\n\nМетрику cancel_rate у розрізі статі можна порахувати різними способами, у цій задачі пропонуємо наступний алгоритм:\n\nСпочатку порахуйте cancel_rate для кожного користувача.\nПотім додайте інформацію про поле користувачів.\nПотім розрахуйте avg_cancel_rate для кожної статі та округліть значення до трьох знаків після коми.\n\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT coalesce(sex, 'unknown') as sex,\n       round(avg(cancel_rate), 3) as avg_cancel_rate\nFROM   (SELECT user_id,\n               sex,\n               count(distinct order_id) filter (WHERE action = 'cancel_order')::decimal / count(distinct order_id) as cancel_rate\n        FROM   user_actions\n            LEFT JOIN users using(user_id)\n        GROUP BY user_id, sex\n        ORDER BY cancel_rate desc) t\nGROUP BY sex\nORDER BY sex\n\n\n\n\n\n\n\n\n\nsex\navg_cancel_rate\n\n\n\n\n0\nfemale\n0.051\n\n\n1\nmale\n0.048\n\n\n2\nunknown\n0.046\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.17  За таблицями orders та courier_actions визначте id десяти замовлень, які доставляли найдовше.\nПоле у результуючій таблиці: order_id\n\n\n\n\n\n\nПояснення\n\n\n\n\n\nДля розрахунку часу, витраченого на доставку замовлення, використовуйте інформацію про час доставки та час створення замовлення - з даними у форматі часу можна також проводити арифметичні операції (наприклад, обчислювати різницю між ними). Зауважте, що колонки з цими даними знаходяться в різних таблицях. Для визначення найдовших замовлень використовуйте оператор LIMIT.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id\nFROM   (SELECT order_id,\n               time - creation_time as time_to_deliv\n        FROM   orders\n            LEFT JOIN courier_actions using (order_id)\n        WHERE  action = 'deliver_order'\n        ORDER BY time_to_deliv desc) as t1 limit 10\n\n-- або\n-- SELECT order_id\n-- FROM   (SELECT order_id,\n--                time - creation_time as time_to_deliv\n--         FROM   orders\n--             LEFT JOIN courier_actions using (order_id)\n--         WHERE  action = 'deliver_order'\n--         ORDER BY time_to_deliv desc) as t1 limit 10\n\n\n\n\n\n\n\n\n\norder_id\n\n\n\n\n0\n22408\n\n\n1\n58491\n\n\n2\n1155\n\n\n3\n1464\n\n\n4\n4788\n\n\n5\n11064\n\n\n6\n12150\n\n\n7\n14647\n\n\n8\n18991\n\n\n9\n22907"
  },
  {
    "objectID": "sql_join.html#збираємо-списки-array_agg",
    "href": "sql_join.html#збираємо-списки-array_agg",
    "title": "13  Об’єднання таблиць",
    "section": "13.8 Збираємо списки: array_agg()",
    "text": "13.8 Збираємо списки: array_agg()\nДнями менеджер знову звернувся до вас із завданням: попросив зробити вивантаження з таблиці orders з усіма замовленнями та їх вмістом. З листування ви так і не зрозуміли, навіщо всі ці дані, але завдання зробили: натиснули SELECT * і відправили йому excel-файл із замовленнями. Наступного ранку з’ясувалося, що такі дані його не влаштовують, оскільки він не розуміє, що це за списки з наборами чисел. Справді, цей момент ви не врахували. Давайте виправлятися!\narray_agg — це просунута агрегатна функція, яка збирає всі значення в зазначеному стовпці в єдиний список (ARRAY). По суті array_agg - це операція, зворотна unnest, її синтаксис нічим не відрізняється від синтаксису інших агрегатних функцій:\nSELECT column_1, array_agg(column_2) AS new_array\nFROM table\nGROUP BY column_1\nПеред тим, як вирішувати завдання, спробуйте спочатку виконати просту вправу: розгорніть списки з id товарів, помістіть результат у підзапит, а потім відразу ж поверніть все назад у списки за допомогою array_agg. Алгоритм вирішення цього завдання приблизно такий самий.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.18  Змініть списки з id товарів з таблиці orders на списки з найменуваннями товарів. Назви візьміть з таблиці products. Назвіть колонку з новими списками найменувань product_names.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля у результуючій таблиці: order_id, product_names\n\n\n\n\n\n\nПояснення\n\n\n\n\n\nДля вирішення задачі вам потрібно зробити unnest колонки product_ids, об’єднати проміжний результат з таблицею products для отримання найменувань товарів, а потім зробити групування з агрегацією в список найменувань.\nДля того, щоб зробити агрегацію значень у колонці до списку, необхідно скористатися функцією array_agg.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       array_agg(name) as product_names\nFROM   (SELECT order_id,\n               unnest(product_ids) as product_id\n        FROM   orders) t join products using(product_id)\nGROUP BY order_id limit 1000\n\n\n\n\n\n\n\n\n\norder_id\nproduct_names\n\n\n\n\n0\n11\n[tangerines, mayonnaise, pork]\n\n\n1\n16\n[apples, waffles, cookie]\n\n\n2\n26\n[salted fish, mutton, pears, black leaf tea]\n\n\n3\n55\n[bread, sour cream, kvass]\n\n\n4\n67\n[milk, black leaf tea, lollipops]\n\n\n...\n...\n...\n\n\n995\n18270\n[bread, cookie, chicken]\n\n\n996\n18311\n[multifruit juice, salt, lemonade]\n\n\n997\n18324\n[black leaf tea, peas]\n\n\n998\n18335\n[ivan-tea in bags, waffles, salt]\n\n\n999\n18340\n[instant coffee, still water]\n\n\n\n\n1000 rows × 2 columns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.19  З’ясуйте, хто замовляв та доставляв найбільші замовлення. Найбільшими вважають замовлення з найбільшою кількістю товарів.\nВиведіть id замовлення, id користувача та id кур’єра. Також в окремих колонках вкажіть вік користувача та вік кур’єра. Вік виміряйте числом повних років, як ми робили раніше. Рахуйте його щодо останньої дати в таблиці user_actions як для користувачів, так і для кур’єрів. Колонки з віком назвіть user_age та courier_age. Результат відсортуйте за зростанням id замовлення.\nПоля в результуючій таблиці: order_id, user_id, user_age, courier_id, courier_age\n\n\n\n\n\nРішення\n%%sql\nwith order_id_large_size as (SELECT order_id\n                             FROM   orders\n                             WHERE  array_length(product_ids, 1) = (SELECT max(array_length(product_ids, 1))\n                                                                    FROM   orders))\nSELECT DISTINCT order_id,\n                user_id,\n                date_part('year', age((SELECT max(time)\n                       FROM   user_actions), users.birth_date))::integer as user_age, courier_id, date_part('year', age((SELECT max(time)\n                                                                                                  FROM   user_actions), couriers.birth_date))::integer as courier_age\nFROM   (SELECT order_id,\n               user_id\n        FROM   user_actions\n        WHERE  order_id in (SELECT *\n                            FROM   order_id_large_size)) t1\n    LEFT JOIN (SELECT order_id,\n                      courier_id\n               FROM   courier_actions\n               WHERE  order_id in (SELECT *\n                                   FROM   order_id_large_size)) t2 using(order_id)\n    LEFT JOIN users using(user_id)\n    LEFT JOIN couriers using(courier_id)\nORDER BY order_id"
  },
  {
    "objectID": "sql_join.html#self-join",
    "href": "sql_join.html#self-join",
    "title": "13  Об’єднання таблиць",
    "section": "13.9 SELF JOIN",
    "text": "13.9 SELF JOIN\nІ насамкінець розглянемо ще один тип об’єднання таблиць, який теж потрібно знати. Це так званий SELF JOIN.\nSELF JOIN - не що інше, як об’єднання таблиці із самою собою. Так, така операція також можлива і, більше того, часто буває корисною.\nПриєднати таблицю до себе можна з допомогою будь-якого розглянутого раніше типу джойна:\nSELECT ...\nFROM table JOIN table\n     ON [condition]\n\n\nSELECT ...\nFROM table LEFT JOIN table\n     ON [condition]\n\n\nSELECT ...\nFROM table FULL JOIN table\n     ON [condition]\n\n\nSELECT ...\nFROM table CROSS JOIN table\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 13.20  З’ясуйте, які пари товарів купують разом найчастіше.\nПари товарів сформуйте на основі таблиці із замовленнями. Скасовані замовлення не враховуйте. Як результат виведіть дві колонки - колонку з парами найменувань товарів і колонку зі значеннями, які показують, скільки разів конкретна пара зустрілася у замовленнях користувачів. Колонки назвіть відповідно pair та count_pair.\nПари товарів мають бути представлені у вигляді списків із двох найменувань. Пари товарів усередині списків мають бути відсортовані у порядку зростання найменування. Результат відсортуйте спочатку за зменшенням частоти зустрічі пари товарів у замовленнях, потім по колонці pair — за зростанням.\nПоля у результуючій таблиці: pair, count_pair\n\n\n\n\n\n\nПояснення + підказка\n\n\n\n\n\nУ цій задачі вам необхідно зробити SELF JOIN. Подумайте, яку таблицю потрібно приєднати до себе і заздалегідь обробіть дані. Для вирішення рекомендуємо скористатися табличними виразами. Також вам знадобляться функції для роботи зі списками. Ознайомтеся з прикладами документації та подумайте, що можна використовувати у своєму рішенні.\nЗавдання творче і може бути вирішене різними способами.\nДля кожної пари товарів вам необхідно порахувати скільки разів вона зустрілася в замовленнях користувачів. Головна проблема полягає в тому, що при SELF JOIN кожен товар утворює пару з самим собою («A-A») і при цьому кожна пара зустрічається двічі («A-B» та «B-A»). Суть завдання полягає в тому, щоб позбавитися цих двох проблем і отримати коректні розрахунки.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nwith main_table as (SELECT DISTINCT order_id,\n                                    product_id,\n                                    name\n                    FROM   (SELECT order_id,\n                                   unnest(product_ids) as product_id\n                            FROM   orders\n                            WHERE  order_id not in (SELECT order_id\n                                                    FROM   user_actions\n                                                    WHERE  action = 'cancel_order')\n                               and order_id in (SELECT order_id\n                                             FROM   user_actions\n                                             WHERE  action = 'create_order')) t join products using(product_id)\n                    ORDER BY order_id, name)\nSELECT pair,\n       count(order_id) as count_pair\nFROM   (SELECT DISTINCT a.order_id,\n                        case when a.name &gt; b.name then string_to_array(concat(b.name, '+', a.name), '+')\n                             else string_to_array(concat(a.name, '+', b.name), '+') end as pair\n        FROM   main_table a join main_table b\n                ON a.order_id = b.order_id and\n                   a.name != b.name) t\nGROUP BY pair\nORDER BY count_pair desc, pair\n\n-- або\n-- with \n--     t as (select order_id, \n--             unnest(product_ids) as product_id from orders\n--             left join user_actions using(order_id)\n--             where order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')\n--             ),\n\n--     k as (select order_id, t.product_id as pr, t1.product_id as pr1\n--             from t\n--             join t as t1 using(order_id)\n--             where t.product_id != t1.product_id),\n-- \n--     p as (select order_id, pr, pr1, name \n--             from k\n--             left join products on pr = products.product_id),\n-- \n--     s as (select order_id, p.name as name, products.name as name1\n--             from p\n--             left join products on pr1 = products.product_id),\n-- \n--    l as (select  distinct\n--                 order_id, \n--                 array_sort(array_cat(array[name], array[name1])) as pair \n--             from s)\n\n-- select pair, count(*) as count_pair from l\n-- group by  pair\n-- order by count_pair desc, pair"
  },
  {
    "objectID": "sql_window.html#over---визначення-вікна",
    "href": "sql_window.html#over---визначення-вікна",
    "title": "14  Віконні функції",
    "section": "14.1 OVER - визначення вікна",
    "text": "14.1 OVER - визначення вікна\nВизначаються вікна за допомогою оператора OVER – у загальному вигляді його синтаксис виглядає так:\nOVER (\n     PARTITION BY column_1, column_2, ...   - визначаються партиції усередині вікна (аналог GROUP BY) \n     ORDER BY column_3, ...                 - вказується сортування записів у партиціях\n     ROWS/RANGE BETWEEN ...                 - задаються межі вікна\n)\nДля проведення обчислень за заданим в OVER вікну використовуються різні функції. Наприклад, з агрегуючою функцією SUM запис може виглядати так:\nSELECT SUM(column) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS sum\nFROM table\nТепер кілька слів про інструкції, які можна вказувати під час створення вікна. Усього їх три:\n\nPARTITION BY\nORDER BY ASC/DESC\nROWS/RANGE BETWEEN\n\nПри цьому всі вони є необов’язковими."
  },
  {
    "objectID": "sql_window.html#partition-by",
    "href": "sql_window.html#partition-by",
    "title": "14  Віконні функції",
    "section": "14.2 PARTITION BY",
    "text": "14.2 PARTITION BY\nІнструкція PARTITION BY визначає стовпець, яким дані ділитися на групи, які називаються партіціями. Наприклад, так як буде виглядати групування за user_id:\nSELECT user_id, date, price, \n       SUM(price) OVER (PARTITION BY user_id) AS sum\nFROM table\nВ результаті такого запиту для кожного запису в таблиці буде обчислено загальну суму всіх покупок даного користувача, а результат обчислень буде вписаний в стовпець sum:\n\n\n\nuser_id\ndate\nprice\nsum\n\n\n\n\nAlex\n09.01\n500\n3950\n\n\nAlex\n13.03\n3000\n3950\n\n\nAlex\n02.08\n450\n3950\n\n\nKate\n25.07\n100\n900\n\n\nKate\n17.09\n800\n900"
  },
  {
    "objectID": "sql_window.html#order-by",
    "href": "sql_window.html#order-by",
    "title": "14  Віконні функції",
    "section": "14.3 ORDER BY",
    "text": "14.3 ORDER BY\nІнструкція ORDER BY визначає стовпець, яким значення всередині вікна будуть сортуватися при обробці. Наприклад, сортування по date всередині вікна задається так:\nSELECT user_id, date, price, \n       SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum\nFROM table\nУ цьому випадку для кожного запису в таблиці буде обчислено суму поточної та всіх попередніх покупок користувача. Результат обчислень буде вписаний у стовпець sum:\n\n\n\nuser_id\ndate\nprice\nsum\n\n\n\n\nAlex\n09.01\n500\n500\n\n\nAlex\n13.03\n3000\n3500\n\n\nAlex\n02.08\n450\n3950\n\n\nKate\n25.07\n100\n100\n\n\nKate\n17.09\n800\n900\n\n\n\nЧому ж рахується сума саме поточної та всіх попередніх, а не взагалі всіх покупок користувача?\nСправа в тому, що при використанні у парі віконних та агрегатних функцій для кожного рядка визначається так звана рамка вікна - набір рядків у її партиції. Якщо в OVER вказати ORDER BY, то за замовчуванням рамка складатиметься з усіх рядків від початку партиції до поточного рядка (також у рамку будуть включені рядки, що дорівнюють поточному рядку за значенням вказаним у ORDER BY).\nСаме тому в нашому прикладі сума вважається за кожним користувачем наростаючим підсумком.\nЯкщо ж ORDER BY не вказувати, то стандартна рамка буде складатися з усіх рядків партиції, тобто буде пораховано суму всіх покупок кожного користувача. Також можна не вказувати і PARTITION BY – тоді рамкою вікна стане вся таблиця, і ми просто порахуємо суму покупок усіх користувачів:\nSELECT user_id, date, price, \n       SUM(price) OVER () AS sum\nFROM table"
  },
  {
    "objectID": "sql_window.html#rowsrange-between",
    "href": "sql_window.html#rowsrange-between",
    "title": "14  Віконні функції",
    "section": "14.4 ROWS/RANGE BETWEEN",
    "text": "14.4 ROWS/RANGE BETWEEN\nІнструкції ROWS та RANGE можуть додатково задавати межі рамки вікна та обмежувати діапазон роботи функцій усередині партиції. Першим аргументом вказується початок рамки, другим - кінець рамки:\nSELECT user_id, date, price, \n       SUM(price) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS sum\nFROM table\nВ результаті для кожного запису в таблиці буде обчислено суму поточної та попередньої покупок користувача, а результат буде знову вписаний в стовпець sum:\n\n\n\nuser_id\ndate\nprice\nsum\n\n\n\n\nAlex\n09.01\n500\n500\n\n\nAlex\n13.03\n3000\n3500\n\n\nAlex\n02.08\n450\n3450\n\n\nKate\n25.07\n100\n100\n\n\nKate\n17.09\n800\n900\n\n\n\nРамку можна встановити в двох режимах:\n\nROWS — початок та кінець рамки визначаються рядками щодо поточного рядка.\nRANGE — початок та кінець рамки задаються різницею значень у стовпці з ORDER BY.\n\nПочаток і кінець рамки задаються одним із наступних способів:\nUNBOUNDED PRECEDING\nзначення PRECEDING\nCURRENT ROW\nзначення FOLLOWING\nUNBOUNDED FOLLOWING\n\nUNBOUNDED PRECEDING: вказує, що рамка починається з першого рядка партиції.\nUNBOUNDED FOLLOWING: вказує, що рамка закінчується на останньому рядку партиції.\nPRECEDING та FOLLOWING: вказують, що рамка починається або закінчується зі зсувом на задану кількість рядків щодо поточного рядка.\nCURRENT ROW: вказує, що рамка починається або закінчується на поточному рядку.\n\nРамка завжди починається з початку рамки та закінчується кінцем рамки. Якщо кінець рамки не вказаний, мається на увазі CURRENT ROW.\nЗа замовчуванням рамка визначається так:\nRANGE UNBOUNDED PRECEDING\nЦе рівносильно розширеному визначенню рамки:\nRANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\nВаріанти значення PRECEDING та значення FOLLOWING допускаються лише у режимі ROWS.\nНаприклад, наступний запис означає створення рамки, що включає 3 рядки до поточної і 3 рядки після поточної (зрозуміло, поточний рядок також включається до рамки):\nROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING\nЯкщо в інструкції ORDER BY знаходиться стовпець date з типом даних DATE, то рамку вікна можна задати так:\nRANGE BETWEEN '3 days' PRECEDING AND '3 days' FOLLOWING\nЦе означатиме рамку, що включає 3 дні перед та 3 дні після поточної дати (включаючи поточну дату).\nПри вказівці рамки через RANGE обов’язковою умовою є лише один стовпчик в інструкції ORDER BY.\nЯк і решта інструкцій, інструкція ROWS/RANGE BETWEEN є необов’язковою."
  },
  {
    "objectID": "sql_window.html#де-та-як-можна-використовувати-віконні-функції",
    "href": "sql_window.html#де-та-як-можна-використовувати-віконні-функції",
    "title": "14  Віконні функції",
    "section": "14.5 Де та як можна використовувати віконні функції?",
    "text": "14.5 Де та як можна використовувати віконні функції?\nТакож важливо знати, що віконні функції дозволяється використовувати у запиті лише у SELECT та ORDER BY. В інших операторах, включаючи WHERE, HAVING і GROUP BY, вони заборонені, оскільки логічно виконуються після звичайних агрегатних функцій.\nЯкщо потрібно відфільтрувати або згрупувати рядки після обчислення віконних функцій, можна використати вкладений запит:\nSELECT user_id, date, price, sum\nFROM (\n    SELECT user_id, date, price, SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum\n    FROM table\n) t\nWHERE sum &gt; 1000\nНад результатом віконних функцій можна виконувати різні арифметичні операції. Також результат віконних функцій може виступати як аргумент інших функцій:\nSELECT user_id, date, price, 1.15 * SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum\nFROM table\n\nSELECT user_id, date, price, ROUND(AVG(price) OVER (PARTITION BY user_id ORDER BY date), 2) AS sum\nFROM table\nТакож для визначення інструкцій усередині вікна можна використовувати розрахункові поля:\nSELECT user_id, date, price, SUM(price) OVER (PARTITION BY DATE_TRUNC('month', date)) AS monthly_sum\nFROM table  \nСамі вікна також можна визначати через оператор WINDOW, а потім викликати по аліасу в операторі SELECT:\nSELECT SUM(column) OVER w AS sum\nFROM table\nWHERE ...\nGROUP BY ...\nHAVING ...\nWINDOW w AS (\n    PARTITION BY ... \n    ORDER BY ...\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    )\nORDER BY ...\nLIMIT ..."
  },
  {
    "objectID": "sql_window.html#використання-віконних-функцій-з-іншими-функціями",
    "href": "sql_window.html#використання-віконних-функцій-з-іншими-функціями",
    "title": "14  Віконні функції",
    "section": "14.6 Використання віконних функцій з іншими функціями",
    "text": "14.6 Використання віконних функцій з іншими функціями\nУ парі з віконними функціями можна використовувати функції різних класів:\n\nАгрегатні функції SUM, AVG, MAX, MIN, COUNT\n\nВсередині вікна до таких функцій можна застосовувати ORDER BY. Так, сортування дозволить отримати замість загальної суми наростаючу, а замість абсолютного максимуму — максимум серед значень до поточного.\n\nРанжируючі функції:\n\n\nROW_NUMBER: проста нумерація (1, 2, 3, 4, 5).\nRANK: нумерація з урахуванням повторюваних значень з пропуском рангів (1, 2, 2, 4, 5).\nDENSE_RANK: нумерація з урахуванням повторюваних значень без пропуску рангів (1, 2, 2, 3, 4).\n\nЗрозуміло, для функцій ранжирування завжди потрібно вказувати ORDER BY, інакше вони працюватимуть некоректно.\n\nФункції зміщення:\n\n\nLAG, LEAD: значення попереднього чи наступного рядка.\nFIRST_VALUE, LAST_VALUE: перше чи останнє значення у вікні.\n\nДля функцій зміщення визначення правил сортування теж необхідне.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про віконні функції можна почитати у документації DuckDB.\nТакож рекомендуємо до прочитання статтю."
  },
  {
    "objectID": "sql_window.html#ранжуючі-функції",
    "href": "sql_window.html#ранжуючі-функції",
    "title": "14  Віконні функції",
    "section": "14.7 Ранжуючі функції",
    "text": "14.7 Ранжуючі функції\nПочнемо знайомство з віконними функціями з найпростіших завдань. Для початку попрацюємо з ранжуючими функціями:\nSELECT ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS row_number\nFROM table\n\nSELECT RANK() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS rank\nFROM table\n\nSELECT DENSE_RANK() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS dense_rank\nFROM table\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.1  Застосуйте віконні функції до таблиці products і за допомогою ранжирующих функцій упорядкуйте всі товари за ціною від найдорожчих до найдешевших. Додайте до таблиці наступні колонки:\n\nКолонку product_number із порядковим номером товару (функція ROW_NUMBER).\nКолонку product_rank із рангом товару з пропусками рангів (функція RANK).\nКолонку product_dense_rank з рангом товару без перепусток рангів (функція DENSE_RANK).\n\nНе забувайте вказувати у вікні сортування записів — без неї ранжуючі функції можуть давати некоректний результат, якщо таблиця заздалегідь не відсортована. Поділ на партиції всередині вікна зараз не потрібний. Сортувати записи в результуючій таблиці також не потрібно.\nПоля в результуючій таблиці: product_id, name, price, product_number, product_rank, product_dense_rank\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       row_number() OVER (ORDER BY price desc) as product_number,\n       rank() OVER (ORDER BY price desc) as product_rank,\n       dense_rank() OVER (ORDER BY price desc) as product_dense_rank\nFROM   products\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\nproduct_number\nproduct_rank\nproduct_dense_rank\n\n\n\n\n0\n13\ncaviar\n800.0\n1\n1\n1\n\n\n1\n37\nmutton\n559.0\n2\n2\n2\n\n\n2\n15\nolive oil\n450.0\n3\n3\n3\n\n\n3\n57\npork\n450.0\n4\n3\n3\n\n\n4\n43\ndecaffeinated coffee\n400.0\n5\n5\n4\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n83\n83\n49\n\n\n83\n5\ncoffee 3 in 1\n15.0\n84\n84\n50\n\n\n84\n73\ncake\n15.0\n85\n84\n50\n\n\n85\n10\nseeds\n12.0\n86\n86\n51\n\n\n86\n54\npaper bag\n1.0\n87\n87\n52\n\n\n\n\n87 rows × 6 columns"
  },
  {
    "objectID": "sql_window.html#агрегатні-функції",
    "href": "sql_window.html#агрегатні-функції",
    "title": "14  Віконні функції",
    "section": "14.8 Агрегатні функції",
    "text": "14.8 Агрегатні функції\nЗ ранжуючими функціями розібралися, тепер давайте навчимося в парі з віконними і агрегуючі функції:\nSELECT SUM(column) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS sum\nFROM table\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.2  Застосуйте віконну функцію до таблиці products і за допомогою агрегатної функції в окремій колонці для кожного запису проставте ціну найдорожчого товару. Колонку із цим значенням назвіть max_price. Потім для кожного товару порахуйте частку його ціни у вартості найдорожчого товару - просто поділіть одну колонку на іншу. Отримані частки округліть до двох знаків після коми. Колонку із частками назвіть share_of_max.\nВиведіть всю інформацію про товари, включаючи значення у нових колонках. Результат відсортуйте спочатку за спаданням ціни товару, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, max_price, share_of_max\nПояснення:\nУ цьому вся задачі вікном виступає вся таблиця. Сортувати всередині вікна вказувати не потрібно.\nЗ результатом агрегації з вікном можна проводити арифметичні та логічні операції. Також до нього можна застосовувати й інші функції - наприклад, округлення, як у цій задачі.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       max(price) OVER () as max_price,\n       round(price / max(price) OVER (), 2) as share_of_max\nFROM   products\nORDER BY price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\nmax_price\nshare_of_max\n\n\n\n\n0\n13\ncaviar\n800.0\n800.0\n1.00\n\n\n1\n37\nmutton\n559.0\n800.0\n0.70\n\n\n2\n15\nolive oil\n450.0\n800.0\n0.56\n\n\n3\n57\npork\n450.0\n800.0\n0.56\n\n\n4\n43\ndecaffeinated coffee\n400.0\n800.0\n0.50\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n800.0\n0.03\n\n\n83\n5\ncoffee 3 in 1\n15.0\n800.0\n0.02\n\n\n84\n73\ncake\n15.0\n800.0\n0.02\n\n\n85\n10\nseeds\n12.0\n800.0\n0.02\n\n\n86\n54\npaper bag\n1.0\n800.0\n0.00\n\n\n\n\n87 rows × 5 columns"
  },
  {
    "objectID": "sql_window.html#віконні-функції-та-order-by",
    "href": "sql_window.html#віконні-функції-та-order-by",
    "title": "14  Віконні функції",
    "section": "14.9 Віконні функції та ORDER BY",
    "text": "14.9 Віконні функції та ORDER BY\nА тепер давайте доповнимо наш попередній запит і вкажемо інструкцію ORDER BY для вікна, що працює в парі агрегатною функцією.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.3  Застосуйте дві віконні функції до таблиці products — одна з функцією MAX, а інша MIN — для обчислення максимальної та мінімальної ціни. Для двох вікон задайте інструкцію ORDER BY щодо зменшення ціни. Помістіть результат обчислень у дві колонки max_price та min_price.\nВиведіть всю інформацію про товари, включаючи значення у нових колонках. Результат відсортуйте спочатку за спаданням ціни товару, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, max_price, min_price\nПісля того, як вирішите завдання, проаналізуйте отриманий результат і подумайте, чому вийшли саме такі розрахунки. За потреби поверніться до першого кроку і ще раз уважно ознайомтеся з тим, як працює рамка вікна під час сортування.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       max(price) OVER (ORDER BY price desc) as max_price,\n       min(price) OVER (ORDER BY price desc) as min_price\nFROM   products\nORDER BY price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\nmax_price\nmin_price\n\n\n\n\n0\n13\ncaviar\n800.0\n800.0\n800.0\n\n\n1\n37\nmutton\n559.0\n800.0\n559.0\n\n\n2\n15\nolive oil\n450.0\n800.0\n450.0\n\n\n3\n57\npork\n450.0\n800.0\n450.0\n\n\n4\n43\ndecaffeinated coffee\n400.0\n800.0\n400.0\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n800.0\n25.0\n\n\n83\n5\ncoffee 3 in 1\n15.0\n800.0\n15.0\n\n\n84\n73\ncake\n15.0\n800.0\n15.0\n\n\n85\n10\nseeds\n12.0\n800.0\n12.0\n\n\n86\n54\npaper bag\n1.0\n800.0\n1.0\n\n\n\n\n87 rows × 5 columns\n\n\n\n\nТепер застосуємо віконну функцію з інструкцією ORDER BY для вирішення практичного завдання.\nЯк ми пам’ятаємо з першого кроку, вказівка сортування визначає рамку вікна від початку таблиці або партиції до поточного рядка. Давайте використовуємо цю особливість розрахунку кумулятивної суми, тобто зробимо так, щоб для кожного запису повертався результат додавання її значення зі значеннями всіх попередніх записів.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.4  Спочатку на основі таблиці orders сформуйте нову таблицю із загальною кількістю замовлень по дням. Підраховуючи кількість замовлень, не враховуйте скасовані замовлення (їх можна визначити за таблицею user_actions). Колонку з днями назвіть date, а колонку з числом замовлень orders_count.\nПотім помістіть отриману таблицю в підзапит і застосуйте до неї віконну функцію в парі з функцією SUM для розрахунку кумулятивної суми числа замовлень. Не забудьте для вікна вказати інструкцію ORDER BY за датою.\nНазвіть колонку з накопичувальною сумою orders_cum_count. В результаті такої операції значення кумулятивної суми для останнього дня має вийти рівним загальній кількості замовлень за весь період.\nСортувати результуючу таблицю робити не потрібно.\nПоля в результуючій таблиці: date, orders_count, orders_cum_count\nПояснення:\nЗверніть увагу, що віконні функції як результат повертають значення типу DECIMAL, незважаючи на те, що вхідне значення знаходиться у форматі INTEGER. Тому не забудьте отримане значення кумулятивної суми додатково привести до цілісного формату.\n\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT creation_time::date as date,\n    COUNT(*) as orders_count\nFROM orders\nWHERE order_id NOT IN (SELECT order_id from user_actions WHERE action = 'cancel_order')\nGROUP BY date)\n\nselect date,\n    orders_count,\n    SUM(orders_count) OVER (ORDER BY date)::integer as orders_cum_count\nFROM t1"
  },
  {
    "objectID": "sql_window.html#віконні-функції-та-partition-by",
    "href": "sql_window.html#віконні-функції-та-partition-by",
    "title": "14  Віконні функції",
    "section": "14.10 Віконні функції та PARTITION BY",
    "text": "14.10 Віконні функції та PARTITION BY\nУ попередніх завданнях як вікно виступала вся таблиця. Тепер давайте навчимося додавати у параметри вікна поділ на партиції та попрацюємо з інструкцією PARTITION BY.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.5  Для кожного користувача у таблиці user_actions порахуйте порядковий номер кожного замовлення. Для цього застосовуйте віконну функцію ROW_NUMBER до колонки з часом замовлення. Не забудьте вказати поділ на партиції за користувачами та сортування усередині партицій. Скасовані замовлення не враховуйте. Нову колонку із порядковим номером замовлення назвіть order_number. Результат відсортуйте спочатку за зростанням ID користувача, потім за зростанням order_number. Додати LIMIT 1000.\nПоля в результуючій таблиці: user_id, order_id, time, order_number\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       time,\n       row_number() OVER (PARTITION BY user_id\n                          ORDER BY time) as order_number\nFROM   user_actions\nWHERE  order_id not in (SELECT order_id\n                        FROM   user_actions\n                        WHERE  action = 'cancel_order')\nORDER BY user_id, order_number limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\ntime\norder_number\n\n\n\n\n0\n1\n1\n2022-08-24 01:52:00\n1\n\n\n1\n1\n4683\n2022-08-27 20:56:00\n2\n\n\n2\n1\n22901\n2022-09-02 00:58:00\n3\n\n\n3\n1\n23149\n2022-09-02 02:36:00\n4\n\n\n4\n2\n2\n2022-08-24 06:37:00\n1\n\n\n...\n...\n...\n...\n...\n\n\n995\n248\n13935\n2022-08-30 17:13:00\n8\n\n\n996\n248\n15518\n2022-08-31 02:25:00\n9\n\n\n997\n249\n287\n2022-08-25 03:54:00\n1\n\n\n998\n249\n758\n2022-08-25 15:19:00\n2\n\n\n999\n249\n7347\n2022-08-28 19:27:00\n3\n\n\n\n\n1000 rows × 4 columns"
  },
  {
    "objectID": "sql_window.html#віконні-функції-та-зміщення",
    "href": "sql_window.html#віконні-функції-та-зміщення",
    "title": "14  Віконні функції",
    "section": "14.11 Віконні функції та зміщення",
    "text": "14.11 Віконні функції та зміщення\nТепер давайте попрацюємо з функціями зміщення – у цьому теж немає нічого складного:\nSELECT LAG(column, 1) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS lag_value\nFROM table\n\nSELECT LEAD(column, 1) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS lead_value\nFROM table\nВ якості першого аргументу функцій LAG і LEAD вказується колонка зі значеннями, в якості другого — те, скільки рядків проводити зміщення (назад і вперед відповідно). Другий аргумент можна не вказувати, за умовчанням його значення дорівнює 1.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.6  Доповніть запит із попереднього завдання та за допомогою віконної функції для кожного замовлення кожного користувача розрахуйте, скільки часу пройшло з попереднього замовлення.\nДля цього спочатку в окремому стовпці за допомогою LAG зробіть зміщення по стовпцю часу на одне значення назад. Стовпець зі зміщеними значеннями назвіть time_lag. Потім відніміть від кожного значення колонці time нове значення зі зміщенням (або можете використовувати вже знайому функцію AGE). Назвіть колонку з отриманим інтервалом time_diff. Змінювати формат відображення значень не потрібно, вони повинні мати приблизно такий вигляд:\n3 days, 12:18:22\nЯк і раніше, не враховуйте скасовані замовлення. Також залиште у запиті порядковий номер кожного замовлення, розрахований на минулому етапі. Результат відсортуйте спочатку за зростанням ID користувача, потім за зростанням порядкового номера замовлення. Додати LIMIT 1000.\nПоля в результуючій таблиці: user_id, order_id, time, order_number, time_lag, time_diff\nПояснення:\nНе забувайте про поділ на партиції та сортування усередині вікна.\nТакож зверніть увагу, що в результаті зміщення перших замовлень кожного користувача в колонці time_lag вийшли пропущені значення. Для таких записів функція не знайшла попередніх значень та повернула NULL. Те саме сталося в записах користувачів з одним замовленням — усередині партиції з одним записом просто нема куди зміщатися.\nПропущені значення, що утворилися, прибирати з результату не потрібно.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       time,\n       row_number() OVER (PARTITION BY user_id\n                          ORDER BY time) as order_number,\n       lag(time, 1) OVER (PARTITION BY user_id\n                          ORDER BY time) as time_lag,\n       time - lag(time, 1) OVER (PARTITION BY user_id\n                                 ORDER BY time) as time_diff\nFROM   user_actions\nWHERE  order_id not in (SELECT order_id\n                        FROM   user_actions\n                        WHERE  action = 'cancel_order')\nORDER BY user_id, order_number limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\ntime\norder_number\ntime_lag\ntime_diff\n\n\n\n\n0\n1\n1\n2022-08-24 01:52:00\n1\nNaT\nNaT\n\n\n1\n1\n4683\n2022-08-27 20:56:00\n2\n2022-08-24 01:52:00\n3 days 19:04:00\n\n\n2\n1\n22901\n2022-09-02 00:58:00\n3\n2022-08-27 20:56:00\n5 days 04:02:00\n\n\n3\n1\n23149\n2022-09-02 02:36:00\n4\n2022-09-02 00:58:00\n0 days 01:38:00\n\n\n4\n2\n2\n2022-08-24 06:37:00\n1\nNaT\nNaT\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n995\n248\n13935\n2022-08-30 17:13:00\n8\n2022-08-30 11:04:00\n0 days 06:09:00\n\n\n996\n248\n15518\n2022-08-31 02:25:00\n9\n2022-08-30 17:13:00\n0 days 09:12:00\n\n\n997\n249\n287\n2022-08-25 03:54:00\n1\nNaT\nNaT\n\n\n998\n249\n758\n2022-08-25 15:19:00\n2\n2022-08-25 03:54:00\n0 days 11:25:00\n\n\n999\n249\n7347\n2022-08-28 19:27:00\n3\n2022-08-25 15:19:00\n3 days 04:08:00\n\n\n\n\n1000 rows × 6 columns\n\n\n\n\nДавайте для повноти картини порахуємо, скільки в середньому проходить між замовленнями кожного користувача.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.7  На основі запиту попереднього завдання для кожного користувача розрахуйте, скільки в середньому часу проходить між його замовленнями. Порахуйте цей показник лише для користувачів, які за весь час оформили більше одного замовлення.\nСередній час між замовленнями виразіть у годинах, округливши значення до цілого числа. Колонку із середнім значенням часу назвіть hours_between_orders. Результат відсортуйте за зростанням id користувача.\nДодайте в запит оператор LIMIT і включіть у результат лише перші 1000 записів.\nПоля у результуючій таблиці: user_id, hours_between_orders\nПояснення:\nЩоб перевести значення інтервалу в години, необхідно витягти з нього кількість секунд, а потім поділити на кількість секунд в одній годині. Для отримання кількості секунд з інтервалу можна скористатися такою конструкцією:\nSELECT EXTRACT(epoch FROM INTERVAL '3 days, 1:21:32')\n\nРезультат:\n264092  \nФункція EXTRACT працює аналогічно до функції DATE_PART, яку ми розглядали раніше, але має дещо інший синтаксис. Спробуйте скористатися функцією EXTRACT у цій задачі.\nВ результаті всіх розрахунків для кожного користувача з більш ніж одним замовленням, у вас має вийти ціле число годин, яке в середньому проходить між його замовленнями. Подумайте, як отримати з даних користувачів з одним замовленням. За потреби додатково перетворіть середнє значення годин на цілий тип даних.\nПовторювати всі попередні віконні функції з попереднього запиту не обов’язково — залиште найнеобхідніше.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       avg(time_diff)::integer as hours_between_orders\nFROM   (SELECT user_id,\n               order_id,\n               time,\n               extract(epoch\n        FROM   (time - lag(time, 1)\n        OVER (\n        PARTITION BY user_id\n        ORDER BY time)))/3600 as time_diff\n        FROM   user_actions\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')) t\nWHERE  time_diff is not null\nGROUP BY user_id\nORDER BY user_id limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\nhours_between_orders\n\n\n\n\n0\n1\n72\n\n\n1\n2\n108\n\n\n2\n3\n64\n\n\n3\n4\n77\n\n\n4\n6\n11\n\n\n...\n...\n...\n\n\n995\n1125\n35\n\n\n996\n1126\n49\n\n\n997\n1127\n37\n\n\n998\n1129\n33\n\n\n999\n1130\n20\n\n\n\n\n1000 rows × 2 columns"
  },
  {
    "objectID": "sql_window.html#задачі-з-rows-between",
    "href": "sql_window.html#задачі-з-rows-between",
    "title": "14  Віконні функції",
    "section": "14.12 Задачі з ROWS BETWEEN",
    "text": "14.12 Задачі з ROWS BETWEEN\nНастав час трохи попрацювати з інструкцією ROWS BETWEEN, яку докладно розглядали раніше. Нагадаємо, що початок і кінець рамки задаються такими способами:\nUNBOUNDED PRECEDING\nзначення PRECEDING\nCURRENT ROW\nзначення FOLLOWING\nUNBOUNDED FOLLOWING\nОсь ще один приклад вказівки меж рамки:\nSELECT SUM(column_3) OVER (PARTITION BY column_1 \n                           ORDER BY column_2 \n                           ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING) AS sum\nFROM table\nАле в яких завданнях корисно вказувати рамку для розрахунків? Перше, що спадає на думку будь-якому аналітику, — ковзна середня.\nКовзне середнє - це показник, який обчислюється в кожній точці часового ряду як середнє значення за N попередніх періодів (днів, тижнів, місяців тощо в залежності від рівня агрегації даних). Ковзне середнє переміщається по часовому ряду і щоразу враховує фіксовану кількість значень - для проведення таких розрахунків якраз і потрібна рамка вікна, яка задається інструкцією ROWS BETWEEN.\nСпробуймо провести такі розрахунки на наших даних.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.8  Спочатку на основі таблиці orders сформуйте нову таблицю із загальною кількістю замовлень щодня. Ви вже робили у завданні 14.4. Підраховуючи кількість замовлень, не враховуйте скасовані замовлення (їх можна визначити за таблицею user_actions). Назвіть колонку з кількістю замовлень orders_count.\nПотім помістіть отриману таблицю в підзапит і застосуйте до неї віконну функцію в парі з функцією AVG для розрахунку ковзного середнього числа замовлень. Ковзне середнє для кожного запису рахуйте за трьома попередніми днями. Подумайте, як правильно встановити межі рамки, щоб отримати коректні розрахунки.\nОтримані значення ковзного середнього округліть до двох знаків після коми. Колонку із розрахованим показником назвіть moving_avg. Сортувати результуючу таблицю робити не потрібно.\nПоля у результуючій таблиці: date, orders_count, moving_avg\nПояснення:\nПри вирішенні завдання можете пробувати різні межі рамки та перевіряти себе вручну. Важливо для кожної дати врахувати у розрахунках саме 3 попередні дні.\nЗаповнювати пропущені значення у цій задачі не потрібно. Подумайте чому вони могли з’явитися.\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       orders_count,\n       round(avg(orders_count) OVER (ORDER BY date rows between 3 preceding and 1 preceding),\n             2) as moving_avg\nFROM   (SELECT creation_time :: date as date,\n               count(order_id) as orders_count,\n               sum(count(order_id)) OVER (ORDER BY creation_time :: date) as orders_cum_count\n        FROM   orders\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')\n        GROUP BY date) as t1\n\n\n\n\n\n\n\n\n\ndate\norders_count\nmoving_avg\n\n\n\n\n0\n2022-08-24\n138\nNaN\n\n\n1\n2022-08-25\n1059\n138.00\n\n\n2\n2022-08-26\n1447\n598.50\n\n\n3\n2022-08-27\n2141\n881.33\n\n\n4\n2022-08-28\n2998\n1549.00\n\n\n5\n2022-08-29\n3267\n2195.33\n\n\n6\n2022-08-30\n3371\n2802.00\n\n\n7\n2022-08-31\n3410\n3212.00\n\n\n8\n2022-09-01\n3688\n3349.33\n\n\n9\n2022-09-02\n5001\n3489.67\n\n\n10\n2022-09-03\n5709\n4033.00\n\n\n11\n2022-09-04\n6010\n4799.33\n\n\n12\n2022-09-05\n4675\n5573.33\n\n\n13\n2022-09-06\n3451\n5464.67\n\n\n14\n2022-09-07\n4777\n4712.00\n\n\n15\n2022-09-08\n5474\n4301.00"
  },
  {
    "objectID": "sql_window.html#задача-з-case",
    "href": "sql_window.html#задача-з-case",
    "title": "14  Віконні функції",
    "section": "14.13 Задача з CASE",
    "text": "14.13 Задача з CASE\nТепер навчимося разом із віконними функціями застосовувати конструкцію CASE. Приклад такого запису:\nSELECT\n    CASE\n    WHEN SUM(column) OVER (...) &gt; 100 THEN 'above 100'\n    WHEN SUM(column) OVER (...) &lt; 100 THEN 'below 100'\n    ELSE 'equal 100'\n    END AS sum_case\nFROM table\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.9  Позначте в окремій таблиці тих кур’єрів, які доставили у вересні 2022 замовлень більше, ніж у середньому всі кур’єри.\nСпочатку для кожного кур’єра у таблиці courier_actions розрахуйте загальну кількість доставлених у вересні замовлень. Потім в окремому стовпці за допомогою віконної функції вкажіть, скільки в середньому замовлень доставили цього місяця всі кур’єри. Після цього порівняйте кількість замовлень, доставлених кожним кур’єром, із середнім значенням у новому стовпці. Якщо кур’єр доставив більше замовлень, ніж у середньому всі кур’єри, то окремому стовпці за допомогою CASE вкажіть число 1, інакше вкажіть 0.\nКолонку з результатом порівняння назвіть is_above_avg, колонку з кількістю доставлених замовлень кожним кур’єром – delivered_orders, а колонку із середнім значенням – avg_delivered_orders. При розрахунку середнього значення округліть його до двох знаків після коми. Результат відсортуйте за зростанням id кур’єра.\nПоля в результуючій таблиці: courier_id, delivered_orders, avg_delivered_orders, is_above_avg\nПояснення:\nТаблицю з кур’єрами та числом доставлених замовлень сформуйте на основі таблиці courier_actions та перед застосуванням віконних функцій помістіть її у підзапит.\nЗ цим завданням можна впоратися без конструкції CASE, якщо сконвертувати результат логічної операції (TRUE чи FALSE) у тип даних INT. Можете спробувати розв’язати завдання різними способами.\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       delivered_orders,\n       round(avg(delivered_orders) OVER (), 2) as avg_delivered_orders,\n       case when delivered_orders &gt; round(avg(delivered_orders) OVER (), 2) then 1\n            else 0 end as is_above_avg\nFROM   (SELECT courier_id,\n               count(order_id) as delivered_orders\n        FROM   courier_actions\n        WHERE  action = 'deliver_order'\n           and date_part('month', time) = 9\n           and date_part('year', time) = 2022\n        GROUP BY courier_id) t\nORDER BY courier_id\n\n-- або\n-- SELECT *,\n--        round(avg(delivered_orders) OVER (), 2) as avg_delivered_orders,\n--        (delivered_orders &gt; avg(delivered_orders) OVER ())::integer as is_above_avg\n-- FROM   (SELECT courier_id,\n--                count(*) as delivered_orders\n--         FROM   courier_actions\n--         WHERE  date_part('month', time) = 09\n--            and date_part('year', time) = 2022\n--            and action = 'deliver_order'\n--         GROUP BY courier_id) t1\n\n\n\n\n\n\n\n\n\ncourier_id\ndelivered_orders\navg_delivered_orders\nis_above_avg\n\n\n\n\n0\n1\n20\n13.76\n1\n\n\n1\n2\n14\n13.76\n1\n\n\n2\n3\n23\n13.76\n1\n\n\n3\n4\n9\n13.76\n0\n\n\n4\n5\n23\n13.76\n1\n\n\n...\n...\n...\n...\n...\n\n\n2817\n3163\n4\n13.76\n0\n\n\n2818\n3164\n3\n13.76\n0\n\n\n2819\n3165\n2\n13.76\n0\n\n\n2820\n3166\n2\n13.76\n0\n\n\n2821\n3167\n3\n13.76\n0\n\n\n\n\n2822 rows × 4 columns"
  },
  {
    "objectID": "sql_window.html#задача-з-filter",
    "href": "sql_window.html#задача-з-filter",
    "title": "14  Віконні функції",
    "section": "14.14 Задача з FILTER",
    "text": "14.14 Задача з FILTER\nУ цьому завданні розглянемо ще більш сучасний функціонал і навчимося разом з віконними функціями застосовувати оператор FILTER, з яким ми вже працювали у завданні 11.16.\nЯкщо до визначення віконної функції додати пропозицію FILTER, то у вікно потраплять лише ті вхідні рядки, для яких умова фільтра буде обчислена як дійсна.\nПри цьому пропозиція FILTER допускається тільки для агрегатних віконних функцій.\nУ загальному вигляді вся конструкція виглядає так:\nSELECT agg_function(column) FILTER (WHERE [condition]) OVER (...)\nFROM table\nПриклад:\nSELECT SUM(column_1) FILTER (WHERE column_2 &gt; 100) OVER (PARTITION BY column_3 ORDER BY column_4) AS sum\nFROM table\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.10  Застосуйте віконну функцію до таблиці products та за допомогою агрегуючої функції в окремій колонці для кожного запису проставте середню ціну всіх товарів. Колонку із цим значенням назвіть avg_price. Потім за допомогою віконної функції та оператора FILTER в окремій колонці розрахуйте середню ціну товарів без урахування найдорожчого. Колонку із цим середнім значенням назвіть avg_price_filtered. Отримані середні значення в колонках avg_price та avg_price_filtered округліть до двох знаків після коми.\nВиведіть всю інформацію про товари, включаючи значення у нових колонках. Результат відсортуйте спочатку за спаданням ціни товару, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, avg_price, avg_price_filtered\nПояснення:\nУ цьому завданні вікном знову виступає вся таблиця. Сортувати всередині вікна не потрібно.\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price,\n       round(avg(price) OVER (), 2) as avg_price,\n       round(avg(price) filter (WHERE price != (SELECT max(price)\n                                         FROM   products))\nOVER (), 2) as avg_price_filtered\nFROM   products\nORDER BY price desc, product_id\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\navg_price\navg_price_filtered\n\n\n\n\n0\n13\ncaviar\n800.0\n133.54\n125.79\n\n\n1\n37\nmutton\n559.0\n133.54\n125.79\n\n\n2\n15\nolive oil\n450.0\n133.54\n125.79\n\n\n3\n57\npork\n450.0\n133.54\n125.79\n\n\n4\n43\ndecaffeinated coffee\n400.0\n133.54\n125.79\n\n\n...\n...\n...\n...\n...\n...\n\n\n82\n6\ncrackers\n25.0\n133.54\n125.79\n\n\n83\n5\ncoffee 3 in 1\n15.0\n133.54\n125.79\n\n\n84\n73\ncake\n15.0\n133.54\n125.79\n\n\n85\n10\nseeds\n12.0\n133.54\n125.79\n\n\n86\n54\npaper bag\n1.0\n133.54\n125.79\n\n\n\n\n87 rows × 5 columns\n\n\n\n\nА тепер ще одне завдання на фільтрацію по вікну — цього разу складніше.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.11  Для кожного запису в таблиці user_actions за допомогою віконних функцій та FILTER порахуйте скільки замовлень зробив і скільки скасував кожен користувач на момент здійснення нової дії.\nІншими словами, для кожного користувача в кожний момент часу порахуйте дві накопичувальні суми - числа оформлених та відмінених замовлень. Якщо користувач оформляє замовлення, кількість оформлених ним замовлень збільшуйте на 1, якщо скасовує — збільшуйте на 1 кількість скасуваних.\nКолонки з накопичувальними сумами числа оформлених та скасованих замовлень назвіть відповідно created_orders та canceled_orders. На основі цих двох колонок для кожного запису користувача порахуйте показник cancel_rate, тобто частку скасованих замовлень у загальній кількості оформлених замовлень. Значення показника округліть до двох знаків після коми. Назвіть колонку з ним cancel_rate.\nВ результаті у вас повинні вийти три нові колонки з динамічними показниками, які змінюються в часі з кожною новою дією користувача.\nУ результуючій таблиці відобразіть усі колонки з вихідної таблиці разом із новими колонками. Відсортуйте результат за колонками user_id, order_id, time – за зростанням значень у кожній.\nДодайте в запит оператор LIMIT та виведіть лише перші 1000 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, order_id, action, time, created_orders, canceled_orders, cance`l_rate\nПояснення:\nПодумайте, як правильно встановити вікна і які фільтри в них потрібно вказати.\nНе забудьте змінити тип даних під час поділу двох цілих значень.\n\n\n\n\n\nРішення\n%%sql\nSELECT user_id,\n       order_id,\n       action,\n       time,\n       created_orders,\n       canceled_orders,\n       round(canceled_orders::decimal / created_orders, 2) as cancel_rate\nFROM   (SELECT user_id,\n               order_id,\n               action,\n               time,\n               count(order_id) filter (WHERE action != 'cancel_order') OVER (PARTITION BY user_id\n                                                                             ORDER BY time) as created_orders,\n               count(order_id) filter (WHERE action = 'cancel_order') OVER (PARTITION BY user_id\n                                                                            ORDER BY time) as canceled_orders\n        FROM   user_actions) t\nORDER BY user_id, order_id, time limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\norder_id\naction\ntime\ncreated_orders\ncanceled_orders\ncancel_rate\n\n\n\n\n0\n1\n1\ncreate_order\n2022-08-24 01:52:00\n1\n0\n0.0\n\n\n1\n1\n4683\ncreate_order\n2022-08-27 20:56:00\n2\n0\n0.0\n\n\n2\n1\n22901\ncreate_order\n2022-09-02 00:58:00\n3\n0\n0.0\n\n\n3\n1\n23149\ncreate_order\n2022-09-02 02:36:00\n4\n0\n0.0\n\n\n4\n2\n2\ncreate_order\n2022-08-24 06:37:00\n1\n0\n0.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n995\n227\n12572\ncreate_order\n2022-08-30 08:36:00\n4\n0\n0.0\n\n\n996\n227\n12578\ncreate_order\n2022-08-30 08:38:00\n5\n0\n0.0\n\n\n997\n227\n23268\ncreate_order\n2022-09-02 04:03:00\n6\n0\n0.0\n\n\n998\n227\n25873\ncreate_order\n2022-09-02 17:52:00\n7\n0\n0.0\n\n\n999\n227\n25885\ncreate_order\n2022-09-02 17:54:00\n8\n0\n0.0\n\n\n\n\n1000 rows × 7 columns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.12  З таблиці courier_actions відберіть топ 10% кур’єрів за кількістю доставлених за весь час замовлень. Виведіть id кур’єрів, кількість доставлених замовлень та порядковий номер кур’єра відповідно до кількості доставлених замовлень.\nУ кур’єра, який доставив найбільше замовлень, порядковий номер повинен дорівнювати 1, а кур’єра з найменшою кількістю замовлень — числу, що дорівнює десяти відсоткам від кількості кур’єрів у таблиці courier_actions.\nПід час розрахунку номера останнього кур’єра округляйте значення до цілого числа.\nКолонки з кількістю доставлених замовлень та порядковим номером назвіть відповідно orders_count та courier_rank. Результат відсортуйте за зростанням порядкового номера кур’єра.\nПоля у результуючій таблиці: courier_id, orders_count, courier_rank\nПояснення:\nЯкщо у двох кур’єрів виявилося однакове число доставлених замовлень, вищий ранг ми надамо кур’єру з меншим id. Наприклад, якщо у кур’єрів з id 10 і 80 виявилася максимальна кількість замовлень, то перший ранг ми надамо кур’єру з id 10.\n\n\n\n\n\nРішення\n%%sql\nwith courier_count as (SELECT count(distinct courier_id)\n                       FROM   courier_actions)\nSELECT courier_id,\n       orders_count,\n       courier_rank\nFROM   (SELECT courier_id,\n               count(distinct order_id) as orders_count,\n               row_number() OVER (ORDER BY count(distinct order_id) desc, courier_id) as courier_rank\n        FROM   courier_actions\n        WHERE  action = 'deliver_order'\n        GROUP BY courier_id\n        ORDER BY orders_count desc, courier_id) as t1\nWHERE  courier_rank &lt;= round((SELECT *\n                              FROM   courier_count)*0.1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.13  За допомогою віконної функції відберіть із таблиці courier_actions всіх кур’єрів, які працюють у нашій компанії 10 і більше днів. Також розрахуйте скільки замовлень вони вже встигли доставити за весь час роботи.\nВважатимемо, що наш сервіс пропонує найвигідніші умови праці і тому за весь аналізований період жоден кур’єр не звільнився з компанії. Можливих перерв між змінами не враховуйте — для нас важлива лише різниця в часі між першою дією кур’єра і поточною позначкою часу.\nПоточною відміткою часу, щодо якої необхідно розраховувати тривалість роботи кур’єра, вважайте час останньої дії таблиці courier_actions. Враховуйте лише цілі дні, що пройшли з моменту першого виходу кур’єра на роботу (години та хвилини не враховуйте).\nУ результат включіть три колонки: id кур’єра, тривалість роботи в днях та кількість доставлених замовлень. Дві нові колонки назвіть відповідно days_employed та delivered_orders. Результат відсортуйте спочатку за зменшенням кількості відпрацьованих днів, потім за зростанням id кур’єра.\nПоля в результуючій таблиці: courier_id, days_employed, delivered_orders\nПояснення:\nДля вирішення задачі крім віконної функції вам можуть стати у нагоді функція DATE_PART та оператор FILTER.\nЧисло днів, які відпрацював кур’єр - це кількість днів, що пройшли з першого прийнятого замовлення до часу останнього запису в таблиці courier_actions. Простежте, щоб кількість днів у результуючій таблиці було виражено цілим числом.\n\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       days_employed,\n       delivered_orders\nFROM   (SELECT courier_id,\n               delivered_orders,\n               date_part('days', max(max_time) OVER() - min_time)::integer as days_employed\n        FROM   (SELECT courier_id,\n                       count(distinct order_id) filter (WHERE action = 'deliver_order') as delivered_orders,\n                       min(time) as min_time,\n                       max(time) as max_time\n                FROM   courier_actions\n                GROUP BY courier_id) t1) t2\nWHERE  days_employed &gt;= 10\nORDER BY days_employed desc, courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\ndays_employed\ndelivered_orders\n\n\n\n\n0\n1\n15\n45\n\n\n1\n2\n15\n35\n\n\n2\n3\n15\n45\n\n\n3\n5\n15\n43\n\n\n4\n7\n15\n40\n\n\n...\n...\n...\n...\n\n\n1059\n1194\n10\n21\n\n\n1060\n1198\n10\n35\n\n\n1061\n1203\n10\n20\n\n\n1062\n1204\n10\n26\n\n\n1063\n1205\n10\n18\n\n\n\n\n1064 rows × 3 columns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.14  За допомогою інформації в таблицях orders і products розрахуйте вартість кожного замовлення, щоденний виторг сервісу та частку вартості кожного замовлення в щоденній виручці, виражену у відсотках. У результаті включіть наступні колонки: id замовлення, час створення замовлення, вартість замовлення, виручку за день, в який було здійснено замовлення, а також частку вартості замовлення у виручці за день, що виражається у відсотках.\nПри розрахунку часток округляйте їх до трьох знаків після коми.\nРезультат відсортуйте спочатку за спаданням дати здійснення замовлення (саме дати, а не часу), потім за зменшенням частки замовлення у виручці за день, потім за зростанням id замовлення.\nПід час проведення розрахунків скасовані замовлення не враховуйте.\nПоля в результуючій таблиці: order_id, creation_time, order_price, daily_revenue, percentage_of_daily_revenue\n\n\n\n\n\nРішення\n%%sql\nSELECT\n  order_id,\n  creation_time,\n  order_price,\n  sum(order_price) OVER(PARTITION BY creation_time::date) as daily_revenue,\n  round(\n    100 * order_price :: decimal / sum(order_price) OVER(PARTITION BY creation_time::date),\n    3\n  ) as percentage_of_daily_revenue\nFROM\n  (\n    SELECT\n      order_id,\n      creation_time,\n      sum(price) as order_price\n    FROM\n      (\n        SELECT\n          order_id,\n          creation_time,\n          product_ids,\n          unnest(product_ids) as product_id\n        FROM\n          orders\n        WHERE\n          order_id not in (\n            SELECT\n              order_id\n            FROM\n              user_actions\n            WHERE\n              action = 'cancel_order'\n          )\n      ) t3\n      LEFT JOIN products using(product_id)\n    GROUP BY\n      order_id,\n      creation_time\n  ) t\nORDER BY\n  creation_time::date desc,\n  percentage_of_daily_revenue desc,\n  order_id\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.15  За допомогою інформації в таблицях orders та products розрахуйте щоденну виручку сервісу та відобразіть її в колонці daily_revenue. Потім за допомогою віконних функцій та функцій зміщення порахуйте щоденний приріст виручки. Приріст виручки відобразіть як у абсолютних значеннях, і у % щодо попереднього дня. Колонку з абсолютним приростом назвіть revenue_growth_abs, а колонку з відносним – revenue_growth_percentage.\nДля першого дня вкажіть приріст рівним 0 в обох колонках. Під час проведення розрахунків скасовані замовлення не враховуйте. Результат відсортуйте по колонці з датами зростання.\nМетрики daily_revenue, revenue_growth_abs, revenue_growth_percentage округліть до одного знака за допомогою ROUND().\nПоля в результуючій таблиці: date, daily_revenue, revenue_growth_abs, revenue_growth_percentage\n\n\n\n\n\nРішення\n%%sql\nwith t1 as (\n    SELECT order_id,\n                       creation_time,\n                       product_ids,\n                       unnest(product_ids) as product_id\n                FROM   orders\n                WHERE  order_id not in (SELECT order_id\n                                        FROM   user_actions\n                                        WHERE  action = 'cancel_order')\n    ),\n    t2 as (\n    SELECT creation_time::date as date,\n               sum(price) as daily_revenue\n        FROM t1\n        LEFT JOIN products using(product_id)\n        GROUP BY date\n    )\n    \nSELECT date,\n       round(daily_revenue, 1) as daily_revenue,\n       round(coalesce(daily_revenue - lag(daily_revenue, 1) OVER (ORDER BY date), 0), 1) as revenue_growth_abs,\n       round(coalesce(round((daily_revenue - lag(daily_revenue, 1) OVER (ORDER BY date))::decimal / lag(daily_revenue, 1) OVER (ORDER BY date) * 100, 2), 0), 1) as revenue_growth_percentage\nFROM t2\nORDER BY date\n\n\n\nІ наприкінці давайте спробуємо застосувати віконні функції на вирішення нетривіальної задачі.\nНасправді при розрахунку середніх значень аналітикам часто доводиться мати справу з екстремально малими чи екстремально великими значеннями у вибірках. Тому замість звичайного середнього іноді доводиться рахувати медіану.\nМедіана - це таке значення в деякому впорядкованому за зростанням наборі чисел, що одна половина елементів набору не менше за нього, а інша половина не більше. Тобто це таке число, що знаходиться десь у середині цього набору.\nНаведемо приклад. Допустимо, у нас є набір наступних чисел:\n1, 5, 2, 12, 17, 8, 50, 12, 9, 1, 3\nЯкщо ми впорядкуємо цей набір за зростанням, то отримаємо наступний числовий ряд:\n1, 1, 2, 3, 5, 8, 9, 12, 12, 17, 50\nДавайте пронумеруємо елементи впорядкованого набору:\nЧисловий ряд:\n1, 1, 2, 3, 5, 8, 9, 12, 12, 17, 50\n\nНомер елемента:\n1, 2, 3, 4, 5, 6, 7,  8,  9, 10, 11  \nТепер добре видно, що центральним елементом ряду є число 8 (елемент під номером 6), оскільки одна половина значень (елементи під номерами 1-5) не більша за 8, а друга половина (елементи під номерами 7-11) не менше 8. Таким чином, медіана нашого ряду дорівнює 8.\nАле це працює, коли ряд складається з непарної кількості елементів (у нас їх 11). Якщо ж у вибірці парне число елементів, тоді як медіану вважають середнє значення двох елементів, що у середині ряду.\nДавайте додамо до нашого ряду число 0 і подивимося, що в результаті вийде:\nЧисловий ряд:\n0, 1, 1, 2, 3, 5, 8, 9, 12, 12, 17, 50\n\nНомер елемента:\n1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12  \nТепер центральними є числа 5 та 8 (елементи під номерами 6 та 7). Медіана у цьому випадку дорівнює: \\[(5+8)/2=6.5\\]\nЗнову половина значень (елементи під номерами 1-5) не більше 6.5, а друга половина (елементи під номерами 7-11) не менше 6.5.\nТрапляються випадки, коли в ряді, що складається з парного числа елементів, граничними є два однакові значення. Давайте замінимо у нашому ряді число 8 на число 5:\nЧисловий ряд:\n0, 1, 1, 2, 3, 5, 5, 9, 12, 12, 17, 50\n\nНомер елемента:\n1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12  \nТепер медіаною буде число 5, оскільки: \\[(5+5)/2=5\\]\nНа цьому наш невеликий лікнеп добігає кінця, і ми повертаємося до практики.\n\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 14.16  За допомогою віконної функції розрахуйте медіанну вартість всіх замовлень із таблиці orders, оформлених у нашому сервісі. Як результат виведіть одне число. Назвіть колонку з ним median_price. Скасовані замовлення не враховуйте.\nПоле у результуючій таблиці: median_price\nПояснення:\nЗапит повинен враховувати два можливі сценарії: для парного та непарного числа замовлень. Вбудовані функції для розрахунку квантилей застосовувати не можна.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля розрахунку медіани необхідно впорядкувати та пронумерувати вартість замовлень, а потім вибрати необхідний елемент/елементи послідовності.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nWITH orders_prods AS (SELECT *,\n                             unnest(product_ids) AS product_id\n                      FROM orders),\n                      \ntotal AS (SELECT order_id,\n                SUM(p.price) AS order_price,\n                ROW_NUMBER() OVER(ORDER BY SUM(p.price)) AS number\n          FROM orders_prods AS o\n          JOIN products AS p ON o.product_id = p.product_id\n          \n          WHERE order_id NOT IN (SELECT order_id\n                             FROM user_actions\n                             WHERE action = 'cancel_order')\n          GROUP BY order_id),\n          \nmedian_numbers AS (SELECT CASE MAX(number) % 2 WHEN 0\n                                               THEN MAX(number) / 2\n                                               ELSE (MAX(number) +1) / 2 END AS number_1,\n                       \n                          CASE MAX(number) % 2 WHEN 0\n                                                THEN MAX(number) / 2 + 1    \n                                                END AS number_2\n                    FROM total),\n                    \nnumber_one AS (SELECT number_1\n                FROM median_numbers),\n                \n\nnumber_two AS (SELECT number_2\n                FROM median_numbers)\n                \nSELECT AVG(order_price) AS median_price\nFROM total\n\nWHERE number IN (SELECT *\n                FROM number_one\n                UNION SELECT *\n                FROM number_two)\n\n--- або\n-- WITH main_table AS (\n--   SELECT\n--     order_price,\n--     ROW_NUMBER() OVER (\n--       ORDER BY\n--         order_price\n--     ) AS row_number,\n--     COUNT(*) OVER() AS total_rows\n--   FROM\n--     (\n--       SELECT\n--         SUM(price) AS order_price\n--       FROM\n--         (\n--           SELECT\n--             order_id,\n--             product_ids,\n--             UNNEST(product_ids) AS product_id\n--           FROM\n--             orders\n--           WHERE\n--             order_id NOT IN (\n--               SELECT\n--                 order_id\n--               FROM\n--                 user_actions\n--               WHERE\n--                 action = 'cancel_order'\n--             )\n--         ) t3\n--         LEFT JOIN products USING(product_id)\n--       GROUP BY\n--         order_id\n--     ) t1\n-- )\n-- SELECT\n--   AVG(order_price) AS median_price\n-- FROM\n--   main_table\n-- WHERE\n--   row_number BETWEEN total_rows / 2.0\n--   AND total_rows / 2.0 + 1\n\n\n\n\n\n\n\n\n\nmedian_price"
  },
  {
    "objectID": "sql_analytic.html#задача-1",
    "href": "sql_analytic.html#задача-1",
    "title": "15  Практичні задачі",
    "section": "15.1 Задача 1",
    "text": "15.1 Задача 1\nДля початку давайте проаналізуємо, наскільки швидко зростає аудиторія нашого сервісу та подивимося на динаміку числа користувачів та кур’єрів.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 15.1  Для кожного дня, представленого в таблицях user_actions та courier_actions, розрахуйте такі показники:\n\nЧисло нових користувачів.\nЧисло нових кур’єрів.\nЗагальна кількість користувачів на сьогодні.\nЗагальна кількість кур’єрів на цей день.\n\nКолонки з показниками назвіть відповідно new_users, new_couriers, total_users, total_couriers. Колонку з датами назвіть date. Простежте, щоб показники були виражені цілими числами. Результат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, new_users, new_couriers, total_users, total_couriers\nПояснення:\nНовими вважатимемо тих користувачів та кур’єрів, які в цей день здійснили свою першу дію в нашому сервісі. Загальна кількість користувачів/кур’єрів на поточний день — це результат додавання числа нових користувачів/кур’єрів у поточний день зі значеннями аналогічного показника всіх попередніх днів.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nЩоб порахувати кількість нових користувачів/кур’єрів на кожну дату спочатку необхідно для кожного користувача/кур’єра визначити мінімальну дату, тобто дату першої дії в нашому сервісі. Потім потрібно провести групування і для кожної отриманої дати порахувати кількість користувачів/кур’єрів із цією датою. Далі до отриманої таблиці достатньо застосувати віконну функцію і кожної дати обчислити накопичувальну суму числа користувачів/кур’єрів.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT start_date as date,\n       new_users,\n       new_couriers,\n       (sum(new_users) OVER (ORDER BY start_date))::int as total_users,\n       (sum(new_couriers) OVER (ORDER BY start_date))::int as total_couriers\nFROM   (SELECT start_date,\n               count(courier_id) as new_couriers\n        FROM   (SELECT courier_id,\n                       min(time::date) as start_date\n                FROM   courier_actions\n                GROUP BY courier_id) t1\n        GROUP BY start_date) t2\n    LEFT JOIN (SELECT start_date,\n                      count(user_id) as new_users\n               FROM   (SELECT user_id,\n                              min(time::date) as start_date\n                       FROM   user_actions\n                       GROUP BY user_id) t3\n               GROUP BY start_date) t4 using (start_date)\n\n\n\n\n\n\n\n\n\ndate\nnew_users\nnew_couriers\ntotal_users\ntotal_couriers\n\n\n\n\n0\n2022-08-24\n134\n95\n134\n95\n\n\n1\n2022-08-25\n829\n242\n963\n337\n\n\n2\n2022-08-26\n1017\n219\n1980\n556\n\n\n3\n2022-08-27\n1225\n186\n3205\n742\n\n\n4\n2022-08-28\n1487\n213\n4692\n955\n\n\n5\n2022-08-29\n1309\n109\n6001\n1064\n\n\n6\n2022-08-30\n1204\n127\n7205\n1191\n\n\n7\n2022-08-31\n1420\n195\n8625\n1386\n\n\n8\n2022-09-01\n1513\n205\n10138\n1591\n\n\n9\n2022-09-02\n1887\n229\n12025\n1820\n\n\n10\n2022-09-03\n1924\n161\n13949\n1981\n\n\n11\n2022-09-04\n1952\n205\n15901\n2186\n\n\n12\n2022-09-05\n1397\n120\n17298\n2306\n\n\n13\n2022-09-06\n1020\n98\n18318\n2404\n\n\n14\n2022-09-07\n1412\n220\n19730\n2624\n\n\n15\n2022-09-08\n1671\n202\n21401\n2826\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results.\n\n\nКод\n%%sql\nresults &lt;&lt; SELECT start_date as date,\n       new_users,\n       new_couriers,\n       (sum(new_users) OVER (ORDER BY start_date))::int as total_users,\n       (sum(new_couriers) OVER (ORDER BY start_date))::int as total_couriers\nFROM   (SELECT start_date,\n               count(courier_id) as new_couriers\n        FROM   (SELECT courier_id,\n                       min(time::date) as start_date\n                FROM   courier_actions\n                GROUP BY courier_id) t1\n        GROUP BY start_date) t2\n    LEFT JOIN (SELECT start_date,\n                      count(user_id) as new_users\n               FROM   (SELECT user_id,\n                              min(time::date) as start_date\n                       FROM   user_actions\n                       GROUP BY user_id) t3\n               GROUP BY start_date) t4 using (start_date)\n\n\nПобудуємо візуалізацію за отриманими даними:\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=results.date, y=results.total_users, mode=\"lines+markers\", name=\"total_users\"\n    )\n)\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.total_couriers,\n        mode=\"lines+markers\",\n        name=\"total_couriers\",\n    )\n)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\nfig.show()\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=results.date, y=results.new_users, mode=\"lines+markers\", name=\"new_users\"\n    )\n)\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.new_couriers,\n        mode=\"lines+markers\",\n        name=\"new_couriers\",\n    )\n)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\nfig.show()\n\n\n\n\n\n\n                                                \n(a) Динаміка загальної кількості користувачів\n\n\n\n\n\n                                                \n(b) Динаміка нових користувачів та кур’єрів\n\n\n\nРисунок 15.1: Графік за результатами SQL-запиту\n\n\n\nПроаналізуйте побудовані графіки та спробуйте відповісти на такі питання:\n\nЩо зростає швидше: кількість користувачів чи кількість кур’єрів?\nНаскільки стабільні показники числа нових користувачів та кур’єрів? Чи немає даних таких днів, коли показники сильно вибивалися із загальної динаміки?\nЧи можна сказати, що кількість нових кур’єрів більш стабільна, ніж кількість нових користувачів?"
  },
  {
    "objectID": "sql_analytic.html#задача-2",
    "href": "sql_analytic.html#задача-2",
    "title": "15  Практичні задачі",
    "section": "15.2 Задача 2",
    "text": "15.2 Задача 2\nАналізуючи динаміку показників із попереднього завдання, ви могли помітити, що порівнювати абсолютні значення не дуже зручно. Давайте порахуємо динаміку показників у відносних величинах.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 15.2  Доповніть запит із попереднього завдання і тепер для кожного дня, поданого в таблицях user_actions та courier_actions, додатково розрахуйте такі показники:\n\nПриріст числа нових користувачів.\nПриріст числа нових кур’єрів.\nПриріст загальної кількості користувачів.\nПриріст загальної кількості кур’єрів.\n\nПоказники, розраховані на попередньому кроці, також включіть у результуючу таблицю.\nКолонки з новими показниками назвіть відповідно new_users_change, new_couriers_change, total_users_growth, total_couriers_growth. Колонку з датами назвіть date.\nУсі показники приросту рахуйте у відсотках відносно попереднього дня. Під час розрахунку показників округляйте значення до двох знаків після коми.\nРезультуюча таблиця має бути відсортована за зростанням дати.\nПоля в результуючій таблиці: date, new_users, new_couriers, total_users, total_couriers, new_users_change, new_couriers_change, total_users_growth, total_couriers_growth\nПояснення:\nНе забувайте при діленні заздалегідь наводити значення до потрібного типу даних. Пропущені значення приростів для першої дати не заповнюйте - просто залиште поля в цьому рядку порожніми.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля розрахунку приростів скористайтесь віконними функціями та функціями зсунення.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       new_users,\n       new_couriers,\n       total_users,\n       total_couriers,\n       round(100 * (new_users - lag(new_users, 1) OVER (ORDER BY date)) / lag(new_users, 1) OVER (ORDER BY date)::decimal,\n             2) as new_users_change,\n       round(100 * (new_couriers - lag(new_couriers, 1) OVER (ORDER BY date)) / lag(new_couriers, 1) OVER (ORDER BY date)::decimal,\n             2) as new_couriers_change,\n       round(100 * new_users::decimal / lag(total_users, 1) OVER (ORDER BY date),\n             2) as total_users_growth,\n       round(100 * new_couriers::decimal / lag(total_couriers, 1) OVER (ORDER BY date),\n             2) as total_couriers_growth\nFROM   (SELECT start_date as date,\n               new_users,\n               new_couriers,\n               (sum(new_users) OVER (ORDER BY start_date))::int as total_users,\n               (sum(new_couriers) OVER (ORDER BY start_date))::int as total_couriers\n        FROM   (SELECT start_date,\n                       count(courier_id) as new_couriers\n                FROM   (SELECT courier_id,\n                               min(time::date) as start_date\n                        FROM   courier_actions\n                        GROUP BY courier_id) t1\n                GROUP BY start_date) t2\n            LEFT JOIN (SELECT start_date,\n                              count(user_id) as new_users\n                       FROM   (SELECT user_id,\n                                      min(time::date) as start_date\n                               FROM   user_actions\n                               GROUP BY user_id) t3\n                       GROUP BY start_date) t4 using (start_date)) t5\n\n\n\n\n\n\n\n\n\ndate\nnew_users\nnew_couriers\ntotal_users\ntotal_couriers\nnew_users_change\nnew_couriers_change\ntotal_users_growth\ntotal_couriers_growth\n\n\n\n\n0\n2022-08-24\n134\n95\n134\n95\nNaN\nNaN\nNaN\nNaN\n\n\n1\n2022-08-25\n829\n242\n963\n337\n518.66\n154.74\n618.66\n254.74\n\n\n2\n2022-08-26\n1017\n219\n1980\n556\n22.68\n-9.50\n105.61\n64.99\n\n\n3\n2022-08-27\n1225\n186\n3205\n742\n20.45\n-15.07\n61.87\n33.45\n\n\n4\n2022-08-28\n1487\n213\n4692\n955\n21.39\n14.52\n46.40\n28.71\n\n\n5\n2022-08-29\n1309\n109\n6001\n1064\n-11.97\n-48.83\n27.90\n11.41\n\n\n6\n2022-08-30\n1204\n127\n7205\n1191\n-8.02\n16.51\n20.06\n11.94\n\n\n7\n2022-08-31\n1420\n195\n8625\n1386\n17.94\n53.54\n19.71\n16.37\n\n\n8\n2022-09-01\n1513\n205\n10138\n1591\n6.55\n5.13\n17.54\n14.79\n\n\n9\n2022-09-02\n1887\n229\n12025\n1820\n24.72\n11.71\n18.61\n14.39\n\n\n10\n2022-09-03\n1924\n161\n13949\n1981\n1.96\n-29.69\n16.00\n8.85\n\n\n11\n2022-09-04\n1952\n205\n15901\n2186\n1.46\n27.33\n13.99\n10.35\n\n\n12\n2022-09-05\n1397\n120\n17298\n2306\n-28.43\n-41.46\n8.79\n5.49\n\n\n13\n2022-09-06\n1020\n98\n18318\n2404\n-26.99\n-18.33\n5.90\n4.25\n\n\n14\n2022-09-07\n1412\n220\n19730\n2624\n38.43\n124.49\n7.71\n9.15\n\n\n15\n2022-09-08\n1671\n202\n21401\n2826\n18.34\n-8.18\n8.47\n7.70\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results.\n\n\nКод\n%%sql\nresults &lt;&lt; SELECT date,\n       new_users,\n       new_couriers,\n       total_users,\n       total_couriers,\n       round(100 * (new_users - lag(new_users, 1) OVER (ORDER BY date)) / lag(new_users, 1) OVER (ORDER BY date)::decimal,\n             2) as new_users_change,\n       round(100 * (new_couriers - lag(new_couriers, 1) OVER (ORDER BY date)) / lag(new_couriers, 1) OVER (ORDER BY date)::decimal,\n             2) as new_couriers_change,\n       round(100 * new_users::decimal / lag(total_users, 1) OVER (ORDER BY date),\n             2) as total_users_growth,\n       round(100 * new_couriers::decimal / lag(total_couriers, 1) OVER (ORDER BY date),\n             2) as total_couriers_growth\nFROM   (SELECT start_date as date,\n               new_users,\n               new_couriers,\n               (sum(new_users) OVER (ORDER BY start_date))::int as total_users,\n               (sum(new_couriers) OVER (ORDER BY start_date))::int as total_couriers\n        FROM   (SELECT start_date,\n                       count(courier_id) as new_couriers\n                FROM   (SELECT courier_id,\n                               min(time::date) as start_date\n                        FROM   courier_actions\n                        GROUP BY courier_id) t1\n                GROUP BY start_date) t2\n            LEFT JOIN (SELECT start_date,\n                              count(user_id) as new_users\n                       FROM   (SELECT user_id,\n                                      min(time::date) as start_date\n                               FROM   user_actions\n                               GROUP BY user_id) t3\n                       GROUP BY start_date) t4 using (start_date)) t5\n\n\nПобудуємо візуалізацію за отриманими даними:\n\nfig = go.Figure()\nfig.add_trace(\n    go.Bar(\n        x=results.date,\n        y=results.new_users_change,\n        name=\"new_users_change\",\n        marker_color=\"indianred\",\n    )\n)\nfig.add_trace(\n    go.Bar(\n        x=results.date,\n        y=results.new_couriers_change,\n        name=\"new_couriers_change\",\n        marker_color=\"lightsalmon\",\n    )\n)\n\nfig.update_layout(\n    barmode=\"group\",\n    xaxis_tickangle=-45,\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\nfig.show()\n\nfig = go.Figure()\nfig.add_trace(\n    go.Bar(\n        x=results.date,\n        y=results.total_users_growth,\n        name=\"total_users_growth\",\n        marker_color=\"indianred\",\n    )\n)\nfig.add_trace(\n    go.Bar(\n        x=results.date,\n        y=results.total_couriers_growth,\n        name=\"total_couriers_growth\",\n        marker_color=\"lightsalmon\",\n    )\n)\n\nfig.update_layout(\n    barmode=\"group\",\n    xaxis_tickangle=-45,\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\nfig.show()\n\n\n\n\n\n\n                                                \n(a) Динаміка приросту числа нових користувачів та кур’єрів\n\n\n\n\n\n                                                \n(b) Динаміка приросту загальної кількості користувачів та кур’єрів\n\n\n\nРисунок 15.2: Графік за результатами SQL-запиту\n\n\n\nПроаналізуйте побудовані графіки та спробуйте відповісти на такі питання:\n\nЯк змінилися темпи приросту загальної кількості користувачів і кур’єрів за проміжок часу, що розглядається? Яка загалом динаміка цих показників: вони ростуть чи, навпаки, згасають?\nУ які дні темп приросту числа нових кур’єрів помітно випереджав темп приросту нових користувачів?\nЧи можна, дивлячись на графіки з відносними показниками, сказати, що кількість нових кур’єрів більш стабільний, ніж показник числа нових користувачів?"
  },
  {
    "objectID": "sql_analytic.html#задача-3",
    "href": "sql_analytic.html#задача-3",
    "title": "15  Практичні задачі",
    "section": "15.3 Задача 3",
    "text": "15.3 Задача 3\nТепер пропонуємо вам подивитися на нашу аудиторію трохи під іншим кутом - давайте порахуємо не просто всіх користувачів, а саме ту частину, яка оформлює та оплачує замовлення у нашому сервісі. Заодно з’ясуємо, яку частку користувачі, що платять, становлять від їх загального числа.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 15.3  Для кожного дня, представленого в таблицях user_actions та courier_actions, розрахуйте такі показники:\n\nЧисло користувачів, які оплачують замовлення.\nЧисло активних кур’єрів.\nЧастку користувачів, що платять, в загальній кількості користувачів на поточний день.\nЧастку активних кур’єрів у кількості кур’єрів на поточний день.\n\nКолонки з показниками назвіть відповідно paying_users, active_couriers, paying_users_share, active_couriers_share. Колонку з датами назвіть date. Простежте, щоб абсолютні показники були виражені цілими числами. Усі показники часток необхідно виразити у відсотках. Під час їх розрахунку округляйте значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, paying_users, active_couriers, paying_users_share, active_couriers_share\nПояснення:\nКористувачів, які оплачують замовлення будемо вважати тих, які в даний день оформили хоча б одне замовлення, яке надалі не було скасовано.\nКур’єрів вважатимемо активними, якщо в даний день вони прийняли хоча б одне замовлення, яке було доставлено (можливо вже наступного дня), або доставили будь-яке замовлення.\nЗагальна кількість користувачів/кур’єрів на поточний день – це, як і раніше, результат складання числа нових користувачів/кур’єрів у поточний день зі значеннями аналогічного показника всіх попередніх днів. Ми рахували цей показник на попередніх кроках.\nНе забувайте при діленні заздалегідь наводити значення до потрібного типу даних.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання необхідно спочатку для кожного дня порахувати кількість користувачів, які оплачують замовлення, і активних кур’єрів, а потім об’єднати отримані таблиці з даними про загальну кількість користувачів і кур’єрів на поточну дату і далі розрахувати всі необхідні відносні показники. Загальну кількість користувачів та кур’єрів на поточну дату ми вже рахували раніше.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       paying_users,\n       active_couriers,\n       round(100 * paying_users::decimal / total_users, 2) as paying_users_share,\n       round(100 * active_couriers::decimal / total_couriers, 2) as active_couriers_share\nFROM   (SELECT start_date as date,\n               new_users,\n               new_couriers,\n               (sum(new_users) OVER (ORDER BY start_date))::int as total_users,\n               (sum(new_couriers) OVER (ORDER BY start_date))::int as total_couriers\n        FROM   (SELECT start_date,\n                       count(courier_id) as new_couriers\n                FROM   (SELECT courier_id,\n                               min(time::date) as start_date\n                        FROM   courier_actions\n                        GROUP BY courier_id) t1\n                GROUP BY start_date) t2\n            LEFT JOIN (SELECT start_date,\n                              count(user_id) as new_users\n                       FROM   (SELECT user_id,\n                                      min(time::date) as start_date\n                               FROM   user_actions\n                               GROUP BY user_id) t3\n                       GROUP BY start_date) t4 using (start_date)) t5\n    LEFT JOIN (SELECT time::date as date,\n                      count(distinct courier_id) as active_couriers\n               FROM   courier_actions\n               WHERE  order_id not in (SELECT order_id\n                                       FROM   user_actions\n                                       WHERE  action = 'cancel_order')\n               GROUP BY date) t6 using (date)\n    LEFT JOIN (SELECT time::date as date,\n                      count(distinct user_id) as paying_users\n               FROM   user_actions\n               WHERE  order_id not in (SELECT order_id\n                                       FROM   user_actions\n                                       WHERE  action = 'cancel_order')\n               GROUP BY date) t7 using (date)\n\n\n\n\n\n\n\n\n\ndate\npaying_users\nactive_couriers\npaying_users_share\nactive_couriers_share\n\n\n\n\n0\n2022-08-24\n127\n93\n94.78\n97.89\n\n\n1\n2022-08-25\n820\n333\n85.15\n98.81\n\n\n2\n2022-08-26\n1137\n526\n57.42\n94.60\n\n\n3\n2022-08-27\n1548\n721\n48.30\n97.17\n\n\n4\n2022-08-28\n2083\n927\n44.39\n97.07\n\n\n5\n2022-08-29\n2202\n1022\n36.69\n96.05\n\n\n6\n2022-08-30\n2253\n1133\n31.27\n95.13\n\n\n7\n2022-08-31\n2430\n1286\n28.17\n92.78\n\n\n8\n2022-09-01\n2710\n1474\n26.73\n92.65\n\n\n9\n2022-09-02\n3429\n1733\n28.52\n95.22\n\n\n10\n2022-09-03\n3794\n1906\n27.20\n96.21\n\n\n11\n2022-09-04\n4104\n2069\n25.81\n94.65\n\n\n12\n2022-09-05\n3362\n2047\n19.44\n88.77\n\n\n13\n2022-09-06\n2701\n1883\n14.75\n78.33\n\n\n14\n2022-09-07\n3517\n2245\n17.83\n85.56\n\n\n15\n2022-09-08\n3912\n2491\n18.28\n88.15\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results.\n\n\nКод\n%%sql\nresults &lt;&lt; SELECT date,\n       paying_users,\n       active_couriers,\n       round(100 * paying_users::decimal / total_users, 2) as paying_users_share,\n       round(100 * active_couriers::decimal / total_couriers, 2) as active_couriers_share\nFROM   (SELECT start_date as date,\n               new_users,\n               new_couriers,\n               (sum(new_users) OVER (ORDER BY start_date))::int as total_users,\n               (sum(new_couriers) OVER (ORDER BY start_date))::int as total_couriers\n        FROM   (SELECT start_date,\n                       count(courier_id) as new_couriers\n                FROM   (SELECT courier_id,\n                               min(time::date) as start_date\n                        FROM   courier_actions\n                        GROUP BY courier_id) t1\n                GROUP BY start_date) t2\n            LEFT JOIN (SELECT start_date,\n                              count(user_id) as new_users\n                       FROM   (SELECT user_id,\n                                      min(time::date) as start_date\n                               FROM   user_actions\n                               GROUP BY user_id) t3\n                       GROUP BY start_date) t4 using (start_date)) t5\n    LEFT JOIN (SELECT time::date as date,\n                      count(distinct courier_id) as active_couriers\n               FROM   courier_actions\n               WHERE  order_id not in (SELECT order_id\n                                       FROM   user_actions\n                                       WHERE  action = 'cancel_order')\n               GROUP BY date) t6 using (date)\n    LEFT JOIN (SELECT time::date as date,\n                      count(distinct user_id) as paying_users\n               FROM   user_actions\n               WHERE  order_id not in (SELECT order_id\n                                       FROM   user_actions\n                                       WHERE  action = 'cancel_order')\n               GROUP BY date) t7 using (date)\n\n\nПобудуємо візуалізацію за отриманими даними:\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.paying_users,\n        mode=\"lines+markers\",\n        name=\"paying_users\",\n    )\n)\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.active_couriers,\n        mode=\"lines+markers\",\n        name=\"active_couriers\",\n    )\n)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\nfig.show()\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.paying_users_share,\n        mode=\"lines+markers\",\n        name=\"paying_users_share\",\n    )\n)\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.active_couriers_share,\n        mode=\"lines+markers\",\n        name=\"active_couriers_share\",\n    )\n)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\nfig.show()\n\n\n\n\n\n\n                                                \n(a) Динаміка користувачів, які платять та активних кур’єрів:\n\n\n\n\n\n                                                \n(b) Динаміка часток користувачів, які платять та активних кур’єрів:\n\n\n\nРисунок 15.3: Графік за результатами SQL-запиту\n\n\n\nПроаналізуйте побудовані графіки та спробуйте відповісти на такі питання:\n\nЧи можна сказати, що разом із загальною кількістю користувачів і кур’єрів зростає кількість користувачів, що платять, і активних кур’єрів?\nЯк водночас поводяться показники часток користувачів, що платять, і активних кур’єрів? Чи можна вважати їхню поточну динаміку в цілому нормальною та закономірною?"
  },
  {
    "objectID": "sql_analytic.html#задача-4",
    "href": "sql_analytic.html#задача-4",
    "title": "15  Практичні задачі",
    "section": "15.4 Задача 4",
    "text": "15.4 Задача 4\nДавайте докладніше зупинимося на користувачах, які оплачують замовлення, копнем трохи глибше і з’ясуємо, як багато користувачів, які оплачують замовленняь, здійснюють більше одного замовлення в день. Зрештою нам важливо розуміти, як здебільшого поводяться наші користувачі — вони заходять у додаток, щоб зробити всього одне замовлення, або наш сервіс настільки хороший, що вони готові користуватися ним кілька разів на день.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 15.4  Для кожного дня, поданого в таблиці user_actions, розрахуйте такі показники:\n\nЧастку користувачів, які зробили в цей день всього одне замовлення, від загальної кількості користувачів, які оплачують замовлення.\nЧастку користувачів, які зробили цього дня кілька замовлень, від загальної кількості користувачів, які оплачують замовлення.\n\nНазвіть колонки з показниками відповідно single_order_users_share, several_orders_users_share. Колонку з датами назвіть date. Усі показники із частками необхідно виразити у відсотках. При розрахунку часток округляйте значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, single_order_users_share, several_orders_users_share\nПояснення:\nКористувачами, що оплачують замовлення, як і раніше, вважаємо тих користувачів, які в даний день оформили (і не скасували) хоча б одне замовлення.\nНе забувайте при діленні заздалегідь наводити значення до потрібного типу даних.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання спочатку необхідно для кожного дня окремо розрахувати загальну кількість користувачів, що оплачують замовлення, кількість користувачів з одним замовленням і кількість користувачів з кількома замовленнями. Потім необхідно поєднати таблиці з цими даними за датою та порахувати всі необхідні показники.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT day::date AS date,\n       ROUND(100 * COUNT(DISTINCT user_id) FILTER(WHERE count_orders = 1) / COUNT(DISTINCT user_id)::numeric, 2) AS single_order_users_share,\n       ROUND(100 * COUNT(DISTINCT user_id) FILTER(WHERE count_orders != 1) / COUNT(DISTINCT user_id)::numeric, 2) AS several_orders_users_share\nFROM(\n\nSELECT user_id,\n       COUNT(DISTINCT order_id) AS count_orders,\n       DATE_TRUNC('day', time) AS day\nFROM user_actions\nWHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')\nGROUP BY user_id, day\n) AS t1\nGROUP BY day\nORDER BY day\n\n\n\n\n\n\n\n\n\ndate\nsingle_order_users_share\nseveral_orders_users_share\n\n\n\n\n0\n2022-08-24\n92.91\n7.09\n\n\n1\n2022-08-25\n76.46\n23.54\n\n\n2\n2022-08-26\n78.45\n21.55\n\n\n3\n2022-08-27\n70.93\n29.07\n\n\n4\n2022-08-28\n67.83\n32.17\n\n\n5\n2022-08-29\n65.58\n34.42\n\n\n6\n2022-08-30\n64.67\n35.33\n\n\n7\n2022-08-31\n70.41\n29.59\n\n\n8\n2022-09-01\n71.70\n28.30\n\n\n9\n2022-09-02\n67.02\n32.98\n\n\n10\n2022-09-03\n63.94\n36.06\n\n\n11\n2022-09-04\n65.94\n34.06\n\n\n12\n2022-09-05\n69.96\n30.04\n\n\n13\n2022-09-06\n77.67\n22.33\n\n\n14\n2022-09-07\n72.65\n27.35\n\n\n15\n2022-09-08\n69.61\n30.39\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results:\n\n\nКод\n%%sql\nresults &lt;&lt; SELECT day::date AS date,\n       ROUND(100 * COUNT(DISTINCT user_id) FILTER(WHERE count_orders = 1) / COUNT(DISTINCT user_id)::numeric, 2) AS single_order_users_share,\n       ROUND(100 * COUNT(DISTINCT user_id) FILTER(WHERE count_orders != 1) / COUNT(DISTINCT user_id)::numeric, 2) AS several_orders_users_share\nFROM(\n\nSELECT user_id,\n       COUNT(DISTINCT order_id) AS count_orders,\n       DATE_TRUNC('day', time) AS day\nFROM user_actions\nWHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')\nGROUP BY user_id, day\n) AS t1\nGROUP BY day\nORDER BY day\n\n\nПобудуємо візуалізацію за отриманими даними:\n\nfig = go.Figure(\n    data=[\n        go.Bar(\n            name=\"single_order_users_share\",\n            x=results.date,\n            y=results.single_order_users_share,\n        ),\n        go.Bar(\n            name=\"several_orders_users_share\",\n            x=results.date,\n            y=results.several_orders_users_share,\n        ),\n    ]\n)\nfig.update_layout(\n    barmode=\"stack\",\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\nfig.show()\n\n\n\n                                                \nРисунок 15.4: Частки користувачів з одним та кількома замовленнями\n\n\n\nПроаналізуйте побудовані графіки та спробуйте відповісти на такі питання:\n\nНа якому рівні у середньому тримається частка користувачів із кількома замовленнями?\nЧи можна вважати значення показника в перший день аномально низьким, якщо взяти до уваги загальну кількість користувачів цього дня?"
  },
  {
    "objectID": "sql_analytic.html#задача-5",
    "href": "sql_analytic.html#задача-5",
    "title": "15  Практичні задачі",
    "section": "15.5 Задача 5",
    "text": "15.5 Задача 5\nПродовжимо вивчати наш сервіс та розрахуємо декілька показників, пов’язаних із замовленнями.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 15.5  Для кожного дня, поданого в таблиці user_actions, розрахуйте такі показники:\n\nЗагальна кількість замовлень.\nЧисло перших замовлень (замовлень, зроблених користувачами вперше).\nЧисло замовлень нових користувачів (замовлень, зроблених користувачами того ж дня, коли вони вперше скористалися сервісом).\nЧастку перших замовлень у кількості замовлень (частку п.2 в п.1).\nЧастку замовлень нових користувачів у кількості замовлень (частку п.3 в п.1).\n\nНазвіть колонки з показниками відповідно orders, first_orders, new_users_orders, first_orders_share, new_users_orders_share. Колонку з датами назвіть date. Простежте, щоб у всіх випадках кількість замовлень була виражена цілим числом. Усі показники із частками необхідно виразити у відсотках. При розрахунку часток округляйте значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, orders, first_orders, new_users_orders, first_orders_share, new_users_orders_share\nПояснення:\nПри розрахунку числа перших замовлень враховуйте, що у кожного користувача може бути лише одне перше замовлення (що цілком логічно).\nПри розрахунку числа замовлень нових користувачів враховуйте, що у свій перший день кожен новий користувач міг як зробити відразу кілька замовлень, так і не здійснити жодного.\nУ всіх випадках при розрахунку числа замовлень враховуйте лише фактично здійснені замовлення, скасовані замовлення не враховуйте.\nНе забувайте при діленні заздалегідь приводити значення до потрібного типу даних.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання спочатку необхідно для кожного дня окремо розрахувати загальну кількість замовлень, кількість перших замовлень і кількість замовлень нових користувачів, а потім об’єднати отримані таблиці в одну і порахувати всі відносні показники. Для розрахунку числа перших замовлень для кожного користувача потрібно знайти дату оформлення першого нескасованого замовлення і потім здійснити групування за датою, порахувавши для кожного дня кількість користувачів, які зробили перше замовлення. Для розрахунку числа замовлень нових користувачів спочатку потрібно для кожного користувача знайти дату здійснення першої дії, а потім доповнити цю таблицю даними про кількість замовлень, зроблених користувачем свого першого дня. Це можна зробити, приєднавши до таблиці з датами перших дій таблицю із загальною кількістю замовлень на кожну дату для кожного користувача. Зверніть увагу, що в цій таблиці для деяких користувачів можуть бути відсутні дати здійснення першої дії оскільки користувач міг скасувати замовлення і фактично не здійснити жодної покупки свого першого дня. Після об’єднання таблиць для таких днів із пропущеними значеннями слід вказати кількість замовлень рівним 0. Це можна зробити, наприклад, за допомогою функції COALESCE.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date, orders, first_orders, new_users_orders::int as new_users_orders,\n        ROUND(100 * first_orders::decimal / orders, 2) AS first_orders_share,\n        ROUND(100 * new_users_orders::decimal / orders, 2) AS new_users_orders_share\n    FROM (\n        SELECT creation_time::date AS date, COUNT(DISTINCT order_id) AS orders\n        FROM orders\n        WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order')\n        AND order_id IN (SELECT order_id FROM courier_actions WHERE action='deliver_order')\n        GROUP BY date\n    ) t5\n    LEFT JOIN (\n        SELECT first_order_date AS date, COUNT(user_id) AS first_orders\n        FROM (\n            SELECT user_id, MIN(time::date) AS first_order_date\n            FROM user_actions\n            WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order')\n            GROUP BY user_id\n        ) t4\n        GROUP BY first_order_date\n    ) t7\n    USING (date)\n    LEFT JOIN (\n        SELECT start_date AS date, SUM(orders) AS new_users_orders\n        FROM (\n            SELECT t1.user_id, t1.start_date, COALESCE(t2.orders, 0) AS orders\n            FROM (\n                SELECT user_id, MIN(time::date) AS start_date\n                FROM user_actions\n                GROUP BY user_id\n            ) t1\n            LEFT JOIN (\n                SELECT user_id, time::date AS date, COUNT(DISTINCT order_id) AS orders\n                FROM user_actions\n                WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order')\n                GROUP BY user_id, date\n            ) t2\n            ON t1.user_id = t2.user_id AND t1.start_date = t2.date\n        ) t3\n        GROUP BY start_date\n    ) t6\n    USING (date)\n    ORDER BY date\n\n\n\n\n\n\n\n\n\ndate\norders\nfirst_orders\nnew_users_orders\nfirst_orders_share\nnew_users_orders_share\n\n\n\n\n0\n2022-08-24\n138\n127\n138\n92.03\n100.00\n\n\n1\n2022-08-25\n1059\n802\n1032\n75.73\n97.45\n\n\n2\n2022-08-26\n1447\n984\n1250\n68.00\n86.39\n\n\n3\n2022-08-27\n2141\n1192\n1624\n55.67\n75.85\n\n\n4\n2022-08-28\n2998\n1460\n2102\n48.70\n70.11\n\n\n5\n2022-08-29\n3267\n1281\n1832\n39.21\n56.08\n\n\n6\n2022-08-30\n3371\n1180\n1714\n35.00\n50.85\n\n\n7\n2022-08-31\n3410\n1380\n1908\n40.47\n55.95\n\n\n8\n2022-09-01\n3688\n1492\n1988\n40.46\n53.90\n\n\n9\n2022-09-02\n5001\n1864\n2655\n37.27\n53.09\n\n\n10\n2022-09-03\n5709\n1907\n2830\n33.40\n49.57\n\n\n11\n2022-09-04\n6010\n1943\n2763\n32.33\n45.97\n\n\n12\n2022-09-05\n4675\n1387\n1865\n29.67\n39.89\n\n\n13\n2022-09-06\n3451\n1012\n1264\n29.32\n36.63\n\n\n14\n2022-09-07\n4777\n1416\n1865\n29.64\n39.04\n\n\n15\n2022-09-08\n5474\n1661\n2300\n30.34\n42.02\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results:\n\n\nКод\n%%sql\nresults &lt;&lt; SELECT date, orders, first_orders, new_users_orders::int as new_users_orders,\n        ROUND(100 * first_orders::decimal / orders, 2) AS first_orders_share,\n        ROUND(100 * new_users_orders::decimal / orders, 2) AS new_users_orders_share\n    FROM (\n        SELECT creation_time::date AS date, COUNT(DISTINCT order_id) AS orders\n        FROM orders\n        WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order')\n        AND order_id IN (SELECT order_id FROM courier_actions WHERE action='deliver_order')\n        GROUP BY date\n    ) t5\n    LEFT JOIN (\n        SELECT first_order_date AS date, COUNT(user_id) AS first_orders\n        FROM (\n            SELECT user_id, MIN(time::date) AS first_order_date\n            FROM user_actions\n            WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order')\n            GROUP BY user_id\n        ) t4\n        GROUP BY first_order_date\n    ) t7\n    USING (date)\n    LEFT JOIN (\n        SELECT start_date AS date, SUM(orders) AS new_users_orders\n        FROM (\n            SELECT t1.user_id, t1.start_date, COALESCE(t2.orders, 0) AS orders\n            FROM (\n                SELECT user_id, MIN(time::date) AS start_date\n                FROM user_actions\n                GROUP BY user_id\n            ) t1\n            LEFT JOIN (\n                SELECT user_id, time::date AS date, COUNT(DISTINCT order_id) AS orders\n                FROM user_actions\n                WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order')\n                GROUP BY user_id, date\n            ) t2\n            ON t1.user_id = t2.user_id AND t1.start_date = t2.date\n        ) t3\n        GROUP BY start_date\n    ) t6\n    USING (date)\n    ORDER BY date\n\n\nПобудуємо візуалізацію за отриманими даними:\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(x=results.date, y=results.orders, mode=\"lines+markers\", name=\"orders\")\n)\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.first_orders,\n        mode=\"lines+markers\",\n        name=\"first_orders\",\n    )\n)\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.new_users_orders,\n        mode=\"lines+markers\",\n        name=\"new_users_orders\",\n    )\n)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\nfig.show()\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.first_orders_share,\n        mode=\"lines+markers\",\n        name=\"first_orders_share\",\n    )\n)\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.new_users_orders_share,\n        mode=\"lines+markers\",\n        name=\"new_users_orders_share\",\n    )\n)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\nfig.show()\n\n\n\n\n\n\n                                                \n(a) Динаміка загальної кількості замовлень, числа перших замовлень та числа замовлень нових користувачів\n\n\n\n\n\n                                                \n(b) Динаміка частки перших замовлень та частки замовлень нових користувачів у кількості замовлень\n\n\n\nРисунок 15.5: Графік за результатами SQL-запиту\n\n\n\nПроаналізуйте побудовані графіки та спробуйте відповісти на такі питання:\n\nЯка загалом динаміка у абсолютних показників? Чи можна сказати, що разом із зростанням кількості всіх замовлень зростають показники числа перших замовлень та кількості замовлень нових користувачів?\nЩо можна сказати про динаміку відносних показників? Чи можна вважати її загалом закономірною? Як, на ваш погляд, поводитимуться ці показники у довгостроковій перспективі: вони зростатимуть чи знижуватимуться?"
  },
  {
    "objectID": "sql_analytic.html#задача-6",
    "href": "sql_analytic.html#задача-6",
    "title": "15  Практичні задачі",
    "section": "15.6 Задача 6",
    "text": "15.6 Задача 6\nТепер давайте спробуємо приблизно оцінити навантаження на наших кур’єрів і дізнаємося, скільки в середньому замовлень та користувачів припадає на кожного з них.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 15.6  На основі даних у таблицях user_actions, courier_actions та orders для кожного дня розрахуйте такі показники:\n\nКількість користувачів, що оплатили замовлення на одного активного кур’єра.\nКількість замовлень на одного активного кур’єра.\n\nКолонки з показниками назвіть відповідно users_per_courier та orders_per_courier. Колонку з датами назвіть date. Під час розрахунку показників округляйте значення до двох знаків після коми.\nРезультуюча таблиця має бути відсортована за зростанням дати.\nПоля в результуючій таблиці: date, users_per_courier, orders_per_courier\nПояснення:\nКористувачів, що оплатили замовлення, як і раніше, вважаємо тих користувачів, які в даний день оформили хоча б одне замовлення, яке надалі не було скасовано.\nКур’єрів вважаємо активними, якщо в даний день вони прийняли хоча б одне замовлення, яке було доставлено (можливо вже наступного дня), або доставили будь-яке замовлення.\nУ розрахунках враховуйте лише нескасовані замовлення.\nНе забувайте при діленні заздалегідь наводити значення до потрібного типу даних.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання спочатку необхідно за допомогою групування та агрегації розрахувати кількість користувачів, кур’єрів та замовлень на кожну дату, а потім об’єднати дані в одну таблицю та провести всі необхідні розрахунки.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       round(paying_users::decimal / couriers, 2) as users_per_courier,\n       round(orders::decimal / couriers, 2) as orders_per_courier\nFROM   (SELECT time::date as date,\n               count(distinct courier_id) as couriers\n        FROM   courier_actions\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')\n        GROUP BY date) t1 join (SELECT creation_time::date as date,\n                               count(distinct order_id) as orders\n                        FROM   orders\n                        WHERE  order_id not in (SELECT order_id\n                                                FROM   user_actions\n                                                WHERE  action = 'cancel_order')\n                        GROUP BY date) t2 using (date) join (SELECT time::date as date,\n                                            count(distinct user_id) as paying_users\n                                     FROM   user_actions\n                                     WHERE  order_id not in (SELECT order_id\n                                                             FROM   user_actions\n                                                             WHERE  action = 'cancel_order')\n                                     GROUP BY date) t3 using (date)\nORDER BY date\n\n\n\n\n\n\n\n\n\ndate\nusers_per_courier\norders_per_courier\n\n\n\n\n0\n2022-08-24\n1.37\n1.48\n\n\n1\n2022-08-25\n2.46\n3.18\n\n\n2\n2022-08-26\n2.16\n2.75\n\n\n3\n2022-08-27\n2.15\n2.97\n\n\n4\n2022-08-28\n2.25\n3.23\n\n\n5\n2022-08-29\n2.15\n3.20\n\n\n6\n2022-08-30\n1.99\n2.98\n\n\n7\n2022-08-31\n1.89\n2.65\n\n\n8\n2022-09-01\n1.84\n2.50\n\n\n9\n2022-09-02\n1.98\n2.89\n\n\n10\n2022-09-03\n1.99\n3.00\n\n\n11\n2022-09-04\n1.98\n2.90\n\n\n12\n2022-09-05\n1.64\n2.28\n\n\n13\n2022-09-06\n1.43\n1.83\n\n\n14\n2022-09-07\n1.57\n2.13\n\n\n15\n2022-09-08\n1.57\n2.20\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results:\n\n\nКод\n%%sql\nresults &lt;&lt; SELECT date,\n       round(paying_users::decimal / couriers, 2) as users_per_courier,\n       round(orders::decimal / couriers, 2) as orders_per_courier\nFROM   (SELECT time::date as date,\n               count(distinct courier_id) as couriers\n        FROM   courier_actions\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')\n        GROUP BY date) t1 join (SELECT creation_time::date as date,\n                               count(distinct order_id) as orders\n                        FROM   orders\n                        WHERE  order_id not in (SELECT order_id\n                                                FROM   user_actions\n                                                WHERE  action = 'cancel_order')\n                        GROUP BY date) t2 using (date) join (SELECT time::date as date,\n                                            count(distinct user_id) as paying_users\n                                     FROM   user_actions\n                                     WHERE  order_id not in (SELECT order_id\n                                                             FROM   user_actions\n                                                             WHERE  action = 'cancel_order')\n                                     GROUP BY date) t3 using (date)\nORDER BY date\n\n\nПобудуємо візуалізацію за отриманими даними:\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.users_per_courier,\n        mode=\"lines+markers\",\n        name=\"users_per_courier\",\n    )\n)\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.orders_per_courier,\n        mode=\"lines+markers\",\n        name=\"orders_per_courier\",\n    )\n)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\nfig.show()\n\n\n\n                                                \nРисунок 15.6: Динаміка числа користувачів та замовлень на одного кур’єра\n\n\n\nПроаналізуйте побудовані графіки та спробуйте відповісти на такі питання:\n\nЧи збігається загалом динаміка аналізованих показників? Якщо так, то чому так відбувається?\nЯк змінюються показники? Вони швидше зростають чи, навпаки, падають? Про що може говорити така динаміка?\nЯк ви вважаєте, чи високе навантаження у кур’єрів нашого сервісу? Чи варто сервісу продовжувати збільшувати кількість кур’єрів чи, навпаки, зараз краще призупинити нарощування їх чисельності?"
  },
  {
    "objectID": "sql_analytic.html#задача-7",
    "href": "sql_analytic.html#задача-7",
    "title": "15  Практичні задачі",
    "section": "15.7 Задача 7",
    "text": "15.7 Задача 7\nРозрахуємо ще один корисний показник, що характеризує якість роботи кур’єрів.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 15.7  На основі даних у таблиці courier_actions для кожного дня розрахуйте, за скільки хвилин у середньому кур’єри доставляли свої замовлення.\nНазвіть колонку з показником minutes_to_deliver. Колонку з датами назвіть date. При розрахунку середнього часу доставки округляйте кількість хвилин до цілих значень. Враховуйте лише доставлені замовлення, скасовані замовлення не враховуйте.\nРезультуюча таблиця має бути відсортована за зростанням дати.\nПоля в результуючій таблиці: date, minutes_to_deliver\nПояснення:\nДля вирішення завдання вам, можливо, доведеться згадати, як визначити кількість хвилин, що містяться в інтервалі часу. Ми вже вирішували схожу задачу у завданні 14.7.\nДеякі замовлення оформляють одного дня, а доставляють вже наступного. При розрахунку середнього часу доставки в якості днів, для яких рахується середнє, використовуйте дні фактичної доставки замовлень.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання спочатку необхідно за допомогою групування та агрегації для кожного замовлення розрахувати час прийняття замовлення кур’єром (мінімальна позначка часу) та час доставки (максимальна позначка часу), обчислити різницю між цими значеннями та за допомогою функції EXTRACT витягти з неї секунди (epoch), перевівши їх за хвилини. Потім можна провести групування за датою доставки та обчислити середній час доставки у кожний із днів.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       round(avg(delivery_time))::int as minutes_to_deliver\nFROM   (SELECT order_id,\n               max(time::date) as date,\n               extract(epoch\n        FROM   max(time) - min(time))/60 as delivery_time\n        FROM   courier_actions\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')\n        GROUP BY order_id) t\nGROUP BY date\nORDER BY date\n\n\n\n\n\n\n\n\n\ndate\nminutes_to_deliver\n\n\n\n\n0\n2022-08-24\n20\n\n\n1\n2022-08-25\n20\n\n\n2\n2022-08-26\n20\n\n\n3\n2022-08-27\n20\n\n\n4\n2022-08-28\n20\n\n\n5\n2022-08-29\n20\n\n\n6\n2022-08-30\n20\n\n\n7\n2022-08-31\n20\n\n\n8\n2022-09-01\n20\n\n\n9\n2022-09-02\n20\n\n\n10\n2022-09-03\n20\n\n\n11\n2022-09-04\n20\n\n\n12\n2022-09-05\n20\n\n\n13\n2022-09-06\n20\n\n\n14\n2022-09-07\n20\n\n\n15\n2022-09-08\n20\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results:\n\n\nКод\n%%sql\nresults &lt;&lt; SELECT date,\n       round(avg(delivery_time))::int as minutes_to_deliver\nFROM   (SELECT order_id,\n               max(time::date) as date,\n               extract(epoch\n        FROM   max(time) - min(time))/60 as delivery_time\n        FROM   courier_actions\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')\n        GROUP BY order_id) t\nGROUP BY date\nORDER BY date\n\n\nВізуалізуємо отримані дані:\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=results.date,\n        y=results.minutes_to_deliver,\n        mode=\"lines+markers\",\n        name=\"users_per_courier\",\n    )\n)\nfig.show()\n\n\n\n                                                \nРисунок 15.7: Динаміка середнього часу доставки замовлень\n\n\n\nПроаналізуйте побудований графік та спробуйте відповісти на наступні питання:\n\nЯкий, найімовірніше, час очікування доставки замовлення в нашому сервісі?\nЧи вдається кур’єрам дотримуватися цього цільового показника?"
  },
  {
    "objectID": "sql_analytic.html#задача-8",
    "href": "sql_analytic.html#задача-8",
    "title": "15  Практичні задачі",
    "section": "15.8 Задача 8",
    "text": "15.8 Задача 8\nІ нарешті, давайте оцінимо погодинне навантаження на наш сервіс, з’ясуємо, в які години користувачі оформлюють найбільше замовлень, і заразом проаналізуємо, як змінюється частка скасування залежно від часу оформлення замовлення.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 15.8  На основі даних у таблиці orders для кожної години на добу розрахуйте такі показники:\n\nЧисло успішних (доставлених) замовлень.\nЧисло скасованих замовлень.\nЧастку скасованих замовлень у загальній кількості замовлень (cancel rate).\n\nКолонки з показниками назвіть відповідно successful_orders, canceled_orders, cancel_rate. Колонку із годиною оформлення замовлення назвіть hour. При розрахунку частки скасованих замовлень округляйте значення до трьох знаків після коми.\nРезультуюча таблиця має бути відсортована за зростанням колонки з годиною оформлення замовлення.\nПоля в результуючій таблиці: hour, successful_orders, canceled_orders, cancel_rate\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання можна спочатку за допомогою групування за датою та агрегацією окремо розрахувати кількість успішних та скасованих замовлень, потім об’єднати дві таблиці в одну за датою і потім розрахувати cancel rate.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT hour,\n       successful_orders,\n       canceled_orders,\n       round(canceled_orders::decimal / (successful_orders + canceled_orders),\n             3) as cancel_rate\nFROM   (SELECT date_part('hour', creation_time)::int as hour,\n               count(order_id) as successful_orders\n        FROM   orders\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')\n        GROUP BY hour) t1\n    LEFT JOIN (SELECT date_part('hour', creation_time)::int as hour,\n                      count(order_id) as canceled_orders\n               FROM   orders\n               WHERE  order_id in (SELECT order_id\n                                   FROM   user_actions\n                                   WHERE  action = 'cancel_order')\n               GROUP BY hour) t2 using (hour)\nORDER BY hour\n\n\n\n\n\n\n\n\n\nhour\nsuccessful_orders\ncanceled_orders\ncancel_rate\n\n\n\n\n0\n0\n2297\n139\n0.057\n\n\n1\n1\n1867\n98\n0.050\n\n\n2\n2\n1422\n62\n0.042\n\n\n3\n3\n958\n56\n0.055\n\n\n4\n4\n926\n48\n0.049\n\n\n5\n5\n1363\n77\n0.053\n\n\n6\n6\n1583\n101\n0.060\n\n\n7\n7\n2101\n100\n0.045\n\n\n8\n8\n2195\n117\n0.051\n\n\n9\n9\n2606\n151\n0.055\n\n\n10\n10\n2641\n135\n0.049\n\n\n11\n11\n2584\n121\n0.045\n\n\n12\n12\n2440\n124\n0.048\n\n\n13\n13\n2424\n122\n0.048\n\n\n14\n14\n2351\n120\n0.049\n\n\n15\n15\n2513\n128\n0.048\n\n\n16\n16\n2480\n158\n0.060\n\n\n17\n17\n2966\n168\n0.054\n\n\n18\n18\n3149\n162\n0.049\n\n\n19\n19\n3496\n189\n0.051\n\n\n20\n20\n3414\n163\n0.046\n\n\n21\n21\n3197\n172\n0.051\n\n\n22\n22\n2978\n127\n0.041\n\n\n23\n23\n2665\n141\n0.050\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results:\n\n\nКод\n%%sql\nresults &lt;&lt; SELECT hour,\n       successful_orders,\n       canceled_orders,\n       round(canceled_orders::decimal / (successful_orders + canceled_orders),\n             3) as cancel_rate\nFROM   (SELECT date_part('hour', creation_time)::int as hour,\n               count(order_id) as successful_orders\n        FROM   orders\n        WHERE  order_id not in (SELECT order_id\n                                FROM   user_actions\n                                WHERE  action = 'cancel_order')\n        GROUP BY hour) t1\n    LEFT JOIN (SELECT date_part('hour', creation_time)::int as hour,\n                      count(order_id) as canceled_orders\n               FROM   orders\n               WHERE  order_id in (SELECT order_id\n                                   FROM   user_actions\n                                   WHERE  action = 'cancel_order')\n               GROUP BY hour) t2 using (hour)\nORDER BY hour\n\n\nВізуалізуємо отримані дані:\n\nfrom plotly.subplots import make_subplots\n\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\nfig.add_trace(\n    go.Bar(\n        name=\"successful_orders\",\n        x=results.hour,\n        y=results.successful_orders,\n        offsetgroup=1,\n    ),\n    secondary_y=False,\n)\nfig.add_trace(\n    go.Bar(\n        name=\"canceled_orders\", x=results.hour, y=results.canceled_orders, offsetgroup=1\n    ),\n    secondary_y=False,\n)\nfig.add_trace(\n    go.Scatter(\n        name=\"cancel_rate\", x=results.hour, y=results.cancel_rate, offsetgroup=2\n    ),\n    secondary_y=True,\n)\nfig.update_yaxes(rangemode=\"tozero\", secondary_y=True)\nfig.update_layout(\n    barmode=\"stack\",\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\n\nfig.show()\n\n\n\n                                                \nРисунок 15.8: Динаміка показника cancel rate та числа успішних/скасованих замовлень:\n\n\n\nПроаналізуйте побудований графік та спробуйте відповісти на такі питання:\n\nВ які години спостерігаються пікові значення числа замовлень? В які години користувачі здійснюють найменше замовлень?\nЧи простежується якийсь взаємозв’язок між кількістю оформлених замовлень і часткою скасованих замовлень? Чи зростає зі збільшенням числа замовлень показник cancel rate?"
  },
  {
    "objectID": "sql_analytic.html#побудова-дашборду",
    "href": "sql_analytic.html#побудова-дашборду",
    "title": "15  Практичні задачі",
    "section": "15.9 Побудова дашборду",
    "text": "15.9 Побудова дашборду\nЗдається, ми порахували вже багато різних показників і збудували достатньо графіків, щоб зібрати з них повноцінний дашборд!\nПобудова дашбордів — творче завдання, тому ми не нічим вас обмежуватимемо. Можете вигадати свої візуалізації, додати графіки з лекції і навіть порахувати свої метрики. Головне — не забувайте про те, що дашборди мають бути зрозумілими та зручними для користувачів.\n\n\n\n\n\n\n                                                \n(a) New Users and Couriers by Date\n\n\n\n\n\n                                                \n(b) Total Users and Couriers Growth\n\n\n\n\n\n                                                \n(c) New Users and Couriers Change by Date, %\n\n\n\n\n\n\n\n                                                \n(d) Total Users and Couriers Change by Date, %\n\n\n\n\n\n                                                \n(e) Paying Users and Active Couriers\n\n\n\n\n\n                                                \n(f) Orders, First Orders and Orders of New Users by Date\n\n\n\n\n\n\n\n                                                \n(g) Paying Users and Active Couriers Share, %\n\n\n\n\n\n                                                \n(h) First Orders and Orders of New Users Share, %\n\n\n\n\n\n                                                \n(i) Single Order Users and Several Orders Users Share, %\n\n\n\n\n\n\n\n                                                \n(j) Orders by Hour\n\n\n\n\n\n                                                \n(k) Users and Orders per Courier\n\n\n\n\n\n                                                \n(l) Average Delivery Time by Date\n\n\n\nРисунок 15.9: Приклад дашборду з результатами SQL-запитів"
  },
  {
    "objectID": "sql_metrics.html#виручка",
    "href": "sql_metrics.html#виручка",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.1 Виручка",
    "text": "16.1 Виручка\nПочнемо з виручки - найбільш загального показника, який покаже, який дохід приносить наш сервіс.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.1  Для кожного дня в таблиці orders розрахуйте такі показники:\n\nВиручку, одержану в цей день.\nСумарний виторг на поточний день.\nПриріст виручки, отриманої цього дня, щодо значення виручки за попередній день.\n\nКолонки з показниками назвіть відповідно revenue, total_revenue, revenue_change. Колонку з датами назвіть date.\nПриріст виручки розрахуйте у відсотках та округліть значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, revenue, total_revenue, revenue_change\nПояснення:\nВважатимемо, що оплата за замовлення надходить відразу після його оформлення, тобто випадки, коли замовлення було оформлено в один день, а оплата отримана наступного, виникнути не можуть.\nСумарна виручка на поточний день – це результат складання виручки, отриманої поточного дня, зі значеннями аналогічного показника всіх попередніх днів.\nПри розрахунку виручки пам’ятайте, що не всі замовлення були сплачені, деякі були скасовані користувачами.\nНе забувайте при діленні заздалегідь переводити значення до потрібного типу даних. Пропущені значення приросту для першої дати не заповнюйте - просто залиште поля в цьому рядку порожніми.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання вам знадобиться інформація про замовлення з таблиці orders та ціни на товари з таблиці products. Щоб порахувати виторг для кожного дня, спочатку необхідно порахувати вартість кожного замовлення. Це можна зробити, склавши ціни товарів, що входять на замовлення. Щоб правильно приєднати дані про ціни на товари, списки із вмістом замовлень потрібно попередньо розширити за допомогою функції unnest. Після того як для кожного дня буде порахована сумарна вартість усіх замовлень (виручка), за допомогою віконних функцій можна порахувати суму наростаючим підсумком (загальну виручку) та приріст виручки (різницю між виручкою в поточний день та виручкою в попередній день, поділену на виручку в попередній день).\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       revenue,\n       sum(revenue) OVER (ORDER BY date) as total_revenue,\n       round(100 * (revenue - lag(revenue, 1) OVER (ORDER BY date))::decimal / lag(revenue, 1) OVER (ORDER BY date),\n             2) as revenue_change\nFROM   (SELECT creation_time::date as date,\n               sum(price) as revenue\n        FROM   (SELECT creation_time,\n                       unnest(product_ids) as product_id\n                FROM   orders\n                WHERE  order_id not in (SELECT order_id\n                                        FROM   user_actions\n                                        WHERE  action = 'cancel_order')) t1\n            LEFT JOIN products using (product_id)\n        GROUP BY date) t2\n\n\n\n\n\n\n\n\n\ndate\nrevenue\ntotal_revenue\nrevenue_change\n\n\n\n\n0\n2022-08-24\n49924.0\n49924.0\nNaN\n\n\n1\n2022-08-25\n430860.0\n480784.0\n763.03\n\n\n2\n2022-08-26\n534766.0\n1015550.0\n24.12\n\n\n3\n2022-08-27\n817053.0\n1832603.0\n52.79\n\n\n4\n2022-08-28\n1133370.0\n2965973.0\n38.71\n\n\n5\n2022-08-29\n1279891.0\n4245864.0\n12.93\n\n\n6\n2022-08-30\n1279377.0\n5525241.0\n-0.04\n\n\n7\n2022-08-31\n1312720.0\n6837961.0\n2.61\n\n\n8\n2022-09-01\n1406101.0\n8244062.0\n7.11\n\n\n9\n2022-09-02\n1907107.0\n10151169.0\n35.63\n\n\n10\n2022-09-03\n2210988.0\n12362157.0\n15.93\n\n\n11\n2022-09-04\n2294009.0\n14656166.0\n3.75\n\n\n12\n2022-09-05\n1784690.0\n16440856.0\n-22.20\n\n\n13\n2022-09-06\n1330931.0\n17771787.0\n-25.43\n\n\n14\n2022-09-07\n1807800.0\n19579587.0\n35.83\n\n\n15\n2022-09-08\n2099508.0\n21679095.0\n16.14\n\n\n\n\n\n\n\nЗапишемо результат запиту у змінну results_1.\n\n\nКод\n%%sql\nresults_1 &lt;&lt; SELECT date,\n       revenue,\n       sum(revenue) OVER (ORDER BY date) as total_revenue,\n       round(100 * (revenue - lag(revenue, 1) OVER (ORDER BY date))::decimal / lag(revenue, 1) OVER (ORDER BY date),\n             2) as revenue_change\nFROM   (SELECT creation_time::date as date,\n               sum(price) as revenue\n        FROM   (SELECT creation_time,\n                       unnest(product_ids) as product_id\n                FROM   orders\n                WHERE  order_id not in (SELECT order_id\n                                        FROM   user_actions\n                                        WHERE  action = 'cancel_order')) t1\n            LEFT JOIN products using (product_id)\n        GROUP BY date) t2\n\n\nПобудуємо візуалізацію за отриманими даними:\n\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\nfig.add_trace(\n    go.Bar(\n        name=\"revenue_change\",\n        x=results_1.date,\n        y=results_1.revenue_change,\n        offsetgroup=1,\n    ),\n    secondary_y=False,\n)\n\nfig.add_trace(\n    go.Scatter(name=\"revenue\", x=results_1.date, y=results_1.revenue, offsetgroup=2),\n    secondary_y=True,\n)\nfig.update_yaxes(rangemode=\"tozero\", secondary_y=True)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\n\nfig.show()\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=results_1.date,\n        y=results_1.total_revenue,\n        mode=\"lines+markers\",\n        name=\"total_revenue\",\n    )\n)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\nfig.show()\n\n\n\n\n\n\n                                                \n(a) Динаміка щоденної виручки\n\n\n\n\n\n                                                \n(b) Динаміка загальної виручки\n\n\n\nРисунок 16.1: Графік за результатами SQL-запиту\n\n\n\nПроаналізуйте побудовані графіки та спробуйте відповісти на такі питання:\n\nЯкі дні спостерігалося помітне зниження щоденної виручки?\nІз чим це могло бути пов’язане?"
  },
  {
    "objectID": "sql_metrics.html#arpu-arppu-та-aov",
    "href": "sql_metrics.html#arpu-arppu-та-aov",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.2 ARPU, ARPPU та AOV",
    "text": "16.2 ARPU, ARPPU та AOV\nТепер на основі даних про виторг розрахуємо кілька відносних показників, які покажуть, скільки в середньому споживачі готові платити за послуги нашого сервісу доставки. Зупинимося на наступних метриках:\n\nARPU (Average Revenue Per User) - середня виручка на одного користувача за певний період.\nARPPU (Average Revenue Per Paying User) - середня виручка на одного користувача, що оплачує замовлення за певний період.\nAOV (Average Order Value) - середній чек або відношення виручки за певний період до загальної кількості замовлень за цей час.\n\nЯкщо за період, що розглядається, сервіс заробив 100 000 грошових одиниць і при цьому ним користувалися 500 унікальних користувачів, з яких 400 зробили загалом 650 замовлень, тоді метрики будуть мати наступні значення:\n\\[ARPU = 100000/500 = 200\\]\n\\[ARPPU = 100 000/400 = 250\\]\n\\[AOV=100000/650≈153,85\\]\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.2  Для кожного дня в таблицях orders та user_actions розрахуйте такі показники:\n\nВиручку користувача (ARPU) за поточний день.\nВиручку на користувача, що платить (ARPPU) за поточний день.\nВиручку із замовлення, або середній чек (AOV) за поточний день.\n\nКолонки з показниками назвіть відповідно arpu, arppu, aov. Колонку з датами назвіть date.\nПід час розрахунку всіх показників округляйте значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, arpu, arppu, aov\nПояснення:\nВважатимемо, що оплата за замовлення надходить відразу після його оформлення, тобто випадки, коли замовлення було оформлено в один день, а оплата отримана наступного, виникнути не можуть.\nКористувачами, що оплатили замовлення будемо вважати тих, які в даний день оформили хоча б одне замовлення, яке надалі не було скасовано.\nПри розрахунку виручки пам’ятайте, що не всі замовлення були сплачені, деякі були скасовані користувачами.\nНе забувайте при діленні заздалегідь приводити значення до потрібного типу даних.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання необхідно спочатку для кожного дня порахувати виручку, кількість всіх користувачів, кількість користувачів, що сплатили замовлення і кількість замовлень. Потім необхідно об’єднати отримані таблиці та розрахувати всі необхідні відносні показники. Виручку ми вже рахували у минулому завданні.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       round(revenue::decimal / users, 2) as arpu,\n       round(revenue::decimal / paying_users, 2) as arppu,\n       round(revenue::decimal / orders, 2) as aov\nFROM   (SELECT creation_time::date as date,\n               count(distinct order_id) as orders,\n               sum(price) as revenue\n        FROM   (SELECT order_id,\n                       creation_time,\n                       unnest(product_ids) as product_id\n                FROM   orders\n                WHERE  order_id not in (SELECT order_id\n                                        FROM   user_actions\n                                        WHERE  action = 'cancel_order')) t1\n            LEFT JOIN products using(product_id)\n        GROUP BY date) t2\n    LEFT JOIN (SELECT time::date as date,\n                      count(distinct user_id) as users\n               FROM   user_actions\n               GROUP BY date) t3 using (date)\n    LEFT JOIN (SELECT time::date as date,\n                      count(distinct user_id) as paying_users\n               FROM   user_actions\n               WHERE  order_id not in (SELECT order_id\n                                       FROM   user_actions\n                                       WHERE  action = 'cancel_order')\n               GROUP BY date) t4 using (date)\nORDER BY date\n\n\n\n\n\n\n\n\n\ndate\narpu\narppu\naov\n\n\n\n\n0\n2022-08-24\n372.57\n393.10\n361.77\n\n\n1\n2022-08-25\n508.09\n525.44\n406.86\n\n\n2\n2022-08-26\n452.04\n470.33\n369.57\n\n\n3\n2022-08-27\n509.38\n527.81\n381.62\n\n\n4\n2022-08-28\n528.38\n544.10\n378.04\n\n\n5\n2022-08-29\n559.15\n581.24\n391.76\n\n\n6\n2022-08-30\n546.74\n567.85\n379.52\n\n\n7\n2022-08-31\n517.63\n540.21\n384.96\n\n\n8\n2022-09-01\n499.33\n518.86\n381.26\n\n\n9\n2022-09-02\n537.67\n556.17\n381.35\n\n\n10\n2022-09-03\n565.90\n582.76\n387.28\n\n\n11\n2022-09-04\n541.55\n558.97\n381.70\n\n\n12\n2022-09-05\n512.84\n530.84\n381.75\n\n\n13\n2022-09-06\n475.33\n492.75\n385.67\n\n\n14\n2022-09-07\n496.65\n514.02\n378.44\n\n\n15\n2022-09-08\n521.10\n536.68\n383.54\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_2.\n\n\nКод\n%%sql\nresults_2 &lt;&lt; SELECT date,\n       round(revenue::decimal / users, 2) as arpu,\n       round(revenue::decimal / paying_users, 2) as arppu,\n       round(revenue::decimal / orders, 2) as aov\nFROM   (SELECT creation_time::date as date,\n               count(distinct order_id) as orders,\n               sum(price) as revenue\n        FROM   (SELECT order_id,\n                       creation_time,\n                       unnest(product_ids) as product_id\n                FROM   orders\n                WHERE  order_id not in (SELECT order_id\n                                        FROM   user_actions\n                                        WHERE  action = 'cancel_order')) t1\n            LEFT JOIN products using(product_id)\n        GROUP BY date) t2\n    LEFT JOIN (SELECT time::date as date,\n                      count(distinct user_id) as users\n               FROM   user_actions\n               GROUP BY date) t3 using (date)\n    LEFT JOIN (SELECT time::date as date,\n                      count(distinct user_id) as paying_users\n               FROM   user_actions\n               WHERE  order_id not in (SELECT order_id\n                                       FROM   user_actions\n                                       WHERE  action = 'cancel_order')\n               GROUP BY date) t4 using (date)\nORDER BY date\n\n\nВізуалізуємо отримані дані:\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\ntraces = [(\"arpu\", results_2.arpu), (\"arppu\", results_2.arppu), (\"aov\", results_2.aov)]\n\nfor trace_name, trace_values in traces:\n    fig.add_trace(\n        go.Scatter(\n            x=results_2.date, y=trace_values, mode=\"lines+markers\", name=trace_name\n        )\n    )\n\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\n\nfig.show()\n\n\n\n                                                \nРисунок 16.2: Динаміка ARPU, ARPPU та AOV\n\n\n\nПроаналізуйте побудований графік та спробуйте відповісти на такі питання:\n\nЯкі метрики мають більший розкид значень протягом періоду, що розглядається?\nЧи можна сказати, що окремі метрики мають аномально високі чи аномально низькі значення окремими днями?\nЯкий висновок можна зробити про співвідношення числа користувачів, що платять, і всіх користувачів сервісу в розглянуті дні?\n\nДоповнимо наш аналіз ще більш цікавими розрахунками — обчислимо ті самі метрики, але для кожного дня враховуватимемо накопичену виручку і всі наявні на даний момент дані про кількість користувачів і замовлень. Таким чином, отримаємо динамічний ARPU, ARPPU і AOV і зможемо простежити, як він змінювався протягом часу з урахуванням даних, що надходять нам.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.3  За таблицями orders та user_actions для кожного дня розрахуйте такі показники:\n\nНакопичений виторг на користувача (Running ARPU).\nНагромаджений виторг на платить користувача (Running ARPPU).\nНакопичений виторг із замовлення, або середній чек (Running AOV).\n\nКолонки з показниками назвіть running_arpu, running_arppu, running_aov. Колонку з датами назвіть date.\nПід час розрахунку всіх показників округляйте значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, running_arpu, running_arppu, running_aov\nПояснення:\nПри розрахунку числа користувачів та користувачів, що оплатили замовлення на поточну дату, враховуйте відповідних користувачів за всі попередні дні, включаючи поточний.\nКористувачами, що оплатили замовлення вважатимемо тих, які на поточний день оформили хоча б одне замовлення, яке надалі не було скасовано.\nВважатимемо, що оплата за замовлення надходить відразу після його оформлення, тобто. Випадки, коли замовлення було оформлено в один день, а оплата отримана наступного, виникнути не можуть.\nПри розрахунку виручки пам’ятайте, що не всі замовлення були сплачені, деякі були скасовані користувачами.\nНе забувайте при діленні заздалегідь приводити значення до потрібного типу даних.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення цього завдання необхідно доповнити запит з попереднього завдання та для кожного дня додатково розрахувати накопичений виторг, а також накопичену кількість усіх користувачів та оркмо користувачів, які оплатили замовлення. Для розрахунку кількості користувачів з накопиченням буде потрібна інформація про нових користувачів і нових користувачів, які оплатили замовлення у кожен із розглянутих днів.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date, \n        ROUND(SUM(revenue) OVER (ORDER BY date)::decimal / SUM(new_users) OVER (ORDER BY date), 2) AS running_arpu, \n        ROUND(SUM(revenue) OVER (ORDER BY date)::decimal / SUM(new_paying_users) OVER (ORDER BY date), 2) AS running_arppu, \n        ROUND(SUM(revenue) OVER (ORDER BY date)::decimal / SUM(orders) OVER (ORDER BY date), 2) AS running_aov \n    FROM ( \n        SELECT creation_time::date AS date,  \n                COUNT(DISTINCT order_id) AS orders,  \n                SUM(price) AS revenue \n        FROM ( \n            SELECT order_id, \n                creation_time, \n                UNNEST(product_ids) AS product_id \n            FROM orders \n            WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n            ) t1 \n        LEFT JOIN products  \n        USING(product_id) \n        GROUP BY date \n    ) t2 \n    LEFT JOIN ( \n        SELECT time::date AS date, COUNT(DISTINCT user_id) AS users \n        FROM user_actions \n        GROUP BY date \n    ) t3 \n    USING (date) \n    LEFT JOIN ( \n        SELECT time::date AS date, COUNT(DISTINCT user_id) AS paying_users \n        FROM user_actions \n        WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n        GROUP BY date \n    ) t4 \n    USING (date) \n    LEFT JOIN ( \n        SELECT date, COUNT(user_id) AS new_users \n        FROM ( \n            SELECT user_id, MIN(time::date) AS date \n            FROM user_actions \n            GROUP BY user_id \n        ) t5 \n        GROUP BY date \n    ) t6 \n    USING (date) \n    LEFT JOIN ( \n        SELECT date, COUNT(user_id) AS new_paying_users \n        FROM ( \n            SELECT user_id, MIN(time::date) AS date \n            FROM user_actions \n            WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n            GROUP BY user_id \n        ) t7 \n        GROUP BY date \n    ) t8 \n    USING (date)\n\n\n\n\n\n\n\n\n\ndate\nrunning_arpu\nrunning_arppu\nrunning_aov\n\n\n\n\n0\n2022-08-24\n372.57\n393.10\n361.77\n\n\n1\n2022-08-25\n499.26\n517.53\n401.66\n\n\n2\n2022-08-26\n512.90\n530.87\n384.10\n\n\n3\n2022-08-27\n571.80\n590.21\n382.99\n\n\n4\n2022-08-28\n632.13\n649.72\n381.08\n\n\n5\n2022-08-29\n707.53\n726.29\n384.24\n\n\n6\n2022-08-30\n766.86\n786.40\n383.14\n\n\n7\n2022-08-31\n792.81\n813.46\n383.49\n\n\n8\n2022-09-01\n813.18\n832.90\n383.11\n\n\n9\n2022-09-02\n844.17\n863.05\n382.77\n\n\n10\n2022-09-03\n886.24\n904.39\n383.57\n\n\n11\n2022-09-04\n921.71\n938.78\n383.28\n\n\n12\n2022-09-05\n950.45\n967.17\n383.11\n\n\n13\n2022-09-06\n970.18\n986.72\n383.30\n\n\n14\n2022-09-07\n992.38\n1007.85\n382.85\n\n\n15\n2022-09-08\n1012.99\n1028.03\n382.91\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_3:\n\n\nКод\n%%sql\nresults_3 &lt;&lt; SELECT date, \n        ROUND(SUM(revenue) OVER (ORDER BY date)::decimal / SUM(new_users) OVER (ORDER BY date), 2) AS running_arpu, \n        ROUND(SUM(revenue) OVER (ORDER BY date)::decimal / SUM(new_paying_users) OVER (ORDER BY date), 2) AS running_arppu, \n        ROUND(SUM(revenue) OVER (ORDER BY date)::decimal / SUM(orders) OVER (ORDER BY date), 2) AS running_aov \n    FROM ( \n        SELECT creation_time::date AS date,  \n                COUNT(DISTINCT order_id) AS orders,  \n                SUM(price) AS revenue \n        FROM ( \n            SELECT order_id, \n                creation_time, \n                UNNEST(product_ids) AS product_id \n            FROM orders \n            WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n            ) t1 \n        LEFT JOIN products  \n        USING(product_id) \n        GROUP BY date \n    ) t2 \n    LEFT JOIN ( \n        SELECT time::date AS date, COUNT(DISTINCT user_id) AS users \n        FROM user_actions \n        GROUP BY date \n    ) t3 \n    USING (date) \n    LEFT JOIN ( \n        SELECT time::date AS date, COUNT(DISTINCT user_id) AS paying_users \n        FROM user_actions \n        WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n        GROUP BY date \n    ) t4 \n    USING (date) \n    LEFT JOIN ( \n        SELECT date, COUNT(user_id) AS new_users \n        FROM ( \n            SELECT user_id, MIN(time::date) AS date \n            FROM user_actions \n            GROUP BY user_id \n        ) t5 \n        GROUP BY date \n    ) t6 \n    USING (date) \n    LEFT JOIN ( \n        SELECT date, COUNT(user_id) AS new_paying_users \n        FROM ( \n            SELECT user_id, MIN(time::date) AS date \n            FROM user_actions \n            WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n            GROUP BY user_id \n        ) t7 \n        GROUP BY date \n    ) t8 \n    USING (date)\n\n\nВізуалізуємо отримані дані:\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\ntraces = [\n    (\"running_arpu\", results_3.running_arpu),\n    (\"running_arppu\", results_3.running_arppu),\n    (\"running_aov\", results_3.running_aov),\n]\n\nfor trace_name, trace_values in traces:\n    fig.add_trace(\n        go.Scatter(\n            x=results_3.date, y=trace_values, mode=\"lines+markers\", name=trace_name\n        )\n    )\n\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\n\nfig.show()\n\n\n\n                                                \nРисунок 16.3: Динаміка Running ARPU, Running ARPPU, Running AOV\n\n\n\nПроаналізуйте побудований графік та спробуйте відповісти на такі питання:\n\nЯка загалом динаміка у розрахованих метрик? Вони ростуть, падають чи мають приблизно однакове значення у кожен із днів?\nЧи можна з огляду на динаміку розрахованих метрик припустити, що з часом зростає кількість замовлень на одного користувача?\n\nДавайте порахуємо ті ж показники, але в іншому розрізі — не просто щодня, а щодня тижня.\nДля виділення порядкового номера тижня можна використовувати функцію DATE_PART з параметром 'isodow'.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.4  Для кожного дня тижня в таблицях orders та user_actions розрахуйте такі показники:\n\nВиручку користувача (ARPU).\nВиручку на користувача, що платить (ARPPU).\nВиторг на замовлення (AOV).\n\nПри розрахунках враховуйте дані лише за період з 26 серпня 2022 року до 8 вересня 2022 року включно — так, щоб до аналізу потрапила однакова кількість усіх днів тижня (рівно по два дні).\nУ результуючу таблицю включіть як найменування днів тижня (наприклад, Monday), так і порядковий номер дня тижня (від 1 до 7, де 1 Monday, 7 Sunday).\nКолонки з показниками назвіть відповідно arpu, arppu, aov. Назвіть колонку з найменуванням дня тижня weekday, а колонку з порядковим номером дня тижня weekday_number.\nПід час розрахунку всіх показників округляйте значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням порядкового номера дня тижня.\nПоля в результуючій таблиці: weekday, weekday_number, arpu, arppu, aov\nПояснення:\nУ цій задачі порядковий номер дня тижня необхідний для того, щоб дні тижня були розташовані на графіці зліва направо в правильному порядку — не за найменуванням, а за зростанням порядкового номера.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля розв’язання задачі необхідно виконати ті самі операції, що й у попередньому завданні, тільки цього разу для днів тижня. Додатково необхідно правильно задати фільтрацію за датою, щоб у аналіз потрапило рівно два однакові дні тижня.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT weekday, t1.weekday_number AS weekday_number, \n        ROUND(revenue::decimal / users, 2) AS arpu, \n        ROUND(revenue::decimal / paying_users, 2) AS arppu, \n        ROUND(revenue::decimal / orders, 2) AS aov \n    FROM ( \n        SELECT DATE_PART('isodow', creation_time) AS weekday, \n                MAX(DATE_PART('isodow', creation_time)) AS weekday_number, \n                COUNT(DISTINCT order_id) AS orders,  \n                SUM(price) AS revenue \n        FROM ( \n            SELECT order_id, \n                creation_time, \n                UNNEST(product_ids) AS product_id \n            FROM orders \n            WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n                AND creation_time &gt;= '2022-08-26' AND creation_time &lt; '2022-09-09' \n            ) t4 \n        LEFT JOIN products  \n        USING(product_id) \n        GROUP BY weekday \n    ) t1 \n    LEFT JOIN ( \n        SELECT DATE_PART('isodow', time) AS weekday, \n            MAX(DATE_PART('isodow', time)) AS weekday_number, \n            COUNT(DISTINCT user_id) AS users \n        FROM user_actions \n        WHERE time &gt;= '2022-08-26' AND time &lt; '2022-09-09' \n        GROUP BY weekday \n    ) t2 \n    USING (weekday) \n    LEFT JOIN ( \n        SELECT DATE_PART('isodow', time) AS weekday,  \n            MAX(DATE_PART('isodow', time)) AS weekday_number, \n            COUNT(DISTINCT user_id) AS paying_users \n        FROM user_actions \n        WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n            AND time &gt;= '2022-08-26' AND time &lt; '2022-09-09' \n        GROUP BY weekday \n    ) t3 \n    USING (weekday) \n    ORDER BY weekday_number\n\n\n\n\n\n\n\n\n\nweekday\nweekday_number\narpu\narppu\naov\n\n\n\n\n0\n1\n1\n555.98\n575.18\n385.87\n\n\n1\n2\n2\n528.94\n548.04\n382.63\n\n\n2\n3\n3\n528.90\n548.33\n381.16\n\n\n3\n4\n4\n533.98\n551.37\n382.62\n\n\n4\n5\n5\n534.79\n553.21\n378.70\n\n\n5\n6\n6\n578.53\n595.48\n385.74\n\n\n6\n7\n7\n566.23\n583.38\n380.48\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_4:\n\n\nКод\n%%sql\nresults_4 &lt;&lt; SELECT weekday, t1.weekday_number AS weekday_number, \n        ROUND(revenue::decimal / users, 2) AS arpu, \n        ROUND(revenue::decimal / paying_users, 2) AS arppu, \n        ROUND(revenue::decimal / orders, 2) AS aov \n    FROM ( \n        SELECT DATE_PART('isodow', creation_time) AS weekday, \n                MAX(DATE_PART('isodow', creation_time)) AS weekday_number, \n                COUNT(DISTINCT order_id) AS orders,  \n                SUM(price) AS revenue \n        FROM ( \n            SELECT order_id, \n                creation_time, \n                UNNEST(product_ids) AS product_id \n            FROM orders \n            WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n                AND creation_time &gt;= '2022-08-26' AND creation_time &lt; '2022-09-09' \n            ) t4 \n        LEFT JOIN products  \n        USING(product_id) \n        GROUP BY weekday \n    ) t1 \n    LEFT JOIN ( \n        SELECT DATE_PART('isodow', time) AS weekday, \n            MAX(DATE_PART('isodow', time)) AS weekday_number, \n            COUNT(DISTINCT user_id) AS users \n        FROM user_actions \n        WHERE time &gt;= '2022-08-26' AND time &lt; '2022-09-09' \n        GROUP BY weekday \n    ) t2 \n    USING (weekday) \n    LEFT JOIN ( \n        SELECT DATE_PART('isodow', time) AS weekday,  \n            MAX(DATE_PART('isodow', time)) AS weekday_number, \n            COUNT(DISTINCT user_id) AS paying_users \n        FROM user_actions \n        WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action='cancel_order') \n            AND time &gt;= '2022-08-26' AND time &lt; '2022-09-09' \n        GROUP BY weekday \n    ) t3 \n    USING (weekday) \n    ORDER BY weekday_number\n\n\nВізуалізуємо отримані дані:\n\nimport plotly.graph_objects as go\n\ndays = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n]\n\nfig = go.Figure()\n\ntraces = [(\"arpu\", results_4.arpu), (\"arppu\", results_4.arppu), (\"aov\", results_4.aov)]\n\nfor trace_name, trace_values in traces:\n    fig.add_trace(\n        go.Scatter(x=days, y=trace_values, mode=\"lines+markers\", name=trace_name)\n    )\n\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n)\n\nfig.show()\n\n\n\n                                                \nРисунок 16.4: Динаміка ARPU, ARPPU та AOV за днями тижня\n\n\n\nПроаналізуйте побудований графік та спробуйте відповісти на такі питання:\n\nУ які дні тижня метрики ARPU та ARPPU набували найбільших значень? Як ви вважаєте, чи це узгоджується в цілому зі стандартною поведінкою користувачів сервісу доставки їжі?\nЯк ви вважаєте, чому в ті дні, коли метрики ARPU та ARPPU набували найбільших значень, метрика AOV залишалася приблизно на тому ж рівні? За якого сценарію таке можливе?"
  },
  {
    "objectID": "sql_metrics.html#виручка-нових-користувачів",
    "href": "sql_metrics.html#виручка-нових-користувачів",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.3 Виручка нових користувачів",
    "text": "16.3 Виручка нових користувачів\nТрохи ускладнимо наш початковий запит і окремо порахуємо щоденну виручку із замовлень нових користувачів нашого сервісу. Подивимося, яку частку вона становить у загальному виторгу із замовлень всіх користувачів — і нових, і старих.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.5  Для кожного дня в таблицях orders та user_actions розрахуйте такі показники:\n\nВиручку, одержану в цей день.\nВиручку із замовлень нових користувачів, отриману цього дня.\nЧастку виручки із замовлень нових користувачів у загальній виручці, отриманої за цей день.\nЧастку виручки із замовлень інших користувачів у загальній виручці, отриманої за цей день.\n\nКолонки з показниками назвіть відповідно revenue, new_users_revenue, new_users_revenue_share, old_users_revenue_share. Колонку з датами назвіть date.\nУсі показники часток необхідно виразити у відсотках. Під час їх розрахунку округляйте значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, revenue, new_users_revenue, new_users_revenue_share, old_users_revenue_share\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання необхідно для кожного дня порахувати виручку з нових користувачів. Щоб це зробити, спочатку необхідно для кожного користувача визначити мінімальну дату, тобто дату першої дії в нашому сервісі, а також порахувати вартість кожного замовлення в таблиці orders. Потім, об’єднавши дані про вартість замовлень з даними про дії користувачів у таблиці user_actions, можна для кожного користувача порахувати сумарну вартість його замовлень на кожну дату (групування за двома полями) та об’єднати ці дані з таблицею з датами початку використання додатку у кожного користувача (порахованою раніше). Таким чином, можна отримати таблицю з виручкою, одержаною з кожного користувача у його перший день. Далі залишається зробити групування за датою та порахувати сумарний виторг з нових користувачів за кожен день.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       revenue,\n       new_users_revenue,\n       round(new_users_revenue / revenue * 100, 2) as new_users_revenue_share,\n       100 - round(new_users_revenue / revenue * 100, 2) as old_users_revenue_share\nFROM   (SELECT creation_time::date as date,\n               sum(price) as revenue\n        FROM   (SELECT order_id,\n                       creation_time,\n                       unnest(product_ids) as product_id\n                FROM   orders\n                WHERE  order_id not in (SELECT order_id\n                                        FROM   user_actions\n                                        WHERE  action = 'cancel_order')) t3\n            LEFT JOIN products using (product_id)\n        GROUP BY date) t1\n    LEFT JOIN (SELECT start_date as date,\n                      sum(revenue) as new_users_revenue\n               FROM   (SELECT t5.user_id,\n                              t5.start_date,\n                              coalesce(t6.revenue, 0) as revenue\n                       FROM   (SELECT user_id,\n                                      min(time::date) as start_date\n                               FROM   user_actions\n                               GROUP BY user_id) t5\n                           LEFT JOIN (SELECT user_id,\n                                             date,\n                                             sum(order_price) as revenue\n                                      FROM   (SELECT user_id,\n                                                     time::date as date,\n                                                     order_id\n                                              FROM   user_actions\n                                              WHERE  order_id not in (SELECT order_id\n                                                                      FROM   user_actions\n                                                                      WHERE  action = 'cancel_order')) t7\n                                          LEFT JOIN (SELECT order_id,\n                                                            sum(price) as order_price\n                                                     FROM   (SELECT order_id,\n                                                                    unnest(product_ids) as product_id\n                                                             FROM   orders\n                                                             WHERE  order_id not in (SELECT order_id\n                                                                                     FROM   user_actions\n                                                                                     WHERE  action = 'cancel_order')) t9\n                                                         LEFT JOIN products using (product_id)\n                                                     GROUP BY order_id) t8 using (order_id)\n                                      GROUP BY user_id, date) t6\n                               ON t5.user_id = t6.user_id and\n                                  t5.start_date = t6.date) t4\n               GROUP BY start_date) t2 using (date)\n\n\n\n\n\n\n\n\n\ndate\nrevenue\nnew_users_revenue\nnew_users_revenue_share\nold_users_revenue_share\n\n\n\n\n0\n2022-08-24\n49924.0\n49924.0\n100.00\n0.00\n\n\n1\n2022-08-25\n430860.0\n417333.0\n96.86\n3.14\n\n\n2\n2022-08-26\n534766.0\n463326.0\n86.64\n13.36\n\n\n3\n2022-08-27\n817053.0\n619318.0\n75.80\n24.20\n\n\n4\n2022-08-28\n1133370.0\n801162.0\n70.69\n29.31\n\n\n5\n2022-08-29\n1279891.0\n717374.0\n56.05\n43.95\n\n\n6\n2022-08-30\n1279377.0\n656429.0\n51.31\n48.69\n\n\n7\n2022-08-31\n1312720.0\n720381.0\n54.88\n45.12\n\n\n8\n2022-09-01\n1406101.0\n757287.0\n53.86\n46.14\n\n\n9\n2022-09-02\n1907107.0\n1017824.0\n53.37\n46.63\n\n\n10\n2022-09-03\n2210988.0\n1079256.0\n48.81\n51.19\n\n\n11\n2022-09-04\n2294009.0\n1063997.0\n46.38\n53.62\n\n\n12\n2022-09-05\n1784690.0\n714459.0\n40.03\n59.97\n\n\n13\n2022-09-06\n1330931.0\n495058.0\n37.20\n62.80\n\n\n14\n2022-09-07\n1807800.0\n710154.0\n39.28\n60.72\n\n\n15\n2022-09-08\n2099508.0\n887959.0\n42.29\n57.71\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_5:\n\n\nКод\n%%sql\nresults_5 &lt;&lt; SELECT date,\n       revenue,\n       new_users_revenue,\n       round(new_users_revenue / revenue * 100, 2) as new_users_revenue_share,\n       100 - round(new_users_revenue / revenue * 100, 2) as old_users_revenue_share\nFROM   (SELECT creation_time::date as date,\n               sum(price) as revenue\n        FROM   (SELECT order_id,\n                       creation_time,\n                       unnest(product_ids) as product_id\n                FROM   orders\n                WHERE  order_id not in (SELECT order_id\n                                        FROM   user_actions\n                                        WHERE  action = 'cancel_order')) t3\n            LEFT JOIN products using (product_id)\n        GROUP BY date) t1\n    LEFT JOIN (SELECT start_date as date,\n                      sum(revenue) as new_users_revenue\n               FROM   (SELECT t5.user_id,\n                              t5.start_date,\n                              coalesce(t6.revenue, 0) as revenue\n                       FROM   (SELECT user_id,\n                                      min(time::date) as start_date\n                               FROM   user_actions\n                               GROUP BY user_id) t5\n                           LEFT JOIN (SELECT user_id,\n                                             date,\n                                             sum(order_price) as revenue\n                                      FROM   (SELECT user_id,\n                                                     time::date as date,\n                                                     order_id\n                                              FROM   user_actions\n                                              WHERE  order_id not in (SELECT order_id\n                                                                      FROM   user_actions\n                                                                      WHERE  action = 'cancel_order')) t7\n                                          LEFT JOIN (SELECT order_id,\n                                                            sum(price) as order_price\n                                                     FROM   (SELECT order_id,\n                                                                    unnest(product_ids) as product_id\n                                                             FROM   orders\n                                                             WHERE  order_id not in (SELECT order_id\n                                                                                     FROM   user_actions\n                                                                                     WHERE  action = 'cancel_order')) t9\n                                                         LEFT JOIN products using (product_id)\n                                                     GROUP BY order_id) t8 using (order_id)\n                                      GROUP BY user_id, date) t6\n                               ON t5.user_id = t6.user_id and\n                                  t5.start_date = t6.date) t4\n               GROUP BY start_date) t2 using (date)\n\n\nВізуалізуємо отримані дані:\n\nfig = go.Figure(\n    data=[\n        go.Bar(\n            name=\"new_users_revenue_share\",\n            x=results_5.date,\n            y=results_5.new_users_revenue_share,\n        ),\n        go.Bar(\n            name=\"old_users_revenue_share\",\n            x=results_5.date,\n            y=results_5.old_users_revenue_share,\n        ),\n    ]\n)\nfig.update_layout(\n    barmode=\"stack\",\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\nfig.show()\n\n\n\n                                                \nРисунок 16.5: Динаміка виручки нових та старих користувачів\n\n\n\nЧи можна сказати, що через два тижні після запуску нашого сервісу показник виручки від нових користувачів, як і раніше, на досить високому рівні?"
  },
  {
    "objectID": "sql_metrics.html#попит-на-товари",
    "href": "sql_metrics.html#попит-на-товари",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.4 Попит на товари",
    "text": "16.4 Попит на товари\nТакож було б цікаво подивитися, які товари мають найбільший попит і приносять нам основний дохід.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.6  Для кожного товару, представленого в таблиці products, за весь період часу в таблиці orders розрахуйте наступні показники:\n\nСумарний виторг, отриманий від продажу цього товару за весь період.\nЧастку виручки від цього товару у загальної виручці, отриманої протягом період.\n\nКолонки з показниками назвіть відповідно revenue та share_in_revenue. Колонку із найменуваннями товарів назвіть product_name.\nЧастку виручки з кожного товару необхідно виразити у відсотках. При її розрахунку округляйте значення до двох знаків після коми.\nТовари, заокруглена частка яких у виручці становить менше 0.5%, об’єднайте в загальну групу під назвою “OTHER” (без лапок), підсумувавши заокруглені частки цих товарів.\nРезультат має бути відсортований за зменшенням виручки від продажу товару.\nПоля в результуючій таблиці: product_name, revenue, share_in_revenue\nПояснення:\nТовари з невеликою часткою у виручці необхідно об’єднати в одну групу, щоб не виводити на графіку всі товари з таблиці products.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання необхідно згадати, як працює конструкція CASE, і порахувати виторг у розрізі найменувань товарів, представлених у таблиці products. Загальний алгоритм розрахунку виручки той самий, що у попередніх завданнях.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT product_name,\n       sum(revenue) as revenue,\n       sum(share_in_revenue) as share_in_revenue\nFROM   (SELECT case when round(100 * revenue / sum(revenue) OVER (), 2) &gt;= 0.5 then name\n                    else 'OTHER' end as product_name,\n               revenue,\n               round(100 * revenue / sum(revenue) OVER (), 2) as share_in_revenue\n        FROM   (SELECT name,\n                       sum(price) as revenue\n                FROM   (SELECT order_id,\n                               unnest(product_ids) as product_id\n                        FROM   orders\n                        WHERE  order_id not in (SELECT order_id\n                                                FROM   user_actions\n                                                WHERE  action = 'cancel_order')) t1\n                    LEFT JOIN products using(product_id)\n                GROUP BY name) t2) t3\nGROUP BY product_name\nORDER BY revenue desc\n\n\n\n\n\n\n\n\n\nproduct_name\nrevenue\nshare_in_revenue\n\n\n\n\n0\npork\n1353600.0\n6.24\n\n\n1\nOTHER\n1225387.0\n5.64\n\n\n2\nchicken\n1171140.0\n5.40\n\n\n3\nolive oil\n1163250.0\n5.37\n\n\n4\nbeef\n977170.0\n4.51\n\n\n...\n...\n...\n...\n\n\n63\nrice\n118930.0\n0.55\n\n\n64\nherbal tea bags\n112580.0\n0.52\n\n\n65\ntea mushroom\n112448.0\n0.52\n\n\n66\nsesame oil\n109750.0\n0.51\n\n\n67\nchewing gum\n109650.0\n0.51\n\n\n\n\n68 rows × 3 columns\n\n\n\nЗбережемо результат запиту у змінну results_6:\n\n\nКод\n%%sql\nresults_6 &lt;&lt; SELECT product_name,\n       sum(revenue) as revenue,\n       sum(share_in_revenue) as share_in_revenue\nFROM   (SELECT case when round(100 * revenue / sum(revenue) OVER (), 2) &gt;= 0.5 then name\n                    else 'OTHER' end as product_name,\n               revenue,\n               round(100 * revenue / sum(revenue) OVER (), 2) as share_in_revenue\n        FROM   (SELECT name,\n                       sum(price) as revenue\n                FROM   (SELECT order_id,\n                               unnest(product_ids) as product_id\n                        FROM   orders\n                        WHERE  order_id not in (SELECT order_id\n                                                FROM   user_actions\n                                                WHERE  action = 'cancel_order')) t1\n                    LEFT JOIN products using(product_id)\n                GROUP BY name) t2) t3\nGROUP BY product_name\nORDER BY revenue desc\n\n\nВізуалізуємо отримані дані:\n\nfig = go.Figure()\nfig.add_trace(\n    go.Bar(\n        x=results_6.product_name, y=results_6.share_in_revenue, name=\"share_in_revenue\"\n    )\n)\n\nfig.update_layout(\n    xaxis_tickangle=-45,\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\nfig.show()\n\n\n\n                                                \nРисунок 16.6: Частка виручки за продуктами\n\n\n\nПодивіться на побудований графік та визначте товари з найбільшою часткою у виручці. Якби ми об’єднали товари в ширші групи, то яка, на вашу думку, опинилася б на першому місці за часткою у виручці?"
  },
  {
    "objectID": "sql_metrics.html#валовий-прибуток",
    "href": "sql_metrics.html#валовий-прибуток",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.5 Валовий прибуток",
    "text": "16.5 Валовий прибуток\nТепер спробуємо врахувати в наших розрахунках витрати з податками і порахуємо валовий прибуток, тобто ту суму, яку ми фактично отримали в результаті реалізації товарів за розглянутий період.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.7  Для кожного дня в таблицях orders та courier_actions розрахуйте такі показники:\n\nВиручку, одержану в цей день.\nВитрати цього дня.\nСуму ПДВ із продажу товарів у цей день.\nВаловий прибуток у цей день (виручка за вирахуванням витрат та ПДВ).\nСумарний виторг на поточний день.\nСумарні витрати на цей день.\nСумарний ПДВ на сьогодні.\nСумарний валовий прибуток на поточний день.\nЧастку валового прибутку у виручці цей день (частку п.4 в п.1).\nЧастку сумарного валового прибутку в сумарній виручці на поточний день (частку п.8 п.5).\n\nКолонки з показниками назвіть відповідно revenue, costs, tax, gross_profit, total_revenue, total_costs, total_tax, total_gross_profit, gross_profit_ratio, total_gross_profit_ratio\nКолонку з датами назвіть date.\nЧастку валового прибутку у виручці необхідно виразити у відсотках, округливши значення до двох знаків після коми.\nРезультат має бути відсортований за зростанням дати.\nПоля в результуючій таблиці: date, revenue, costs, tax, gross_profit, total_revenue, total_costs, total_tax, total_gross_profit, gross_profit_ratio, total_gross_profit_ratio\nЩоб порахувати витрати, в цій задачі введемо додаткові умови.\nУ спрощеному вигляді витрати нашого сервісу рахуватимемо як суму постійних і змінних витрат. До постійних витрат віднесемо оренду складських приміщень, а до змінних - вартість збирання та доставки замовлення. Таким чином, змінні витрати безпосередньо залежатимуть від кількості замовлень.\nЗ даних, які нам надав фінансовий відділ, відомо, що у серпні 2022 року постійні витрати становили 120 000 грошових одиниць на день. Проте вже у вересні нашому сервісу були потрібні додаткові приміщення, і тому постійні витрати зросли до 150 000 грошових одиниць на день.\nТакож відомо, що в серпні 2022 року складання одного замовлення обходилася нам в 140 грошових одиниць, при цьому кур’єрам ми платили по 150 грошових одиниць за одне доставлене замовлення і ще 400 грошових одиниць щодня як бонус, якщо кур’єр доставляв не менше 5 замовлень на день. У вересні продакт-менеджерам вдалося знизити витрати на складання замовлення до 115 грошових одиниць, але при цьому довелося підвищити бонусну виплату за доставку 5 і більше замовлень до 500 грошових одиниць, щоб забезпечити конкурентоспроможніші умови праці. При цьому у вересні виплата кур’єрам за одне доставлене замовлення залишилася незмінною.\nПояснення:\nПри розрахунку змінних витрат враховуйте такі умови:\n\nВитрати на складання враховуються в тому ж дні, коли було оформлено замовлення. Складання скасованих замовлень не проводиться.\nВиплата кур’єрам за доставлене замовлення нараховується відразу після його доставки, тому якщо кур’єр доставить замовлення наступного дня, то й виплата буде врахована наступного дня.\nДля отримання бонусної виплати кур’єрам необхідно доставити не менше ніж 5 замовлень протягом одного дня, тому якщо кур’єр прийме 5 замовлень протягом дня, але останній з них доставить після опівночі, бонусну виплату він не отримає.\n\nПри розрахунку ПДВ враховуйте, що з деяких товарів податок становить не 10%, а 20%. Список товарів зі зниженим ПДВ:\n'sugar', 'crackers', 'drying', 'seeds',\n'linseed oil', 'grapes', 'olive oil',\n'watermelon', 'baton', 'yogurt', 'cream', 'buckwheat',\n'oatmeal', 'pasta', 'mutton', 'oranges',\n'bagels', 'bread', 'peas', 'sour cream', 'smoked fish',\n'flour', 'sprats', 'sausages', 'pork', 'rice',\n'sesame oil', 'condensed milk', 'pineapple', 'beef',\n'salt', 'dried fish', 'sunflower oil', 'apples',\n'pears', 'flatbread', 'milk', 'chicken', 'lavash', 'waffles', 'tangerines'\nТакож при розрахунку величини ПДВ за кожним товаром округляйте значення до двох знаків після коми.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання необхідно для кожного дня окремо порахувати виручку, витрати та величину ПДВ, а потім об’єднати отримані таблиці для подальших розрахунків за допомогою віконних функцій. Виручку ми рахували в минулих завданнях, величину ПДВ ми також рахували на перших уроках - тепер це необхідно зробити для всіх товарів, куплених протягом кожного дня. Найскладніше у цьому - правильно обчислити витрати. Для цього необхідно для кожного дня порахувати кількість оформлених замовлень, кількість доставлених замовлень та кількість кур’єрів, що доставили 5 та більше замовлень. Потім необхідно кожного дня порахувати загальні витрати. Це можна зробити за допомогою конструкції CASE, підставивши постійні та змінні витрати на нескладну формулу, описану в умові.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date,\n       revenue,\n       costs,\n       tax,\n       gross_profit,\n       total_revenue,\n       total_costs,\n       total_tax,\n       total_gross_profit,\n       round(gross_profit / revenue * 100, 2) as gross_profit_ratio,\n       round(total_gross_profit / total_revenue * 100, 2) as total_gross_profit_ratio\nFROM   (SELECT date,\n               revenue,\n               costs,\n               tax,\n               revenue - costs - tax as gross_profit,\n               sum(revenue) OVER (ORDER BY date) as total_revenue,\n               sum(costs) OVER (ORDER BY date) as total_costs,\n               sum(tax) OVER (ORDER BY date) as total_tax,\n               sum(revenue - costs - tax) OVER (ORDER BY date) as total_gross_profit\n        FROM   (SELECT date,\n                       orders_packed,\n                       orders_delivered,\n                       couriers_count,\n                       revenue,\n                       case when date_part('month',\n                                                                                                                                                                      date) = 8 then 120000.0 + 140 * coalesce(orders_packed, 0) + 150 * coalesce(orders_delivered, 0) + 400 * coalesce(couriers_count, 0)\n                            when date_part('month',\n                                                                                                                                                                      date) = 9 then 150000.0 + 115 * coalesce(orders_packed, 0) + 150 * coalesce(orders_delivered, 0) + 500 * coalesce(couriers_count, 0) end as costs,\n                       tax\n                FROM   (SELECT creation_time::date as date,\n                               count(distinct order_id) as orders_packed,\n                               sum(price) as revenue,\n                               sum(tax) as tax\n                        FROM   (SELECT order_id,\n                                       creation_time,\n                                       product_id,\n                                       name,\n                                       price,\n                                       case when name in ('sugar', 'crackers', 'drying', 'seeds',\n                                                          'linseed oil', 'grapes', 'olive oil',\n                                                          'watermelon', 'baton', 'yogurt', 'cream', 'buckwheat',\n                                                          'oatmeal', 'pasta', 'mutton', 'oranges',\n                                                          'bagels', 'bread', 'peas', 'sour cream', 'smoked fish',\n                                                          'flour', 'sprats', 'sausages', 'pork', 'rice',\n                                                          'sesame oil', 'condensed milk', 'pineapple', 'beef',\n                                                          'salt', 'dried fish', 'sunflower oil', 'apples',\n                                                          'pears', 'flatbread', 'milk', 'chicken', 'lavash', 'waffles', 'tangerines') then round(price/110*10,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         2)\n                                            else round(price/120*20, 2) end as tax\n                                FROM   (SELECT order_id,\n                                               creation_time,\n                                               unnest(product_ids) as product_id\n                                        FROM   orders\n                                        WHERE  order_id not in (SELECT order_id\n                                                                FROM   user_actions\n                                                                WHERE  action = 'cancel_order')) t1\n                                    LEFT JOIN products using (product_id)) t2\n                        GROUP BY date) t3\n                    LEFT JOIN (SELECT time::date as date,\n                                      count(distinct order_id) as orders_delivered\n                               FROM   courier_actions\n                               WHERE  order_id not in (SELECT order_id\n                                                       FROM   user_actions\n                                                       WHERE  action = 'cancel_order')\n                                  and action = 'deliver_order'\n                               GROUP BY date) t4 using (date)\n                    LEFT JOIN (SELECT date,\n                                      count(courier_id) as couriers_count\n                               FROM   (SELECT time::date as date,\n                                              courier_id,\n                                              count(distinct order_id) as orders_delivered\n                                       FROM   courier_actions\n                                       WHERE  order_id not in (SELECT order_id\n                                                               FROM   user_actions\n                                                               WHERE  action = 'cancel_order')\n                                          and action = 'deliver_order'\n                                       GROUP BY date, courier_id having count(distinct order_id) &gt;= 5) t5\n                               GROUP BY date) t6 using (date)) t7) t8\n\n\n\n\n\n\n\n\n\ndate\nrevenue\ncosts\ntax\ngross_profit\ntotal_revenue\ntotal_costs\ntotal_tax\ntotal_gross_profit\ngross_profit_ratio\ntotal_gross_profit_ratio\n\n\n\n\n0\n2022-08-24\n49924.0\n159120.0\n6459.77\n-115655.77\n49924.0\n159120.0\n6459.77\n-115655.77\n-231.66\n-231.66\n\n\n1\n2022-08-25\n430860.0\n447560.0\n54458.71\n-71158.71\n480784.0\n606680.0\n60918.48\n-186814.48\n-16.52\n-38.86\n\n\n2\n2022-08-26\n534766.0\n565680.0\n67272.24\n-98186.24\n1015550.0\n1172360.0\n128190.72\n-285000.72\n-18.36\n-28.06\n\n\n3\n2022-08-27\n817053.0\n781040.0\n104010.94\n-67997.94\n1832603.0\n1953400.0\n232201.66\n-352998.66\n-8.32\n-19.26\n\n\n4\n2022-08-28\n1133370.0\n1055870.0\n143194.74\n-65694.74\n2965973.0\n3009270.0\n375396.40\n-418693.40\n-5.80\n-14.12\n\n\n5\n2022-08-29\n1279891.0\n1144280.0\n163192.37\n-27581.37\n4245864.0\n4153550.0\n538588.77\n-446274.77\n-2.15\n-10.51\n\n\n6\n2022-08-30\n1279377.0\n1169140.0\n161750.92\n-51513.92\n5525241.0\n5322690.0\n700339.69\n-497788.69\n-4.03\n-9.01\n\n\n7\n2022-08-31\n1312720.0\n1159250.0\n165617.03\n-12147.03\n6837961.0\n6481940.0\n865956.72\n-509935.72\n-0.93\n-7.46\n\n\n8\n2022-09-01\n1406101.0\n1180320.0\n178047.87\n47733.13\n8244062.0\n7662260.0\n1044004.59\n-462202.59\n3.39\n-5.61\n\n\n9\n2022-09-02\n1907107.0\n1590965.0\n241912.13\n74229.87\n10151169.0\n9253225.0\n1285916.72\n-387972.72\n3.89\n-3.82\n\n\n10\n2022-09-03\n2210988.0\n1813235.0\n280998.88\n116754.12\n12362157.0\n11066460.0\n1566915.60\n-271218.60\n5.28\n-2.19\n\n\n11\n2022-09-04\n2294009.0\n1885300.0\n293110.13\n115598.87\n14656166.0\n12951760.0\n1860025.73\n-155619.73\n5.04\n-1.06\n\n\n12\n2022-09-05\n1784690.0\n1456825.0\n226580.62\n101284.38\n16440856.0\n14408585.0\n2086606.35\n-54335.35\n5.68\n-0.33\n\n\n13\n2022-09-06\n1330931.0\n1077765.0\n168922.71\n84243.29\n17771787.0\n15486350.0\n2255529.06\n29907.94\n6.33\n0.17\n\n\n14\n2022-09-07\n1807800.0\n1452755.0\n230027.23\n125017.77\n19579587.0\n16939105.0\n2485556.29\n154925.71\n6.92\n0.79\n\n\n15\n2022-09-08\n2099508.0\n1669410.0\n268110.26\n161987.74\n21679095.0\n18608515.0\n2753666.55\n316913.45\n7.72\n1.46\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_7:\n\n\nКод\n%%sql\nresults_7 &lt;&lt; SELECT date,\n       revenue,\n       costs,\n       tax,\n       gross_profit,\n       total_revenue,\n       total_costs,\n       total_tax,\n       total_gross_profit,\n       round(gross_profit / revenue * 100, 2) as gross_profit_ratio,\n       round(total_gross_profit / total_revenue * 100, 2) as total_gross_profit_ratio\nFROM   (SELECT date,\n               revenue,\n               costs,\n               tax,\n               revenue - costs - tax as gross_profit,\n               sum(revenue) OVER (ORDER BY date) as total_revenue,\n               sum(costs) OVER (ORDER BY date) as total_costs,\n               sum(tax) OVER (ORDER BY date) as total_tax,\n               sum(revenue - costs - tax) OVER (ORDER BY date) as total_gross_profit\n        FROM   (SELECT date,\n                       orders_packed,\n                       orders_delivered,\n                       couriers_count,\n                       revenue,\n                       case when date_part('month', date) = 8 then 120000.0 + 140 * coalesce(orders_packed, 0) + 150 * coalesce(orders_delivered, 0) + 400 * coalesce(couriers_count, 0)\n                            when date_part('month', date) = 9 then 150000.0 + 115 * coalesce(orders_packed, 0) + 150 * coalesce(orders_delivered, 0) + 500 * coalesce(couriers_count, 0) end as costs,\n                       tax\n                FROM   (SELECT creation_time::date as date,\n                               count(distinct order_id) as orders_packed,\n                               sum(price) as revenue,\n                               sum(tax) as tax\n                        FROM   (SELECT order_id,\n                                       creation_time,\n                                       product_id,\n                                       name,\n                                       price,\n                                       case when name in ('sugar', 'crackers', 'drying', 'seeds',\n                                                          'linseed oil', 'grapes', 'olive oil',\n                                                          'watermelon', 'baton', 'yogurt', 'cream', 'buckwheat',\n                                                          'oatmeal', 'pasta', 'mutton', 'oranges',\n                                                          'bagels', 'bread', 'peas', 'sour cream', 'smoked fish',\n                                                          'flour', 'sprats', 'sausages', 'pork', 'rice',\n                                                          'sesame oil', 'condensed milk', 'pineapple', 'beef',\n                                                          'salt', 'dried fish', 'sunflower oil', 'apples',\n                                                          'pears', 'flatbread', 'milk', 'chicken', 'lavash', 'waffles', 'tangerines') then round(price/110*10,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         2)\n                                            else round(price/120*20, 2) end as tax\n                                FROM   (SELECT order_id,\n                                               creation_time,\n                                               unnest(product_ids) as product_id\n                                        FROM   orders\n                                        WHERE  order_id not in (SELECT order_id\n                                                                FROM   user_actions\n                                                                WHERE  action = 'cancel_order')) t1\n                                    LEFT JOIN products using (product_id)) t2\n                        GROUP BY date) t3\n                    LEFT JOIN (SELECT time::date as date,\n                                      count(distinct order_id) as orders_delivered\n                               FROM   courier_actions\n                               WHERE  order_id not in (SELECT order_id\n                                                       FROM   user_actions\n                                                       WHERE  action = 'cancel_order')\n                                  and action = 'deliver_order'\n                               GROUP BY date) t4 using (date)\n                    LEFT JOIN (SELECT date,\n                                      count(courier_id) as couriers_count\n                               FROM   (SELECT time::date as date,\n                                              courier_id,\n                                              count(distinct order_id) as orders_delivered\n                                       FROM   courier_actions\n                                       WHERE  order_id not in (SELECT order_id\n                                                               FROM   user_actions\n                                                               WHERE  action = 'cancel_order')\n                                          and action = 'deliver_order'\n                                       GROUP BY date, courier_id having count(distinct order_id) &gt;= 5) t5\n                               GROUP BY date) t6 using (date)) t7) t8\n\n\nВізуалізуємо отримані дані:\n\nfrom plotly.subplots import make_subplots\n\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\nfig.add_trace(\n    go.Bar(\n        name=\"gross_profit_ratio\",\n        x=results_7.date,\n        y=results_7.gross_profit_ratio,\n        offsetgroup=1,\n    ),\n    secondary_y=False,\n)\nfig.add_trace(\n    go.Scatter(\n        name=\"gross_profit\", x=results_7.date, y=results_7.gross_profit, offsetgroup=2\n    ),\n    secondary_y=True,\n)\nfig.update_yaxes(range=[-150000, 150000], secondary_y=True)\nfig.update_yaxes(range=[-250, 250], secondary_y=False)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\n\nfig.show()\n\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\nfig.add_trace(\n    go.Bar(\n        name=\"total_gross_profit_ratio\",\n        x=results_7.date,\n        y=results_7.total_gross_profit_ratio,\n        offsetgroup=1,\n    ),\n    secondary_y=False,\n)\nfig.add_trace(\n    go.Scatter(\n        name=\"total_gross_profit\",\n        x=results_7.date,\n        y=results_7.total_gross_profit,\n        offsetgroup=2,\n    ),\n    secondary_y=True,\n)\nfig.update_yaxes(range=[-1200000, 400000], secondary_y=True)\nfig.update_yaxes(range=[-300, 100], secondary_y=False)\nfig.update_layout(\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n)\n\nfig.show()\n\n\n\n\n\n\n                                                \n(a) Динаміка валового прибутку та частки валового прибутку у виручці на поточний день\n\n\n\n\n\n                                                \n(b) Динаміка сумарного виторгу та частки сумарного валового прибутку в сумарному виторгу на поточний день.\n\n\n\nРисунок 16.7: Графік за результатами SQL-запиту\n\n\n\nПроаналізуйте побудовані графіки та спробуйте відповісти на такі питання:\n\nПочинаючи з якого дня щоденний валовий прибуток нашого сервісу став позитивним?\nУ який день сумарний валовий прибуток перевищив нульову позначку та сервіс уперше «вийшов у плюс» за цим показником?\nЧи можна сказати, що оптимізація вартості складання замовлення у вересні дозволила побачити цього місяця позитивний валовий прибуток?"
  },
  {
    "objectID": "sql_metrics.html#customer-acquisition-cost-cac",
    "href": "sql_metrics.html#customer-acquisition-cost-cac",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.6 Customer Acquisition Cost (CAC)",
    "text": "16.6 Customer Acquisition Cost (CAC)\nПознайомимося з метриками, які допомагають оцінити ефективність нашого маркетингу — наскільки ефективно ми залучаємо користувачів до нашого додатку.\nСпочатку розглянемо метрику CAC (Customer Acquisition Cost), яка відображає витрати на залучення одного покупця.\nУявімо ситуацію: до нас звернулися маркетологи з проханням порівняти дві рекламні кампанії.\nУ рекламній кампанії №1 про наш додаток розповів відомий блогер на Youtube-каналі про кулінарії. На цю інтеграцію сумарно витратили 250 000 грошових одиниць. Внаслідок цієї кампанії 1 вересня у додатку зареєструвалася 171 особа.\nУ рамках рекламної кампанії №2 користувачам показували таргетовану рекламу у соціальних мережах. На це теж сумарно витратили 250 000 грошових одиниць, і в результаті 1 вересня у нас з’явилося 236 нових користувачів.\nЯк нам оцінити, який із каналів залучення спрацював краще? На перший погляд, друга кампанія показала себе краще, оскільки нам удалося залучити більше людей за ті самі гроші. Але не поспішатимемо з висновками — давайте спочатку проведемо докладніший аналіз і розрахуємо CAC для двох рекламних кампаній.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.8  На основі таблиці user_actions розрахуйте метрику CAC для двох рекламних кампаній.\nСписок id користувачів, що прийшли після рекламної кампанії №1:\n8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732, 8739, 8741, \n8750, 8751, 8752, 8770, 8774, 8788, 8791, 8804, 8810, 8815, 8828, 8830, 8845, \n8853, 8859, 8867, 8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940, 8972, \n8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020, 9035, 9036, 9061, 9069, 9071, \n9075, 9081, 9085, 9089, 9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175, \n9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278, 9287, 9291, 9313, 9317, \n9321, 9334, 9351, 9391, 9398, 9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, \n9476, 9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528, 9531, 9535, 9550, \n9559, 9561, 9562, 9599, 9603, 9605, 9611, 9612, 9615, 9625, 9633, 9652, 9654, \n9655, 9660, 9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739, 9740, 9762, \n9778, 9786, 9794, 9804, 9810, 9813, 9818, 9828, 9831, 9836, 9838, 9845, 9871, \n9887, 9891, 9896, 9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993, 9998, \n9999, 10001, 10013, 10016, 10023, 10030, 10051, 10057, 10064, 10082, 10103, \n10105, 10122, 10134, 10135\nСписок id користувачів, що прийшли після рекламної кампанії №2:\n8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670, 8675, 8680, 8681, \n8682, 8683, 8694, 8697, 8700, 8704, 8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, \n8771, 8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825, 8827, 8838, 8849, 8851, \n8854, 8855, 8870, 8878, 8882, 8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929, \n8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971, 8973, 8980, 8995, 8999, 9000, \n9007, 9013, 9041, 9042, 9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109, 9117, \n9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179, 9181, 9183, 9185, 9190, 9196, 9203, \n9207, 9226, 9227, 9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281, 9282, 9289, \n9292, 9303, 9310, 9312, 9315, 9327, 9333, 9335, 9337, 9343, 9356, 9368, 9370, 9383, \n9392, 9404, 9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485, 9492, 9495, 9497, \n9498, 9500, 9510, 9527, 9529, 9530, 9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, \n9570, 9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658, 9666, 9672, 9684, 9692, \n9700, 9704, 9706, 9711, 9719, 9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757, \n9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841, 9843, 9853, 9855, 9859, 9863, \n9877, 9879, 9880, 9882, 9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929, 9930, \n9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033, 10038, 10045, 10047, 10048, 10058, \n10059, 10067, 10069, 10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110, 10113, 10131\nНазвіть колонку з найменуваннями кампаній ads_campaign, а колонку зі значенням метрики — cac.\nНазви кампаній виведіть у такому вигляді:\nCompany № 1\nCompany № 2\nОтримані значення метрики заокругліть до двох знаків після коми.\nРезультат має бути відсортований за зменшенням значення метрики.\nПоля у результуючій таблиці: ads_campaign, cac\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nДля вирішення завдання спочатку необхідно відібрати користувачів, що прийшли після проведення рекламних кампаній, а потім серед них відібрати тих, хто став покупцем, тобто зробив хоча б одне замовлення. Далі кожної групи за нескладною формулою можна розрахувати метрику CAC.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT concat('Company № ', ads_campaign) as ads_campaign,\n       round(250000.0 / count(distinct user_id), 2) as cac\nFROM   (SELECT user_id,\n               order_id,\n               action,\n               case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                     8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                     8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                     8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                     8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                     9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                     9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                     9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                     9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                     9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                     9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                     9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                     9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                     9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                     9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                     9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                     9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                     9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                     10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                    when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                     8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                     8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                     8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                     8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                     8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                     8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                     8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                     9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                     9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                     9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                     9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                     9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                     9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                     9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                     9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                     9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                     9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                     9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                     9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                     9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                     9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                     9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                     9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                     10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                     10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                     10113, 10131) then 2\n                    else 0 end as ads_campaign,\n               count(action) filter (WHERE action = 'cancel_order') OVER (PARTITION BY order_id) as is_canceled\n        FROM   user_actions) t1\nWHERE  ads_campaign in (1, 2)\n   and is_canceled = 0\nGROUP BY ads_campaign\nORDER BY cac desc\n\n\n\n\n\n\n\n\n\nads_campaign\ncac\n\n\n\n\n0\nCompany № 1\n1461.99\n\n\n1\nCompany № 2\n1068.38\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_8:\n\n\nКод\n%%sql\nresults_8 &lt;&lt; SELECT concat('Company № ', ads_campaign) as ads_campaign,\n       round(250000.0 / count(distinct user_id), 2) as cac\nFROM   (SELECT user_id,\n               order_id,\n               action,\n               case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                     8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                     8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                     8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                     8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                     9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                     9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                     9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                     9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                     9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                     9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                     9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                     9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                     9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                     9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                     9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                     9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                     9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                     10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                    when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                     8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                     8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                     8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                     8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                     8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                     8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                     8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                     9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                     9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                     9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                     9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                     9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                     9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                     9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                     9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                     9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                     9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                     9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                     9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                     9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                     9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                     9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                     9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                     10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                     10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                     10113, 10131) then 2\n                    else 0 end as ads_campaign,\n               count(action) filter (WHERE action = 'cancel_order') OVER (PARTITION BY order_id) as is_canceled\n        FROM   user_actions) t1\nWHERE  ads_campaign in (1, 2)\n   and is_canceled = 0\nGROUP BY ads_campaign\nORDER BY cac desc\n\n\nВізуалізуємо отримані дані:\n\nfig = px.bar(results_8, x=\"ads_campaign\", y=\"cac\", text_auto=True)\nfig.show()\n\n\n\n                                                \nРисунок 16.8: Customer Acquisition Cost (CAC) за кампаніями\n\n\n\nУ якої рекламної кампанії витрати на залучення одного покупця виявилися нижчими?"
  },
  {
    "objectID": "sql_metrics.html#return-on-investment-roi",
    "href": "sql_metrics.html#return-on-investment-roi",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.7 Return on Investment (ROI)",
    "text": "16.7 Return on Investment (ROI)\nВідмінно, CAC ми розрахували, але чи можемо ми тепер стверджувати, що друга рекламна кампанія краща лише тому, що дозволяє залучати активних користувачів за менші гроші?\nНі, робити такі висновки рано — давайте оцінимо ще один показник, який відображає рентабельність інвестицій і показує, наскільки вигідним є той чи інший проект чи продукт. Ця метрика називається ROI (Return on Investment), у маркетингу її часто застосовують для підрахунку окупності рекламних кампаній.\nНаведемо приклад. Допустимо, ми вклали в рекламу 100 грошових одиниць і в результаті продали товарів на 220 грошових одиниць. Тоді ROI буде розрахований так:\n\\[ROI=\\frac{(220−100)}{100}∗100\\%=120\\%\\]\nТаким чином, на кожну вкладену одиницю грошей у рекламу ми отримали 1,2 грошових одиниць прибутку.\nПорівняємо дві рекламні кампанії за значеннями метрики ROI і зробимо висновок про те, який з рекламних каналів більшою мірою окупає витрати на залучення нових користувачів.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.9  Розрахуйте ROI для кожного рекламного каналу.\nНазвіть колонку з найменуваннями кампаній ads_campaign, а колонку зі значенням метрики — roi.\nНазви кампаній виведіть у такому вигляді:\nCompany № 1\nCompany № 2\nОтримані значення метрики необхідно виразити у відсотках та округлити до двох знаків після коми.\nРезультат має бути відсортований за зменшенням значення метрики.\nПоля у результуючій таблиці: ads_campaign, roi\nПояснення:\nСписки користувачів, що зареєструвалися, ті ж, що і на попередньому кроці.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nВізьміть усіх користувачів, які залучені через рекламний канал. Потім порахуйте сумарну вартість усіх нескасованих замовлень цих користувачів за весь час. Далі відніміть від отриманої суми рекламні витрати та розділіть отриману різницю на рекламні витрати.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT concat('Company № ', ads_campaign) as ads_campaign,\n       round((sum(price) - 250000.0) / 250000.0 * 100, 2) as roi\nFROM   (SELECT ads_campaign,\n               user_id,\n               order_id,\n               product_id,\n               price\n        FROM   (SELECT ads_campaign,\n                       user_id,\n                       order_id\n                FROM   (SELECT user_id,\n                               order_id,\n                               case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                                     8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                                     8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                                     8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                                     8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                                     9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                                     9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                                     9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                                     9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                                     9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                                     9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                                     9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                                     9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                                     9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                                     9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                                     9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                                     9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                                     9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                                     10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                                    when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                                     8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                                     8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                                     8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                                     8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                                     8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                                     8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                                     8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                                     9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                                     9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                                     9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                                     9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                                     9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                                     9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                                     9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                                     9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                                     9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                                     9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                                     9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                                     9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                                     9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                                     9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                                     9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                                     9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                                     10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                                     10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                                     10113, 10131) then 2\n                                    else 0 end as ads_campaign,\n                               count(action) filter (WHERE action = 'cancel_order') OVER (PARTITION BY order_id) as is_canceled\n                        FROM   user_actions) t1\n                WHERE  ads_campaign in (1, 2)\n                   and is_canceled = 0) t2\n            LEFT JOIN (SELECT order_id,\n                              unnest(product_ids) as product_id\n                       FROM   orders) t3 using(order_id)\n            LEFT JOIN products using(product_id)) t4\nGROUP BY ads_campaign\nORDER BY roi desc\n\n\n\n\n\n\n\n\n\nads_campaign\nroi\n\n\n\n\n0\nCompany № 1\n14.50\n\n\n1\nCompany № 2\n-1.61\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_9:\n\n\nКод\n%%sql\nresults_9 &lt;&lt; SELECT concat('Company № ', ads_campaign) as ads_campaign,\n       round((sum(price) - 250000.0) / 250000.0 * 100, 2) as roi\nFROM   (SELECT ads_campaign,\n               user_id,\n               order_id,\n               product_id,\n               price\n        FROM   (SELECT ads_campaign,\n                       user_id,\n                       order_id\n                FROM   (SELECT user_id,\n                               order_id,\n                               case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                                     8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                                     8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                                     8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                                     8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                                     9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                                     9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                                     9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                                     9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                                     9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                                     9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                                     9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                                     9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                                     9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                                     9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                                     9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                                     9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                                     9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                                     10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                                    when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                                     8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                                     8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                                     8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                                     8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                                     8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                                     8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                                     8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                                     9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                                     9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                                     9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                                     9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                                     9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                                     9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                                     9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                                     9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                                     9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                                     9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                                     9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                                     9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                                     9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                                     9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                                     9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                                     9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                                     10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                                     10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                                     10113, 10131) then 2\n                                    else 0 end as ads_campaign,\n                               count(action) filter (WHERE action = 'cancel_order') OVER (PARTITION BY order_id) as is_canceled\n                        FROM   user_actions) t1\n                WHERE  ads_campaign in (1, 2)\n                   and is_canceled = 0) t2\n            LEFT JOIN (SELECT order_id,\n                              unnest(product_ids) as product_id\n                       FROM   orders) t3 using(order_id)\n            LEFT JOIN products using(product_id)) t4\nGROUP BY ads_campaign\nORDER BY roi desc\n\n\nВізуалізуємо отримані дані:\n\nfig = px.bar(results_9, x=\"ads_campaign\", y=\"roi\", text_auto=True)\nfig.show()\n\n\n\n                                                \nРисунок 16.9: Return on Investment (ROI) за кампаніями\n\n\n\nЯкий висновок щодо ефективності рекламних кампаній можна зробити? У який канал залучення є сенс вкладати більше бюджету?"
  },
  {
    "objectID": "sql_metrics.html#середній-чек",
    "href": "sql_metrics.html#середній-чек",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.8 Середній чек",
    "text": "16.8 Середній чек\nОтже, ми з’ясували, що перша рекламна кампанія дозволяє залучати якісніших лідів. Але причина цих відмінностей поки що не зрозуміла. Чому користувачі першого рекламного каналу приносять нам більше грошей? Можливо, у них вищий середній чек?\nДавайте проведемо більш детальний аналіз, щоб з’ясувати, чим відрізняються два рекламні канали з точки зору метрик користувача.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.10  Для кожної рекламної кампанії порахуйте середню вартість замовлення залучених користувачів за перший тиждень використання програми з 1 по 7 вересня 2022 року.\nНазвіть колонку з найменуваннями кампаній ads_campaign, а колонку зі значенням метрики — avg_check.\nНазви кампаній виведіть у такому вигляді:\nCompany № 1\nCompany № 2\nОтримані значення метрики необхідно заокруглити до двох знаків після коми.\nРезультат має бути відсортований за зменшенням значення метрики.\nПоля у результуючій таблиці: ads_campaign, avg_check\nПояснення:\nПокупцями будемо вважати тих користувачів, які зробили хоча б одне замовлення, яке надалі не було скасовано. Наприклад, якщо людина зробила лише одне замовлення, а потім скасувала його, то покупцем ми його не рахуємо.\nСписки користувачів, що зареєструвалися, ті ж, що і на попередніх кроках.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nВізьміть усіх користувачів, залучених через кожний рекламний канал. Потім для кожного користувача порахуйте середню вартість усіх замовлень. Потім ще раз усередніть отримані значення рекламних каналів.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT concat('Company № ', ads_campaign) as ads_campaign,\n       round(avg(user_avg_check), 2) as avg_check\nFROM   (SELECT ads_campaign,\n               user_id,\n               round(avg(order_price), 2) as user_avg_check\n        FROM   (SELECT ads_campaign,\n                       user_id,\n                       order_id,\n                       sum(price) as order_price\n                FROM   (SELECT ads_campaign,\n                               user_id,\n                               order_id,\n                               product_id,\n                               price\n                        FROM   (SELECT ads_campaign,\n                                       user_id,\n                                       order_id\n                                FROM   (SELECT user_id,\n                                               order_id,\n                                               time,\n                                               case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                                                     8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                                                     8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                                                     8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                                                     8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                                                     9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                                                     9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                                                     9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                                                     9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                                                     9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                                                     9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                                                     9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                                                     9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                                                     9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                                                     9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                                                     9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                                                     9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                                                     9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                                                     10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                                                    when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                                                     8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                                                     8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                                                     8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                                                     8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                                                     8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                                                     8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                                                     8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                                                     9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                                                     9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                                                     9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                                                     9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                                                     9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                                                     9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                                                     9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                                                     9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                                                     9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                                                     9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                                                     9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                                                     9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                                                     9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                                                     9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                                                     9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                                                     9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                                                     10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                                                     10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                                                     10113, 10131) then 2\n                                                    else 0 end as ads_campaign,\n                                               count(action) filter (WHERE action = 'cancel_order') OVER (PARTITION BY order_id) as is_canceled\n                                        FROM   user_actions) t1\n                                WHERE  ads_campaign in (1, 2)\n                                   and is_canceled = 0\n                                   and time::date &gt;= '2022-09-01'\n                                   and time::date &lt; '2022-09-08') t2\n                            LEFT JOIN (SELECT order_id,\n                                              unnest(product_ids) as product_id\n                                       FROM   orders) t3 using(order_id)\n                            LEFT JOIN products using(product_id)) t4\n                GROUP BY ads_campaign, user_id, order_id) t5\n        GROUP BY ads_campaign, user_id) t6\nGROUP BY ads_campaign\nORDER BY avg_check desc\n\n\n\n\n\n\n\n\n\nads_campaign\navg_check\n\n\n\n\n0\nCompany № 2\n380.88\n\n\n1\nCompany № 1\n371.73\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_10:\n\n\nКод\n%%sql\nresults_10 &lt;&lt; SELECT concat('Company № ', ads_campaign) as ads_campaign,\n       round(avg(user_avg_check), 2) as avg_check\nFROM   (SELECT ads_campaign,\n               user_id,\n               round(avg(order_price), 2) as user_avg_check\n        FROM   (SELECT ads_campaign,\n                       user_id,\n                       order_id,\n                       sum(price) as order_price\n                FROM   (SELECT ads_campaign,\n                               user_id,\n                               order_id,\n                               product_id,\n                               price\n                        FROM   (SELECT ads_campaign,\n                                       user_id,\n                                       order_id\n                                FROM   (SELECT user_id,\n                                               order_id,\n                                               time,\n                                               case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                                                     8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                                                     8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                                                     8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                                                     8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                                                     9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                                                     9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                                                     9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                                                     9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                                                     9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                                                     9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                                                     9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                                                     9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                                                     9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                                                     9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                                                     9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                                                     9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                                                     9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                                                     10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                                                    when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                                                     8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                                                     8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                                                     8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                                                     8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                                                     8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                                                     8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                                                     8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                                                     9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                                                     9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                                                     9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                                                     9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                                                     9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                                                     9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                                                     9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                                                     9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                                                     9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                                                     9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                                                     9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                                                     9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                                                     9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                                                     9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                                                     9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                                                     9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                                                     10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                                                     10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                                                     10113, 10131) then 2\n                                                    else 0 end as ads_campaign,\n                                               count(action) filter (WHERE action = 'cancel_order') OVER (PARTITION BY order_id) as is_canceled\n                                        FROM   user_actions) t1\n                                WHERE  ads_campaign in (1, 2)\n                                   and is_canceled = 0\n                                   and time::date &gt;= '2022-09-01'\n                                   and time::date &lt; '2022-09-08') t2\n                            LEFT JOIN (SELECT order_id,\n                                              unnest(product_ids) as product_id\n                                       FROM   orders) t3 using(order_id)\n                            LEFT JOIN products using(product_id)) t4\n                GROUP BY ads_campaign, user_id, order_id) t5\n        GROUP BY ads_campaign, user_id) t6\nGROUP BY ads_campaign\nORDER BY avg_check desc\n\n\nВізуалізуємо отримані дані:\n\nfig = px.bar(results_10, x=\"ads_campaign\", y=\"avg_check\", text_auto=True)\nfig.show()\n\n\n\n                                                \nРисунок 16.10: Середній чек за кампаніями"
  },
  {
    "objectID": "sql_metrics.html#retention-rate",
    "href": "sql_metrics.html#retention-rate",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.9 Retention rate",
    "text": "16.9 Retention rate\nСередній чек ми порахували, але відповіді на запитання не отримали. У чому тоді може бути справа? Звернемо увагу на ще один важливий показник — Retention rate.\nRetention rate – коефіцієнт утримання клієнтів. Він показує частку користувачів, які повернулися до програми через N днів, тижнів або місяців після свого першого входу — метрику можна розраховувати за будь-якими цікавими періодами.\nУ разі нашого сервісу доставки високий Retention означає, що користувачі часто повертаються, щоб зробити повторне замовлення. Низький Retention, навпаки, говорить про те, що більшість користувачів йдуть у відтік після однієї чи кількох взаємодій. Можливо, їм незручно користуватися нашим додатком, або їх не влаштовують ціни, асортимент товарів, швидкість або вартість доставки — причини можуть бути різні, і щоб їх встановити, потрібні додаткові дослідження.\nТаким чином, метрика Retention відображає цінність нашого продукту в очах користувачів: якщо вони повертаються до нас із певною періодичністю, то наш продукт допомагає їм вирішувати свої завдання.\nМожливо, саме цей показник допоможе нам відповісти на запитання, чому одна із двох рекламних кампаній показує себе краще. Але перш ніж приступати до аналізу Retention, давайте розберемося докладніше з методикою його розрахунку.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.11  На основі даних у таблиці user_actions розрахуйте показник денного Retention для всіх користувачів, розбивши їх на когорти за датою першої взаємодії з нашим додатком.\nУ результат увімкніть чотири колонки: місяць першої взаємодії, дату першої взаємодії, кількість днів, що пройшли з дати першої взаємодії (порядковий номер дня починаючи з 0), і саме значення Retention.\nКолонки зі значеннями назвіть відповідно start_month, start_date, day_number, retention.\nМетрику необхідно виразити у вигляді частки, округливши отримані значення до двох знаків після коми.\nМісяць першої взаємодії вкажіть у вигляді дати, заокругленої до першого числа місяця.\nРезультат має бути відсортований спочатку за зростанням дати першої взаємодії, потім за зростанням порядкового номера дня.\nПоля в результуючій таблиці: start_month, start_date, day_number, retention\nПояснення:\nВ цьому завданні враховуйте всіх унікальних користувачів у таблиці user_actions.\n\n\n\n\n\n\nАлгоритм розрахунку Retention\n\n\n\n\n\nСпочатку для кожного користувача порахуйте дату найпершої дії в додатку (це можна зробити за допомогою віконної функції). Потім зробіть групування за двома полями: датою першої дії та кожною датою, представленою в даних. Далі за згрупованими даними кожного дня порахуйте кількість унікальних користувачів з певною датою першої дії. Після цього для кожної пари “дата першої взаємодії - дата” необхідно порахувати сам Retention, тобто частку унікальних користувачів у кількості користувачів у когорті (число користувачів у нульовий день). Потім залишиться лише витягти місяць із дат і обчислити різницю в днях між кожною датою та датою першої взаємодії.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT date_trunc('month', start_date)::date as start_month,\n       start_date,\n       date - start_date as day_number,\n       round(users::decimal / max(users) OVER (PARTITION BY start_date), 2) as retention\nFROM   (SELECT start_date,\n               date,\n               count(distinct user_id) as users\n        FROM   (SELECT user_id,\n                       time::date as date,\n                       min(time::date) OVER (PARTITION BY user_id) as start_date\n                FROM   user_actions) t1\n        GROUP BY start_date, date) t2\n\n\n\n\n\n\n\n\n\nstart_month\nstart_date\nday_number\nretention\n\n\n\n\n0\n2022-08-01\n2022-08-31\n4\n0.16\n\n\n1\n2022-08-01\n2022-08-31\n8\n0.10\n\n\n2\n2022-08-01\n2022-08-31\n2\n0.16\n\n\n3\n2022-08-01\n2022-08-31\n3\n0.17\n\n\n4\n2022-08-01\n2022-08-31\n6\n0.10\n\n\n...\n...\n...\n...\n...\n\n\n131\n2022-09-01\n2022-09-03\n1\n0.21\n\n\n132\n2022-09-01\n2022-09-03\n3\n0.12\n\n\n133\n2022-09-01\n2022-09-03\n4\n0.14\n\n\n134\n2022-09-01\n2022-09-03\n2\n0.18\n\n\n135\n2022-09-01\n2022-09-08\n0\n1.00\n\n\n\n\n136 rows × 4 columns\n\n\n\nЗбережемо результат запиту у змінну results_11:\n\n\nКод\n%%sql\nresults_11 &lt;&lt; SELECT date_trunc('month', start_date)::date as start_month,\n       start_date,\n       date - start_date as day_number,\n       round(users::decimal / max(users) OVER (PARTITION BY start_date), 2) as retention\nFROM   (SELECT start_date,\n               date,\n               count(distinct user_id) as users\n        FROM   (SELECT user_id,\n                       time::date as date,\n                       min(time::date) OVER (PARTITION BY user_id) as start_date\n                FROM   user_actions) t1\n        GROUP BY start_date, date) t2\n\n\nПобудуємо зведену таблицю:\n\npd.pivot_table(\n    results_11,\n    index=[\"start_month\", \"start_date\"],\n    columns=\"day_number\",\n    values=\"retention\",\n).style.background_gradient(\n    cmap=\"Blues\",\n)\n\n\n\n\n\n\n \nday_number\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nstart_month\nstart_date\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n2022-08-01\n2022-08-24\n1.000000\n0.140000\n0.150000\n0.180000\n0.190000\n0.140000\n0.120000\n0.160000\n0.100000\n0.150000\n0.110000\n0.150000\n0.070000\n0.050000\n0.050000\n0.070000\n\n\n2022-08-25\n1.000000\n0.180000\n0.160000\n0.190000\n0.170000\n0.190000\n0.160000\n0.170000\n0.160000\n0.150000\n0.140000\n0.080000\n0.090000\n0.100000\n0.090000\nnan\n\n\n2022-08-26\n1.000000\n0.220000\n0.200000\n0.220000\n0.170000\n0.150000\n0.150000\n0.140000\n0.140000\n0.150000\n0.090000\n0.090000\n0.100000\n0.090000\nnan\nnan\n\n\n2022-08-27\n1.000000\n0.220000\n0.220000\n0.190000\n0.160000\n0.140000\n0.170000\n0.180000\n0.130000\n0.130000\n0.090000\n0.100000\n0.090000\nnan\nnan\nnan\n\n\n2022-08-28\n1.000000\n0.220000\n0.210000\n0.170000\n0.170000\n0.200000\n0.170000\n0.170000\n0.130000\n0.110000\n0.120000\n0.110000\nnan\nnan\nnan\nnan\n\n\n2022-08-29\n1.000000\n0.180000\n0.150000\n0.160000\n0.150000\n0.160000\n0.140000\n0.100000\n0.080000\n0.090000\n0.080000\nnan\nnan\nnan\nnan\nnan\n\n\n2022-08-30\n1.000000\n0.150000\n0.130000\n0.140000\n0.120000\n0.130000\n0.110000\n0.070000\n0.090000\n0.090000\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-08-31\n1.000000\n0.160000\n0.160000\n0.170000\n0.160000\n0.110000\n0.100000\n0.120000\n0.100000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-09-01\n2022-09-01\n1.000000\n0.180000\n0.180000\n0.180000\n0.140000\n0.090000\n0.120000\n0.100000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-09-02\n1.000000\n0.200000\n0.180000\n0.150000\n0.130000\n0.150000\n0.130000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-09-03\n1.000000\n0.210000\n0.180000\n0.120000\n0.140000\n0.140000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-09-04\n1.000000\n0.160000\n0.130000\n0.160000\n0.160000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-09-05\n1.000000\n0.110000\n0.120000\n0.150000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-09-06\n1.000000\n0.120000\n0.120000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-09-07\n1.000000\n0.170000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2022-09-08\n1.000000\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n\n\n\nА тепер повернемося до аналізу рекламних кампаній та порахуємо Retention для двох груп користувачів. Можливо, справа саме в тому, що один із каналів привів більш активних та зацікавлених користувачів. Давайте це з’ясуємо!\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.12  Для кожної рекламної кампанії порахуйте Retention 1-го та 7-го дня у залучених користувачів.\nУ результаті включіть чотири колонки: колонку з найменуваннями кампаній, дату першої взаємодії з додатком, кількість днів, що минули з дати першої взаємодії (порядковий номер), і саме значення Retention.\nКолонки зі значеннями назвіть відповідно ads_campaign, start_date, day_number, retention.\nНазви кампаній виведіть у такому вигляді:\nCompany № 1\nCompany № 2\nМетрику необхідно виразити у вигляді частки, округливши отримані значення до двох знаків після коми.\nРезультат має бути відсортований спочатку за найменуванням кампанії (за зростанням), потім за зростанням порядкового номера дня.\nУ результат мають потрапити наступні дні: нульовий, перший та сьомий.\nПоля в результуючій таблиці: ads_campaign, start_date, day_number, retention\nПояснення:\nСписки користувачів, що зареєструвалися, ті ж, що і на попередніх кроках.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nАлгоритм розрахунку Retention той самий, що і в попередньому завданні, тільки тепер необхідно додати рекламну кампанію в групування і потім відфільтрувати необхідні дні.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nSELECT concat('Company № ', ads_campaign) as ads_campaign,\n       start_date,\n       day_number,\n       round(users::decimal / max(users) OVER (PARTITION BY ads_campaign,\n                                                            start_date), 2) as retention\nFROM   (SELECT ads_campaign,\n               start_date,\n               date - start_date as day_number,\n               count(distinct user_id) as users\n        FROM   (SELECT ads_campaign,\n                       user_id,\n                       date,\n                       min(date) OVER (PARTITION BY ads_campaign,\n                                                    user_id) as start_date\n                FROM   (SELECT user_id,\n                               time::date as date,\n                               case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                                     8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                                     8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                                     8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                                     8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                                     9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                                     9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                                     9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                                     9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                                     9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                                     9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                                     9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                                     9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                                     9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                                     9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                                     9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                                     9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                                     9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                                     10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                                    when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                                     8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                                     8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                                     8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                                     8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                                     8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                                     8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                                     8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                                     9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                                     9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                                     9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                                     9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                                     9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                                     9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                                     9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                                     9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                                     9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                                     9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                                     9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                                     9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                                     9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                                     9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                                     9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                                     9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                                     10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                                     10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                                     10113, 10131) then 2\n                                    else 0 end as ads_campaign\n                        FROM   user_actions) t1\n                WHERE  ads_campaign in (1, 2)) t2\n        GROUP BY ads_campaign, start_date, date) t3\nWHERE  day_number in (0, 1, 7)\n\n\n\n\n\n\n\n\n\nads_campaign\nstart_date\nday_number\nretention\n\n\n\n\n0\nCompany № 2\n2022-09-01\n0\n1.00\n\n\n1\nCompany № 2\n2022-09-01\n1\n0.17\n\n\n2\nCompany № 2\n2022-09-01\n7\n0.09\n\n\n3\nCompany № 1\n2022-09-01\n0\n1.00\n\n\n4\nCompany № 1\n2022-09-01\n1\n0.42\n\n\n5\nCompany № 1\n2022-09-01\n7\n0.22\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_12:\n\n\nКод\n%%sql\nresults_12 &lt;&lt; SELECT concat('Company № ', ads_campaign) as ads_campaign,\n       start_date,\n       day_number,\n       round(users::decimal / max(users) OVER (PARTITION BY ads_campaign,\n                                                            start_date), 2) as retention\nFROM   (SELECT ads_campaign,\n               start_date,\n               date - start_date as day_number,\n               count(distinct user_id) as users\n        FROM   (SELECT ads_campaign,\n                       user_id,\n                       date,\n                       min(date) OVER (PARTITION BY ads_campaign,\n                                                    user_id) as start_date\n                FROM   (SELECT user_id,\n                               time::date as date,\n                               case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                                     8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                                     8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                                     8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                                     8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                                     9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                                     9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                                     9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                                     9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                                     9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                                     9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                                     9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                                     9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                                     9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                                     9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                                     9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                                     9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                                     9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                                     10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                                    when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                                     8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                                     8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                                     8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                                     8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                                     8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                                     8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                                     8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                                     9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                                     9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                                     9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                                     9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                                     9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                                     9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                                     9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                                     9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                                     9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                                     9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                                     9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                                     9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                                     9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                                     9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                                     9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                                     9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                                     10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                                     10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                                     10113, 10131) then 2\n                                    else 0 end as ads_campaign\n                        FROM   user_actions) t1\n                WHERE  ads_campaign in (1, 2)) t2\n        GROUP BY ads_campaign, start_date, date) t3\nWHERE  day_number in (0, 1, 7)\n\n\nПобудуємо зведену таблицю:\n\npd.pivot_table(\n    results_12,\n    index=\"ads_campaign\",\n    columns=\"day_number\",\n    values=\"retention\",\n).style.background_gradient(\n    cmap=\"Blues\",\n)\n\n\n\n\n\n\nday_number\n0\n1\n7\n\n\nads_campaign\n \n \n \n\n\n\n\nCompany № 1\n1.000000\n0.420000\n0.220000\n\n\nCompany № 2\n1.000000\n0.170000\n0.090000\n\n\n\n\n\nТо чому дві рекламні кампанії відрізняються за значенням метрики ROI? Який висновок можна зробити?\nВисновок: користувачі з обох рекламних каналів практично не відрізняються за середнім чеком, але Retention майже вдвічі вищий у першої групи. Це призводить до того, що користувачі з першої групи приносять нам більше грошей."
  },
  {
    "objectID": "sql_metrics.html#накопичувальний-arppu",
    "href": "sql_metrics.html#накопичувальний-arppu",
    "title": "16  Аналіз продуктових метрик",
    "section": "16.10 Накопичувальний ARPPU",
    "text": "16.10 Накопичувальний ARPPU\nІ насамкінець давайте з’ясуємо, на який день дохід від замовлень покупців, що прийшли після першої рекламної кампанії, перевищив витрати на їхнє залучення. Для цього розрахуємо накопичувальний ARPPU та порівняємо його з уже порахованою раніше метрикою CAC. Зробимо це для двох кампаній, щоб переконатися, що у випадку другої рекламної кампанії витрати ми поки не окупили.\nСуть розрахунку накопичувального ARPPU полягає в тому, що для кожного дня кількість покупців у когорті залишатиметься незмінною, а отриманий від їх замовлень дохід — зростатиме. В результаті накопичувальний ARPPU поступово збільшуватиметься і в якийсь момент перевищить суму початкових витрат на залучення одного покупця.\n\n\n\n\n\n\n\n\n\n\n\nЗавдання 16.13  Для кожної рекламної кампанії кожного дня порахуйте дві метрики:\n\nНакопичувальний ARPPU.\nВитрати залучення одного покупця (CAC).\n\nКолонку з найменуваннями кампаній назвіть ads_campaign, колонку з днями – day, а колонки зі значеннями метрик – cumulative_arppu та cac.\nЗначення метрики CAC вкажіть однаковим для всіх днів (це необхідно для візуалізації).\nНазви кампаній виведіть у такому вигляді:\nCompany № 1\nCompany № 2\nДні пронумеруйте починаючи з 0 та відобразіть у наступному форматі:\nDay 0\nDay 1\nDay 2\n...\nОтримані значення метрика необхідно округлити до двох знаків після коми.\nРезультат повинен бути відсортований спочатку за найменуванням кампанії (за зростанням), потім за найменуванням дня (також за зростанням).\nПоля в результуючій таблиці: ads_campaign, day, cumulative_arppu, cac\nПояснення:\nСписки користувачів, що зареєструвалися, ті ж, що і на попередніх кроках.\n\n\n\n\n\n\nПідказка на випадок, якщо зовсім не виходить\n\n\n\n\n\nЩоб отримати необхідну таблицю, потрібно для кожної рекламної кампанії для кожного дня порахувати сумарну вартість замовлень користувачів, що прийшли відповідним каналом, і розділити її на кількість користувачів, що прийшли в нульовий день. У колонці зі значенням метрики CAC необхідно проставити те саме значення для кожного дня. Метрику CAC ми рахували раніше.\n\n\n\n\n\n\n\n\nРішення\n%%sql\nwith main_table as (SELECT ads_campaign,\n                           user_id,\n                           order_id,\n                           time,\n                           product_id,\n                           price\n                    FROM   (SELECT ads_campaign,\n                                   user_id,\n                                   order_id,\n                                   time\n                            FROM   (SELECT user_id,\n                                           order_id,\n                                           time,\n                                           case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                                                 8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                                                 8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                                                 8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                                                 8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                                                 9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                                                 9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                                                 9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                                                 9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                                                 9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                                                 9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                                                 9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                                                 9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                                                 9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                                                 9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                                                 9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                                                 9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                                                 9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                                                 10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                                                when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                                                 8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                                                 8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                                                 8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                                                 8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                                                 8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                                                 8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                                                 8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                                                 9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                                                 9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                                                 9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                                                 9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                                                 9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                                                 9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                                                 9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                                                 9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                                                 9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                                                 9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                                                 9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                                                 9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                                                 9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                                                 9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                                                 9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                                                 9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                                                 10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                                                 10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                                                 10113, 10131) then 2\n                                                else 0 end as ads_campaign,\n                                           count(action) filter (WHERE action = 'cancel_order') OVER (PARTITION BY order_id) as is_canceled\n                                    FROM   user_actions) t1\n                            WHERE  ads_campaign in (1, 2)\n                               and is_canceled = 0) t2\n                        LEFT JOIN (SELECT order_id,\n                                          unnest(product_ids) as product_id\n                                   FROM   orders) t3 using(order_id)\n                        LEFT JOIN products using(product_id))\nSELECT concat('Кампания № ', ads_campaign) as ads_campaign,\n       concat('Day ', row_number() OVER (PARTITION BY ads_campaign\n                                         ORDER BY date) - 1) as day,\n       round(sum(revenue) OVER (PARTITION BY ads_campaign\n                                ORDER BY date) / paying_users::decimal, 2) as cumulative_arppu,\n       cac\nFROM   (SELECT ads_campaign,\n               time::date as date,\n               sum(price) as revenue\n        FROM   main_table\n        GROUP BY ads_campaign, time::date) t1\n    LEFT JOIN (SELECT ads_campaign,\n                      count(distinct user_id) as paying_users,\n                      round(250000.0 / count(distinct user_id), 2) as cac\n               FROM   main_table\n               GROUP BY ads_campaign) t2 using (ads_campaign)\n\n\n\n\n\n\n\n\n\nads_campaign\nday\ncumulative_arppu\ncac\n\n\n\n\n0\nКампания № 2\nDay 0\n548.42\n1068.38\n\n\n1\nКампания № 2\nDay 1\n656.20\n1068.38\n\n\n2\nКампания № 2\nDay 2\n765.34\n1068.38\n\n\n3\nКампания № 2\nDay 3\n829.88\n1068.38\n\n\n4\nКампания № 2\nDay 4\n888.80\n1068.38\n\n\n5\nКампания № 2\nDay 5\n938.66\n1068.38\n\n\n6\nКампания № 2\nDay 6\n999.46\n1068.38\n\n\n7\nКампания № 2\nDay 7\n1051.21\n1068.38\n\n\n8\nКампания № 1\nDay 0\n521.36\n1461.99\n\n\n9\nКампания № 1\nDay 1\n784.64\n1461.99\n\n\n10\nКампания № 1\nDay 2\n1010.70\n1461.99\n\n\n11\nКампания № 1\nDay 3\n1227.84\n1461.99\n\n\n12\nКампания № 1\nDay 4\n1375.46\n1461.99\n\n\n13\nКампания № 1\nDay 5\n1464.25\n1461.99\n\n\n14\nКампания № 1\nDay 6\n1575.26\n1461.99\n\n\n15\nКампания № 1\nDay 7\n1674.02\n1461.99\n\n\n\n\n\n\n\nЗбережемо результат запиту у змінну results_13:\n\n\nКод\n%%sql\nresults_13 &lt;&lt; with main_table as (SELECT ads_campaign,\n                           user_id,\n                           order_id,\n                           time,\n                           product_id,\n                           price\n                    FROM   (SELECT ads_campaign,\n                                   user_id,\n                                   order_id,\n                                   time\n                            FROM   (SELECT user_id,\n                                           order_id,\n                                           time,\n                                           case when user_id in (8631, 8632, 8638, 8643, 8657, 8673, 8706, 8707, 8715, 8723, 8732,\n                                                                 8739, 8741, 8750, 8751, 8752, 8770, 8774, 8788, 8791,\n                                                                 8804, 8810, 8815, 8828, 8830, 8845, 8853, 8859, 8867,\n                                                                 8869, 8876, 8879, 8883, 8896, 8909, 8911, 8933, 8940,\n                                                                 8972, 8976, 8988, 8990, 9002, 9004, 9009, 9019, 9020,\n                                                                 9035, 9036, 9061, 9069, 9071, 9075, 9081, 9085, 9089,\n                                                                 9108, 9113, 9144, 9145, 9146, 9162, 9165, 9167, 9175,\n                                                                 9180, 9182, 9197, 9198, 9210, 9223, 9251, 9257, 9278,\n                                                                 9287, 9291, 9313, 9317, 9321, 9334, 9351, 9391, 9398,\n                                                                 9414, 9420, 9422, 9431, 9450, 9451, 9454, 9472, 9476,\n                                                                 9478, 9491, 9494, 9505, 9512, 9518, 9524, 9526, 9528,\n                                                                 9531, 9535, 9550, 9559, 9561, 9562, 9599, 9603, 9605,\n                                                                 9611, 9612, 9615, 9625, 9633, 9652, 9654, 9655, 9660,\n                                                                 9662, 9667, 9677, 9679, 9689, 9695, 9720, 9726, 9739,\n                                                                 9740, 9762, 9778, 9786, 9794, 9804, 9810, 9813, 9818,\n                                                                 9828, 9831, 9836, 9838, 9845, 9871, 9887, 9891, 9896,\n                                                                 9897, 9916, 9945, 9960, 9963, 9965, 9968, 9971, 9993,\n                                                                 9998, 9999, 10001, 10013, 10016, 10023, 10030, 10051,\n                                                                 10057, 10064, 10082, 10103, 10105, 10122, 10134, 10135) then 1\n                                                when user_id in (8629, 8630, 8644, 8646, 8650, 8655, 8659, 8660, 8663, 8665, 8670,\n                                                                 8675, 8680, 8681, 8682, 8683, 8694, 8697, 8700, 8704,\n                                                                 8712, 8713, 8719, 8729, 8733, 8742, 8748, 8754, 8771,\n                                                                 8794, 8795, 8798, 8803, 8805, 8806, 8812, 8814, 8825,\n                                                                 8827, 8838, 8849, 8851, 8854, 8855, 8870, 8878, 8882,\n                                                                 8886, 8890, 8893, 8900, 8902, 8913, 8916, 8923, 8929,\n                                                                 8935, 8942, 8943, 8949, 8953, 8955, 8966, 8968, 8971,\n                                                                 8973, 8980, 8995, 8999, 9000, 9007, 9013, 9041, 9042,\n                                                                 9047, 9064, 9068, 9077, 9082, 9083, 9095, 9103, 9109,\n                                                                 9117, 9123, 9127, 9131, 9137, 9140, 9149, 9161, 9179,\n                                                                 9181, 9183, 9185, 9190, 9196, 9203, 9207, 9226, 9227,\n                                                                 9229, 9230, 9231, 9250, 9255, 9259, 9267, 9273, 9281,\n                                                                 9282, 9289, 9292, 9303, 9310, 9312, 9315, 9327, 9333,\n                                                                 9335, 9337, 9343, 9356, 9368, 9370, 9383, 9392, 9404,\n                                                                 9410, 9421, 9428, 9432, 9437, 9468, 9479, 9483, 9485,\n                                                                 9492, 9495, 9497, 9498, 9500, 9510, 9527, 9529, 9530,\n                                                                 9538, 9539, 9545, 9557, 9558, 9560, 9564, 9567, 9570,\n                                                                 9591, 9596, 9598, 9616, 9631, 9634, 9635, 9636, 9658,\n                                                                 9666, 9672, 9684, 9692, 9700, 9704, 9706, 9711, 9719,\n                                                                 9727, 9735, 9741, 9744, 9749, 9752, 9753, 9755, 9757,\n                                                                 9764, 9783, 9784, 9788, 9790, 9808, 9820, 9839, 9841,\n                                                                 9843, 9853, 9855, 9859, 9863, 9877, 9879, 9880, 9882,\n                                                                 9883, 9885, 9901, 9904, 9908, 9910, 9912, 9920, 9929,\n                                                                 9930, 9935, 9939, 9958, 9959, 9961, 9983, 10027, 10033,\n                                                                 10038, 10045, 10047, 10048, 10058, 10059, 10067, 10069,\n                                                                 10073, 10075, 10078, 10079, 10081, 10092, 10106, 10110,\n                                                                 10113, 10131) then 2\n                                                else 0 end as ads_campaign,\n                                           count(action) filter (WHERE action = 'cancel_order') OVER (PARTITION BY order_id) as is_canceled\n                                    FROM   user_actions) t1\n                            WHERE  ads_campaign in (1, 2)\n                               and is_canceled = 0) t2\n                        LEFT JOIN (SELECT order_id,\n                                          unnest(product_ids) as product_id\n                                   FROM   orders) t3 using(order_id)\n                        LEFT JOIN products using(product_id))\nSELECT concat('Кампания № ', ads_campaign) as ads_campaign,\n       concat('Day ', row_number() OVER (PARTITION BY ads_campaign\n                                         ORDER BY date) - 1) as day,\n       round(sum(revenue) OVER (PARTITION BY ads_campaign\n                                ORDER BY date) / paying_users::decimal, 2) as cumulative_arppu,\n       cac\nFROM   (SELECT ads_campaign,\n               time::date as date,\n               sum(price) as revenue\n        FROM   main_table\n        GROUP BY ads_campaign, time::date) t1\n    LEFT JOIN (SELECT ads_campaign,\n                      count(distinct user_id) as paying_users,\n                      round(250000.0 / count(distinct user_id), 2) as cac\n               FROM   main_table\n               GROUP BY ads_campaign) t2 using (ads_campaign)\n\n\nВізуалізуємо отримані дані:\n\nimport plotly.express as px\n\ncomp_1 = results_13[results_13[\"ads_campaign\"] == \"Кампания № 1\"]\ncomp_2 = results_13[results_13[\"ads_campaign\"] == \"Кампания № 2\"]\n\nfig = px.area(comp_1, x=\"day\", y=\"cumulative_arppu\")\nfig.add_hline(y=1461.99, line_color=\"red\", annotation_text=\"CAC = 1461.99\")\nfig.show()\n\nfig = px.area(comp_2, x=\"day\", y=\"cumulative_arppu\")\nfig.add_hline(y=1068.38, line_color=\"red\", annotation_text=\"CAC = 1068.38\")\nfig.show()\n\n\n\n\n\n\n                                                \n(a) Графік для першої рекламної кампанії\n\n\n\n\n\n                                                \n(b) Графік для першої рекламної кампанії\n\n\n\nРисунок 16.11: Графік за результатами SQL-запиту\n\n\n\nЯкий висновок можна зробити на основі побудованих графіків?\nВисновок: для першої рекламної кампанії накопичувальний ARPPU перевищив витрати на залучення одного покупця (CAC) вже на 5 день, тоді як для другої кампанії навіть на 7 день значення CAC все ще перевищувало значення ARPPU."
  },
  {
    "objectID": "quarto.html#що-таке-quarto",
    "href": "quarto.html#що-таке-quarto",
    "title": "17  Quarto",
    "section": "17.1 Що таке Quarto",
    "text": "17.1 Що таке Quarto\nQuarto — це науково–технічна видавнича система з відкритим кодом, яка ґрунтується на універсальному конверторі документів Pandoc та використовує мову розмітки Markdown. Це універсальний інструмент для тих, хто пише на R, Python, Julia та Observable JavaScript.\nЗа допомогою Quarto можна поєднувати описовий текст і код для створення відформатованих документів, веб–сторінок, постів у блогах, книг тощо.\n\n17.1.1 Назва Quarto\nРозробники Quarto хотіли використати ім’я, яке мало деяке значення в історії видавничої справи. Вибір пав на Quarto (від латинського quārtō, скорочено Qto, 4to або 4º) — це формат книги або брошури в одну четвертину топографічного листа. На кожній стороні листа при цьому поміщається 4 сторінки книги (8 сторінок на один лист).\nНайраннішим відомим виданням такого формату була Книга Сивіл (англ. Sibyllenbuch), що була надрукована Йоганном Гутенбергом у 1452–1453 роках.\n\n\n\nРисунок 17.1: Quarto\n\n\n\n\n17.1.2 Можливості Quarto\nQuarto являє собою текстовий документ спеціального формату .qmd, який можна скомпілювати у різноманітні документи:\n\nДокументи у форматах:\n\nHTML\nPDF\nePub\nMS Word\nOpenOffice\n\nПрезентації у форматах:\n\nreveal.js (HTML)\nPowerPoint (MS Office)\nBeamer (LaTeX/PDF)\n\nВеб-сторінки:\n\nPractical Deep Learning від fast.ai\nnbdev від fast.ai\nКурс Julia Workshop for Data Science\n\nКниги, приклади яких можна переглянути за посиланнями:\n\nPython for Data Analysis\nR for Data Science\nVisualization Curriculum\n\nІнтерактивні документи:\n\nObservable reactive JavaScript\nShiny вебфреймворк\nІнтерактивні віджети Jupyter"
  },
  {
    "objectID": "quarto.html#початок-роботи-з-quarto",
    "href": "quarto.html#початок-роботи-з-quarto",
    "title": "17  Quarto",
    "section": "17.2 Початок роботи з Quarto",
    "text": "17.2 Початок роботи з Quarto\n\n17.2.1 Встановлення Quarto\nДля роботи з Quarto потрібно: 1. Встановити інтерфейс командного рядка Quarto (CLI) під актуальну операційну систему (Windows, Linux або Mac OS).\n\nВстановити плагін для інтегрованого середовища розробки (IDE). На даний момент підтримуються:\n\nVS Code\nRStudio\nJupyter\n\n\n\n\n17.2.2 Робота з проектами\nСтворити Quarto–проект можна декількома шляхами:\n\nЗа допомогою командного рядка:\n\n\n\nterminal\n\n# веб-сайт\nquarto create-project mysite --type website\n\n# блог\nquarto create-project myblog --type website:blog\n\n# книга\nquarto create-project mybook --type book\n\n\nЗасобами IDE:\n\n\nVS Code: File -&gt; New File -&gt; …\n\n\n\n\nРисунок 17.2: Меню створення Quarto–проекту у VS Code\n\n\n\nRStudio: File -&gt; New Project… -&gt; New Directory\n\n\n\n\nРисунок 17.3: Меню створення Quarto–проекту у RStudio\n\n\n\n\n17.2.3 Як працює Quarto\nСпочатку Knitr (для R) або Jupyter (для Python або Julia) виконує всі фрагменти коду .qmd-файлу і створює новий markdown (.md) документ, який включає в себе код і всі його результати. Далі .md–файл оброблюється Pandoc для перетворення у різноманітні формати файлів (HTML, PDF, Word тощо).\n\n\n\nРисунок 17.4: Процедура рендерінгу документів в Quarto\n\n\n\n\n17.2.4 Рендерінг\n\nДля рендерінгу документу можна використати кнопку Render в VS Code.\n\n\n\n\nРисунок 17.5: Клавіша рендерінгу документу в VS Code\n\n\n\nРендерінг за допомогою командного рядку:\n\n\n\nterminal\n\nquarto render &lt;input&gt; --to &lt;format&gt;\n\n# Наприклад:\nquarto render document.qmd --to docx"
  },
  {
    "objectID": "quarto.html#структура-документів-quatro",
    "href": "quarto.html#структура-документів-quatro",
    "title": "17  Quarto",
    "section": "17.3 Структура документів Quatro",
    "text": "17.3 Структура документів Quatro\nQuatro документи складаються з трьох базових складових:\n\nYAML–шапки1\nТекст з використанням розмітки Markdown\nЧанків (анг. chunks) з кодом\n\n\n17.3.1 YAML–шапка\nYAML–шапка знаходиться нагорі документу і відділена трьома дефісами (---) зверху та знизу. В ній зберігається мета–інформація документу: назва, дата створення, автор, інформація щодо роботи коду, контенту і процесу рендерінгу.\n---\ntitle: \"Dracula\"\nauthor: \"Bram Stoker\"\ndate: \"May 26, 1897\"\nformat: \n  html:\n    toc: true\n    code-fold: true\n---\n\n\n17.3.2 Текст з використанням розмітки Markdown\nЦя частина документу йде одраtextзу після YAML–шапки і складає основну частину документу.\nMarkdown — це популярна і зручна мова розмітки. Ви непевно зустрічали її в README.md–файлах репозиторіїв GitHub, а також у Telegram–повідомленнях.\n\n\n17.3.3 Чанки з кодом\nЧанки — це блоки, які відділяються від тексту потрійними зворотніми лапками ``` ( анг. backtick) на початку та в кінці. У фігурних дужках вказується мова програмування на якій необхідно виконати код.\n```{python}\nprint('Fly, you fools!')\n```\nРезультат чанку за замовчування виводиться одразу після нього, але все це можна налаштувати."
  },
  {
    "objectID": "quarto.html#yaml-шапка",
    "href": "quarto.html#yaml-шапка",
    "title": "17  Quarto",
    "section": "17.4 YAML-шапка",
    "text": "17.4 YAML-шапка\nМетадані документу можуть бути задані у шапці документу або окремим _quarto.yml-файлом.\nВ цій частині документу зберігається інформація щодо назви документу, дати, автора, налаштування рендерінгу, параметри чанків та інші додаткові налаштування. Всі параметри встановлюються у форматі key: value.\n\n17.4.1 Налаштування виводу\nКлюч format: відповідає за тип вихідного файлу.\n\n\n\n\n\n\n\n\nТип\nЗначення\nОпис\n\n\n\n\nДокументи\n\nhtml\npdf\ndocx\nodt\nepub\n\n\nHTML\nPDF\nMS Word\nOpenDocument\nePub\n\n\n\nПрезентації\n\nrevealjs\npptx\nbeamer\n\n\nRevealjs\nPowerPoint\nBeamer\n\n\n\nMarkdown\n\ngfm\ncommonmark\nmarkua\n\n\nGFM\nCommonMark\nMarkua\n\n\n\nWiki\n\nmediawiki\ndokuwiki\nzimwiki\njira\nxwiki\n\n\nMediaWiki\nDocuWiki\nZimWiki\nJira Wiki\nXWiki\n\n\n\n\nА також цілу низку інших форматів, документацію по котрим можна отримати в розділі Reference документації.\n\n\n17.4.2 Назва, дата та автор\nВ залежності від типу вихідного документу, ці ключі можуть відрізнятися, але наведу основні:\n\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\n\ntitle\nНазва документа\n\n\nsubtitle\nПідзаголовок документа\n\n\ndate\nДата документа\n\n\nauthor\nАвтор або автори документа\n\n\n\n\n\n17.4.3 Зміст\nДля генерації змісту (анг. table of contents, скорочено toc) необхідно ключу toc задати значення true. В залежності від типу вихідного документу зміст буде згенерований відповідно до заголовків (Розділ 17.5.2).\n\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\n\ntoc\nДодайте автоматично створений зміст у вихідний документ.\n\n\ntoc-depth\nКількість рівнів розділу, які потрібно включити у зміст. За замовчуванням 3\n\n\ntoc-title\nЗаголовок, використаний для змісту.\n\n\n\n\n\n17.4.4 Локалізація документу\nQuarto, Pandoc та LaTeX генерують текстові елементи документу, які потребують локалізації. Наприклад: “Рисунок” або “Таблиця” для перехресних посилань, назви виносок тощо.\n\n17.4.4.1 Налаштування lang\nПриклад використання польської локалізації документу:\n---\ntitle: \"Mój dokument\"\nlang: pl  \n---\nЦе призведе до використання польського перекладу компонентів документу, а також до застосування інших мовних правил обробки документів.\nНаразі доступні повні переклади такими мовами:\n\nанглійська (en, за замовчуванням)\nголландська (nl)\nіспанська (es)\nіталійська (it)\nкитайська (zh)\nкорейська (kr)\nнімецька (de)\nпольська (pl)\nпортугальська (pt)\nросійська (ru)\nфінська (fi)\nфранцузька (fr)\nчеська (cs)\nяпонська (ja)\n\n\n\n17.4.4.2 Власна локалізація\nЯкщо вас не влаштовує мова за умовчанням, яка використовується для певної частини документа, ви можете вказати альтернативну мову за допомогою ключа language. Наприклад, щоб замінити значення підписів «Author» і «Published», які використовуються в блоках заголовків, ви можете зробити це:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: \n  title-block-author-single: \"Автор\"\n  title-block-published: \"Опубліковано\"\n---\nВсі ці зміни можна зберегти в окремому .yml-файлі і використовувати власну локалізацію до документу:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: custom.yml\n---\nЯ зробив власну українську локалізацію Quarto-документів, яку Ви можете завантажити з мого GitHub-репозиторія: https://github.com/aranaur/quarto-ukrainian.\nОзнайомитися з усіма офіційними локалізаціями можна за посиланням: https://github.com/quarto-dev/quarto-cli/tree/main/src/resources/language."
  },
  {
    "objectID": "quarto.html#основи-markdown",
    "href": "quarto.html#основи-markdown",
    "title": "17  Quarto",
    "section": "17.5 Основи Markdown",
    "text": "17.5 Основи Markdown\nQuarto ґрунтується на Pandoc та використовує різновид markdown в якості базового синтаксису. Pandoc markdown — це розширена та злегка перероблена версія синтаксису markdown.\nMarkdown — це формат звичайного тексту, який розроблено таким чином, щоб його було легко писати та, що ще важливіше, легко читати.\n\n17.5.1 Форматування тексту\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n*курсив* та **жирний**\nкурсив та жирний\n\n\nнадрядковий^2^ / підрядковий~2~\nнадрядковий2 / підрядковий2\n\n\n~~перекреслення~~\nперекреслення\n\n\n`дослівний код`\nдослівний код\n\n\n\n\n\n17.5.2 Заголовки\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n# Заголовок 1\nЗаголовок 1\n\n\n## Заголовок 2\nЗаголовок 2\n\n\n### Заголовок 3\nЗаголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6\n\n\n\n\n\n17.5.3 Посилання та рисунки\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n[Python](https://python.org)\nPython\n\n\n![Підпис](img/python-logo.jpg)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org \"Python\")\n\n\n\n[![](img/python-logo.jpg){fig-alt=\"Alt text\"}](https://www.python.org)\n\n\n\n\n\n\n17.5.4 Списки\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\n* невпорядкований список\n    + підпункт 1\n    + підпункт 2\n        - під--підпункт 1\n\nневпорядкований список\n\nпідпункт 1\nпідпункт 2\n\nпід–підпункт 1\n\n\n\n\n\n*   пункт 2\n\n    Продовження (відступ 4 інтервали)\n\nпункт 2\nПродовження (відступ 4 інтервали)\n\n\n\n1. впорядкований список\n2. пункт 2\n    i) підпункт 1\n         A.  під--підпункт 1\n\nвпорядкований список\nпункт 2\n\nпідпункт 1\n\nпід–підпункт 1\n\n\n\n\n\n(@)  Список, нумерація якого\n\nпродовжується після\n\n(@)  переривання\n\nСписок, нумерація якого\n\nпродовжується після\n\nпереривання\n\n\n\nтермін\n: визначення\n\nтермін\n\nвизначення\n\n\n\n\n\n\n\n17.5.5 Таблиці\n\n17.5.5.1 Таблиці markdown\n\nСинтаксис markdown\n| Зліва | Справа | За замовчуванням | По центру |\n|------:|:-------|------------------|:---------:|\n|   12  |  12    |    12            |    12     |\n|  123  |  123   |   123            |   123     |\n|    1  |    1   |     1            |     1     |\n\n\nРезультат\n\n\n\nЗліва\nСправа\nЗа замовчуванням\nПо центру\n\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\nФормувати такі таблиці вручну досить складно і незручно. В таких випадках на допомогу приходить Markdown Tables Generator.\n\n\n\n17.5.5.2 Таблиці з Python\n\nЗа допомогою комбінації функцій Markdown() та пакету tabulate:\n\n\n\nterminal\n\npip install tabulate\n\n\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\ntable = [[\"Bilbo Baggins\", \"Hobbits\", \"Male\"],\n         [\"Beren\", \"Men\", \"Male\"],\n         [\"Nimrodel\", \"Elves\", \"Female\"],\n         [\"Muzgash\", \"Orc\", \"Male\"]]\nMarkdown(tabulate(\n  table, \n  headers=[\"Name\", \"Race\", \"Sex\"]\n))\n\n\n\nТаблиця 17.1: Персонажі Середзем’я\n\n\nName\nRace\nSex\n\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nPandas DataFrame у форматі консолі:\n\n\nчерез функцію print(), у форматі консолі:\n\n\nimport pandas as pd\n\ndf = pd.DataFrame(data = table,\n    columns = [\"Name\", \"Race\", \"Sex\"])\nprint(df)\n\n            Name     Race     Sex\n0  Bilbo Baggins  Hobbits    Male\n1          Beren      Men    Male\n2       Nimrodel    Elves  Female\n3        Muzgash      Orc    Male\n\n\n\nМожна викликати Python через R за допомогою пакету reticulate та використати функцію kable() з пакету knitr:\n\n\nlibrary(reticulate)\nlibrary(knitr)\n\nkable(py$df)\n\n\n\nТаблиця 17.2: Персонажі Середзем’я\n\n\nName\nRace\nSex\n\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nДодаткові можливості з’являються разом з пакетом kableExtra:\n\n\n# R chunk\nlibrary(kableExtra)\n\npy$df %&gt;% \n  kbl() %&gt;%\n  kable_classic_2(full_width = F)\n\n\n\nТаблиця 17.3: Персонажі Середзем’я\n\n\nName\nRace\nSex\n\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\n\n\n\n\n17.5.6 Рівняння\nДля запису рівняння в середині тексту використовується одинарний символ $ та подвійний $$ для запису рівняння з нового рядка:\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\nу середині тексту: $E = mc^{2}$\nу середині тексту: \\(E=mc^{2}\\)\n\n\nз нового рядка:\n\n$$E = mc^{2}$$\nз нового рядка:\n\\[E = mc^{2}\\]\n\n\n\nВ якості допомоги формування рівнянь рекомендую ресурс Online LaTeX Equation Editor.\n\n\n17.5.7 Діаграми\nQuarto має вбудовану підтримку для створення діаграм Mermaid та Graphviz. Це дає змогу створювати блок–схеми, діаграми послідовності, діаграми станів тощо, використовуючи синтаксис простого тексту.\nПриклад створення блок–схеми за допомогою Mermaid:\n\n```{mermaid}\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n```\n\n\n\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n\n\n\n\n\nБільше інформації у розділі Diagrams.\n\n\n17.5.8 Відео\nВставляти відео у документи можна за допомогою запису {{&lt; video &gt;}}.\nПриклад використання відео з Youtube:\n{{&lt; video https://www.youtube.com/embed/qOhk7YyxXQ4 &gt;}}\nБільше інформації у розділі Videos.\n\n\n17.5.9 Виноски\n\n17.5.9.1 Типи виносок\nВиноски — чудовий спосіб привернути додаткову увагу до певних понять або чіткіше вказати, що певний вміст є додатковим або потребує додаткової уваги.\nУ Quarto є п’ять різноманітних виносок: - примітка (note) - застереження (warning) - важливо (important) - підказка (tip) - попередження (caution)\nКолір і значок відрізнятимуться залежно від обраного типу. Ось як виглядають різні виноски в HTML:\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що існує п’ять типів виносок, зокрема: note, tip, warning, caution та important.\n\n\n\n\n\n\n\n\nЗастереження\n\n\n\nВиноски — простий спосіб привернути увагу, наприклад, до цього застереження.\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nВиноски точно покращать Ваш текст.\n\n\n\n\n\n\n\n\nПідказка\n\n\n\nПриклад виноски з текстом\n\n\n\n\n\n\n\n\nРозгорніть, щоб дізнатися про згортання\n\n\n\n\n\nЦе приклад «згорнутої» виноски з попередженням. Використайте collapse=\"true\" щоб згорнути її за замовчуванням та collapse=\"false\" щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n\n\n\n\n\n17.5.9.2 Синтаксис markdown\nСтворіть виноски в розмітці за допомогою наступного синтаксису (зверніть увагу, що перший заголовок, використаний у виносці, використовується як заголовок виноски):\n::: {.callout-note}\n## Примітка\n\nЗауважте, що існує п’ять типів виносок, зокрема:\n`note`, `tip`, `warning`, `caution` та `important`.\n:::\n\n::: {.callout-tip}\n## Підказка\n\nПриклад виноски з текстом\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Розгорніть, щоб дізнатися про згортання\n\nЦе приклад «згорнутої» виноски з попередженням.\nВикористайте `collapse=\"true\"` щоб згорнути її за замовчуванням та `collapse=\"false\"` щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n:::\n\n\n\n17.5.10 Спеціальні символи\n\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n\nтире: -\nтире: -\n\n\nкоротке (середнє) тире: --\nкоротке (середнє) тире: –\n\n\nдовге тире: ---\nдовге тире: —\n\n\n\n\n\n\n\n\n\nПриклади\n\n\n\n\nЖиття прожити — не поле перейти (довге тире)\n2020–2022 (коротке тире)\n25 - 5 (тире)"
  },
  {
    "objectID": "quarto.html#виконання-коду",
    "href": "quarto.html#виконання-коду",
    "title": "17  Quarto",
    "section": "17.6 Виконання коду",
    "text": "17.6 Виконання коду\n\n17.6.1 Налаштування виводу\nІснує широкий спектр доступних параметрів для налаштування виводу виконаного коду. Усі ці параметри можна вказати глобально (у YAML-шапці з ключем execute) або для кожного блоку коду.\n\nПриклад глобальних налаштувань:\n\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\nexecute:\n  echo: false\n---\n\nПриклад налаштування конкретного чанку:\n\n```{python}\n#| echo: true\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nx = np.arange(-4, 4, .012)\ny = np.arange(-4, 4, .012)\nX, Y = np.meshgrid(x, y)\nZ = 1 - np.abs(X) - np.sin(Y**2)\nW = 1 + Y - np.cos(X**2)\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(projection='polar')\nplt.scatter(Z, W, alpha=.03, s=0.2)\nplt.axis('off')\nplt.show()\n```\nПараметри налаштування знаходяться у верхній частині блоку під спеціальним коментарем #|.\n\n\n\n\n\n\n\nНалаштування\nОпис\n\n\n\n\neval\nОцініть фрагмент коду (якщо false, просто відтворіть код).\n\n\necho\nПоказувати код (якщо false, код не буде виведено на екран).\n\n\nwarning\nПоказувати попередження, які виникають під час виконання коду\n\n\nerror\nПоказувати помилки у документі (це означає, що помилки під час виконання коду не зупинять обробку документа).\n\n\ninclude\nЗапобігає виводу коду та його результатів.\n\n\n\n\n\n17.6.2 Вбудований код\nQuarto дозволяє виводити результат коду в середині тексту. Це особливо зручно, якщо необхідно щоб документ використовував найсвіжіші розрахунки. Проте синтаксис виводу залежить від рушія (анг. engine) Quarto: Jupyter, Knitr або OJS.\n\n17.6.2.1 Jupyter\nЩоб включити збережену змінну, використовуєте IPython.display.Markdown.\nНаприклад, виведемо площу кола за заданим радіусом (radius):\n```{python}\n#| echo: false\n\nfrom IPython.display import Markdown\nimport math\n\nradius = 10\ncircle_area = math.pi * pow(radius, 2)\n\nMarkdown((f\"\"\"\nПлоща кола з радіусом {radius} дорівнює {round(circle_area, 2)}.\n\"\"\"\n))\n```\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що ми використовуємо опцію echo: false, щоб не виводити код у фінальний документ, а тільки результат.\n\n\n\n\n17.6.2.2 Knitr\nАналогічно до роботи з таблицями (див. Розділ 17.5.5.2) можемо поєднати можливості R та Python для виводу результату коду в тексті документу.\nЩоб включити вирази в розмітку для Knitr, використовується вираз у `r `:\n```{r}\n#| include: false\n\nlibrary(reticulate)\n```\n```{python}\n#| echo: false\n\nimport math\n\nradius = 10\ncircle_area = round(math.pi * pow(radius, 2), 2)\n```\nПлоща кола з радіусом  `r⠀py$radius`  дорівнює `r⠀py$circle_area`.\n\n\n\n\n\n\nПримітка\n\n\n\nЗапис py$radius означає: взяти значення змінної Python з ім’ям radius."
  },
  {
    "objectID": "quarto.html#основи-публікації",
    "href": "quarto.html#основи-публікації",
    "title": "17  Quarto",
    "section": "17.7 Основи публікації",
    "text": "17.7 Основи публікації\nІснує низка способів публікації документів, презентацій і веб-документів, створених за допомогою Quarto. Оскільки вміст, відтворений за допомогою Quarto, використовує стандартні формати (HTML, PDF, MS Word тощо), його можна опублікувати будь-де. Крім того, доступна команда quarto publish для легкої публікації в різних популярних службах (GitHub, Netlify, RStudio Connect тощо), а також різні інструменти, які полегшують публікацію з системи Неперервної інтеграції (анг. Continuous integration).\nСервіси для публікації:\n\n\n\n\n\n\n\nСервіс\nОпис\n\n\n\n\nQuarto Pub\nПублікація документів, веб-сайтів і книг Quarto.\n\n\nGitHub Pages\nПублікація документів за допомогою репозиторію GitHub\n\n\nRStudio Connect\nПлатформа для безпечного обміну даними в межах організації.\n\n\nNetlify\nПрофесійна платформа веб-публікації.\n\n\nІнші сервіси\nСкористайтеся цими сервісами, якщо один із наведених вище методів не відповідає вашим вимогам."
  },
  {
    "objectID": "quarto.html#footnotes",
    "href": "quarto.html#footnotes",
    "title": "17  Quarto",
    "section": "",
    "text": "YAML це рекурсивний акронім YAML Ain’t Markup Language («YAML — не мова розмітки»). У назві відображена історія розвитку: на ранніх етапах мова називалася Yet Another Markup Language («Ще одна мова розмітки») і навіть розглядалася як конкурент XML, але пізніше була перейменована з метою акцентувати увагу на даних, а не на розбивці документів.↩︎"
  },
  {
    "objectID": "python_loops.html#словники",
    "href": "python_loops.html#словники",
    "title": "3  Цикли",
    "section": "3.3 Словники",
    "text": "3.3 Словники\nРозглянемо ще один тип структури даних в Python - словники dict. Словники в Python створюються за допомогою фігурних дужок {} і містять пари ключ-значення. Ключі у словниках мають бути унікальними, тобто не можуть повторюватися. Значення у словниках можуть бути будь-якого типу, в тому числі інші словники.\nПрипустимо, що ми хочемо відстежувати, хто до якого гуртожитку відноситься в Гоґвортсі. Для прикладу візьмемо чотирьох учнів:\n\n\n\n\n\n\n\n\n\nГерміона Грейнджер\nГаррі Поттер\nРон Уізлі\nДрако Малфой\n\n\n\n\nҐрифіндор\nҐрифіндор\nҐрифіндор\nСлизерин\n\n\n\nТож давайте додамо ще один створимо словник students:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nТепер давайте виведемо на екран ім’я та гуртожиток кожного учня. Для цього ми можемо скористатися циклом for. Але якщо ми спробуємо використати цикл for таким чином, як ми це робили раніше, то ми отримаємо лише імена учнів:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nfor student in students:\n    print(student)\n\nГерміона Грейнджер\nГаррі Поттер\nРон Уізлі\nДрако Малфой\n\n\nЩоб вивести ім’я та гуртожиток кожного учня, ми можемо скористатися індексацією словника за ключем. Індексація словника за ключем відбувається за допомогою квадратних дужок [] після назви змінної. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = {\n    \"Герміона Грейнджер\": \"Ґрифіндор\",\n    \"Гаррі Поттер\": \"Ґрифіндор\",\n    \"Рон Уізлі\": \"Ґрифіндор\",\n    \"Драко Малфой\": \"Слизерин\"\n}\n\nfor student in students:\n    print(f\"{student}: {students[student]}\")\n\nГерміона Грейнджер: Ґрифіндор\nГаррі Поттер: Ґрифіндор\nРон Уізлі: Ґрифіндор\nДрако Малфой: Слизерин\n\n\nДавайте ускладнимо задачу і додамо ще одину характеристику до кожного учня - його Патронуса:\n\n\n\nІм’я\nГуртожиток\nПатронус\n\n\n\n\nГерміона Грейнджер\nҐрифіндор\nВидра\n\n\nГаррі Поттер\nҐрифіндор\nОлень\n\n\nРон Уізлі\nҐрифіндор\nТер’єр\n\n\nДрако Малфой\nСлизерин\n\n\n\n\nДля цього ми можемо використати список, який містить словники. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = [\n    {\n        \"ім'я\": \"Герміона Грейнджер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    {\n        \"ім'я\": \"Гаррі Поттер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    {\n        \"ім'я\": \"Рон Уізлі\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    {\n        \"ім'я\": \"Драко Малфой\",\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n]\n\nЗверніть увагу, що згідно канонічного варіанту Драко Малфой не має Патронуса. Тому ми вказали його значення як None - це спеціальне значення, яке означає “нічого”.\nДля виводу інформації про учнів ми можемо скористатися циклом for:\n\nstudents = [\n    {\n        \"ім'я\": \"Герміона Грейнджер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    {\n        \"ім'я\": \"Гаррі Поттер\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    {\n        \"ім'я\": \"Рон Уізлі\",\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    {\n        \"ім'я\": \"Драко Малфой\",\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n]\n\nfor student in students:\n    print(student[\"ім'я\"], student[\"гуртожиток\"], student[\"патронус\"], sep=\", \")\n\nГерміона Грейнджер, Ґрифіндор, Видра\nГаррі Поттер, Ґрифіндор, Олень\nРон Уізлі, Ґрифіндор, Тер'єр\nДрако Малфой, Слизерин, None\n\n\nАльтернативний варіант створення словника students - це використання вкладених словників:\n\nstudents = {\n    \"Герміона Грейнджер\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Видра\"\n    },\n    \"Гаррі Поттер\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Олень\"\n    },\n    \"Рон Уізлі\": {\n        \"гуртожиток\": \"Ґрифіндор\",\n        \"патронус\": \"Тер'єр\"\n    },\n    \"Драко Малфой\": {\n        \"гуртожиток\": \"Слизерин\",\n        \"патронус\": None\n    }\n}\n\nfor student in students:\n    print(student, students[student][\"гуртожиток\"], students[student][\"патронус\"], sep=\", \")\n\nГерміона Грейнджер, Ґрифіндор, Видра\nГаррі Поттер, Ґрифіндор, Олень\nРон Уізлі, Ґрифіндор, Тер'єр\nДрако Малфой, Слизерин, None\n\n\n\n3.3.1 Створення словника\nУ Python є кілька способів створення словників. Ось деякі з них:\n\nЛітерали словника\n\nЛітерали словника являють собою список ключів і значень, укладених у фігурні дужки. Ключ і значення розділяються двокрапкою, а пари ключ-значення розділяються комою. Наприклад:\n\nmy_dict = {'ім\\'я': 'Аліса', 'вік': 25, 'місто': 'Київ'}\nprint(my_dict)\n\n{\"ім'я\": 'Аліса', 'вік': 25, 'місто': 'Київ'}\n\n\n\nВбудована функція dict()\n\nФункцію dict() можна використовувати для створення словників з інших послідовностей або для створення порожнього словника. Наприклад:\n\nempty_dict = dict()\nprint(empty_dict)\n\n{}\n\n\n\nfruit_dict = dict([('яблуко', 5), ('банан', 3), ('апельсин', 2)])\nprint(fruit_dict)\n\n{'яблуко': 5, 'банан': 3, 'апельсин': 2}\n\n\n\nГенератор словників\n\nГенератори словників дозволяють створювати словники на основі інших послідовностей. Наприклад:\n\nfruit_list = ['яблуко', 'банан', 'апельсин']\nfruit_dict = {fruit: len(fruit) for fruit in fruit_list}\nprint(fruit_dict)\n\n{'яблуко': 6, 'банан': 5, 'апельсин': 8}\n\n\n\nМетод fromkeys()\n\nМетод fromkeys() дає змогу створити словник із зазначеними ключами й одним і тим самим значенням для всіх ключів. Наприклад:\n\nfruit_list = ['яблуко', 'банан', 'апельсин']\nfruit_dict = {}.fromkeys(fruit_list, 0)\nprint(fruit_dict)\n\n{'яблуко': 0, 'банан': 0, 'апельсин': 0}\n\n\nПам’ятаєте, ми з вами говорили про frozenset (див. 4.0.2)? Одна з його корисних особливостей - frozenset можна використовувати як ключ словника. Припустимо, ми хочемо як ключ, зберігати одразу кілька значень - ім’я користувача і його вік.\n\nstudents_courses = {}\nname_age = frozenset(['Anatoly', 32])\nstudents_courses.update({name_age: ['Python', 'C++']})\nprint(students_courses)\n\n{frozenset({32, 'Anatoly'}): ['Python', 'C++']}\n\n\nЦе один із прикладів практичного застосування frozenset, якщо ми хочемо створити словник, де сам ключ - це масив із кількох елементів, то frozenset зможе нам допомогти. Список або звичайний set використовувати як ключ для словника не вийде.\nЦе лише деякі зі способів створення словників у Python. Кожен із них має свої особливості та може використовуватися залежно від конкретного завдання.\n\n\n3.3.2 Основні методи словників\n\nget() - дає змогу отримати значення за ключем, але на відміну від звернення через [], не викликає виняток KeyError, якщо ключ відсутній у словнику. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.get(\"two\"))\nprint(my_dict.get(\"four\", \"Key not found\"))\n\n2\nKey not found\n\n\n\nkeys() - дає змогу отримати список ключів словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.keys())\n\ndict_keys(['one', 'two', 'three'])\n\n\n\nvalues() - дає змогу отримати список значень словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.values())\n\ndict_values([1, 2, 3])\n\n\n\nitems() - дає змогу отримати список пар ключ-значення словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.items())\n\ndict_items([('one', 1), ('two', 2), ('three', 3)])\n\n\n\npop() - дає змогу видалити пару ключ-значення за ключем. Якщо ключ відсутній, викликає виняток KeyError або повертає другий аргумент, якщо він переданий. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.pop(\"two\"))\nprint(my_dict.pop(\"four\", \"Key not found\"))\n\n2\nKey not found\n\n\n\nclear() - дає змогу видалити всі пари ключ-значення зі словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nmy_dict.clear()\nprint(my_dict)\n\n{}\n\n\n\nupdate() - дає змогу оновити словник із іншого словника або із послідовності пар ключ-значення. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nnew_dict = {\"two\": 22, \"four\": 4}\nmy_dict.update(new_dict)\nprint(my_dict)\n\n{'one': 1, 'two': 22, 'three': 3, 'four': 4}\n\n\n\ncopy() - дає змогу створити копію словника. Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nnew_dict = my_dict.copy()\nprint(new_dict)\n\n{'one': 1, 'two': 2, 'three': 3}\n\n\n\nsetdefault() - повертає значення за ключем. Якщо ключ відсутній, то він буде вставлений у словник із зазначеним значенням (або None, якщо значення не вказано). Приклад:\n\n\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\nprint(my_dict.setdefault(\"two\", 22))\nprint(my_dict.setdefault(\"four\"))\nprint(my_dict)\n\n2\nNone\n{'one': 1, 'two': 2, 'three': 3, 'four': None}\n\n\n\n\n3.3.3 pop() vs. remove()\nДавайте знову зупинимося на різниці цих методів. Методи pop() і remove() застосовуються для видалення елементів зі списків Python.\n\nМетод pop() видаляє та повертає останній елемент зі списку. Якщо в дужках вказати індекс елемента, буде видалено елемент із зазначеним індексом. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop()\nprint(fruits)\n\n['apple', 'banana']\n\n\n\nprint(removed_fruit)\n\norange\n\n\nА якщо ми хочемо видалити елемент за індексом, то потрібно вказати індекс у дужках методу:\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop(1)\nprint(fruits)\n\n['apple', 'orange']\n\n\n\nprint(removed_fruit)\n\nbanana\n\n\n\nМетод remove() видаляє перший елемент зі списку, який збігається з переданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.remove('banana')\nprint(fruits)\n\n['apple', 'orange']\n\n\nВажливо, що якщо у списку не буде елемента із зазначеним індексом або значенням, методи pop() та remove() повернуть помилки. Таким чином, основна відмінність між методами pop() і remove() полягає в тому, що pop() видаляє елемент за індексом, повертаючи його значення, а remove() видаляє перший знайдений елемент із заданим значенням."
  },
  {
    "objectID": "python_loops.html#цикл-for-та-списки",
    "href": "python_loops.html#цикл-for-та-списки",
    "title": "3  Цикли",
    "section": "3.2 Цикл for та списки",
    "text": "3.2 Цикл for та списки\nДля демонстрації можливостей циклу for, нам слід познайомитися ще з однією ідеєю в Python, а саме списками list - це структура даних, яка дозволяє зберігати декілька значень у одній змінній. Списки в Python створюються за допомогою квадратних дужок [] і можуть містити будь-які значення, в тому числі інші списки.\nПринцип роботи циклу for полягає в тому, що він дозволяє ітераційно перебирати список елементів, наприклад так:\n\nfor i in [0, 1, 2]:\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nТакий код став коротшим, ніж варіант з циклом while. Список у цій програмі - це саме [0, 1, 2]. Але що в цьому варіанті коду не так? Якщо ми захочемо змінити кількість нявкань, нам доведеться змінювати список. Це не дуже зручно. Щоб цього уникнути, ми можемо скористатися функцією range(), яка дозволяє створити список послідовності чисел. Таким чином, ми можемо переписати наш код наступним чином:\n\nfor i in range(3):\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nДозвольне показати Вам ще дещо пітонічнє: зверніть увагу, що хоча я визначаю змінну i, я ніколи не використовую її. Але в Python є угода, що якщо вам потрібна змінна тільки тому, що функція програмування вимагає від неї певного підрахунку або автоматичного оновлення, але вам байдуже щодо її значення - назвіть цю змінну _. Це не змінить коректність програми, але це є сигнал колегам, які дивляться на ваш код. Це означає, що вам не потрібно буде звертати увагу на цю змінну, коли ви читаєте код:\n\nfor _ in range(3):\n    print(\"Няв!\")\n\nНяв!\nНяв!\nНяв!\n\n\nЧи можна зробити цей код ще більш пітонічним? Так, можна. Оскільки ми використовуємо рядки, які повторюються, ми можемо скористатися операцією множення рядків на число. При цьому слід не забувати, що ми хочемо виводити кожне \"Няв!\" у новому рядку (за допомогою \\n та end=\"\"). Таким чином, ми можемо переписати наш код наступним чином:\n\nprint(\"Няв!\\n\" * 3, end=\"\")\n\nНяв!\nНяв!\nНяв!\n\n\nДавайте запитаємо користувача, скільки разів цей кіт має нявкнути. Але в цьому випадку слід врахувати, що користувач має вказати позитивне число. Якщо користувач введе неправильне значення, ми маємо попросити його ввести число ще раз. Для цього ми можемо скористатися циклом while True, який буде виконуватися доти, доки не буде введено коректне значення. Таким чином, ми можемо переписати наш код наступним чином:\n\nwhile True:\n    n = int(input(\"Скільки разів кіт має нявкнути? \")) # 3\n        if n &gt; 0:\n            break\n\nfor _ in range(n):\n    print(\"Няв!\")\n\n\n\nНяв!\nНяв!\nНяв!\n\n\nЦикл while буде виконуватися доти, доки не буде введено коректне значення. Якщо користувач введе число, яке менше або дорівнює нулю, то цикл while буде виконуватися знову і знову. Якщо користувач введе коректне значення, то цикл while буде припинено за допомогою інструкції break і виконано цикл for.\nДавайте ще трошки попрактикуємо писати власні функції. Напишемо функцію cat(), яка буде нявкати задану кількість разів. Для цього нам потрібно передати цю кількість як аргумент функції. Таким чином, ми можемо переписати наш код наступним чином:\n\ndef main():\n    number = get_number()\n    cat(number)\n\ndef get_number():\n    while True:\n        n = int(input(\"Скільки разів кіт має нявкнути? \"))\n        if n &gt; 0:\n            break\n    return n\n\ndef cat(n):\n    for _ in range(n):\n        print(\"Няв!\")\n\nmain()\n\n\n3.2.1 Індексація списків\nПотренуємося працювати з індексами списків. До будь-якого елемента списку можна звернутися за його індексом. Запам’ятайте, що індексація починається з нуля.\n\nfruits = ['apple', 'banana', 'orange']\nprint(fruits[0])\n\napple\n\n\nТакож ми можемо робити зрізи:\n\nfruits = ['apple', 'banana', 'orange']\nprint(fruits[0:2])\n\n['apple', 'banana']\n\n\nДавайте створимо файл hogwarts.py в якому створимо список учнів Гоґвортсу:\n\n\nTerminal\n\ncode hogwarts.py\n\nЗмінну назвемо students і помістимо у неї список із трьох учнів:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nЯк мені роздрукувати список студентів? Для цього я можу скористатися індексом, який вказує на позицію елемента у списку за допомогою квадратних [] дужок після назви змінної. Індекси у списку починаються з нуля. Таким чином, якщо я хочу вивести першого студента, я можу використати індекс 0:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nprint(students[0])\nprint(students[1])\nprint(students[2])\n\nГаррі Поттер\nГерміона Грейнджер\nРон Уізлі\n\n\nАле ж має бути кращий спосіб, чи не так? Особливо, якщо я не знаю заздалегідь, хто буде в цьому списку. Якщо наступного року в Гоґвортсі з’являться нові учні, ми можемо використати цикл for для того, щоб вивести їх імена:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor student in students:\n    print(student)\n\nГаррі Поттер\nГерміона Грейнджер\nРон Уізлі\n\n\nДозвольте продемонструвати альтернативний варіант вирішення цієї задачі. Ми можемо використати комбінацію функції range() для визначення діапазону та функції len() для того, щоб отримати довжину списку. Таким чином, ми можемо переписати наш код наступним чином:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor i in range(len(students)):\n    print(students[i])\n\nГаррі Поттер\nГерміона Грейнджер\nРон Уізлі\n\n\nА що, якщо я хочу крім імені студента вивести його номер у списку? Для цього я можу скористатися функцією enumerate(), яка дозволяє мені отримати індекс елемента у списку. Таким чином, я можу переписати наш код наступним чином:\n\nstudents = [\"Гаррі Поттер\", \"Герміона Грейнджер\", \"Рон Уізлі\"]\n\nfor i, student in enumerate(students):\n    print(f\"{i + 1}: {student}\")\n\n1: Гаррі Поттер\n2: Герміона Грейнджер\n3: Рон Уізлі\n\n\n\n\n3.2.2 Методи списків\nПогляньмо на всі методи списку. Не треба заучувати їх напам’ять. Але якщо ви зіткнетеся із завданням, в якому треба буде щось зробити зі списком, то перед тим, як намагатися самому придумати рішення, подивіться, може бути потрібний метод.\n\nappend() - додає елемент у кінець списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.append('melon')\nprint(fruits)\n\n['apple', 'banana', 'orange', 'melon']\n\n\n\nclear() - видаляє всі елементи списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.clear()\nprint(fruits)\n\n[]\n\n\n\ncopy() - повертає копію списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits_copy = fruits.copy()\nprint(fruits_copy)\n\n['apple', 'banana', 'orange']\n\n\n\ncount(item) - повертає кількість елементів із заданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange', 'banana']\nprint(fruits.count('banana'))\n\n2\n\n\n\nextend(iterable) - додає елементи іншого списку до поточного. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.extend(['melon', 'watermelon'])\nprint(fruits)\n\n['apple', 'banana', 'orange', 'melon', 'watermelon']\n\n\n\nindex(item, start, end) - повертає індекс першого елемента, який збігається із заданим значенням (item) у діапазоні індексів від start до end. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange', 'banana']\nprint(fruits.index('banana'))\n\n1\n\n\n\ninsert(index, item) - додає елемент item на позицію index. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.insert(1, 'melon')\nprint(fruits)\n\n['apple', 'melon', 'banana', 'orange']\n\n\n\npop(index) - видаляє та повертає елемент із заданим індексом. Якщо індекс не вказано, видаляє та повертає останній елемент списку. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nremoved_fruit = fruits.pop(1)\nprint(removed_fruit)\n\nbanana\n\n\n\nremove(item) - видаляє перший елемент із заданим значенням. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.remove('banana')\nprint(fruits)\n\n['apple', 'orange']\n\n\n\nreverse() - змінює порядок елементів у списку на зворотній. Наприклад:\n\n\nfruits = ['apple', 'banana', 'orange']\nfruits.reverse()\nprint(fruits)\n\n['orange', 'banana', 'apple']\n\n\n\nsort(key, reverse) - сортує елементи списку. Наприклад:\n\n\nfruits = ['banana', 'orange', 'apple']\nfruits.sort()\nprint(fruits)\n\n['apple', 'banana', 'orange']"
  }
]