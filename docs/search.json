[
  {
    "objectID": "quarto.html#що-таке-quarto",
    "href": "quarto.html#що-таке-quarto",
    "title": "\n6  Quarto\n",
    "section": "\n6.1 Що таке Quarto",
    "text": "6.1 Що таке Quarto\nQuarto — це науково–технічна видавнича система з відкритим кодом, яка ґрунтується на універсальному конверторі документів Pandoc та використовує мову розмітки Markdown. Це універсальний інструмент для тих, хто пише на R, Python, Julia та Observable JavaScript.\nЗа допомогою Quarto можна поєднувати описовий текст і код для створення відформатованих документів, веб–сторінок, постів у блогах, книг тощо.\n\n6.1.1 Назва Quarto\nРозробники Quarto хотіли використати ім’я, яке мало деяке значення в історії видавничої справи. Вибір пав на Quarto (від латинського quārtō, скорочено Qto, 4to або 4º) — це формат книги або брошури в одну четвертину топографічного листа. На кожній стороні листа при цьому поміщається 4 сторінки книги (8 сторінок на один лист).\nНайраннішим відомим виданням такого формату була Книга Сивіл (англ. Sibyllenbuch), що була надрукована Йоганном Гутенбергом у 1452–1453 роках.\n\n\nРисунок 6.1: Quarto\n\n\n6.1.2 Можливості Quarto\nQuarto являє собою текстовий документ спеціального формату .qmd, який можна скомпілювати у різноманітні документи:\n\nДокументи у форматах:\n\nHTML\nPDF\nePub\nMS Word\nOpenOffice\n\n\nПрезентації у форматах:\n\n\nreveal.js (HTML)\n\nPowerPoint (MS Office)\n\nBeamer (LaTeX/PDF)\n\n\nВеб-сторінки:\n\n\nPractical Deep Learning від fast.ai\n\nnbdev від fast.ai\nКурс Julia Workshop for Data Science\n\n\n\nКниги, приклади яких можна переглянути за посиланнями:\n\nPython for Data Analysis\nR for Data Science\nVisualization Curriculum\n\n\nІнтерактивні документи:\n\n\nObservable reactive JavaScript\n\nShiny вебфреймворк\nІнтерактивні віджети Jupyter"
  },
  {
    "objectID": "quarto.html#початок-роботи-з-quarto",
    "href": "quarto.html#початок-роботи-з-quarto",
    "title": "\n6  Quarto\n",
    "section": "\n6.2 Початок роботи з Quarto",
    "text": "6.2 Початок роботи з Quarto\n\n6.2.1 Встановлення Quarto\nДля роботи з Quarto потрібно: 1. Встановити інтерфейс командного рядка Quarto (CLI) під актуальну операційну систему (Windows, Linux або Mac OS).\n\nВстановити плагін для інтегрованого середовища розробки (IDE). На даний момент підтримуються:\n\nVS Code\nRStudio\nJupyter\n\n\n\n6.2.2 Робота з проектами\nСтворити Quarto–проект можна декількома шляхами:\n\nЗа допомогою командного рядка:\n\n\n\nterminal\n\n# веб-сайт\nquarto create-project mysite --type website\n\n# блог\nquarto create-project myblog --type website:blog\n\n# книга\nquarto create-project mybook --type book\n\n\nЗасобами IDE:\n\n\n\nVS Code: File -&gt; New File -&gt; …\n\n\n\n\nРисунок 6.2: Меню створення Quarto–проекту у VS Code\n\n\n\nRStudio: File -&gt; New Project… -&gt; New Directory\n\n\n\n\nРисунок 6.3: Меню створення Quarto–проекту у RStudio\n\n\n6.2.3 Як працює Quarto\nСпочатку Knitr (для R) або Jupyter (для Python або Julia) виконує всі фрагменти коду .qmd-файлу і створює новий markdown (.md) документ, який включає в себе код і всі його результати. Далі .md–файл оброблюється Pandoc для перетворення у різноманітні формати файлів (HTML, PDF, Word тощо).\n\n\nРисунок 6.4: Процедура рендерінгу документів в Quarto\n\n\n6.2.4 Рендерінг\n\nДля рендерінгу документу можна використати кнопку Render в VS Code.\n\n\n\nРисунок 6.5: Клавіша рендерінгу документу в VS Code\n\n\nРендерінг за допомогою командного рядку:\n\n\n\nterminal\n\nquarto render &lt;input&gt; --to &lt;format&gt;\n\n# Наприклад:\nquarto render document.qmd --to docx"
  },
  {
    "objectID": "quarto.html#структура-документів-quatro",
    "href": "quarto.html#структура-документів-quatro",
    "title": "\n6  Quarto\n",
    "section": "\n6.3 Структура документів Quatro",
    "text": "6.3 Структура документів Quatro\nQuatro документи складаються з трьох базових складових:\n\nYAML–шапки1\n\nТекст з використанням розмітки Markdown\nЧанків (анг. chunks) з кодом\n\n\n6.3.1 YAML–шапка\nYAML–шапка знаходиться нагорі документу і відділена трьома дефісами (---) зверху та знизу. В ній зберігається мета–інформація документу: назва, дата створення, автор, інформація щодо роботи коду, контенту і процесу рендерінгу.\n---\ntitle: \"Dracula\"\nauthor: \"Bram Stoker\"\ndate: \"May 26, 1897\"\nformat: \n  html:\n    toc: true\n    code-fold: true\n---\n\n6.3.2 Текст з використанням розмітки Markdown\nЦя частина документу йде одраtextзу після YAML–шапки і складає основну частину документу.\nMarkdown — це популярна і зручна мова розмітки. Ви непевно зустрічали її в README.md–файлах репозиторіїв GitHub, а також у Telegram–повідомленнях.\n\n6.3.3 Чанки з кодом\nЧанки — це блоки, які відділяються від тексту потрійними зворотніми лапками ``` ( анг. backtick) на початку та в кінці. У фігурних дужках вказується мова програмування на якій необхідно виконати код.\n```{python}\nprint('Fly, you fools!')\n```\nРезультат чанку за замовчування виводиться одразу після нього, але все це можна налаштувати."
  },
  {
    "objectID": "quarto.html#yaml-шапка",
    "href": "quarto.html#yaml-шапка",
    "title": "\n6  Quarto\n",
    "section": "\n6.4 YAML-шапка",
    "text": "6.4 YAML-шапка\nМетадані документу можуть бути задані у шапці документу або окремим _quarto.yml-файлом.\nВ цій частині документу зберігається інформація щодо назви документу, дати, автора, налаштування рендерінгу, параметри чанків та інші додаткові налаштування. Всі параметри встановлюються у форматі key: value.\n\n6.4.1 Налаштування виводу\nКлюч format: відповідає за тип вихідного файлу.\n\n\n\n\n\n\n\nТип\nЗначення\nОпис\n\n\n\nДокументи\n\nhtml\npdf\ndocx\nodt\nepub\n\n\nHTML\nPDF\nMS Word\nOpenDocument\nePub\n\n\n\nПрезентації\n\nrevealjs\npptx\nbeamer\n\n\nRevealjs\nPowerPoint\nBeamer\n\n\n\nMarkdown\n\ngfm\ncommonmark\nmarkua\n\n\nGFM\nCommonMark\nMarkua\n\n\n\nWiki\n\nmediawiki\ndokuwiki\nzimwiki\njira\nxwiki\n\n\nMediaWiki\nDocuWiki\nZimWiki\nJira Wiki\nXWiki\n\n\n\n\nА також цілу низку інших форматів, документацію по котрим можна отримати в розділі Reference документації.\n\n6.4.2 Назва, дата та автор\nВ залежності від типу вихідного документу, ці ключі можуть відрізнятися, але наведу основні:\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\ntitle\nНазва документа\n\n\nsubtitle\nПідзаголовок документа\n\n\ndate\nДата документа\n\n\nauthor\nАвтор або автори документа\n\n\n\n6.4.3 Зміст\nДля генерації змісту (анг. table of contents, скорочено toc) необхідно ключу toc задати значення true. В залежності від типу вихідного документу зміст буде згенерований відповідно до заголовків (Розділ 6.5.2).\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\ntoc\nДодайте автоматично створений зміст у вихідний документ.\n\n\ntoc-depth\nКількість рівнів розділу, які потрібно включити у зміст. За замовчуванням 3\n\n\ntoc-title\nЗаголовок, використаний для змісту.\n\n\n\n6.4.4 Локалізація документу\nQuarto, Pandoc та LaTeX генерують текстові елементи документу, які потребують локалізації. Наприклад: “Рисунок” або “Таблиця” для перехресних посилань, назви виносок тощо.\n\n6.4.4.1 Налаштування lang\n\nПриклад використання польської локалізації документу:\n---\ntitle: \"Mój dokument\"\nlang: pl  \n---\nЦе призведе до використання польського перекладу компонентів документу, а також до застосування інших мовних правил обробки документів.\nНаразі доступні повні переклади такими мовами:\n\nанглійська (en, за замовчуванням)\nголландська (nl)\nіспанська (es)\nіталійська (it)\nкитайська (zh)\nкорейська (kr)\nнімецька (de)\nпольська (pl)\nпортугальська (pt)\nросійська (ru)\nфінська (fi)\nфранцузька (fr)\nчеська (cs)\nяпонська (ja)\n\n6.4.4.2 Власна локалізація\nЯкщо вас не влаштовує мова за умовчанням, яка використовується для певної частини документа, ви можете вказати альтернативну мову за допомогою ключа language. Наприклад, щоб замінити значення підписів «Author» і «Published», які використовуються в блоках заголовків, ви можете зробити це:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: \n  title-block-author-single: \"Автор\"\n  title-block-published: \"Опубліковано\"\n---\nВсі ці зміни можна зберегти в окремому .yml-файлі і використовувати власну локалізацію до документу:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: custom.yml\n---\nЯ зробив власну українську локалізацію Quarto-документів, яку Ви можете завантажити з мого GitHub-репозиторія: https://github.com/aranaur/quarto-ukrainian.\nОзнайомитися з усіма офіційними локалізаціями можна за посиланням: https://github.com/quarto-dev/quarto-cli/tree/main/src/resources/language."
  },
  {
    "objectID": "quarto.html#основи-markdown",
    "href": "quarto.html#основи-markdown",
    "title": "\n6  Quarto\n",
    "section": "\n6.5 Основи Markdown",
    "text": "6.5 Основи Markdown\nQuarto ґрунтується на Pandoc та використовує різновид markdown в якості базового синтаксису. Pandoc markdown — це розширена та злегка перероблена версія синтаксису markdown.\nMarkdown — це формат звичайного тексту, який розроблено таким чином, щоб його було легко писати та, що ще важливіше, легко читати.\n\n6.5.1 Форматування тексту\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n*курсив* та **жирний**\n\nкурсив та жирний\n\n\n\nнадрядковий^2^ / підрядковий~2~\nнадрядковий2 / підрядковий2\n\n\n\n~~перекреслення~~\nперекреслення\n\n\n`дослівний код`\nдослівний код\n\n\n\n6.5.2 Заголовки\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n# Заголовок 1\nЗаголовок 1\n\n\n## Заголовок 2\nЗаголовок 2\n\n\n### Заголовок 3\nЗаголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6\n\n\n\n6.5.3 Посилання та рисунки\n\n\nСинтаксис markdown\nРезультат\n\n\n\n[Python](https://python.org)\nPython\n\n\n![Підпис](img/python-logo.jpg)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org \"Python\")\n\n\n\n[![](img/python-logo.jpg){fig-alt=\"Alt text\"}](https://www.python.org)\n\n\n\n\n6.5.4 Списки\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n* невпорядкований список\n    + підпункт 1\n    + підпункт 2\n        - під--підпункт 1\n\n\nневпорядкований список\n\nпідпункт 1\n\nпідпункт 2\n\nпід–підпункт 1\n\n\n\n\n\n\n\n*   пункт 2\n\n    Продовження (відступ 4 інтервали)\n\n\nпункт 2\nПродовження (відступ 4 інтервали)\n\n\n\n\n1. впорядкований список\n2. пункт 2\n    i) підпункт 1\n         A.  під--підпункт 1\n\nвпорядкований список\n\nпункт 2\n\n\nпідпункт 1\n\nпід–підпункт 1\n\n\n\n\n\n\n\n(@)  Список, нумерація якого\n\nпродовжується після\n\n(@)  переривання\n\n\nСписок, нумерація якого\n\nпродовжується після\n\nпереривання\n\n\n\n\nтермін\n: визначення\n\nтермін\n\nвизначення\n\n\n\n\n\n6.5.5 Таблиці\n\n6.5.5.1 Таблиці markdown\nСинтаксис markdown\n| Зліва | Справа | За замовчуванням | По центру |\n|------:|:-------|------------------|:---------:|\n|   12  |  12    |    12            |    12     |\n|  123  |  123   |   123            |   123     |\n|    1  |    1   |     1            |     1     |\nРезультат\n\n\nЗліва\nСправа\nЗа замовчуванням\nПо центру\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\nФормувати такі таблиці вручну досить складно і незручно. В таких випадках на допомогу приходить Markdown Tables Generator.\n\n6.5.5.2 Таблиці з Python\n\nЗа допомогою комбінації функцій Markdown() та пакету tabulate:\n\n\n\nterminal\n\npip install tabulate\n\n\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\ntable = [[\"Bilbo Baggins\", \"Hobbits\", \"Male\"],\n         [\"Beren\", \"Men\", \"Male\"],\n         [\"Nimrodel\", \"Elves\", \"Female\"],\n         [\"Muzgash\", \"Orc\", \"Male\"]]\nMarkdown(tabulate(\n  table, \n  headers=[\"Name\", \"Race\", \"Sex\"]\n))\n\n\n\nТаблиця 6.1: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nPandas DataFrame у форматі консолі:\n\n\nчерез функцію print(), у форматі консолі:\n\n\nimport pandas as pd\n\ndf = pd.DataFrame(data = table,\n    columns = [\"Name\", \"Race\", \"Sex\"])\nprint(df)\n\n            Name     Race     Sex\n0  Bilbo Baggins  Hobbits    Male\n1          Beren      Men    Male\n2       Nimrodel    Elves  Female\n3        Muzgash      Orc    Male\n\n\n\nМожна викликати Python через R за допомогою пакету reticulate та використати функцію kable() з пакету knitr:\n\n\nlibrary(reticulate)\n\nWarning: package 'reticulate' was built under R version 4.2.2\n\nlibrary(knitr)\n\nkable(py$df)\n\n\n\nТаблиця 6.2: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nДодаткові можливості з’являються разом з пакетом kableExtra:\n\n\n# R chunk\nlibrary(kableExtra)\n\npy$df %&gt;% \n  kbl() %&gt;%\n  kable_classic_2(full_width = F)\n\n\n\nТаблиця 6.3: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\n\n\n6.5.6 Рівняння\nДля запису рівняння в середині тексту використовується одинарний символ $ та подвійний $$ для запису рівняння з нового рядка:\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\nу середині тексту: $E = mc^{2}$\nу середині тексту: \\(E=mc^{2}\\)\n\n\n\nз нового рядка:\n\n$$E = mc^{2}$$\nз нового рядка:\\[E = mc^{2}\\]\n\n\n\n\nВ якості допомоги формування рівнянь рекомендую ресурс Online LaTeX Equation Editor.\n\n6.5.7 Діаграми\nQuarto має вбудовану підтримку для створення діаграм Mermaid та Graphviz. Це дає змогу створювати блок–схеми, діаграми послідовності, діаграми станів тощо, використовуючи синтаксис простого тексту.\nПриклад створення блок–схеми за допомогою Mermaid:\n\n```{mermaid}\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n```\n\n\n\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n\n\n\n\n\nБільше інформації у розділі Diagrams.\n\n6.5.8 Відео\nВставляти відео у документи можна за допомогою запису {{&lt; video &gt;}}.\nПриклад використання відео з Youtube:\n{{&lt; video https://www.youtube.com/embed/qOhk7YyxXQ4 &gt;}}\nБільше інформації у розділі Videos.\n\n6.5.9 Виноски\n\n6.5.9.1 Типи виносок\nВиноски — чудовий спосіб привернути додаткову увагу до певних понять або чіткіше вказати, що певний вміст є додатковим або потребує додаткової уваги.\nУ Quarto є п’ять різноманітних виносок: - примітка (note) - застереження (warning) - важливо (important) - підказка (tip) - попередження (caution)\nКолір і значок відрізнятимуться залежно від обраного типу. Ось як виглядають різні виноски в HTML:\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що існує п’ять типів виносок, зокрема: note, tip, warning, caution та important.\n\n\n\n\n\n\n\n\nЗастереження\n\n\n\nВиноски — простий спосіб привернути увагу, наприклад, до цього застереження.\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nВиноски точно покращать Ваш текст.\n\n\n\n\n\n\n\n\nПідказка\n\n\n\nПриклад виноски з текстом\n\n\n\n\n\n\n\n\nРозгорніть, щоб дізнатися про згортання\n\n\n\n\n\nЦе приклад «згорнутої» виноски з попередженням. Використайте collapse=\"true\" щоб згорнути її за замовчуванням та collapse=\"false\" щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n\n\n\n\n6.5.9.2 Синтаксис markdown\nСтворіть виноски в розмітці за допомогою наступного синтаксису (зверніть увагу, що перший заголовок, використаний у виносці, використовується як заголовок виноски):\n::: {.callout-note}\n## Примітка\n\nЗауважте, що існує п’ять типів виносок, зокрема:\n`note`, `tip`, `warning`, `caution` та `important`.\n:::\n\n::: {.callout-tip}\n## Підказка\n\nПриклад виноски з текстом\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Розгорніть, щоб дізнатися про згортання\n\nЦе приклад «згорнутої» виноски з попередженням.\nВикористайте `collapse=\"true\"` щоб згорнути її за замовчуванням та `collapse=\"false\"` щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n:::\n\n6.5.10 Спеціальні символи\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\nтире: -\nтире: -\n\n\nкоротке (середнє) тире: --\nкоротке (середнє) тире: –\n\n\nдовге тире: ---\nдовге тире: —\n\n\n\n\n\n\n\n\n\nПриклади\n\n\n\n\nЖиття прожити — не поле перейти (довге тире)\n2020–2022 (коротке тире)\n25 - 5 (тире)"
  },
  {
    "objectID": "quarto.html#виконання-коду",
    "href": "quarto.html#виконання-коду",
    "title": "\n6  Quarto\n",
    "section": "\n6.6 Виконання коду",
    "text": "6.6 Виконання коду\n\n6.6.1 Налаштування виводу\nІснує широкий спектр доступних параметрів для налаштування виводу виконаного коду. Усі ці параметри можна вказати глобально (у YAML-шапці з ключем execute) або для кожного блоку коду.\n\nПриклад глобальних налаштувань:\n\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\nexecute:\n  echo: false\n---\n\nПриклад налаштування конкретного чанку:\n\n```{python}\n#| echo: true\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nx = np.arange(-4, 4, .012)\ny = np.arange(-4, 4, .012)\nX, Y = np.meshgrid(x, y)\nZ = 1 - np.abs(X) - np.sin(Y**2)\nW = 1 + Y - np.cos(X**2)\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(projection='polar')\nplt.scatter(Z, W, alpha=.03, s=0.2)\nplt.axis('off')\nplt.show()\n```\nПараметри налаштування знаходяться у верхній частині блоку під спеціальним коментарем #|.\n\n\n\n\n\n\nНалаштування\nОпис\n\n\n\neval\nОцініть фрагмент коду (якщо false, просто відтворіть код).\n\n\necho\nПоказувати код (якщо false, код не буде виведено на екран).\n\n\nwarning\nПоказувати попередження, які виникають під час виконання коду\n\n\nerror\nПоказувати помилки у документі (це означає, що помилки під час виконання коду не зупинять обробку документа).\n\n\ninclude\nЗапобігає виводу коду та його результатів.\n\n\n\n6.6.2 Вбудований код\nQuarto дозволяє виводити результат коду в середині тексту. Це особливо зручно, якщо необхідно щоб документ використовував найсвіжіші розрахунки. Проте синтаксис виводу залежить від рушія (анг. engine) Quarto: Jupyter, Knitr або OJS.\n\n6.6.2.1 Jupyter\nЩоб включити збережену змінну, використовуєте IPython.display.Markdown.\nНаприклад, виведемо площу кола за заданим радіусом (radius):\n```{python}\n#| echo: false\n\nfrom IPython.display import Markdown\nimport math\n\nradius = 10\ncircle_area = math.pi * pow(radius, 2)\n\nMarkdown((f\"\"\"\nПлоща кола з радіусом {radius} дорівнює {round(circle_area, 2)}.\n\"\"\"\n))\n```\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що ми використовуємо опцію echo: false, щоб не виводити код у фінальний документ, а тільки результат.\n\n\n\n6.6.2.2 Knitr\nАналогічно до роботи з таблицями (див. Розділ 6.5.5.2) можемо поєднати можливості R та Python для виводу результату коду в тексті документу.\nЩоб включити вирази в розмітку для Knitr, використовується вираз у `r `:\n```{r}\n#| include: false\n\nlibrary(reticulate)\n```\n```{python}\n#| echo: false\n\nimport math\n\nradius = 10\ncircle_area = round(math.pi * pow(radius, 2), 2)\n```\nПлоща кола з радіусом  `r⠀py$radius`  дорівнює `r⠀py$circle_area`.\n\n\n\n\n\n\nПримітка\n\n\n\nЗапис py$radius означає: взяти значення змінної Python з ім’ям radius."
  },
  {
    "objectID": "quarto.html#основи-публікації",
    "href": "quarto.html#основи-публікації",
    "title": "\n6  Quarto\n",
    "section": "\n6.7 Основи публікації",
    "text": "6.7 Основи публікації\nІснує низка способів публікації документів, презентацій і веб-документів, створених за допомогою Quarto. Оскільки вміст, відтворений за допомогою Quarto, використовує стандартні формати (HTML, PDF, MS Word тощо), його можна опублікувати будь-де. Крім того, доступна команда quarto publish для легкої публікації в різних популярних службах (GitHub, Netlify, RStudio Connect тощо), а також різні інструменти, які полегшують публікацію з системи Неперервної інтеграції (анг. Continuous integration).\nСервіси для публікації:\n\n\n\n\n\n\nСервіс\nОпис\n\n\n\nQuarto Pub\nПублікація документів, веб-сайтів і книг Quarto.\n\n\nGitHub Pages\nПублікація документів за допомогою репозиторію GitHub\n\n\nRStudio Connect\nПлатформа для безпечного обміну даними в межах організації.\n\n\nNetlify\nПрофесійна платформа веб-публікації.\n\n\nІнші сервіси\nСкористайтеся цими сервісами, якщо один із наведених вище методів не відповідає вашим вимогам."
  },
  {
    "objectID": "quarto.html#footnotes",
    "href": "quarto.html#footnotes",
    "title": "\n6  Quarto\n",
    "section": "",
    "text": "YAML це рекурсивний акронім YAML Ain’t Markup Language («YAML — не мова розмітки»). У назві відображена історія розвитку: на ранніх етапах мова називалася Yet Another Markup Language («Ще одна мова розмітки») і навіть розглядалася як конкурент XML, але пізніше була перейменована з метою акцентувати увагу на даних, а не на розбивці документів.↩︎"
  },
  {
    "objectID": "sql_agg.html#унікальні-значення-distinct",
    "href": "sql_agg.html#унікальні-значення-distinct",
    "title": "4  Агрегація даних",
    "section": "4.1 Унікальні значення: DISTINCT",
    "text": "4.1 Унікальні значення: DISTINCT\nКлючове слово DISTINCT дає змогу відбирати унікальні записи, тобто позбавлятися всіх дублікатів у таблиці.\nВказується DISTINCT одразу після SELECT. Для виведення унікальних значень в одній колонці можна скласти наступний запит:\nSELECT DISTINCT column\nFROM table\nДавайте спершу вирішимо просте завдання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.1  Виведіть ID всіх унікальних користувачів з таблиці user_actions. Результат відсортуйте за зростанням id.\nПоле у результуючій таблиці: user_id\n\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT user_id\nFROM   user_actions\nORDER BY user_id\n\n\n\n\n\n\n\n\n\nuser_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n...\n...\n\n\n21396\n21398\n\n\n21397\n21399\n\n\n21398\n21400\n\n\n21399\n21401\n\n\n21400\n21402\n\n\n\n\n21401 rows × 1 columns\n\n\n\nКлючове слово DISTINCT можна застосовувати не тільки до однієї колонки, а й одразу до кількох.\nНаприклад, запит для двох колонок виглядатиме так:\nSELECT DISTINCT column_1, column_2\nFROM table\nУ такому випадку запит поверне унікальні комбінації значень в колонках.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.2  Застосуйте DISTINCT відразу до двох колонок таблиці courier_actions та відберіть унікальні пари значень courier_id та order_id.\nРезультат відсортуйте спочатку за зростанням id кур’єра, потім за зростанням id замовлення.\nПоля у результуючій таблиці: courier_id, order_id\n\n\n\n\n\nРішення\n%%sql\nSELECT DISTINCT courier_id,\n                order_id\nFROM   courier_actions\nORDER BY courier_id, order_id\n\n\n\n\n\n\n\n\n\ncourier_id\norder_id\n\n\n\n\n0\n1\n98\n\n\n1\n1\n194\n\n\n2\n1\n233\n\n\n3\n1\n522\n\n\n4\n1\n1251\n\n\n...\n...\n...\n\n\n59590\n3166\n56165\n\n\n59591\n3166\n56940\n\n\n59592\n3167\n56176\n\n\n59593\n3167\n58039\n\n\n59594\n3167\n58774\n\n\n\n\n59595 rows × 2 columns"
  },
  {
    "objectID": "sql_agg.html#базова-агрегація-count-sum-avg-min-max",
    "href": "sql_agg.html#базова-агрегація-count-sum-avg-min-max",
    "title": "4  Агрегація даних",
    "section": "4.2 Базова агрегація: COUNT, SUM, AVG, MIN, MAX",
    "text": "4.2 Базова агрегація: COUNT, SUM, AVG, MIN, MAX\nАгрегатними функціями називають функції, які обробляють певний набір спостережень і повертають одне узагальнююче значення. Якщо ви коли-небудь працювали в Excel, то, напевно, стикалися з підрахунком суми або максимального/мінімального значення по стовпцю — йдеться саме про це.\nОсь кілька прикладів таких функцій у SQL:\n\nCOUNT: повертає кількість значень у колонці;\nSUM: обчислює суму значень;\nAVG: обчислює середнє значення;\nMAX: обчислює максимальне значення;\nMIN: обчислює мінімальне значення.\n\nПриклад:\nSELECT COUNT(column) AS count\nFROM table\n\n\nSELECT SUM(column_1) AS sum,\n       AVG(column_2) AS average\nFROM table\nЗверніть увагу, що деякі з вищезгаданих функцій не можна застосовувати до колонок з текстом, датами та часом, оскільки не цілком зрозуміло, що, наприклад, означає знайти середнє значення або суму найменувань товарів.\nУ той самий час «максимальне» найменування товару обчислити можна — функція MAX шукатиме найбільше значення упорядкованої послідовності (відповідно до встановлених правил сортування значень рядкового типу).\nВтім, заучувати межі застосування цих функцій не потрібно — просто керуйтеся здоровим глуздом.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про агрегатні функції в DuckDB можна ознайомитися тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.3  Порахуйте максимальну та мінімальну ціни товарів у таблиці products. Поля назвіть відповідно max_price, min_price.\nПоля у результуючій таблиці: max_price, min_price\nПояснення: в одному запиті можна використовувати відразу кілька агрегаційних функцій — якщо необхідно, то навіть по кількох різних колонках.\n\n\n\n\n\nРішення\n%%sql\nSELECT max(price) as max_price,\n       min(price) as min_price\nFROM   products\n\n\n\n\n\n\n\n\n\nmax_price\nmin_price\n\n\n\n\n0\n800.0\n1.0"
  },
  {
    "objectID": "sql_agg.html#count-vs-countcolumn",
    "href": "sql_agg.html#count-vs-countcolumn",
    "title": "4  Агрегація даних",
    "section": "4.3 COUNT(*) vs COUNT(column)",
    "text": "4.3 COUNT(*) vs COUNT(column)\nТакож при підрахунку кількості записів іноді замість найменування колонки як атрибут функції COUNT використовують зірочку «*»:\nSELECT COUNT(*)\nFROM table\nОднак важливо враховувати один нюанс: запит із зірочкою повертає кількість взагалі всіх записів у таблиці, а запит із зазначенням стовпця — кількість тих записів, де в заданому стовпці значення не є NULL.\nТаким чином, якщо в деякій колонці column є перепустки, вирази COUNT(*) і COUNT(column) повернуть різні значення.\nДавайте перевіримо!\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.4  Як ви пам’ятаєте, у таблиці users в деяких користувачів не було зазначено їх дати народження.\nПорахуйте в одному запиті кількість усіх записів у таблиці та кількість лише тих записів, для яких у колонці birth_date вказана дата народження.\nКолонку із загальним числом записів назвіть dates, а колонку із записами без перепусток — dates_not_null.\nПоля у результуючій таблиці: dates, dates_not_null\n\n\n\n\n\nРішення\n%%sql\nSELECT count(*) as dates,\n       count(birth_date) as dates_not_null\nFROM   users\n\n\n\n\n\n\n\n\n\ndates\ndates_not_null\n\n\n\n\n0\n20331\n20281\n\n\n\n\n\n\n\nІ ще один важливий момент: агрегатні функції можна застосовувати в поєднанні з ключовим словом DISTINCT. У такому випадку розрахунки будуть проводитися лише за унікальними значеннями.\nЯкщо у випадку з MIN та MAX це не має особливого сенсу, то при розрахунку AVG, SUM та COUNT іноді це буває корисно:\nSELECT SUM(DISTINCT column) AS sum_distinct\nFROM table\nПри цьому досить часто DISTINCT використовується саме в поєднанні з COUNT для підрахунку числа унікальних користувачів, унікальних замовлень тощо.\nSELECT COUNT(DISTINCT column) AS count_distinct\nFROM table\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.5  Порахуйте кількість всіх значень у колонці user_id у таблиці user_actions, а також кількість унікальних значень у цій колонці (тобто кількість унікальних користувачів сервісу).\nКолонку з першим отриманим значенням назвіть users, а колонку з другим – unique_users.\nПоля у результуючій таблиці: users, unique_users\n\n\n\n\n\nРішення\n%%sql\nSELECT count(user_id) as users,\n       count(distinct user_id) as unique_users\nFROM   user_actions\n\n\n\n\n\n\n\n\n\nusers\nunique_users\n\n\n\n\n0\n62574\n21401"
  },
  {
    "objectID": "sql_agg.html#фільтрація-та-агрегація",
    "href": "sql_agg.html#фільтрація-та-агрегація",
    "title": "4  Агрегація даних",
    "section": "4.4 Фільтрація та агрегація",
    "text": "4.4 Фільтрація та агрегація\nА якщо для розрахунків нам потрібні не всі дані в стовпці, а тільки якась частина? Тоді в запит з агрегатними функціями можна включити оператор WHERE, вказавши умову для відбору записів:\nSELECT COUNT(column_1) AS count\nFROM table\nWHERE column_2 &gt; 100\nУ такому випадку спочатку буде виконана фільтрація таблиці і тільки потім буде проведена агрегація по записах, що залишилися.\nПро всяк випадок нагадаємо порядок виконання у запиті відомих нам ключових операторів:\nSELECT      -- перерахування полів результуючої таблиці\nFROM        -- вказівка джерела даних\nWHERE       -- фільтрація даних\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів, що виводяться\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.6  Порахуйте кількість кур’єрів жіночої статі у таблиці couriers. Отриманий стовпець з одним значенням назвіть couriers.\nПоле в результуючій таблиці: couriers\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct courier_id) as couriers\nFROM   couriers\nWHERE  sex = 'female'\n\n\n\n\n\n\n\n\n\ncouriers\n\n\n\n\n0\n1149\n\n\n\n\n\n\n\nІ ще одне завдання на агрегацію із фільтрацією. На цей раз проведемо розрахунки по колонці з даними у форматі TIMESTAMP.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.7  Розрахуйте час, коли було здійснено першу та останню доставку замовлень у таблиці courier_actions.\nКолонку з часом першої доставки назвіть first_delivery, а колонку з часом останньої – last_delivery.\nПоля у результуючій таблиці: first_delivery, last_delivery\nПояснення: зауважте, що в таблиці з діями кур’єрів є не тільки записи з часом доставки замовлень, але й записи з часом їх прийняття.\n\n\n\n\n\nРішення\n%%sql\nSELECT min(time) as first_delivery,\n       max(time) as last_delivery\nFROM   courier_actions\nWHERE  action = 'deliver_order'\n\n\n\n\n\n\n\n\n\nfirst_delivery\nlast_delivery\n\n\n\n\n0\n2022-08-24 02:15:00\n2022-09-08 23:59:00\n\n\n\n\n\n\n\nУ поєднанні з агрегатними функціями можна використовувати ті ж умовні конструкції, які ми розглядали раніше.\nДавайте додамо до нашого запиту більш цікаву фільтрацію.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.8  Уявіть, що один із користувачів сервісу зробив замовлення, до якого увійшли одна пачка крекерів (crackers), одна пачка чіпсів (chips) та один енергетичний напій (energy drink). Порахуйте вартість такого замовлення.\nКолонку із розрахованою вартістю замовлення назвіть order_price.\nДля розрахунків використовуйте таблицю products.\nПоле в результуючій таблиці: order_price\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля вирішення завдання необхідно «сформувати» описане замовлення, відібравши з таблиці products зазначені товари та порахувавши їхню сумарну вартість.\n\n\n\n\n\nРішення\n%%sql\nSELECT sum(price) as order_price\nFROM   products\nWHERE  name in ('crackers', 'chips', 'energy drink')\n\n\n\n\n\n\n\n\n\norder_price\n\n\n\n\n0\n235.0"
  },
  {
    "objectID": "sql_agg.html#довжина-списку-array_length",
    "href": "sql_agg.html#довжина-списку-array_length",
    "title": "4  Агрегація даних",
    "section": "4.5 Довжина списку: ARRAY_LENGTH",
    "text": "4.5 Довжина списку: ARRAY_LENGTH\nЯк пам’ятаєте, у таблиці orders вміст замовлень представлено вигляді списків товарів (масивів). Щоб порахувати кількість товарів у кожному замовленні, можна скористатися функцією array_length.\nФункція array_length обчислює кількість елементів у масиві (довжину масиву) і записується так:\nSELECT array_length(ARRAY['first', 'second', 'third'], 1)\n\nРезультат:\n3\nСинтаксис може здатися вам трохи складним, але це лише на перший погляд! Давайте розбиратися.\nARRAY['first', 'second', 'third'] – це деякий список із трьох значень: 'first', 'second', 'third’.\nОдиниця як другий аргумент — це розмірність масиву, за якій рахується його довжина. Так як список у нас одновимірний (просто значення, записані в один рядок), то вибір у нас невеликий – можемо вказати лише першу розмірність.\nЯкби в нас була таблиця N x N, в якій були б і рядки, і стовпці, то розмірності було б дві: перша відповідала кількості рядків, а друга — числу стовпців. У такому випадку ми могли б вказати або першу, або другу розмірність.\nДавайте уявімо, що у нас є проста таблиця наступного виду:\n _______\n| 1 | 2 |\n| 3 | 4 |\n| 5 | 6 |\n ‾‾‾‾‾‾‾\nУ цій таблиці 3 рядки та 2 стовпці, тому її можна описати у вигляді наступного списку з трьох вкладених у нього списків:\nARRAY[[1,2], [3,4], [5,6]]\nУ прикладі вище кількість списків усередині основного списку — кількість рядків у таблиці, а кількість елементів усередині кожного внутрішнього списку — кількість стовпців.\nЗверніть увагу на результат обчислень функції array_length для першої та другої розмірності:\nSELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)\n\nРезультат:\n3\n\nSELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)\n\nРезультат:\n2\nУ це досить складно повірити, але значеннями в основній таблиці справді можуть бути інші таблиці (матриці). На щастя, у нас не такі дані, тому ми працюватимемо із простими однорозмірними списками значень.\nВ якості аргументу функції array_length на місці масиву можна вказувати ім’я колонки, яка містить масиви (у нашому випадку це колонка product_ids):\nSELECT array_length(column, 1)\nFROM table\n\n\n\n\n\n\nПримітка\n\n\n\nДізнатися більше про функції для роботи з масивами можна у документації. З деякими з них ми познайомимося далі.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.9  Порахуйте кількість замовлень у таблиці orders із дев’ятьма і більше товарами. Для цього скористайтесь функцією array_length, відфільтруйте дані щодо кількості товарів у замовленні та проведіть агрегацію. Отриманий стовпець назвіть orders.\nПоле в результуючій таблиці: orders\nПояснення: у наших даних у колонці product_ids містяться звичайні списки товарів лише з однією розмірністю.\n\n\n\n\n\nРішення\n%%sql\nSELECT count(order_id) as orders\nFROM   orders\nWHERE  array_length(product_ids, 1) &gt;= 9\n\n\n\n\n\n\n\n\n\norders\n\n\n\n\n0\n5"
  },
  {
    "objectID": "sql_agg.html#різниця-часу-age",
    "href": "sql_agg.html#різниця-часу-age",
    "title": "4  Агрегація даних",
    "section": "4.6 Різниця часу: AGE",
    "text": "4.6 Різниця часу: AGE\nВ якості агрегатних функцій можуть виступати не тільки стовпці, але також розрахункові колонки або результат іншої функції:\nSELECT AVG(some_function(column))\nFROM table\n\n\nSELECT AVG(column_1 + column_2)\nFROM table\nСпробуємо розрахувати середній вік користувачів чоловічої статі. Для цього скористаємось новою для нас функцією AGE.\nФункція AGE повертає різницю між двома значеннями, наведеними у форматі TIMESTAMP. При цьому від першого значення віднімається друге, а сама різниця повертається у форматі INTERVAL:\nSELECT AGE('2022-12-12', '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nТаким чином, з '2021-11-10' до '2022-12-12' пройшло рівно 397 днів.\nЯкщо в якості першого аргументу нічого не вказати, то на місце першої дати автоматично підставиться поточна дата (опівніч поточного дня, тобто початок дня).\nЯкщо сьогодні '2022-12-12', то з '2021-11-10' пройшло рівно стільки ж днів, скільки у прикладі вище:\nSELECT AGE(TIMESTAMP '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nНасправді поточній даті відповідає значення current_date, яке можна вказувати як аргумент функції AGE:\nSELECT AGE(TIMESTAMP '2021-11-10')\n\nРезультат:\n397 days, 0:00:00\nМожете самостійно запустити два запити - з current_date і без - і порівняти отримані результати. У вашому випадку це будуть нові результати, але вони мають збігтися.\nА саме значення current_date можна викликати так:\nSELECT current_date\n\nРезультат:\n2023-06-01  \nДля того щоб результат відображався не у кількості днів, а в зручнішому форматі, можна переводити результат обчислень у тип VARCHAR:\nSELECT AGE(current_date, '2021-11-10')::VARCHAR\n\nРезультат:\n1 year 1 mon 2 days\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.10  За допомогою функції AGE і агрегатної функції розрахуйте вік наймолодшого кур’єра чоловічої статі в таблиці couriers.\nВік виведіть через кількість років, місяців і днів (як у прикладі вище), перевівши їх у тип VARCHAR.\nВ якості дати, відносно якої необхідно розрахувати вік кур’єрів, використовуйте свою поточну дату (або не вказуйте її на місці першого аргументу, як показано в прикладах).\nОтриману колонку зі значенням віку назвіть min_age.\nПоле у результуючій таблиці: min_age\nПояснення: оскільки в якості дати, щодо якої проводиться розрахунок віку, ми використовуємо поточну дату, кожен новий день ми отримуватимемо новий результат.\nЗрозуміло, що рахувати вік у такий спосіб не зовсім коректно. Ми навчимося робити це правильно в розділі «Підзапити».\n\n\n\n\n\nРішення\n%%sql\nSELECT age(max(birth_date))::varchar as min_age\nFROM   couriers\nWHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nmin_age\n\n\n\n\n0\n17 years 7 months 5 days 20:53:58.636"
  },
  {
    "objectID": "sql_agg.html#агрегація-з-case-when",
    "href": "sql_agg.html#агрегація-з-case-when",
    "title": "4  Агрегація даних",
    "section": "4.7 Агрегація з CASE WHEN",
    "text": "4.7 Агрегація з CASE WHEN\nАргументом агрегатної функції може бути і складніша розрахункова колонка - наприклад, отримана в результаті роботи конструкції CASE.\nУ такому випадку сама конструкція CASE поміщається всередину дужок агрегатної функції:\nAVG(\n    CASE  \n    WHEN logical_expression_1 THEN expression_1\n    WHEN logical_expression_2 THEN expression_2\n    ELSE expression_else\n    END\n)\nТак, якби в нашій таблиці всі товари були розбиті за категоріями і ми захотіли б порахувати середню ціну товарів з урахуванням підвищувальних чи знижувальних коефіцієнтів для кожної категорії, то ми могли б зробити це, наприклад, так:\nSELECT AVG(\n    CASE \n    WHEN category=\"м'ясо\" THEN price*0.95\n    WHEN category=\"риба\" THEN price*0.9\n    WHEN category=\"напої\" THEN price*1.05\n    ELSE price\n    END\n    ) AS avg_price\nFROM products\nДавайте ускладнимо одне з попередніх завдань і розрахуємо вартість ще одного замовлення.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.11  Порахуйте вартість замовлення, в якому будуть три пачки крекерів ('crackers'), дві пачки чіпсів ('chips') та один енергетичний напій ('energy drink'). Колонку із розрахованою вартістю замовлення назвіть order_price.\nДля розрахунків використовуйте таблицю products.\nПоле в результуючій таблиці: order_price\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розв’язання задачі необхідно за допомогою конструкції CASE створити розрахункову колонку, в якій навпроти кожного товару, який увійшов у замовлення, проставити ціну, помножену на кількість таких товарів у замовленні. Для товарів, які не увійшли у замовлення, необхідно вказати ціну, що дорівнює 0 або NULL. Потім за допомогою агрегатної функції достатньо порахувати суму значень у новій розрахунковій колонці.\n\n\n\n\n\nРішення\n%%sql\nSELECT sum(case when name = 'crackers' then price * 3\n                when name = 'chips' then price * 2\n                when name = 'energy drink' then price\n                else 0 end) as order_price\nFROM   products\n\n\n\n\n\n\n\n\n\norder_price\n\n\n\n\n0\n355.0"
  },
  {
    "objectID": "sql_agg.html#агрегатні-вирази-з-фільтрацією",
    "href": "sql_agg.html#агрегатні-вирази-з-фільтрацією",
    "title": "4  Агрегація даних",
    "section": "4.8 Агрегатні вирази з фільтрацією",
    "text": "4.8 Агрегатні вирази з фільтрацією\nМи розглянули кілька прикладів, коли в якості агрументу агрегатних функцій виступає результат виконання іншої функції.\nАле агрегатна функція може і сама опинитися на місці аргументу якоїсь функції:\nSELECT some_function(SUM(column)) AS result\nFROM table\nНаочний приклад — застосування функції ROUND до результату агрегації:\nSELECT ROUND(SUM(column)) AS rounded_sum\nFROM table\nДавайте вирішимо схоже завдання і заразом ненадовго повернемося до наших напоїв та оператора LIKE.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.12  Розрахуйте середню ціну товарів у таблиці products, у назвах яких є слова 'tea' чи 'coffee'. Виключіть з розрахунку товари, що містять «іван-чай» ('ivan-tea') або «чайний гриб» ('tea mushroom').\nСередню ціну округліть до двох знаків після коми. Стовпець із отриманим значенням назвіть avg_price.\nПоле у результуючій таблиці: avg_price\nПояснення: пам’ятайте, що виконання логічних виразів можна керувати за допомогою дужок. Це може стати в нагоді.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(price), 2) as avg_price\nFROM   products\nWHERE  (name like '%tea%'\n    or name like '%coffee%')\n   and name not like '%ivan-tea%'\n   and name not like '%mushroom%'\n\n\n\n\n\n\n\n\n\navg_price\n\n\n\n\n0\n135.23\n\n\n\n\n\n\n\nВтім, бувають і випадки, коли як аргументи деякої функції виступають відразу кілька агрегатних функцій:\nSELECT some_function(SUM(column_1), SUM(column_2)) AS result\nFROM table\nНаприклад, нам уже знайома функція AGE, яка може приймати одразу два аргументи - дату кінця та дату початку деякого періоду часу.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.13  Скористайтеся функцією AGE та розрахуйте різницю у віці між найстарішим та наймолодшим користувачами чоловічої статі у таблиці users.\nРізницю у віці висловіть кількістю років, місяців та днів, перевівши її у тип VARCHAR.\nНазвіть колонку з порахованим значенням age_diff.\nПоле у результуючій таблиці: age_diff\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nЦе завдання можна вирішити різними способами: можна просто знайти різницю між датами народження наймолодшого і найстарішого користувачів, а можна порахувати різницю між їх віком. Можете піти будь-яким шляхом. Якщо рахуватимете вік, то в якості першої дати використовуйте свою поточну дату (current_date).\n\n\n\n\n\nРішення\n%%sql\nSELECT age(max(birth_date), min(birth_date))::varchar as age_diff\nFROM   users\nWHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nage_diff\n\n\n\n\n0\n21 years 9 months 27 days\n\n\n\n\n\n\n\nА тепер розглянемо приклад, коли агрегатна функція приймає в якості аргументу одну функцію і при цьому сама є аргументом іншої функції.\nВиглядати це може так:\nSELECT function_two(SUM(funtion_one(column))) AS result\nFROM table\nУ цьому прикладі спочатку до колонки column застосовується функція funtion_one, потім за допомогою функції SUM буде пораховано суму отриманих значень, і тільки потім до результату агрегації застосовується функція funtion_two.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.14  Розрахуйте середню кількість товарів у замовленнях з таблиці orders, які користувачі оформляли у вихідні дні (субота та неділя) протягом усього часу роботи сервісу.\nОтримане значення округліть до двох знаків після коми. Назвіть колонку з ним avg_order_size.\nПоле у результуючій таблиці: avg_order_size\n\n\n\n\n\n\n\n\n\nПідказка\n\n\n\n\n\nДля розрахунку кількості товарів у замовленнях скористайтесь функцією array_length. Для фільтрації таблиці у вихідні дні можна використовувати функцію DATE_PART з параметром 'dow'.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(array_length(product_ids, 1)), 2) as avg_order_size\nFROM   orders\nWHERE  date_part('dow', creation_time) in (6, 0)\n\n\n\n\n\n\n\n\n\navg_order_size\n\n\n\n\n0\n3.39\n\n\n\n\n\n\n\nРезультати декількох агрегатних функцій можна використовувати в одному запиті для проведення над ними арифметичних операцій:\nSELECT (SUM(column_1) + SUM(column_2)) / 2\nFROM table\nУ запиті вище буде пораховано середнє арифметичне двох сум — значень колонки column_1 і значень колонки column_2.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.15  На основі даних у таблиці user_actions порахуйте: - кількість унікальних користувачів сервісу; - кількість унікальних замовлень - скільки замовлень припадає на одного користувача.\nУ результуючій таблиці відобразіть усі три значення – поля назвіть відповідно unique_users, unique_orders, orders_per_user.\nПоказник числа замовлень користувача округліть до двох знаків після коми.\nПоля у результуючій таблиці: unique_users, unique_orders, orders_per_user\n\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nЩоб отримати коректний результат поділу, необхідно хоча б одне із значень попередньо привести до типу DECIMAL (або помножити на 1.0). Інакше результатом розподілу цілого числа інше ціле число буде теж ціле число.\nДо речі, з подібною проблемою можна ознайомитись на stackoverflow. Це дуже корисний ресурс для пошуку відповідей на свої запитання. Навіть досвідчені програмісти часто ним користуються. Можете вже зараз почати виробляти звичку звертатися до нього за необхідності.\nТакож пам’ятайте, що використовувати в розрахунках аліаси нових колонок не можна.\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct user_id) as unique_users,\n       count(distinct order_id) as unique_orders,\n       round(count(distinct order_id) * 1.0 / count(distinct user_id),\n             2) as orders_per_user\nFROM   user_actions\n\n-- Рішення через DECIMAL\n-- SELECT count(distinct user_id) as unique_users,\n--        count(distinct order_id) as unique_orders,\n--        round(count(distinct order_id)::DECIMAL / count(distinct user_id),\n--              2) as orders_per_user\n-- FROM   user_actions\n\n\n\n\n\n\n\n\n\nunique_users\nunique_orders\norders_per_user\n\n\n\n\n0\n21401\n59595\n2.78\n\n\n\n\n\n\n\nІ насамкінець познайомимося з більш просунутим функціоналом — агрегатними виразами з фільтрацією.\nЯкщо після агрегатної функції вказати ключове слово FILTER і помістити в дужках деяку умову condition після WHERE, то агрегатній функції на вхід будуть подані тільки ті рядки, для яких умова фільтра виявиться істинною.\nЗагалом ця конструкція виглядає так:\nSELECT agg_function(column) FILTER (WHERE condition)\nFROM table\nНаприклад, якби ми захотіли порахувати середню ціну тільки для товарів категорії 'fish', то запит виглядав би так:\nSELECT AVG(price) FILTER (WHERE category = 'fish') AS avg_fish_price\nFROM table\nЗверніть увагу: це дуже схоже на звичайну фільтрацію з агрегацією, яку ми розглядали в попередніх завданнях, тільки в даному випадку умова відбору записів вказується відразу в блоці SELECT.\nПеревага такого запису в тому, що він дозволяє проводити розрахунки без проміжних запитів з умовами у блоці WHERE.\nРозглянемо ще один приклад.\nУ нашому випадку досить зрозуміло, як порахувати загальну кількість користувачів. Також зрозуміло, як порахувати кількість користувачів, які хоча б раз скасовували замовлення — досить просто вказати потрібну умову в операторі WHERE. Але як у рамках одного запиту порахувати тих, хто ніколи не скасовував своє замовлення?\nОскільки об’єднувати кілька запитів разом ми поки що не вміємо, нам допоможе прийти агрегатний вираз.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.16  Порахуйте скільки користувачів ніколи не скасовували своє замовлення. Для цього із загальної кількості всіх унікальних користувачів відніміть кількість унікальних користувачів, які хоча б раз скасовували замовлення. Подумайте, яку умову необхідно вказати у FILTER, щоб отримати коректний результат.\nОтриманий стовпець назвіть users_count.\nПоле в результуючій таблиці: users_count\n\n\n\n\n\nРішення\n%%sql\n-- Рішення через різницю\nSELECT count(distinct user_id) - count(distinct user_id) filter (WHERE action = 'cancel_order') as users_count\nFROM   user_actions\n\n-- Рішення через вкладений запит\n-- SELECT count(distinct user_id) filter (WHERE user_id not in (SELECT DISTINCT user_id\n--                                                              FROM   user_actions\n--                                                              WHERE  action = 'cancel_order')) as users_count\n-- FROM   user_actions\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n18641\n\n\n\n\n\n\n\nДавайте вирішимо ще одне завдання на агрегатні вирази з фільтрацією - цього разу з більш складними розрахунками.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 4.17  Порахуйте:\n\nзагальну кількість замовлень у таблиці orders\nкількість замовлень із п’ятьма та більше товарами\nчастку замовлень із п’ятьма та більше товарами у загальній кількості замовлень.\n\nУ результуючій таблиці відобразіть усі три значення - поля назвіть відповідно orders, large_orders, large_orders_share.\nЧастку замовлень із п’ятьма та більше товарами у загальній кількості товарів округліть до двох знаків після коми.\nПоля в результуючій таблиці: orders, large_orders, large_orders_share\nПояснення: при розрахунку частки не забудьте хоча б одне із значень попередньо привести до типу DECIMAL (або домножити на 1.0). Також пам’ятайте, що використовувати в розрахунках аліаси нових колонок не можна.\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct order_id) as orders,\n       count(distinct order_id) filter (WHERE array_length(product_ids, 1) &gt;= 5) as large_orders,\n       round(count(distinct order_id) filter (WHERE array_length(product_ids, 1) &gt;= 5)::decimal / count(distinct order_id),\n             2) as large_orders_share\nFROM   orders\n\n\n\n\n\n\n\n\n\norders\nlarge_orders\nlarge_orders_share\n\n\n\n\n0\n59595\n11498\n0.19"
  },
  {
    "objectID": "sql_groupby.html#оператор-group-by",
    "href": "sql_groupby.html#оператор-group-by",
    "title": "5  Групування даних",
    "section": "5.1 Оператор GROUP BY",
    "text": "5.1 Оператор GROUP BY\nДля групування даних в SQL використовується оператор GROUP BY. Він дозволяє групувати дані по одному або декільком стовпцям таблиці. При цьому вибірка даних буде містити лише унікальні значення з вказаних стовпців:\n\nСпочатку в таблиці визначаються рядки, в яких у вказаному в GROUP BY стовпці є однакові значення.\nДалі за цими значеннями записи об’єднуються у групи, причому у групі може бути навіть один запис.\nПісля цього над елементами цих груп, як правило, проводяться якісь операції за допомогою агрегатних функцій: наприклад, за допомогою SUM() обчислюється сума значень в якому-небудь стовпці в кожній групі:\n\nSELECT column_1, SUM(column_2)\nFROM table\nGROUP BY column_1\n\nПотім у результуючий запит потрапляє по одному унікальному запису зі стовпця, по якому здійснювалося групування. При цьому навпроти кожного такого значення відображається результат агрегації по відповідній групі, якщо агрегація проводилася.\n\nТут важливо зробити кілька уточнень:\n\nПо-перше, групування виконується після фільтрації, тобто спочатку виконуються інструкції WHERE і лише потім дані групуються через GROUP BY.\nПо-друге, до груп, що утворилися в результаті застосування GROUP BY, можна застосовувати відразу кілька агрегатних функцій (у тому числі до різних колонок).\nПо-третє, групування можна робити відразу за новими полями, порахованими в SELECT: при цьому допускається використання в GROUP BY аліасу колонки, зазначеного в SELECT. Наступні два запити дадуть однаковий результат:\n\nSELECT DATE(column_1) AS date, SUM(column_2)\nFROM table\nGROUP BY DATE(column_1)\n\n\nSELECT DATE(column_1) AS date, SUM(column_2)\nFROM table\nGROUP BY date\n\nПо-четверте, робити агрегацію після групування необов’язково. Якщо не вказувати агрегатну функцію, то запит поверне унікальні значення в стовпці, тобто той самий результат, як і оператор DISTINCT. Можете самостійно запустити наступний запит та переконатися:\n\nSELECT user_id\nFROM user_actions\nGROUP BY user_id\n\nSELECT DISTINCT user_id\nFROM user_actions\nДо речі, питання про те, як можна відібрати унікальні значення, досвідчені аналітики люблять ставити на співбесідах своїм менш досвідченим колегам.\nІ нарешті, останнє важливе уточнення: під час використання групування колонки, вказаних у SELECT, повинні бути і GROUP BY, якщо вони використовуються у агрегатних функціях. Це обов’язкова умова, і якщо вона не буде виконана, база даних поверне помилку.\nНаступний запит не працюватиме, оскільки в GROUP BY вказані не всі неагреговані колонки з блоку SELECT:\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY column_1\nВодночас такий запит спрацює:\nSELECT SUM(column_2)\nFROM table\nGROUP BY column_1\nЗверніть увагу, що у цьому запиті у блоці SELECT немає колонки, вказаної у GROUP BY, тобто у зворотний бік правило не працює: якщо ми щось вказали в GROUP BY, це не обов’язково вказувати в SELECT. Інакше кажучи, виводити найменування груп необов’язково.\nІ ще: замість назв колонок у блоці GROUP BY можна використовувати номер колонки, вказаної у SELECT. Наприклад, наступні два запити еквівалентні:\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY column_1, column_2\n\n\nSELECT column_1, column_2, SUM(column_3)\nFROM table\nGROUP BY 1, 2\nПри цьому номери колонок із SELECT також можна використовувати при сортуванні в операторі ORDER BY. Можете самі поекспериментувати із цим у наступних завданнях.\nЗ теорією начебто розібралися, тепер приступимо до практики. Минулого разу ми вже рахували кількість кур’єрів жіночої статі та використовували для цього фільтрацію. Групування дозволить нам провести розрахунки відразу для двох статей.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.1  За допомогою групування порахуйте кількість кур’єрів чоловічої та жіночої статі у таблиці couriers. Нову колонку з числом кур’єром назвіть couriers_count. Результат відсортуйте по цій колонці за зростанням.\nПоля у результуючій таблиці: sex, couriers_count\n\n\n\n\n\nРішення\n%%sql\nSELECT sex,\n       count(courier_id) as couriers_count\nFROM   couriers\nGROUP BY sex\nORDER BY couriers_count\n\n\n\n\n\n\n\n\n\nsex\ncouriers_count\n\n\n\n\n0\nfemale\n1149\n\n\n1\nmale\n1674\n\n\n\n\n\n\n\nТепер давайте аналогічним чином порахуємо максимальний вік користувачів чоловічої та жіночої статі. Тільки на цей раз виведемо не повний вік, а лише кількість повних років. Для цього до результату обчислень можна застосувати вже знайому нам функцію DATE_PART з аргументом 'year'.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.2  Порахуйте максимальний вік користувачів чоловічої та жіночої статі у таблиці users. Вік виміряйте кількістю повних років. Нову колонку з віком назвіть max_age. Результат відсортуйте за новою колонкою за зростанням віку.\nПоля у результуючій таблиці: sex, max_age\n\n\n\n\n\nРішення\n%%sql\nSELECT sex,\n       date_part('year', max(age(birth_date))) as max_age\nFROM   users\nGROUP BY sex\nORDER BY max_age\n\n\n\n\n\n\n\n\n\nsex\nmax_age\n\n\n\n\n0\nfemale\n40\n\n\n1\nmale\n41\n\n\n\n\n\n\n\nМаркетологи знову звернулися до нас із завданням: цього разу вони просять провести невеликий аналіз нашої аудиторії та порахувати, скільки клієнтів певного віку користуються нашим сервісом. Давайте допоможемо нашим колегам!\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.3  Розбийте користувачів з таблиці users на групи віком (вік вимірюємо кількістю повних років) і порахуйте кількість користувачів кожного віку. Колонку з віком назвіть age, а колонку з кількістю користувачів users_count. Відсортуйте отриманий результат за зростанням по віку. Не забудемо і про тих користувачів, у яких замість віку буде перепустки, для цієї групи також підрахуємо кількість користувачів.\nПоля у результуючій таблиці: age, users_count\nПояснення: зверніть увагу, що у цій задачі вам необхідно провести групування за новим розрахунковим полем з віком. У цій ситуації важливо пам’ятати, що колонки, вказані в SELECT, повинні знаходитись і в GROUP BY (якщо вони не використовуються в агрегатних функціях). При цьому GROUP BY допускається використання аліасу колонки, зазначеного в блоці SELECT, тобто повторно проводити обчислення у GROUP BY не обов’язково.\n\n\n\n\n\nРішення\n%%sql\nSELECT date_part('year', age(birth_date)) as age,\n       count(user_id) as users_count\nFROM   users\nGROUP BY age\nORDER BY age\nLIMIT 10\n\n\n\n\n\n\n\n\n\nage\nusers_count\n\n\n\n\n0\nNaN\n50\n\n\n1\n19.0\n1\n\n\n2\n20.0\n3\n\n\n3\n21.0\n6\n\n\n4\n22.0\n30\n\n\n5\n23.0\n86\n\n\n6\n24.0\n222\n\n\n7\n25.0\n469\n\n\n8\n26.0\n916\n\n\n9\n27.0\n1497\n\n\n\n\n\n\n\nВи могли помітити, що результат попереднього запиту для однієї з груп повернув пусте значення віку. Ми знову зіткнулися з значеннями NULL — цього разу в колонці birth_date. Давайте позбавимося їх перед групуванням і заодно зробимо наш аналіз ще більш детальним: додамо до групування стать користувачів.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.4  Знову розбийте користувачів із таблиці users на групи за віком (вік вимірюємо кількістю повних років), тільки тепер додайте до групування стать користувача. В результаті в кожній віковій групі має з’явитися ще по дві підгрупи зі статтю. У кожній такій підгрупі порахуйте кількість користувачів.\nУсі значення NULL у колонці birth_date заздалегідь відфільтруйте за допомогою WHERE. Колонку з віком назвіть age, а колонку з числом користувачів -users_count`, ім’я колонки зі статтю залиште без змін. Відсортуйте отриману таблицю спочатку по колонці з віком по зростанню, потім по колонці з підлогою теж по зростанню.\nПоля у результуючій таблиці: age, sex, users_count\n\n\n\n\n\nРішення\n%%sql\nSELECT date_part('year', age(birth_date)) as age,\n       sex,\n       count(user_id) as users_count\nFROM   users\nWHERE  birth_date is not null\nGROUP BY age, sex\nORDER BY age, sex\nLIMIT 10\n\n\n\n\n\n\n\n\n\nage\nsex\nusers_count\n\n\n\n\n0\n19\nmale\n1\n\n\n1\n20\nfemale\n1\n\n\n2\n20\nmale\n2\n\n\n3\n21\nfemale\n3\n\n\n4\n21\nmale\n3\n\n\n5\n22\nfemale\n14\n\n\n6\n22\nmale\n16\n\n\n7\n23\nfemale\n41\n\n\n8\n23\nmale\n45\n\n\n9\n24\nfemale\n119\n\n\n\n\n\n\n\nА тепер, використовуючи наші знання про групування, давайте порахуємо скільки замовлень було зроблено і скільки скасовано в кожному окремому місяці. На цей раз для роботи з датами будемо використовувати не DATE_PART, а нову функцію DATE_TRUNC.\nФункція DATE_TRUNC використовується усічення дат і часу, тобто вона працює аналогічно округленню ROUND, тільки для типів даних TIMESTAMP та INTERVAL.\nСинтаксис у неї такий самий, як і у DATE_PART:\nSELECT DATE_TRUNC(part, column)\nНа місці part у лапках вказується, до якої точності слід обрізати передане значення часу: 'year', 'month', 'day', 'hour’ тощо.\nОтримані значення мають тип TIMESTAMP або INTERVAL, а всі «частини» вихідного значення, менш значущі, ніж задана «частина», прирівнюються до нуля (або одиниці, якщо це номер дня або місяця):\nSELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-01 00:00\n\nSELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-12 00:00    \n\nSELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')\n\nРезультат:\n2022-01-12 08:00\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше з функцією DATE_TRUNC можна ознайомитись тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.5  Використовуючи функцію DATE_TRUNC, порахуйте, скільки замовлень було зроблено та скільки було скасовано кожного місяця. Розрахунки проводьте за таблицею user_actions. Колонку з усіченою датою назвіть month, колонку з кількістю замовлень - orders_count. Результат відсортуйте спочатку за місяцями – за зростанням, потім за типом дії – також за зростанням.\nПоля в результуючій таблиці: month, action, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT date_trunc('month', time) as month,\n       action,\n       count(order_id) as orders_count\nFROM   user_actions\nGROUP BY month, action\nORDER BY month, action\n\n\n\n\n\n\n\n\n\nmonth\naction\norders_count\n\n\n\n\n0\n2022-08-01\ncancel_order\n967\n\n\n1\n2022-08-01\ncreate_order\n18799\n\n\n2\n2022-09-01\ncancel_order\n2012\n\n\n3\n2022-09-01\ncreate_order\n40796\n\n\n\n\n\n\n\nУ Завдання 4.9 ми навчилися працювати з функцією array_length і навіть порахували з її допомогою кількість товарів у кожному замовленні. Давайте для кожного розміру замовлення, яке зустрічається у даних, порахуємо загальну кількість замовлень такого розміру.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.6  Порахуйте кількість товарів у кожному замовленні з таблиці orders, застосуйте до цих значень групування та порахуйте кількість замовлень у кожній групі. Виведіть дві колонки: кількість товарів у замовленні та кількість замовлень з такою кількістю. Колонки назвіть відповідно order_size та orders_count. Результат відсортуйте за зростанням кількості товарів у замовленні.\nПоля у результуючій таблиці: order_size, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT array_length(product_ids, 1) as order_size,\n       count(order_id) as orders_count\nFROM   orders\nGROUP BY order_size\nORDER BY order_size\n\n\n\n\n\n\n\n\n\norder_size\norders_count\n\n\n\n\n0\n1\n3333\n\n\n1\n2\n11851\n\n\n2\n3\n17856\n\n\n3\n4\n15057\n\n\n4\n5\n8065\n\n\n5\n6\n2774\n\n\n6\n7\n583\n\n\n7\n8\n71\n\n\n8\n9\n5"
  },
  {
    "objectID": "sql_groupby.html#фільтрація-після-групування-having",
    "href": "sql_groupby.html#фільтрація-після-групування-having",
    "title": "5  Групування даних",
    "section": "5.2 Фільтрація після групування: HAVING",
    "text": "5.2 Фільтрація після групування: HAVING\nHAVING використовується для фільтрації даних після групування. Він працює аналогічно WHERE, тільки використовується після GROUP BY і фільтрує вже групи, а не окремі записи.\nАле треба обговорити одну важливу особливість роботи з HAVING: у цьому блоці не можна вказувати аліаси розрахункових полів із блоку SELECT. Справа в тому, що відповідно до порядку виконання запиту оператор SELECT виконується після оператора HAVING. Тому агрегацію необхідно також вказувати і HAVING.\nНаприклад, такий запит не спрацює:\nSELECT column_1, SUM(column_2) AS new_column\nFROM table\nGROUP BY column_1\nHAVING new_column = 10\nА такий спрацює:\nSELECT column_1, SUM(column_2) AS new_column\nFROM table\nGROUP BY column_1\nHAVING SUM(column_2) = 10\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 5.7  Доповніть попередній запит оператором HAVING та відберіть лише ті розміри замовлень, загальна кількість яких перевищує 5000. Знову виведіть дві колонки: кількість товарів у замовленні та кількість замовлень з такою кількістю. Колонки назвіть відповідно order_size та orders_count. Результат відсортуйте за зростанням кількості товарів у замовленні.\nПоля у результуючій таблиці: order_size, orders_count\n\n\n\n\n\nРішення\n%%sql\nSELECT array_length(product_ids, 1) as order_size,\n       count(order_id) as orders_count\nFROM   orders\nGROUP BY order_size\nHAVING count(order_id) &gt; 5000\nORDER BY order_size\n\n\n\n\n\n\n\n\n\norder_size\norders_count\n\n\n\n\n0\n2\n11851\n\n\n1\n3\n17856\n\n\n2\n4\n15057\n\n\n3\n5\n8065"
  }
]