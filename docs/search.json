[
  {
    "objectID": "sql_subquery.html#порядок-виконання-запитів",
    "href": "sql_subquery.html#порядок-виконання-запитів",
    "title": "6  Підзапити",
    "section": "6.1 Порядок виконання запитів",
    "text": "6.1 Порядок виконання запитів\nПерш ніж переходити до підзапитів, давайте трохи поговоримо про порядок виконання запитів у SQL.\nДо цього моменту ми вже встигли познайомитися з основними операторами, які складають “скелет” стандартного SQL-запиту: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY та LIMIT.\nМи вже знаємо, що порядок їх написання у запиті наступний:\nSELECT      -- перелік полів результуючої таблиці\nFROM        -- вказівник джерела даних\nWHERE       -- фільтрація даних\nGROUP BY    -- групування даних\nHAVING      -- фільтрація даних після групування\nORDER BY    -- сортування результуючої таблиці\nLIMIT       -- обмеження кількості записів у виводі\nПроте важливо розуміти, що порядок виконання операторів у базах даних дещо відрізняється від порядку їх написання у запиті. У спрощеному вигляді порядок виконання запиту такий:\nFROM       -- вказівник джерела даних\nWHERE      -- фільтрація даних\nGROUP BY   -- групування даних\nHAVING     -- фільтрація даних після групування\nSELECT     -- перелік полів результуючої таблиці\nORDER BY   -- сортування результуючої таблиці\nLIMIT      -- бмеження кількості записів у виводі\nТаким чином:\n\nСпочатку з допомогою FROM визначається таблиця.\nПотім відповідно до зазначеної у WHERE умові з цієї таблиці відбираються записи.\nПотім вибрані дані групуються та агрегуються за допомогою GROUP BY.\nДалі з агрегованих записів відбираються ті, які задовольняють умову HAVING.\nТільки після цього відповідно до зазначених у SELECT інструкціях формується результуюча таблиця — проводяться всі необхідні обчислення, надаються нові імена тощо.\nПотім результуюча таблиця сортується відповідно до ORDER BY.\nІ нарешті спрацьовує обмеження кількості рядків, вказане в LIMIT.\n\nНасправді це дуже важлива інформація, яку слід пам’ятати при складанні будь-яких SQL-запитів.\nМожливо, ви вже зіткнулися з помилками, коли намагалися в блоці WHERE використовувати фільтрацію по нових полях, розрахованих у SELECT. Така операція не відповідає порядку виконання операторів і тому так робити не можна. Також ви могли потрапити в ситуацію, коли при фільтрації у HAVING у вас не приймався аліас колонки, розрахованої в SELECT. Це відбувалося з тієї ж причини – база даних просто ще не знала про те, що ви надали колонці нове ім’я.\nІ ще одна важлива порада. Зверніть увагу, що фільтрацію даних за неагрегованими значеннями можна робити як у блоці WHERE, так і в блоці HAVING. Уважно подивіться на такі запити:\nSELECT sex, COUNT(user_id)\nFROM users\nWHERE sex != 'male'\nGROUP BY sex\n\n\nSELECT sex, COUNT(user_id)\nFROM users\nGROUP BY sex\nHAVING sex != 'male'\nЇх результат буде однаковим (можете переконатися в цьому самі).\nПроте робити фільтрацію за неагрегованими даними рекомендується саме у блоці WHERE, тобто заздалегідь. У такому разі ви ще до угруповання прибираєте з розрахунків непотрібні вам дані і таким чином не витрачаєте обчислювальні ресурси на підрахунок значень, які будуть відфільтровані вами пізніше.\nЦе важливий момент щодо оптимізації SQL-запитів, тому рекомендуємо вам взяти до уваги інформацію."
  },
  {
    "objectID": "sql_subquery.html#підзапити",
    "href": "sql_subquery.html#підзапити",
    "title": "6  Підзапити",
    "section": "6.2 Підзапити",
    "text": "6.2 Підзапити\nПідзапити це потужним інструментом в мові SQL, який дозволяє нам виконувати запити в середині інших запитів. Вони дають можливість створювати складніші і більш гнучкі запити, які вимагають доступу до даних з кількох таблиць або виконання додаткових обчислень.\nОдин із сценаріїв використання підзапитів - це пошук даних в одній таблиці на основі значень з іншої таблиці. Наприклад, ми можемо створити запит, що повертає всіх клієнтів, які зробили замовлення на товари з певної категорії, використовуючи підзапит для вибірки ідентифікаторів цих товарів з таблиці товарів.\nНаприклад у нас є дві таблиці: clients і orders. Нам потрібно отримати список клієнтів, які зробили замовлення після певної дати. Для цього ми можемо скористатися підзапитом:\nSELECT *\nFROM clients\nWHERE ID IN (SELECT client_id\n             FROM orders\n             WHERE data &gt; '2023-01-01');\n)\nІншими словами, підзапит — це лише запит усередині іншого запиту.\nПідзапити можуть застосовуватись у таких частинах основного запиту:\n\nв операторі FROM;\nв операторі SELECT (якщо запит повертає один стовпець з одним значенням);\nв операторах WHERE та HAVING (якщо запит повертає один стовпець з одним або декількома значеннями).\n\nАле давайте про все по порядку.\nНасамперед важливо зрозуміти, що з результату виконання підзапиту можна звертатися також як і до таблиць у базі даних, тобто використовувати їх у блоці FROM замість наявних таблиць:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM table\n) AS subquery_1\nВ межах даного запиту спочатку буде виконано підзапит, який відбере колонки column_1 і column_2 з таблиці table, а потім вже з таблиці, що утворилася, основний запит вибере колонку column_1.\nВажливий момент: при використанні підзапиту в блоці FROM сформованій на основі підзапиту таблиці необхідно привласнити якийсь аліас, інакше основний запит не спрацює. У прикладі вище ми позначили результат підзапиту subquery_1.\nКрім того, рівнів вкладеності може бути декілька:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM (\n        SELECT column_1, column_2, column_3\n        FROM table\n    ) AS subquery_1\n) AS subquery_2\nВ даному випадку послідовність роботи запиту така: спочатку буде виконано підзапит, що повертає результат subquery_1, потім підзапит, що повертає результат subquery_2, і тільки потім в результаті основного підзапиту потрапить колонка column_1. В результаті виходить щось схоже на матрьошку, при цьому до основної таблиці table звертається тільки перший підзапит subquery_1.\nНаведений приклад досить умовний і на практиці колонки в такий спосіб відбирати не варто, але загальну ідею він має передавати.\nРозуміння того, як працюють підзапити в блоці FROM, нам особливо стане в нагоді, коли ми вчитимемося об’єднувати різні таблиці.\nА зараз давайте вирішимо просте завдання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.1  Використовуючи дані з таблиці user_actions, розрахуйте середню кількість замовлень для всіх користувачів нашого сервісу. Для цього спочатку в підзапиті порахуйте скільки замовлень зробив кожен користувач, а потім зверніться до результату підзапиту в блоці FROM і вже в основному запиті усередніть кількість замовлень по всіх користувачах. Отриману середню кількість замовлень всіх користувачів округліть до двох знаків після коми. Назвіть колонку з цим значенням orders_avg.\nПоле у результуючій таблиці: orders_avg\nПояснення: до колонок з підзапиту можна застосовувати агрегатні функції — так само, як би ми зверталися до колонок вихідних таблиць.\n\n\n\n\n\nРішення\n%%sql\nSELECT round(avg(orders_count), 2) as orders_avg\nFROM   (SELECT count(order_id) as orders_count\n        FROM   user_actions\n        WHERE  action = 'create_order'\n        GROUP BY user_id) as t1\n\n\n\n\n\n\n\n\n\norders_avg\n\n\n\n\n0\n2.78"
  },
  {
    "objectID": "sql_subquery.html#табличні-вирази-with",
    "href": "sql_subquery.html#табличні-вирази-with",
    "title": "6  Підзапити",
    "section": "6.3 Табличні вирази: WITH",
    "text": "6.3 Табличні вирази: WITH\nВирішуючи попереднє завдання, ви могли запитати себе: а що якщо один і той же підзапит буде використовуватися в декількох частинах основного запиту? Невже щоразу доведеться дублювати той самий підзапит? А якщо рівнів вкладеності буде кілька? Чи не вийде тоді надто складний та громіздкий запит, який буде складно читати?\nДля таких випадків SQL передбачений оператор WITH, який дозволяє створювати так звані табличні вирази (CTE, анг. common table expressions) - тимчасові таблиці, які існують тільки для одного запиту. Їхнє основне призначення полягає в розбиття складних запитів на кілька частин.\nТабличні вирази створюються так:\nWITH subquery_1 AS (\n    SELECT column_1, column_2\n    FROM table\n)\nSELECT column_1\nFROM subquery_1\nПорівняйте запит вище з результатом запиту, який ми використовували раніше:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM table\n) AS subquery_1\nОператор WITH може містити кілька табличних виразів, причому до зазначених раніше виразів можна звертатися у подальших виразах:\nWITH subquery_1 AS (\n    SELECT column_1, column_2, column_3\n    FROM table\n    ),\n     subquery_2 AS (\n    SELECT column_1, column_2\n    FROM subquery_1\n    )\n\nSELECT column_1\nFROM subquery_2\nМожете знову порівняти запит вище із запитом, який ми використовували раніше:\nSELECT column_1\nFROM (\n    SELECT column_1, column_2\n    FROM (\n        SELECT column_1, column_2, column_3\n        FROM table\n    ) AS subquery_1\n) AS subquery_2\nВикористовувати у своїх запитах оператор WITH чи ні вирішувати вам, але в деяких випадках він може спростити роботу з кодом запиту.\n\n\n\n\n\n\nПримітка\n\n\n\nДокладніше про WITH та табличні вирази можна почитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.2  Повторіть запит із завдання 6.1, але тепер замість підзапиту використовуйте оператор WITH та табличний вираз. Умови завдання ті самі.\nПоле у результуючій таблиці: orders_avg\n\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT user_id,\n                   count(order_id) as orders_count\n            FROM   user_actions\n            WHERE  action = 'create_order'\n            GROUP BY user_id)\nSELECT round(avg(orders_count), 2) as orders_avg\nFROM   t1\n\n\n\n\n\n\n\n\n\norders_avg\n\n\n\n\n0\n2.78\n\n\n\n\n\n\n\nЩе один важливий напрямок застосування підзапитів - створення більш просунутих умовних виразів в операторах WHERE та HAVING. Але оскільки і в тому, і в іншому випадку синтаксис і призначення підзапитів приблизно однакові, у цьому уроці ми розглядатимемо все на прикладі підзапитів у WHERE.\nНасамперед важливо зрозуміти, що підзапит, який повертає одне значення, може використовуватися як звичайне значення спільно з операторами порівняння.\nУявіть, що нам потрібно порівняти значення в якомусь стовпці з максимальним, мінімальним чи середнім значенням у цьому стовпці. Зробити це в рамках одного запиту не вийде, оскільки агрегатні функції не можна використовувати в блоці WHERE.\nНаприклад, наступний запит не працюватиме (база даних повідомить про помилку):\nSELECT column\nFROM table\nWHERE column = MAX(column) \nУ той же час такий запит спрацює, тому що підзапит виконається першим і поверне одне значення:\nSELECT column\nFROM table\nWHERE column = (SELECT MAX(column) FROM table) \nВ результаті виконання такого запиту ми отримаємо всі значення в колонці column, що дорівнює максимальному значенню в цій колонці.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.3  Виведіть з таблиці products інформацію про всі товари крім найдешевшого. Результат відсортуйте за зменшенням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nWHERE  price != (SELECT min(price)\n                 FROM   products)\nORDER BY product_id desc\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n87\nveal\n398.0\n\n\n1\n86\ncold coffee\n70.0\n\n\n2\n85\njam\n200.0\n\n\n3\n84\ntangerines\n90.0\n\n\n4\n83\nwaffles\n55.0\n\n\n...\n...\n...\n...\n\n\n81\n5\ncoffee 3 in 1\n15.0\n\n\n82\n4\nlollipops\n46.0\n\n\n83\n3\nstill water\n80.0\n\n\n84\n2\ngreen tea bags\n50.0\n\n\n85\n1\nsugar\n150.0\n\n\n\n\n86 rows × 3 columns\n\n\n\nУ блоці WHERE результати підзапитів, що повертають одне значення, також можна використовувати в арифметичних операціях:\nSELECT column\nFROM table\nWHERE column = (SELECT MAX(column) FROM table) - 100\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.4  Виведіть інформацію про товари в таблиці products, ціна на які перевищує середню ціну всіх товарів на 20 і більше одиниць. Результат відсортуйте за зменшенням id товару.\nПоля у результуючій таблиці: product_id, name, price\n\n\n\n\n\nРішення\n%%sql\nSELECT product_id,\n       name,\n       price\nFROM   products\nWHERE  price &gt;= (SELECT avg(price)\n                 FROM   products) + 20\nORDER BY product_id desc\nLIMIT 10\n\n\n\n\n\n\n\n\n\nproduct_id\nname\nprice\n\n\n\n\n0\n87\nveal\n398.0\n\n\n1\n85\njam\n200.0\n\n\n2\n77\nchicken\n298.0\n\n\n3\n69\ncranberry juice\n175.0\n\n\n4\n66\nbeef\n370.0\n\n\n5\n64\npineapple\n200.0\n\n\n6\n61\nhoney\n380.0\n\n\n7\n59\nsesame oil\n250.0\n\n\n8\n57\npork\n450.0\n\n\n9\n51\nsmoked fish\n195.0"
  },
  {
    "objectID": "sql_subquery.html#підзапит-з-інтервалом-часу-interval",
    "href": "sql_subquery.html#підзапит-з-інтервалом-часу-interval",
    "title": "6  Підзапити",
    "section": "6.4 Підзапит з інтервалом часу: INTERVAL",
    "text": "6.4 Підзапит з інтервалом часу: INTERVAL\nУ яких випадках нам може стати в нагоді підзапит в операторі WHERE?\nУявімо, що нам потрібно провести якісь розрахунки за останні N днів — скажімо, за останній тиждень. Чи будемо ми вручну відраховувати 7 днів від останньої дати в нашій таблиці? Зрозуміло, що ні. Крім того, остання дата може згодом змінитись, коли до нас надійдуть нові дані. Щоразу писати новий запит і рахувати дату вручну — заняття не для нас.\nДля вирішення такого завдання ми можемо спочатку за допомогою підзапиту обчислити останню дату наших даних, а потім відкласти від неї тиждень.\nЩоб відкласти від дати або додати до неї певний проміжок часу, можна використовувати нескладні арифметичні операції з датами. Наприклад, від поточної дати можна відібрати якийсь проміжок INTERVAL:\nSELECT NOW() - INTERVAL '1 year 2 months 1 week'\n\nРезультат:\n2022-04-24 13:10\nДо речі, NOW() — корисна функція, яка дозволяє отримувати поточну дату та час (у вашому випадку вона буде іншою):\nSELECT NOW()\n\nРезультат:\n2022-07-10 16:11\n\n\n\n\n\n\nПримітка\n\n\n\nЗ іншими прикладами роботи з INTERVAL та арифметичними операціями з датами можна ознайомитись тут.\nПро функцію NOW() можна додатково прочитати тут.\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.5  Порахуйте кількість унікальних клієнтів у таблиці user_actions, які зробили за останній тиждень хоча б одне замовлення. Отриману колонку зі значенням назвіть users_count. В якості поточної дати, від якої відкладати тиждень, використовуйте останню дату тієї ж таблиці user_actions.\nПоле у результуючій таблиці: users_count\n\n\n\n\n\nРішення\n%%sql\nSELECT count(distinct user_id) as users_count\nFROM   user_actions\nWHERE  action = 'create_order'\n   and time &gt; (SELECT max(time)\n            FROM   user_actions) - interval '1 week'\n\n\n\n\n\n\n\n\n\nusers_count\n\n\n\n\n0\n17352\n\n\n\n\n\n\n\nВиходить, що в одному з минулих завдань (4.10) ми неправильно рахували вік кур’єрів. Дійсно, як перша дата у функції AGE() ми використовували поточну дату, а не останню дату в наших даних. Давайте виправимо це прикре непорозуміння, адже тепер у нас для цього є всі необхідні знання.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.6  За допомогою функції AGE() і агрегатної функції знову розрахуйте вік наймолодшого кур’єра чоловічої статі в таблиці couriers, але цього разу в якості першої дати використовуйте останню дату з таблиці courier_actions. Щоб вийшла саме дата, перед застосуванням функції AGE() переведіть пораховану останню дату у формат DATE, як ми робили у 2.9. Вік кур’єра виміряйте кількістю років, місяців і днів і переведіть його до типу VARCHAR. Отриману колонку зі значенням віку назвіть min_age.\nПоле у результуючій таблиці: min_age\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цій задачі результат підзапиту виступає як аргумент функції. Щоб весь запит виглядав компактнішим, для приведення даних до іншого типу можна використовувати формат запису з двома двокрапками - ::.\nТакож зверніть увагу, що для отримання необхідного результату ми звертаємось до різних таблиць у рамках одного загального запиту – так можна робити теж.\n\n\n\n\nРішення\n%%sql\n-- варіант 1\nSELECT age((SELECT max(time)::date\n            FROM   courier_actions), max(birth_date))::varchar as min_age\nFROM   couriers\nWHERE  sex = 'male'\n\n-- варіант 2\n-- SELECT min(age((SELECT max(time)::date\n--                 FROM   courier_actions), birth_date))::varchar as min_age\n-- FROM   couriers\n-- WHERE  sex = 'male'\n\n\n\n\n\n\n\n\n\nmin_age\n\n\n\n\n0\n16 years 10 months 11 days\n\n\n\n\n\n\n\nПідзапит, який повертає кілька значень, може використовуватися в блоці WHERE спільно з оператором IN — наприклад, коли нам потрібно перевірити, чи збігається значення в стовпці з одним із значень із певної множини, отриманої в результаті виконання підзапиту:\nSELECT column_1\nFROM table_1\nWHERE column_1 IN (SELECT column_2 FROM table_2) \nПри цьому, запит вище буде рівносильний запиту з табличним виразом:\nWITH subquery AS (\n    SELECT column_2\n    FROM table_2\n    )\n\nSELECT column_1\nFROM table_1\nWHERE column_1 IN (SELECT * FROM subquery) \nЗверніть увагу, що при використанні в операторі табличного виразу WHERE звернутися просто до його імені не можна - необхідно попередньо вибрати всі його записи, тобто написати підзапит. При цьому в табличному вираженні має бути лише один стовпець, інакше база даних поверне помилку.\nКрім того, в табличному вираженні можна зберігати лише одне значення (наприклад, результат агрегації) і аналогічним чином викликати його в операторі WHERE як змінну:\nWITH subquery AS (\n    SELECT MAX(column_2)\n    FROM table_2\n    )\n\nSELECT column_1\nFROM table_1\nWHERE column_1 = (SELECT * FROM subquery) \nДавайте розглянемо такий приклад.\nЗ наших даних досить легко відібрати скасовані замовлення - достатньо вказати у WHERE потрібний фільтр. Але як відібрати створені, але не скасовані замовлення? Це якраз можна зробити за допомогою підзапиту або табличного виразу.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.7  З таблиці user_actions за допомогою підзапиту або табличного виразу відберіть усі замовлення, які не було скасовано користувачами. Виведіть стовпчик з id цих замовлень. Результат запиту відсортуйте за зростанням id замовлення. Додайте в запит оператор LIMIT та виведіть лише перші 10 рядків результуючої таблиці.\nПоле у результуючій таблиці: order_id\n\n\n\n\n\nРішення\n%%sql\n-- варіант 1\nSELECT order_id\nFROM   user_actions\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order')\nORDER BY order_id limit 10\n\n-- варіант 2\n-- SELECT order_id\n-- FROM   user_actions\n-- WHERE  order_id not in (SELECT order_id\n--                         FROM   user_actions\n--                         WHERE  action = 'cancel_order')\n-- ORDER BY order_id limit 10\n\n\n\n\n\n\n\n\n\norder_id\n\n\n\n\n0\n1\n\n\n1\n2\n\n\n2\n3\n\n\n3\n4\n\n\n4\n5\n\n\n5\n6\n\n\n6\n8\n\n\n7\n9\n\n\n8\n10\n\n\n9\n11"
  },
  {
    "objectID": "sql_subquery.html#підзапити-в-блоці-select",
    "href": "sql_subquery.html#підзапити-в-блоці-select",
    "title": "6  Підзапити",
    "section": "6.5 Підзапити в блоці SELECT",
    "text": "6.5 Підзапити в блоці SELECT\nЯк було зазначено в першому кроці, вкладений запит може бути розміщений і після оператора SELECT. Однак результатом підзапиту в такому випадку може бути тільки одне значення — наприклад, результат застосування агрегатної функції до якоїсь колонки:\nSELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1\nFROM table\nВ такому випадку з таблиці table буде обрано колонка column_1, і навпаки кожного значення у цій колонці буде виведено результат виконання вкладеного запиту, тобто максимальне значення у цій колонці. При цьому давати аліасу результату підзапиту не обов’язково.\nТакож результати підзапитів у блоці SELECT можна використовувати у обчисленнях:\nSELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2\nFROM table\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.8  Використовуючи дані з таблиці user_actions, розрахуйте скільки замовлень зробив кожен користувач і відобразіть це в стовпці orders_count. В окремому стовпці orders_avg навпроти кожного користувача вкажіть середню кількість замовлень всіх користувачів, округливши до двох знаків після коми. Також для кожного користувача порахуйте відхилення замовлень від середнього значення. Відхилення рахуйте так: число замовлень «мінус» заокруглене середнє значення. Назвіть колонку з відхиленням orders_diff. Результат відсортуйте за зростанням id користувача. Додайте в запит оператор LIMIT та виведіть лише перші 10 рядків результуючої таблиці.\nПоля в результуючій таблиці: user_id, orders_count, orders_avg, orders_diff\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nУ цій задачі можна використовувати підзапит, написаний у перших завданнях цього уроку. Щоб не довелося двічі писати той самий підзапит, можна використовувати оператор WITH.\n\n\n\n\nРішення\n%%sql\nwith t1 as (SELECT user_id,\n                   count(order_id) as orders_count\n            FROM   user_actions\n            WHERE  action = 'create_order'\n            GROUP BY user_id)\nSELECT user_id,\n       orders_count,\n       round((SELECT avg(orders_count) FROM   t1), 2) as orders_avg,\n       orders_count - round((SELECT avg(orders_count) FROM   t1), 2) as orders_diff\nFROM   t1\nORDER BY user_id limit 1000\n\n\n\n\n\n\n\n\n\nuser_id\norders_count\norders_avg\norders_diff\n\n\n\n\n0\n1\n4\n2.78\n1.22\n\n\n1\n2\n2\n2.78\n-0.78\n\n\n2\n3\n4\n2.78\n1.22\n\n\n3\n4\n2\n2.78\n-0.78\n\n\n4\n5\n1\n2.78\n-1.78\n\n\n...\n...\n...\n...\n...\n\n\n995\n996\n4\n2.78\n1.22\n\n\n996\n997\n4\n2.78\n1.22\n\n\n997\n998\n2\n2.78\n-0.78\n\n\n998\n999\n3\n2.78\n0.22\n\n\n999\n1000\n5\n2.78\n2.22\n\n\n\n\n1000 rows × 4 columns\n\n\n\nПеред тим, як піти далі, пропонуємо вам вирішити ще кілька завдань на підзапити.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.9  Виведіть id та вміст 100 останніх доставлених замовлень із таблиці orders. Вмістом замовлень вважаються списки з id товарів, що входять у замовлення. Результат відсортуйте за зростанням id замовлення.\nПоля у результуючій таблиці: order_id, product_ids\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що вміст замовлень знаходиться у таблиці orders, а інформація про дії із замовленнями – у таблиці courier_actions.\n\n\n\n\nРішення\n%%sql\nSELECT order_id,\n       product_ids\nFROM   orders\nWHERE  order_id in (SELECT order_id\n                    FROM   courier_actions\n                    WHERE  action = 'deliver_order'\n                    ORDER BY time desc limit 100)\nORDER BY order_id\n\n\n\n\n\n\n\n\n\norder_id\nproduct_ids\n\n\n\n\n0\n59466\n[71, 50, 45]\n\n\n1\n59481\n[26, 30, 84, 1]\n\n\n2\n59482\n[32, 42, 79, 56]\n\n\n3\n59487\n[9, 62, 77]\n\n\n4\n59489\n[67, 42]\n\n\n...\n...\n...\n\n\n95\n59591\n[74, 26, 69, 3]\n\n\n96\n59592\n[34, 58, 31]\n\n\n97\n59593\n[52, 46, 40]\n\n\n98\n59594\n[2, 62]\n\n\n99\n59595\n[18, 30, 67]\n\n\n\n\n100 rows × 2 columns\n\n\n\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.10  З таблиці couriers виведіть всю інформацію про кур’єрів, які у вересні 2022 року доставили 30 і більше замовлень. Результат відсортуйте за зростанням id кур’єра.\nПоля в результуючій таблиці: courier_id, birth_date, sex\n\n\n\n\n\n\n\n\n\nПримітка\n\n\n\nЗверніть увагу, що інформація про кур’єрів знаходиться в таблиці couriers, а інформація про дії із замовленнями - у таблиці courier_actions.\n\n\n\n\nРішення\n%%sql\nSELECT courier_id,\n       birth_date,\n       sex\nFROM   couriers\nWHERE  courier_id in (SELECT courier_id\n                      FROM   courier_actions\n                      WHERE  date_part('month', time) = 9\n                         and date_part('year', time) = 2022\n                         and action = 'deliver_order'\n                      GROUP BY courier_id having count(distinct order_id) &gt;= 30)\nORDER BY courier_id\n\n\n\n\n\n\n\n\n\ncourier_id\nbirth_date\nsex\n\n\n\n\n0\n23\n1990-03-26\nmale\n\n\n1\n869\n2001-08-25\nfemale\n\n\n2\n1466\n1994-04-07\nmale\n\n\n3\n1664\n1987-12-16\nmale\n\n\n\n\n\n\n\nУ цій задачі об’єднаємо знання про конструкцію CASE та підзапити.\n\n\n\n\n\n\nЗавдання\n\n\n\n\nЗавдання 6.11  Призначте знижку 15% на товари, ціна яких перевищує середню ціну на всі товари на 50 і більше одиниць, а також знижку 10% на товари, ціна яких нижча за середню на 50 і більше одиниць. Ціну інших товарів усередині діапазону (середнє – 50; середнє + 50) залиште без змін. При розрахунку середньої ціни округліть її до двох знаків після коми.\nВиведіть інформацію про всі товари із зазначенням старої та нової ціни. Колонку із новою ціною назвіть new_price. Результат відсортуйте спочатку за спаданням колишньої ціни в колонці price, потім за зростанням id товару.\nПоля в результуючій таблиці: product_id, name, price, new_price"
  },
  {
    "objectID": "quarto.html#що-таке-quarto",
    "href": "quarto.html#що-таке-quarto",
    "title": "\n7  Quarto\n",
    "section": "\n7.1 Що таке Quarto",
    "text": "7.1 Що таке Quarto\nQuarto — це науково–технічна видавнича система з відкритим кодом, яка ґрунтується на універсальному конверторі документів Pandoc та використовує мову розмітки Markdown. Це універсальний інструмент для тих, хто пише на R, Python, Julia та Observable JavaScript.\nЗа допомогою Quarto можна поєднувати описовий текст і код для створення відформатованих документів, веб–сторінок, постів у блогах, книг тощо.\n\n7.1.1 Назва Quarto\nРозробники Quarto хотіли використати ім’я, яке мало деяке значення в історії видавничої справи. Вибір пав на Quarto (від латинського quārtō, скорочено Qto, 4to або 4º) — це формат книги або брошури в одну четвертину топографічного листа. На кожній стороні листа при цьому поміщається 4 сторінки книги (8 сторінок на один лист).\nНайраннішим відомим виданням такого формату була Книга Сивіл (англ. Sibyllenbuch), що була надрукована Йоганном Гутенбергом у 1452–1453 роках.\n\n\nРисунок 7.1: Quarto\n\n\n7.1.2 Можливості Quarto\nQuarto являє собою текстовий документ спеціального формату .qmd, який можна скомпілювати у різноманітні документи:\n\nДокументи у форматах:\n\nHTML\nPDF\nePub\nMS Word\nOpenOffice\n\n\nПрезентації у форматах:\n\n\nreveal.js (HTML)\n\nPowerPoint (MS Office)\n\nBeamer (LaTeX/PDF)\n\n\nВеб-сторінки:\n\n\nPractical Deep Learning від fast.ai\n\nnbdev від fast.ai\nКурс Julia Workshop for Data Science\n\n\n\nКниги, приклади яких можна переглянути за посиланнями:\n\nPython for Data Analysis\nR for Data Science\nVisualization Curriculum\n\n\nІнтерактивні документи:\n\n\nObservable reactive JavaScript\n\nShiny вебфреймворк\nІнтерактивні віджети Jupyter"
  },
  {
    "objectID": "quarto.html#початок-роботи-з-quarto",
    "href": "quarto.html#початок-роботи-з-quarto",
    "title": "\n7  Quarto\n",
    "section": "\n7.2 Початок роботи з Quarto",
    "text": "7.2 Початок роботи з Quarto\n\n7.2.1 Встановлення Quarto\nДля роботи з Quarto потрібно: 1. Встановити інтерфейс командного рядка Quarto (CLI) під актуальну операційну систему (Windows, Linux або Mac OS).\n\nВстановити плагін для інтегрованого середовища розробки (IDE). На даний момент підтримуються:\n\nVS Code\nRStudio\nJupyter\n\n\n\n7.2.2 Робота з проектами\nСтворити Quarto–проект можна декількома шляхами:\n\nЗа допомогою командного рядка:\n\n\n\nterminal\n\n# веб-сайт\nquarto create-project mysite --type website\n\n# блог\nquarto create-project myblog --type website:blog\n\n# книга\nquarto create-project mybook --type book\n\n\nЗасобами IDE:\n\n\n\nVS Code: File -&gt; New File -&gt; …\n\n\n\n\nРисунок 7.2: Меню створення Quarto–проекту у VS Code\n\n\n\nRStudio: File -&gt; New Project… -&gt; New Directory\n\n\n\n\nРисунок 7.3: Меню створення Quarto–проекту у RStudio\n\n\n7.2.3 Як працює Quarto\nСпочатку Knitr (для R) або Jupyter (для Python або Julia) виконує всі фрагменти коду .qmd-файлу і створює новий markdown (.md) документ, який включає в себе код і всі його результати. Далі .md–файл оброблюється Pandoc для перетворення у різноманітні формати файлів (HTML, PDF, Word тощо).\n\n\nРисунок 7.4: Процедура рендерінгу документів в Quarto\n\n\n7.2.4 Рендерінг\n\nДля рендерінгу документу можна використати кнопку Render в VS Code.\n\n\n\nРисунок 7.5: Клавіша рендерінгу документу в VS Code\n\n\nРендерінг за допомогою командного рядку:\n\n\n\nterminal\n\nquarto render &lt;input&gt; --to &lt;format&gt;\n\n# Наприклад:\nquarto render document.qmd --to docx"
  },
  {
    "objectID": "quarto.html#структура-документів-quatro",
    "href": "quarto.html#структура-документів-quatro",
    "title": "\n7  Quarto\n",
    "section": "\n7.3 Структура документів Quatro",
    "text": "7.3 Структура документів Quatro\nQuatro документи складаються з трьох базових складових:\n\nYAML–шапки1\n\nТекст з використанням розмітки Markdown\nЧанків (анг. chunks) з кодом\n\n\n7.3.1 YAML–шапка\nYAML–шапка знаходиться нагорі документу і відділена трьома дефісами (---) зверху та знизу. В ній зберігається мета–інформація документу: назва, дата створення, автор, інформація щодо роботи коду, контенту і процесу рендерінгу.\n---\ntitle: \"Dracula\"\nauthor: \"Bram Stoker\"\ndate: \"May 26, 1897\"\nformat: \n  html:\n    toc: true\n    code-fold: true\n---\n\n7.3.2 Текст з використанням розмітки Markdown\nЦя частина документу йде одраtextзу після YAML–шапки і складає основну частину документу.\nMarkdown — це популярна і зручна мова розмітки. Ви непевно зустрічали її в README.md–файлах репозиторіїв GitHub, а також у Telegram–повідомленнях.\n\n7.3.3 Чанки з кодом\nЧанки — це блоки, які відділяються від тексту потрійними зворотніми лапками ``` ( анг. backtick) на початку та в кінці. У фігурних дужках вказується мова програмування на якій необхідно виконати код.\nprint('Fly, you fools!')\nРезультат чанку за замовчування виводиться одразу після нього, але все це можна налаштувати."
  },
  {
    "objectID": "quarto.html#yaml-шапка",
    "href": "quarto.html#yaml-шапка",
    "title": "\n7  Quarto\n",
    "section": "\n7.4 YAML-шапка",
    "text": "7.4 YAML-шапка\nМетадані документу можуть бути задані у шапці документу або окремим _quarto.yml-файлом.\nВ цій частині документу зберігається інформація щодо назви документу, дати, автора, налаштування рендерінгу, параметри чанків та інші додаткові налаштування. Всі параметри встановлюються у форматі key: value.\n\n7.4.1 Налаштування виводу\nКлюч format: відповідає за тип вихідного файлу.\n\n\n\n\n\n\n\nТип\nЗначення\nОпис\n\n\n\nДокументи\n\nhtml\npdf\ndocx\nodt\nepub\n\n\nHTML\nPDF\nMS Word\nOpenDocument\nePub\n\n\n\nПрезентації\n\nrevealjs\npptx\nbeamer\n\n\nRevealjs\nPowerPoint\nBeamer\n\n\n\nMarkdown\n\ngfm\ncommonmark\nmarkua\n\n\nGFM\nCommonMark\nMarkua\n\n\n\nWiki\n\nmediawiki\ndokuwiki\nzimwiki\njira\nxwiki\n\n\nMediaWiki\nDocuWiki\nZimWiki\nJira Wiki\nXWiki\n\n\n\n\nА також цілу низку інших форматів, документацію по котрим можна отримати в розділі Reference документації.\n\n7.4.2 Назва, дата та автор\nВ залежності від типу вихідного документу, ці ключі можуть відрізнятися, але наведу основні:\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\ntitle\nНазва документа\n\n\nsubtitle\nПідзаголовок документа\n\n\ndate\nДата документа\n\n\nauthor\nАвтор або автори документа\n\n\n\n7.4.3 Зміст\nДля генерації змісту (анг. table of contents, скорочено toc) необхідно ключу toc задати значення true. В залежності від типу вихідного документу зміст буде згенерований відповідно до заголовків (Розділ 7.5.2).\n\n\n\n\n\n\nКлюч\nЗначення\n\n\n\ntoc\nДодайте автоматично створений зміст у вихідний документ.\n\n\ntoc-depth\nКількість рівнів розділу, які потрібно включити у зміст. За замовчуванням 3\n\n\ntoc-title\nЗаголовок, використаний для змісту.\n\n\n\n7.4.4 Локалізація документу\nQuarto, Pandoc та LaTeX генерують текстові елементи документу, які потребують локалізації. Наприклад: “Рисунок” або “Таблиця” для перехресних посилань, назви виносок тощо.\n\n7.4.4.1 Налаштування lang\n\nПриклад використання польської локалізації документу:\n---\ntitle: \"Mój dokument\"\nlang: pl  \n---\nЦе призведе до використання польського перекладу компонентів документу, а також до застосування інших мовних правил обробки документів.\nНаразі доступні повні переклади такими мовами:\n\nанглійська (en, за замовчуванням)\nголландська (nl)\nіспанська (es)\nіталійська (it)\nкитайська (zh)\nкорейська (kr)\nнімецька (de)\nпольська (pl)\nпортугальська (pt)\nросійська (ru)\nфінська (fi)\nфранцузька (fr)\nчеська (cs)\nяпонська (ja)\n\n7.4.4.2 Власна локалізація\nЯкщо вас не влаштовує мова за умовчанням, яка використовується для певної частини документа, ви можете вказати альтернативну мову за допомогою ключа language. Наприклад, щоб замінити значення підписів «Author» і «Published», які використовуються в блоках заголовків, ви можете зробити це:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: \n  title-block-author-single: \"Автор\"\n  title-block-published: \"Опубліковано\"\n---\nВсі ці зміни можна зберегти в окремому .yml-файлі і використовувати власну локалізацію до документу:\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\ndate: 12/15/2022\nlanguage: custom.yml\n---\nЯ зробив власну українську локалізацію Quarto-документів, яку Ви можете завантажити з мого GitHub-репозиторія: https://github.com/aranaur/quarto-ukrainian.\nОзнайомитися з усіма офіційними локалізаціями можна за посиланням: https://github.com/quarto-dev/quarto-cli/tree/main/src/resources/language."
  },
  {
    "objectID": "quarto.html#основи-markdown",
    "href": "quarto.html#основи-markdown",
    "title": "\n7  Quarto\n",
    "section": "\n7.5 Основи Markdown",
    "text": "7.5 Основи Markdown\nQuarto ґрунтується на Pandoc та використовує різновид markdown в якості базового синтаксису. Pandoc markdown — це розширена та злегка перероблена версія синтаксису markdown.\nMarkdown — це формат звичайного тексту, який розроблено таким чином, щоб його було легко писати та, що ще важливіше, легко читати.\n\n7.5.1 Форматування тексту\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n*курсив* та **жирний**\n\nкурсив та жирний\n\n\n\nнадрядковий^2^ / підрядковий~2~\nнадрядковий2 / підрядковий2\n\n\n\n~~перекреслення~~\nперекреслення\n\n\n`дослівний код`\nдослівний код\n\n\n\n7.5.2 Заголовки\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n# Заголовок 1\nЗаголовок 1\n\n\n## Заголовок 2\nЗаголовок 2\n\n\n### Заголовок 3\nЗаголовок 3\n\n\n#### Заголовок 4\nЗаголовок 4\n\n\n##### Заголовок 5\nЗаголовок 5\n\n\n###### Заголовок 6\nЗаголовок 6\n\n\n\n7.5.3 Посилання та рисунки\n\n\nСинтаксис markdown\nРезультат\n\n\n\n[Python](https://python.org)\nPython\n\n\n![Підпис](img/python-logo.jpg)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org)\n\n\n\n[![Caption](img/python-logo.jpg)](https://www.python.org \"Python\")\n\n\n\n[![](img/python-logo.jpg){fig-alt=\"Alt text\"}](https://www.python.org)\n\n\n\n\n7.5.4 Списки\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\n* невпорядкований список\n    + підпункт 1\n    + підпункт 2\n        - під--підпункт 1\n\n\nневпорядкований список\n\nпідпункт 1\n\nпідпункт 2\n\nпід–підпункт 1\n\n\n\n\n\n\n\n*   пункт 2\n\n    Продовження (відступ 4 інтервали)\n\n\nпункт 2\nПродовження (відступ 4 інтервали)\n\n\n\n\n1. впорядкований список\n2. пункт 2\n    i) підпункт 1\n         A.  під--підпункт 1\n\nвпорядкований список\n\nпункт 2\n\n\nпідпункт 1\n\nпід–підпункт 1\n\n\n\n\n\n\n\n(@)  Список, нумерація якого\n\nпродовжується після\n\n(@)  переривання\n\n\nСписок, нумерація якого\n\nпродовжується після\n\nпереривання\n\n\n\n\nтермін\n: визначення\n\nтермін\n\nвизначення\n\n\n\n\n\n7.5.5 Таблиці\n\n7.5.5.1 Таблиці markdown\nСинтаксис markdown\n| Зліва | Справа | За замовчуванням | По центру |\n|------:|:-------|------------------|:---------:|\n|   12  |  12    |    12            |    12     |\n|  123  |  123   |   123            |   123     |\n|    1  |    1   |     1            |     1     |\nРезультат\n\n\nЗліва\nСправа\nЗа замовчуванням\nПо центру\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\nФормувати такі таблиці вручну досить складно і незручно. В таких випадках на допомогу приходить Markdown Tables Generator.\n\n7.5.5.2 Таблиці з Python\n\nЗа допомогою комбінації функцій Markdown() та пакету tabulate:\n\n\n\nterminal\n\npip install tabulate\n\n\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\ntable = [[\"Bilbo Baggins\", \"Hobbits\", \"Male\"],\n         [\"Beren\", \"Men\", \"Male\"],\n         [\"Nimrodel\", \"Elves\", \"Female\"],\n         [\"Muzgash\", \"Orc\", \"Male\"]]\nMarkdown(tabulate(\n  table, \n  headers=[\"Name\", \"Race\", \"Sex\"]\n))\n\n\n\nТаблиця 7.1: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nPandas DataFrame у форматі консолі:\n\n\nчерез функцію print(), у форматі консолі:\n\n\nimport pandas as pd\n\ndf = pd.DataFrame(data = table,\n    columns = [\"Name\", \"Race\", \"Sex\"])\nprint(df)\n\n            Name     Race     Sex\n0  Bilbo Baggins  Hobbits    Male\n1          Beren      Men    Male\n2       Nimrodel    Elves  Female\n3        Muzgash      Orc    Male\n\n\n\nМожна викликати Python через R за допомогою пакету reticulate та використати функцію kable() з пакету knitr:\n\n\nlibrary(reticulate)\n\nWarning: package 'reticulate' was built under R version 4.2.2\n\nlibrary(knitr)\n\nkable(py$df)\n\n\n\nТаблиця 7.2: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\nДодаткові можливості з’являються разом з пакетом kableExtra:\n\n\n# R chunk\nlibrary(kableExtra)\n\npy$df %&gt;% \n  kbl() %&gt;%\n  kable_classic_2(full_width = F)\n\n\n\nТаблиця 7.3: Персонажі Середзем’я\n\nName\nRace\nSex\n\n\n\nBilbo Baggins\nHobbits\nMale\n\n\nBeren\nMen\nMale\n\n\nNimrodel\nElves\nFemale\n\n\nMuzgash\nOrc\nMale\n\n\n\n\n\n\n\n\n\n7.5.6 Рівняння\nДля запису рівняння в середині тексту використовується одинарний символ $ та подвійний $$ для запису рівняння з нового рядка:\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\nу середині тексту: $E = mc^{2}$\nу середині тексту: \\(E=mc^{2}\\)\n\n\n\nз нового рядка:\n\n$$E = mc^{2}$$\nз нового рядка:\\[E = mc^{2}\\]\n\n\n\n\nВ якості допомоги формування рівнянь рекомендую ресурс Online LaTeX Equation Editor.\n\n7.5.7 Діаграми\nQuarto має вбудовану підтримку для створення діаграм Mermaid та Graphviz. Це дає змогу створювати блок–схеми, діаграми послідовності, діаграми станів тощо, використовуючи синтаксис простого тексту.\nПриклад створення блок–схеми за допомогою Mermaid:\n\n```{mermaid}\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n```\n\n\n\nflowchart LR\n  A[Квадратна форма] --&gt; B(Кругла форма)\n  B --&gt; C{Рішення}\n  C --&gt; D[Результат один]\n  C --&gt; E[Результат два]\n\n\n\n\n\nБільше інформації у розділі Diagrams.\n\n7.5.8 Відео\nВставляти відео у документи можна за допомогою запису {{&lt; video &gt;}}.\nПриклад використання відео з Youtube:\n{{&lt; video https://www.youtube.com/embed/qOhk7YyxXQ4 &gt;}}\nБільше інформації у розділі Videos.\n\n7.5.9 Виноски\n\n7.5.9.1 Типи виносок\nВиноски — чудовий спосіб привернути додаткову увагу до певних понять або чіткіше вказати, що певний вміст є додатковим або потребує додаткової уваги.\nУ Quarto є п’ять різноманітних виносок: - примітка (note) - застереження (warning) - важливо (important) - підказка (tip) - попередження (caution)\nКолір і значок відрізнятимуться залежно від обраного типу. Ось як виглядають різні виноски в HTML:\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що існує п’ять типів виносок, зокрема: note, tip, warning, caution та important.\n\n\n\n\n\n\n\n\nЗастереження\n\n\n\nВиноски — простий спосіб привернути увагу, наприклад, до цього застереження.\n\n\n\n\n\n\n\n\nВажливо\n\n\n\nВиноски точно покращать Ваш текст.\n\n\n\n\n\n\n\n\nПідказка\n\n\n\nПриклад виноски з текстом\n\n\n\n\n\n\n\n\nРозгорніть, щоб дізнатися про згортання\n\n\n\n\n\nЦе приклад «згорнутої» виноски з попередженням. Використайте collapse=\"true\" щоб згорнути її за замовчуванням та collapse=\"false\" щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n\n\n\n\n7.5.9.2 Синтаксис markdown\nСтворіть виноски в розмітці за допомогою наступного синтаксису (зверніть увагу, що перший заголовок, використаний у виносці, використовується як заголовок виноски):\n::: {.callout-note}\n## Примітка\n\nЗауважте, що існує п’ять типів виносок, зокрема:\n`note`, `tip`, `warning`, `caution` та `important`.\n:::\n\n::: {.callout-tip}\n## Підказка\n\nПриклад виноски з текстом\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Розгорніть, щоб дізнатися про згортання\n\nЦе приклад «згорнутої» виноски з попередженням.\nВикористайте `collapse=\"true\"` щоб згорнути її за замовчуванням та `collapse=\"false\"` щоб виноска могла бути згорнута, але була розгорнути за замовчуванням.\n:::\n\n7.5.10 Спеціальні символи\n\n\n\n\n\n\nСинтаксис markdown\nРезультат\n\n\n\nтире: -\nтире: -\n\n\nкоротке (середнє) тире: --\nкоротке (середнє) тире: –\n\n\nдовге тире: ---\nдовге тире: —\n\n\n\n\n\n\n\n\n\nПриклади\n\n\n\n\nЖиття прожити — не поле перейти (довге тире)\n2020–2022 (коротке тире)\n25 - 5 (тире)"
  },
  {
    "objectID": "quarto.html#виконання-коду",
    "href": "quarto.html#виконання-коду",
    "title": "\n7  Quarto\n",
    "section": "\n7.6 Виконання коду",
    "text": "7.6 Виконання коду\n\n7.6.1 Налаштування виводу\nІснує широкий спектр доступних параметрів для налаштування виводу виконаного коду. Усі ці параметри можна вказати глобально (у YAML-шапці з ключем execute) або для кожного блоку коду.\n\nПриклад глобальних налаштувань:\n\n---\ntitle: \"Мій документ\"\nauthor: \"Ігор Мірошниченко\"\nexecute:\n  echo: false\n---\n\nПриклад налаштування конкретного чанку:\n\n#| echo: true\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nx = np.arange(-4, 4, .012)\ny = np.arange(-4, 4, .012)\nX, Y = np.meshgrid(x, y)\nZ = 1 - np.abs(X) - np.sin(Y**2)\nW = 1 + Y - np.cos(X**2)\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(projection='polar')\nplt.scatter(Z, W, alpha=.03, s=0.2)\nplt.axis('off')\nplt.show()\nПараметри налаштування знаходяться у верхній частині блоку під спеціальним коментарем #|.\n\n\n\n\n\n\nНалаштування\nОпис\n\n\n\neval\nОцініть фрагмент коду (якщо false, просто відтворіть код).\n\n\necho\nПоказувати код (якщо false, код не буде виведено на екран).\n\n\nwarning\nПоказувати попередження, які виникають під час виконання коду\n\n\nerror\nПоказувати помилки у документі (це означає, що помилки під час виконання коду не зупинять обробку документа).\n\n\ninclude\nЗапобігає виводу коду та його результатів.\n\n\n\n7.6.2 Вбудований код\nQuarto дозволяє виводити результат коду в середині тексту. Це особливо зручно, якщо необхідно щоб документ використовував найсвіжіші розрахунки. Проте синтаксис виводу залежить від рушія (анг. engine) Quarto: Jupyter, Knitr або OJS.\n\n7.6.2.1 Jupyter\nЩоб включити збережену змінну, використовуєте IPython.display.Markdown.\nНаприклад, виведемо площу кола за заданим радіусом (radius):\n#| echo: false\n\nfrom IPython.display import Markdown\nimport math\n\nradius = 10\ncircle_area = math.pi * pow(radius, 2)\n\nMarkdown((f\"\"\"\nПлоща кола з радіусом {radius} дорівнює {round(circle_area, 2)}.\n\"\"\"\n))\n\n\n\n\n\n\nПримітка\n\n\n\nЗауважте, що ми використовуємо опцію echo: false, щоб не виводити код у фінальний документ, а тільки результат.\n\n\n\n7.6.2.2 Knitr\nАналогічно до роботи з таблицями (див. Розділ 7.5.5.2) можемо поєднати можливості R та Python для виводу результату коду в тексті документу.\nЩоб включити вирази в розмітку для Knitr, використовується вираз у `r `:\n#| include: false\n\nlibrary(reticulate)\n#| echo: false\n\nimport math\n\nradius = 10\ncircle_area = round(math.pi * pow(radius, 2), 2)\nПлоща кола з радіусом  `r⠀py$radius`  дорівнює `r⠀py$circle_area`.\n\n\n\n\n\n\nПримітка\n\n\n\nЗапис py$radius означає: взяти значення змінної Python з ім’ям radius."
  },
  {
    "objectID": "quarto.html#основи-публікації",
    "href": "quarto.html#основи-публікації",
    "title": "\n7  Quarto\n",
    "section": "\n7.7 Основи публікації",
    "text": "7.7 Основи публікації\nІснує низка способів публікації документів, презентацій і веб-документів, створених за допомогою Quarto. Оскільки вміст, відтворений за допомогою Quarto, використовує стандартні формати (HTML, PDF, MS Word тощо), його можна опублікувати будь-де. Крім того, доступна команда quarto publish для легкої публікації в різних популярних службах (GitHub, Netlify, RStudio Connect тощо), а також різні інструменти, які полегшують публікацію з системи Неперервної інтеграції (анг. Continuous integration).\nСервіси для публікації:\n\n\n\n\n\n\nСервіс\nОпис\n\n\n\nQuarto Pub\nПублікація документів, веб-сайтів і книг Quarto.\n\n\nGitHub Pages\nПублікація документів за допомогою репозиторію GitHub\n\n\nRStudio Connect\nПлатформа для безпечного обміну даними в межах організації.\n\n\nNetlify\nПрофесійна платформа веб-публікації.\n\n\nІнші сервіси\nСкористайтеся цими сервісами, якщо один із наведених вище методів не відповідає вашим вимогам."
  },
  {
    "objectID": "quarto.html#footnotes",
    "href": "quarto.html#footnotes",
    "title": "\n7  Quarto\n",
    "section": "",
    "text": "YAML це рекурсивний акронім YAML Ain’t Markup Language («YAML — не мова розмітки»). У назві відображена історія розвитку: на ранніх етапах мова називалася Yet Another Markup Language («Ще одна мова розмітки») і навіть розглядалася як конкурент XML, але пізніше була перейменована з метою акцентувати увагу на даних, а не на розбивці документів.↩︎"
  }
]