<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Книга-конспект матеріалів">

<title>Від нуля до Python Data Scientist - 7&nbsp; Об’єднання таблиць</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./sql_window.html" rel="next">
<link href="./sql_subquery.html" rel="prev">
<link href="./cover.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Пошук не дав результату",
    "search-matching-documents-text": "Результати пошуку",
    "search-copy-link-title": "Скопіюйте посилання для пошуку",
    "search-hide-matches-text": "Приховати додаткові результати",
    "search-more-match-text": "Додатковий результат у цьому документі",
    "search-more-matches-text": "Додаткові результати у цьому документі",
    "search-clear-button-title": "Очистити",
    "search-detached-cancel-button-title": "Скасувати",
    "search-submit-button-title": "Надіслати",
    "search-label": "Пошук"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-0C9TJBF3C5"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-0C9TJBF3C5', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Переключити бокову панель навігації" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./sql.html">SQL</a></li><li class="breadcrumb-item"><a href="./sql_join.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Об'єднання таблиць</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Переключити бокову панель навігації" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./cover.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Від нуля до Python Data Scientist</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/Aranaur/py4ds" rel="" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Переключити темний режим"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Пошук"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Вступне слово</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./python.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Python</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Переключити розділ">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./python_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Змінні та типи даних</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./sql.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SQL</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Переключити розділ">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Базові запити</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_filter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Фільтрація даних</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_agg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Агрегація даних</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_groupby.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Групування даних</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_subquery.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Підзапити</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_join.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Об’єднання таблиць</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_window.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Віконні функції</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_analytic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Практичні задачі</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sql_metrics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Аналіз продуктових метрик</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./quarto.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Quarto</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Зміст</h2>
   
  <ul>
  <li><a href="#основні-типи-обєднань-join" id="toc-основні-типи-обєднань-join" class="nav-link active" data-scroll-target="#основні-типи-обєднань-join"><span class="header-section-number">7.1</span> Основні типи об’єднань JOIN</a></li>
  <li><a href="#як-працює-обєднання-таблиць" id="toc-як-працює-обєднання-таблиць" class="nav-link" data-scroll-target="#як-працює-обєднання-таблиць"><span class="header-section-number">7.2</span> Як працює об’єднання таблиць</a></li>
  <li><a href="#inner-join" id="toc-inner-join" class="nav-link" data-scroll-target="#inner-join"><span class="header-section-number">7.3</span> INNER JOIN</a></li>
  <li><a href="#left-та-right-join" id="toc-left-та-right-join" class="nav-link" data-scroll-target="#left-та-right-join"><span class="header-section-number">7.4</span> LEFT та RIGHT JOIN</a></li>
  <li><a href="#full-join" id="toc-full-join" class="nav-link" data-scroll-target="#full-join"><span class="header-section-number">7.5</span> FULL JOIN</a></li>
  <li><a href="#операції-над-множинами" id="toc-операції-над-множинами" class="nav-link" data-scroll-target="#операції-над-множинами"><span class="header-section-number">7.6</span> Операції над множинами</a></li>
  <li><a href="#cross-join" id="toc-cross-join" class="nav-link" data-scroll-target="#cross-join"><span class="header-section-number">7.7</span> CROSS JOIN</a></li>
  <li><a href="#збираємо-списки-array_agg" id="toc-збираємо-списки-array_agg" class="nav-link" data-scroll-target="#збираємо-списки-array_agg"><span class="header-section-number">7.8</span> Збираємо списки: <code>array_agg()</code></a></li>
  <li><a href="#self-join" id="toc-self-join" class="nav-link" data-scroll-target="#self-join"><span class="header-section-number">7.9</span> SELF JOIN</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.dev/Aranaur/py4ds/blob/main/sql_join.ipynb" class="toc-action">Редагувати сторінку</a></p><p><a href="https://github.com/Aranaur/py4ds/issues/new" class="toc-action">Повідомити про проблему</a></p><p><a href="https://github.com/Aranaur/py4ds/blob/main/sql_join.ipynb" class="toc-action">Переглянути код</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Об’єднання таблиць</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="основні-типи-обєднань-join" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="основні-типи-обєднань-join"><span class="header-section-number">7.1</span> Основні типи об’єднань JOIN</h2>
<p>Ось ми й підібралися до однієї з найважливіших тем у SQL – об’єднання таблиць.</p>
<p>SQL-запити дозволяють вибирати та обробляти дані не тільки з однієї таблиці – у цьому ми вже переконалися, коли працювали з підзапитами. Але таблиці можна об’єднувати в один результуючий набір записів, пов’язуючи їх за певними умовами. Це дозволяє робити операція з’єднання <code>JOIN</code>.</p>
<p>Ми розглянемо такі типи з’єднань таблиць:</p>
<ol type="1">
<li><code>INNER JOIN</code></li>
<li><code>LEFT/RIGHT JOIN</code></li>
<li><code>FULL JOIN</code></li>
<li><code>CROSS JOIN</code></li>
</ol>
<p>Оператори об’єднання включаються до розділу <code>FROM</code> запиту. Загалом, незалежно від того, який тип об’єднання використовується, запит на об’єднання таблиць виглядає наступним чином:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">FROM</span> table_1 </span>
<span id="cb1-3"><a href="#cb1-3"></a>     <span class="kw">JOIN</span> table_2</span>
<span id="cb1-4"><a href="#cb1-4"></a>     <span class="kw">ON</span> [condition]</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Як правило (але далеко не завжди), в якості умови <strong>[condition]</strong>, за якою відбувається об’єднання, виступає рівність значень у певних стовпцях. Такі стовпці зазвичай використовуються як ключі із зазначенням id (товару, користувача тощо), тобто значень, за якими можна однозначно ідентифікувати певну сутність:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">SELECT</span> table_1.column_1, table_2.column_2</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">FROM</span> table_1 </span>
<span id="cb2-3"><a href="#cb2-3"></a>     <span class="kw">JOIN</span> table_2</span>
<span id="cb2-4"><a href="#cb2-4"></a>     <span class="kw">ON</span> table_1.<span class="kw">id</span> <span class="op">=</span> table_2.<span class="kw">id</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>При цьому рекомендується до кожної колонка через точку вказувати ім’я таблиці, яка містить цю колонку. Більше того, це стає вже не рекомендацією, а необхідністю, коли імена стовпців у таблицях збігаються - без явного вказівки джерел, база даних не зможе сама визначити, які стовпці та з яких таблиць ви маєте на увазі, і в результаті поверне помилку.</p>
<p>Якщо імена таблиць надто довгі, таблицям можна присвоїти аліаси. За цими ж аліасами можна відразу зручно звертатися до колонок:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">SELECT</span> a.column_1, b.column_2</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">FROM</span> table_1 a </span>
<span id="cb3-3"><a href="#cb3-3"></a>     <span class="kw">JOIN</span> table_2 b</span>
<span id="cb3-4"><a href="#cb3-4"></a>     <span class="kw">ON</span> a.<span class="kw">id</span> <span class="op">=</span> b.<span class="kw">id</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Якщо ім’я поля, за котрим відбувається об’єднання, збігається в обох таблицях (як у прикладах вище), можна використовувати скорочений запис з оператором <code>USING</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">SELECT</span> a.column_1, b.column_2</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">FROM</span> table_1 a </span>
<span id="cb4-3"><a href="#cb4-3"></a>     <span class="kw">JOIN</span> table_2 b</span>
<span id="cb4-4"><a href="#cb4-4"></a>     <span class="kw">USING</span> (<span class="kw">id</span>)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>При об’єднанні таблиць можна використовувати підзапити. Їх можна поєднувати з іншими таблицями або одину з одною:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">FROM</span> table_1</span>
<span id="cb5-3"><a href="#cb5-3"></a>     <span class="kw">JOIN</span> (</span>
<span id="cb5-4"><a href="#cb5-4"></a>          <span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb5-5"><a href="#cb5-5"></a>          <span class="kw">FROM</span> table_2</span>
<span id="cb5-6"><a href="#cb5-6"></a>     ) <span class="kw">AS</span> subquery</span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="kw">ON</span> table_1.<span class="kw">id</span> <span class="op">=</span> subquery.<span class="kw">id</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="op">..</span>.</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="kw">FROM</span> (</span>
<span id="cb5-13"><a href="#cb5-13"></a>     <span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb5-14"><a href="#cb5-14"></a>     <span class="kw">FROM</span> table_1</span>
<span id="cb5-15"><a href="#cb5-15"></a>) <span class="kw">AS</span> subquery_1</span>
<span id="cb5-16"><a href="#cb5-16"></a>     <span class="kw">JOIN</span> (</span>
<span id="cb5-17"><a href="#cb5-17"></a>          <span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb5-18"><a href="#cb5-18"></a>          <span class="kw">FROM</span> table_2</span>
<span id="cb5-19"><a href="#cb5-19"></a>     ) <span class="kw">AS</span> subquery_2</span>
<span id="cb5-20"><a href="#cb5-20"></a>    <span class="kw">ON</span> subquery_1.<span class="kw">id</span> <span class="op">=</span> subquery_2.<span class="kw">id</span></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="op">..</span>.</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="як-працює-обєднання-таблиць" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="як-працює-обєднання-таблиць"><span class="header-section-number">7.2</span> Як працює об’єднання таблиць</h2>
<p>Добре, із записом у загальному вигляді начебто зрозуміло. Але що насправді відбувається при об’єднанні таблиць? Давайте розбиратися.</p>
<p>Процес об’єднання можна подати у вигляді наступної послідовності операцій:</p>
<ol type="1">
<li>Спочатку кожен рядок першої таблиці зіставляється з кожним рядком другої таблиці, тобто відбувається <a href="https://uk.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D1%96%D0%B2_%D0%B4%D0%BE%D0%B1%D1%83%D1%82%D0%BE%D0%BA_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B8%D0%BD">декартів добуток</a> вдох множин, результатом якого є нове множина, що складається з різних пар вхідних рядків. Наприклад, якщо у одній таблиці було 50 записів, а інший 10, то результаті декартового добутку вийде 500 записів. На іграшковому прикладі це можна уявити так:</li>
</ol>
<div id="fig-cartesian" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="img/sql/cartesian.png" class="img-fluid figure-img" style="width:45.0%"></p>
<figcaption class="figure-caption">Рисунок&nbsp;7.1: Декартів добуток</figcaption>
</figure>
</div>
<ol start="2" type="1">
<li><p>Потім для кожного об’єднаного рядка, що складається з двох вхідних таблиць, перевіряється умова з’єднання, вказана після оператора <code>ON</code>.</p></li>
<li><p>Після цього відповідно до обраного типу об’єднання формується результуюча таблиця.</p></li>
</ol>
<p>При з’єднанні yне двох, а кількох таблиць, операція об’єднання виконується послідовно кілька разів, тобто описаний вище алгоритм запускається стільки разів, скільки зазначено з’єднань. При цьому в цій послідовності при кожному об’єднанні можна використовувати будь-який тип з’єднання (<code>INNER</code>, <code>LEFT</code> тощо).</p>
<p>Для двох об’єднань запит може виглядати приблизно так:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">SELECT</span> a.column_1, b.column_2</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">FROM</span> table_1 a </span>
<span id="cb6-3"><a href="#cb6-3"></a>     <span class="kw">LEFT</span> <span class="kw">JOIN</span> table_2 b</span>
<span id="cb6-4"><a href="#cb6-4"></a>     <span class="kw">ON</span> a.user_id <span class="op">=</span> b.user_id</span>
<span id="cb6-5"><a href="#cb6-5"></a>     <span class="kw">JOIN</span> table_3 c</span>
<span id="cb6-6"><a href="#cb6-6"></a>     <span class="kw">ON</span> b.order_id <span class="op">=</span> c.order_id</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="op">..</span>.</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Про те, як саме вибір типу <code>JOIN</code> впливає на результат, ми говоритимемо далі.</p>
<p>Якщо щось на цьому кроці залишилося незрозумілим, не переживайте. Далі все прояснимо на практичних прикладах!</p>
</section>
<section id="inner-join" class="level2 page-columns page-full" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="inner-join"><span class="header-section-number">7.3</span> INNER JOIN</h2>
<p>Перший тип об’єднання, який ми розглянемо, має назву <code>INNER JOIN</code>. Це оператор внутрішнього об’єднання, якому абсолютно неважливий порядок зазначення таблиць, тобто у таких випадках результат об’єднання буде однаковим:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">FROM</span> table_1 <span class="kw">INNER</span> <span class="kw">JOIN</span> table_2</span>
<span id="cb7-3"><a href="#cb7-3"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="op">..</span>.</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">FROM</span> table_2 <span class="kw">INNER</span> <span class="kw">JOIN</span> table_1 </span>
<span id="cb7-9"><a href="#cb7-9"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="op">..</span>.</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>При цьому в запиті замість <code>INNER JOIN</code> можна писати просто <code>JOIN</code> - це те саме.</p>
<p>Результат об’єднання <code>INNER JOIN</code> формується так:</p>
<ol type="1">
<li>Спочатку кожен рядок першої таблиці зіставляється з кожним рядком другої таблиці (відбувається декартів добуток).</li>
<li>Потім для кожного об’єднаного рядка перевіряється умова з’єднання, вказана після оператора <code>ON</code>.</li>
<li>Після цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.</li>
</ol>
<p>Таким чином, в результаті об’єднання <code>INNER JOIN</code> із двох таблиць відкидаються усі рядки, які не пройшли перевірку на відповідність зазначеній умові. От і все!</p>
<p>Розглянемо наступний приклад:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">SELECT</span> A.<span class="kw">id</span> <span class="kw">as</span> <span class="kw">id</span>,</span>
<span id="cb8-2"><a href="#cb8-2"></a>       A.city <span class="kw">as</span> city,</span>
<span id="cb8-3"><a href="#cb8-3"></a>       B.country <span class="kw">as</span> country</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">FROM</span> table_A <span class="kw">as</span> A</span>
<span id="cb8-5"><a href="#cb8-5"></a>     <span class="kw">JOIN</span> table_B <span class="kw">as</span> B</span>
<span id="cb8-6"><a href="#cb8-6"></a>     <span class="kw">ON</span> A.<span class="kw">id</span> <span class="op">=</span> B.<span class="kw">id</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>В результаті такого запиту таблиці <code>table_A</code> та <code>table_B</code> будуть об’єднані в таблицю <code>table_С</code>:</p>
<div id="tbl-panel" class="tbl-parent quarto-layout-panel anchored">
<div class="panel-caption table-caption">
<p>Таблиця&nbsp;7.1: Приклад роботи <code>INNER JOIN</code></p>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-A" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-primary table-bordered small table">
<caption>(a) Таблиця A</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">city</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">01</td>
<td style="text-align: left;">London</td>
</tr>
<tr class="even">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Kyiv</td>
</tr>
</tbody>
</table>
</div>
<div id="tbl-B" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-secondary table-bordered small table">
<caption>(b) Таблиця B</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="even">
<td style="text-align: left;">03</td>
<td style="text-align: left;">Poland</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-C" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 100.0%;justify-content: center;">
<table class="table-sm table-success table-bordered small table">
<caption>(c) Таблиця C</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">city</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Kyiv</td>
<td style="text-align: left;">Ukraine</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>Оскільки таблиці збігаються лише за одним значенням у стовпці <code>id</code>, то в результат буде включено лише одне запис.</p>
<p>Схематично результат роботи об’єднань прийнято зображувати за допомогою <a href="https://uk.wikipedia.org/wiki/%D0%94%D1%96%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%B0_%D0%92%D0%B5%D0%BD%D0%BD%D0%B0">діаграм Венна</a>. Для <code>INNER JOIN</code> наведено на <a href="#fig-sql-inner-join">рисунку&nbsp;<span>7.2</span></a>.</p>
<div class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div id="fig-sql-inner-join" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="sql_join_files/figure-html/fig-sql-inner-join-output-1.png" width="511" height="389" class="figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;7.2: Діаграма Венна: INNER JOIN</figcaption>
</figure>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Примітка
</div>
</div>
<div class="callout-body-container callout-body">
<p>Докладніше про <code>INNER JOIN</code> можна почитати <a href="https://duckdb.org/docs/sql/query_syntax/from#outer-joins">тут</a>.</p>
</div>
</div>
<p>А тепер давайте повернемося до нашої бази даних та вирішимо завдання.</p>
<p>Для початку спробуйте виконати наступні два запити та порахувати кількість унікальних користувачів у таблицях <code>users</code> та <code>user_actions</code>:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="op">%%</span>sql</span>
<span id="cb9-2"><a href="#cb9-2"></a>SELECT COUNT(DISTINCT user_id) AS users_count</span>
<span id="cb9-3"><a href="#cb9-3"></a>FROM users</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">users_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>20331</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">%%</span>sql</span>
<span id="cb10-2"><a href="#cb10-2"></a>SELECT COUNT(DISTINCT user_id) <span class="im">as</span> users_count</span>
<span id="cb10-3"><a href="#cb10-3"></a>FROM user_actions</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">users_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>21401</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Ви помітите, що у таблиці <code>user_actions</code> унікальних користувачів більше. Це означає, що про частину користувачів ми щось не знаємо — у нас просто немає інформації в таблиці <code>users</code>. Тому в результаті об’єднання цих двох таблиць за допомогою <code>INNER JOIN</code> цю частину користувачів буде виключено з результату.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-01" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.1 </strong></span><br> Об’єднайте таблиці <code>user_actions</code> та <code>users</code> за ключом <code>user_id</code>. У результаті включіть дві колонки з <code>user_id</code> з обох таблиць. Ці дві колонки назвіть відповідно <code>user_id_left</code> та <code>user_id_right</code>. Також у результат включіть колонки <code>order_id</code>, <code>time</code>, <code>action</code>, <code>sex</code>, <code>birth_date</code>. Відсортуйте таблицю за зростанням id користувача (у будь-якій з двох колонок з id).</p>
<p>Поля в результуючій таблиці: <code>user_id_left</code>, <code>user_id_right</code>, <code>order_id</code>, <code>time</code>, <code>action</code>, <code>sex</code>, <code>birth_date</code></p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Примітка
</div>
</div>
<div class="callout-body-container callout-body">
<p>Зверніть увагу, що в результаті об’єднання колонки з ключами (у нашому випадку це <code>user_id</code>) не перетворюються на одну загальну колонку, а разом додаються в результуючу таблицю. Тобто скільки було сумарно колонок у двох таблицях, стільки виявиться і в результуючій таблиці після об’єднання. А вже далі в операторі <code>SELECT</code> можна вибирати потрібні та проводити над ними операції.</p>
<p>Щоб звернутися до колонок з однаковим ім’ям (<code>user_id</code>), що прийшли з різних таблиць, призначте таблицям аліаси та зверніться до колонок через них. Приклад, як це можна зробити:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">SELECT</span> A.<span class="kw">id</span> <span class="kw">as</span> id_a, </span>
<span id="cb11-2"><a href="#cb11-2"></a>       B.<span class="kw">id</span> <span class="kw">as</span> id_b, </span>
<span id="cb11-3"><a href="#cb11-3"></a>       <span class="op">..</span>.</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="kw">FROM</span> table_A <span class="kw">as</span> A</span>
<span id="cb11-5"><a href="#cb11-5"></a>     <span class="kw">JOIN</span> table_B <span class="kw">as</span> B</span>
<span id="cb11-6"><a href="#cb11-6"></a>     <span class="kw">ON</span> A.<span class="kw">id</span> <span class="op">=</span> B.<span class="kw">id</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="op">..</span>.</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div class="cell page-columns page-full" data-execution_count="5">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="op">%%</span>sql</span>
<span id="cb12-2"><a href="#cb12-2"></a>SELECT a.user_id <span class="im">as</span> user_id_left,</span>
<span id="cb12-3"><a href="#cb12-3"></a>       b.user_id <span class="im">as</span> user_id_right,</span>
<span id="cb12-4"><a href="#cb12-4"></a>       order_id,</span>
<span id="cb12-5"><a href="#cb12-5"></a>       time,</span>
<span id="cb12-6"><a href="#cb12-6"></a>       action,</span>
<span id="cb12-7"><a href="#cb12-7"></a>       sex,</span>
<span id="cb12-8"><a href="#cb12-8"></a>       birth_date</span>
<span id="cb12-9"><a href="#cb12-9"></a>FROM   user_actions a join users b using (user_id)</span>
<span id="cb12-10"><a href="#cb12-10"></a>ORDER BY user_id_left</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display column-body-outset" data-execution_count="5">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id_left</th>
<th data-quarto-table-cell-role="th">user_id_right</th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">time</th>
<th data-quarto-table-cell-role="th">action</th>
<th data-quarto-table-cell-role="th">sex</th>
<th data-quarto-table-cell-role="th">birth_date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2022-08-24 01:52:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>1</td>
<td>4683</td>
<td>2022-08-27 20:56:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>1</td>
<td>22901</td>
<td>2022-09-02 00:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>1</td>
<td>23149</td>
<td>2022-09-02 02:36:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2022-08-24 06:37:00</td>
<td>create_order</td>
<td>female</td>
<td>1993-06-18</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">59341</td>
<td>21399</td>
<td>21399</td>
<td>59583</td>
<td>2022-09-08 23:56:00</td>
<td>create_order</td>
<td>female</td>
<td>1987-04-27</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">59342</td>
<td>21399</td>
<td>21399</td>
<td>59587</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1987-04-27</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">59343</td>
<td>21400</td>
<td>21400</td>
<td>59586</td>
<td>2022-09-08 23:57:00</td>
<td>create_order</td>
<td>male</td>
<td>1986-12-31</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">59344</td>
<td>21401</td>
<td>21401</td>
<td>59589</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1993-03-20</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">59345</td>
<td>21402</td>
<td>21402</td>
<td>59591</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-05-24</td>
</tr>
</tbody>
</table>

<p>59346 rows × 7 columns</p>
</div>
</div>
</div>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-02" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.2 </strong></span><br> А тепер спробуйте трохи переписати запит із минулого завдання та порахувати кількість унікальних id в об’єднаній таблиці. Тобто знову поєднайте таблиці, але цього разу просто порахуйте унікальні <code>user_id</code> в одній з колонок з id. Виведіть цю кількість як результат. Назвіть колонку з порахованим значенням <code>users_count</code>.</p>
<p>Поле у результуючій таблиці: <code>users_count</code></p>
<p>Після того, як вирішите завдання, порівняйте отримане значення з кількістю унікальних користувачів у таблицях <code>users</code> та <code>user_actions</code>, яку ми порахували раніше. З яким значенням воно збігається?</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="6">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="op">%%</span>sql</span>
<span id="cb14-2"><a href="#cb14-2"></a>SELECT count(distinct a.user_id) <span class="im">as</span> users_count</span>
<span id="cb14-3"><a href="#cb14-3"></a>FROM   user_actions a </span>
<span id="cb14-4"><a href="#cb14-4"></a>    JOIN users b using (user_id)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">users_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>20331</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<hr>
</section>
<section id="left-та-right-join" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="left-та-right-join"><span class="header-section-number">7.4</span> LEFT та RIGHT JOIN</h2>
<p>Наступний тип об’єднання, який ми розглянемо, це <code>LEFT OUTER JOIN</code> (або просто <code>LEFT JOIN</code>).</p>
<p><code>LEFT JOIN</code>— це оператор зовнішнього об’єднання, котрій важливий порядок таблиць у запиті, тобто на відміну від <code>INNER JOIN</code>, він не є симетричним.</p>
<p>Тому наступні два записи вже не є еквівалентними:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">FROM</span> table_1 <span class="kw">LEFT</span> <span class="kw">JOIN</span> table_2</span>
<span id="cb15-3"><a href="#cb15-3"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="op">..</span>.</span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">FROM</span> table_2 <span class="kw">LEFT</span> <span class="kw">JOIN</span> table_1 </span>
<span id="cb15-9"><a href="#cb15-9"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="op">..</span>.</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат об’єднання <code>LEFT JOIN</code> формується так:</p>
<ol type="1">
<li>Спочатку кожен рядок лівої таблиці зіставляється з кожним рядком правої таблиці (відбувається декартів добуток).</li>
<li>Потім для кожного об’єднаного рядка перевіряється умова з’єднання, вказана після оператора <code>ON</code>.</li>
<li>Після цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.</li>
<li>Далі в результат додаються ті записи з лівої таблиці (<strong>увага: тільки з лівої</strong>), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля правої таблиці заповнюються значеннями <code>NULL</code>.</li>
</ol>
<p>Якщо уважно подивитися на описаний алгоритм, можна зрозуміти, що він легко зводиться до наступної послідовності дій:</p>
<ul>
<li>Спочатку відповідно до зазначеної умови виконується <code>INNER JOIN</code> першої та другої таблиць.</li>
<li>Потім до результату додаються ті записи з лівої таблиці (<strong>увага: тільки з лівої</strong>), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля правої таблиці заповнюються значеннями <code>NULL</code>.</li>
</ul>
<p>Ось і вся магія!</p>
<p>Об’єднання <code>RIGHT JOIN</code> працює аналогічним чином, тільки на другому етапі результат <code>INNER JOIN</code> додаються записи не з лівої, а <strong>з правої таблиці</strong>.</p>
<p>Давайте знову розглянемо кілька простих прикладів.</p>
<p>Так буде виглядати запит та його результат із <code>LEFT JOIN</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">SELECT</span> A.<span class="kw">id</span> <span class="kw">as</span> <span class="kw">id</span>,</span>
<span id="cb16-2"><a href="#cb16-2"></a>       A.city <span class="kw">as</span> city,</span>
<span id="cb16-3"><a href="#cb16-3"></a>       B.country <span class="kw">as</span> country</span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">FROM</span> table_A <span class="kw">as</span> A</span>
<span id="cb16-5"><a href="#cb16-5"></a>     <span class="kw">LEFT</span> <span class="kw">JOIN</span> table_B <span class="kw">as</span> B</span>
<span id="cb16-6"><a href="#cb16-6"></a>     <span class="kw">ON</span> A.<span class="kw">id</span> <span class="op">=</span> B.<span class="kw">id</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="tbl-panel" class="tbl-parent quarto-layout-panel anchored">
<div class="panel-caption table-caption">
<p>Таблиця&nbsp;7.2: Приклад роботи <code>LEFT JOIN</code></p>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-A-left" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-primary table-bordered small table">
<caption>(a) Таблиця A</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">city</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">01</td>
<td style="text-align: left;">London</td>
</tr>
<tr class="even">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Kyiv</td>
</tr>
</tbody>
</table>
</div>
<div id="tbl-B-left" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-secondary table-bordered small table">
<caption>(b) Таблиця B</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="even">
<td style="text-align: left;">03</td>
<td style="text-align: left;">Poland</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-C-left" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 100.0%;justify-content: center;">
<table class="table-sm table-success table-bordered small table">
<caption>(c) Таблиця C</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">city</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">01</td>
<td style="text-align: left;">London</td>
<td style="text-align: left;">NULL</td>
</tr>
<tr class="even">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Kyiv</td>
<td style="text-align: left;">Ukraine</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>У цьому випадку до результату потрапить запис з <code>id 2</code>, оскільки вона є в обох таблицях, а також запис з <code>id 1</code> з лівої таблиці.</p>
<p>Діаграма Венна для <code>LEFT JOIN</code> наведено на <a href="#fig-sql_left-join">рис.&nbsp;<span>7.3</span></a>.</p>
<div class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<div id="fig-sql_left-join" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="sql_join_files/figure-html/fig-sql_left-join-output-1.png" width="511" height="389" class="figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;7.3: Діаграма Венна: LEFT JOIN</figcaption>
</figure>
</div>
</div>
</div>
<p>А ось таким вийде результат запиту з <code>RIGHT JOIN</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">SELECT</span> B.<span class="kw">id</span> <span class="kw">as</span> <span class="kw">id</span>,</span>
<span id="cb17-2"><a href="#cb17-2"></a>       A.city <span class="kw">as</span> city,</span>
<span id="cb17-3"><a href="#cb17-3"></a>       B.country <span class="kw">as</span> country</span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="kw">FROM</span> table_A <span class="kw">as</span> A</span>
<span id="cb17-5"><a href="#cb17-5"></a>     <span class="kw">RIGHT</span> <span class="kw">JOIN</span> table_B <span class="kw">as</span> B</span>
<span id="cb17-6"><a href="#cb17-6"></a>     <span class="kw">ON</span> A.<span class="kw">id</span> <span class="op">=</span> B.<span class="kw">id</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="tbl-panel" class="tbl-parent quarto-layout-panel anchored">
<div class="panel-caption table-caption">
<p>Таблиця&nbsp;7.3: Приклад роботи <code>RIGHT JOIN</code></p>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-A-right" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-primary table-bordered small table">
<caption>(a) Таблиця A</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">city</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">01</td>
<td style="text-align: left;">London</td>
</tr>
<tr class="even">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Kyiv</td>
</tr>
</tbody>
</table>
</div>
<div id="tbl-B-right" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-secondary table-bordered small table">
<caption>(b) Таблиця B</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="even">
<td style="text-align: left;">03</td>
<td style="text-align: left;">Poland</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-C-right" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 100.0%;justify-content: center;">
<table class="table-sm table-success table-bordered small table">
<caption>(c) Таблиця C</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">city</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Kyiv</td>
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="even">
<td style="text-align: left;">03</td>
<td style="text-align: left;">NULL</td>
<td style="text-align: left;">Poland</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>Все як і у випадку з <code>LEFT JOIN</code>, тільки в результат вже потрапить запис з <code>id 3</code> з правої таблиці.</p>
<p>Діаграма Венна для <code>RIGHT JOIN</code> зображена на <a href="#fig-sql_right-join">рис.&nbsp;<span>7.4</span></a></p>
<div class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<div id="fig-sql_right-join" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="sql_join_files/figure-html/fig-sql_right-join-output-1.png" width="511" height="389" class="figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;7.4: Діаграма Венна: LEFT JOIN</figcaption>
</figure>
</div>
</div>
</div>
<p>А тепер розглянемо на прикладі наших даних.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-03" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.3 </strong></span><br> За допомогою <code>LEFT JOIN</code> об’єднайте таблиці <code>user_actions</code> та <code>users</code> за ключом <code>user_id</code>. Зверніть увагу на порядок таблиць – ліворуч <code>users_actions</code>, праворуч <code>users</code>. У результаті включіть дві колонки з <code>user_id</code> з обох таблиць. Ці дві колонки назвіть відповідно <code>user_id_left</code> та <code>user_id_right</code>. Також у результат увімкніть колонки <code>order_id</code>, <code>time</code>, <code>action</code>, <code>sex</code>, <code>birth_date</code>. Відсортуйте таблицю, що вийшла, за зростанням id користувача (у колонці з <strong>лівої</strong> таблиці).</p>
<p>Поля в результуючій таблиці: <code>user_id_left</code>, <code>user_id_right</code>, <code>order_id</code>, <code>time</code>, <code>action</code>, <code>sex</code>, <code>birth_date</code></p>
<p>Після того як розв’яжете завдання, зверніть увагу на колонки з <code>user_id</code>. Чи немає в якомусь із них пропущених значень?</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="9">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="op">%%</span>sql</span>
<span id="cb18-2"><a href="#cb18-2"></a>SELECT a.user_id <span class="im">as</span> user_id_left,</span>
<span id="cb18-3"><a href="#cb18-3"></a>       b.user_id <span class="im">as</span> user_id_right,</span>
<span id="cb18-4"><a href="#cb18-4"></a>       order_id,</span>
<span id="cb18-5"><a href="#cb18-5"></a>       time,</span>
<span id="cb18-6"><a href="#cb18-6"></a>       action,</span>
<span id="cb18-7"><a href="#cb18-7"></a>       sex,</span>
<span id="cb18-8"><a href="#cb18-8"></a>       birth_date</span>
<span id="cb18-9"><a href="#cb18-9"></a>FROM   user_actions a</span>
<span id="cb18-10"><a href="#cb18-10"></a>    LEFT JOIN users b using (user_id)</span>
<span id="cb18-11"><a href="#cb18-11"></a>ORDER BY user_id_left</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="9">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id_left</th>
<th data-quarto-table-cell-role="th">user_id_right</th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">time</th>
<th data-quarto-table-cell-role="th">action</th>
<th data-quarto-table-cell-role="th">sex</th>
<th data-quarto-table-cell-role="th">birth_date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>1.0</td>
<td>1</td>
<td>2022-08-24 01:52:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>1.0</td>
<td>4683</td>
<td>2022-08-27 20:56:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>1.0</td>
<td>22901</td>
<td>2022-09-02 00:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>1.0</td>
<td>23149</td>
<td>2022-09-02 02:36:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2</td>
<td>2.0</td>
<td>2</td>
<td>2022-08-24 06:37:00</td>
<td>create_order</td>
<td>female</td>
<td>1993-06-18</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">62569</td>
<td>21399</td>
<td>21399.0</td>
<td>59583</td>
<td>2022-09-08 23:56:00</td>
<td>create_order</td>
<td>female</td>
<td>1987-04-27</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">62570</td>
<td>21399</td>
<td>21399.0</td>
<td>59587</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1987-04-27</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">62571</td>
<td>21400</td>
<td>21400.0</td>
<td>59586</td>
<td>2022-09-08 23:57:00</td>
<td>create_order</td>
<td>male</td>
<td>1986-12-31</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">62572</td>
<td>21401</td>
<td>21401.0</td>
<td>59589</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1993-03-20</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">62573</td>
<td>21402</td>
<td>21402.0</td>
<td>59591</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-05-24</td>
</tr>
</tbody>
</table>

<p>62574 rows × 7 columns</p>
</div>
</div>
</div>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-04" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.4 </strong></span><br> Тепер знову спробуйте трохи переписати запит з минулого завдання та порахуйте кількість унікальних id у колонці <code>user_id</code>, що надійшла з лівої таблиці <code>user_actions</code>. Виведіть цю кількість як результат. Назвіть колонку з порахованим значенням <code>users_count</code>.</p>
<p>Поле у результуючій таблиці: <code>users_count</code></p>
<p>Після того, як вирішите завдання, порівняйте отримане значення з кількістю унікальних користувачів у таблицях <code>users</code> та <code>user_actions</code>. З яким значенням воно збіглося цього разу?</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="10">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a><span class="op">%%</span>sql</span>
<span id="cb20-2"><a href="#cb20-2"></a>SELECT count(distinct a.user_id) <span class="im">as</span> users_count</span>
<span id="cb20-3"><a href="#cb20-3"></a>FROM   user_actions a</span>
<span id="cb20-4"><a href="#cb20-4"></a>    LEFT JOIN users b using (user_id)</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="10">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">users_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>21401</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<hr>
<p>Ви могли помітити, що при об’єднанні таблиць <code>user_actions</code> і <code>users</code> за допомогою <code>LEFT JOIN</code> у стовпцях, що прийшли з правої таблиці <code>users</code>, утворилися значення <code>NULL</code>. Якщо не помітили, спробуйте відсортувати об’єднану таблицю по полях <code>users.user_id</code> і <code>users.birth_date</code>.</p>
<p>Це саме те, про що ми говорили — при формуванні об’єднаних рядків для тих id з лівої таблиці, яких не було в правій таблиці, поля з правої таблиці були заповнені порожніми значеннями.</p>
<p>А тепер давайте перевернемо один трюк.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-05" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.5 </strong></span><br> Візьміть запит із <a href="#exr-sql-join-03">завдання&nbsp;<span>7.3</span></a>, де ви об’єднували таблиці <code>user_actions</code> і <code>users</code> за допомогою <code>LEFT JOIN</code>, додайте до запиту оператор <code>WHERE</code> і виключіть значення <code>NULL</code> в колонці <code>user_id</code> з правої таблиці. Включіть у результат ті самі колонки і відсортуйте таблицю, що вийшла, за зростанням id користувача в колонці з лівої таблиці.</p>
<p>Поля в результуючій таблиці: <code>user_id_left</code>, <code>user_id_right</code>, <code>order_id</code>, <code>time</code>, <code>action</code>, <code>sex</code>, <code>birth_date</code></p>
<p>Після того як розв’яжете завдання, спробуйте порівняти це рішення із <a href="#exr-sql-join-01">завданням&nbsp;<span>7.1</span></a>. Подумайте, який <code>JOIN</code> ми отримали після всіх маніпуляцій з результатом. Заодно можете порахувати кількість унікальних <code>user_id</code> у запиті з цього завдання, щоб розставити всі крапки над “i”.</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="11">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a><span class="op">%%</span>sql</span>
<span id="cb21-2"><a href="#cb21-2"></a>SELECT a.user_id <span class="im">as</span> user_id_left,</span>
<span id="cb21-3"><a href="#cb21-3"></a>       b.user_id <span class="im">as</span> user_id_right,</span>
<span id="cb21-4"><a href="#cb21-4"></a>       order_id,</span>
<span id="cb21-5"><a href="#cb21-5"></a>       time,</span>
<span id="cb21-6"><a href="#cb21-6"></a>       action,</span>
<span id="cb21-7"><a href="#cb21-7"></a>       sex,</span>
<span id="cb21-8"><a href="#cb21-8"></a>       birth_date</span>
<span id="cb21-9"><a href="#cb21-9"></a>FROM   user_actions a</span>
<span id="cb21-10"><a href="#cb21-10"></a>    LEFT JOIN users b using (user_id)</span>
<span id="cb21-11"><a href="#cb21-11"></a>WHERE  b.user_id IS NOT NULL</span>
<span id="cb21-12"><a href="#cb21-12"></a>ORDER BY user_id_left</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="11">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id_left</th>
<th data-quarto-table-cell-role="th">user_id_right</th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">time</th>
<th data-quarto-table-cell-role="th">action</th>
<th data-quarto-table-cell-role="th">sex</th>
<th data-quarto-table-cell-role="th">birth_date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2022-08-24 01:52:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>1</td>
<td>4683</td>
<td>2022-08-27 20:56:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>1</td>
<td>22901</td>
<td>2022-09-02 00:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>1</td>
<td>23149</td>
<td>2022-09-02 02:36:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-10-23</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2022-08-24 06:37:00</td>
<td>create_order</td>
<td>female</td>
<td>1993-06-18</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">59341</td>
<td>21399</td>
<td>21399</td>
<td>59583</td>
<td>2022-09-08 23:56:00</td>
<td>create_order</td>
<td>female</td>
<td>1987-04-27</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">59342</td>
<td>21399</td>
<td>21399</td>
<td>59587</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1987-04-27</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">59343</td>
<td>21400</td>
<td>21400</td>
<td>59586</td>
<td>2022-09-08 23:57:00</td>
<td>create_order</td>
<td>male</td>
<td>1986-12-31</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">59344</td>
<td>21401</td>
<td>21401</td>
<td>59589</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1993-03-20</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">59345</td>
<td>21402</td>
<td>21402</td>
<td>59591</td>
<td>2022-09-08 23:58:00</td>
<td>create_order</td>
<td>female</td>
<td>1991-05-24</td>
</tr>
</tbody>
</table>

<p>59346 rows × 7 columns</p>
</div>
</div>
</div>
<hr>
</section>
<section id="full-join" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="full-join"><span class="header-section-number">7.5</span> FULL JOIN</h2>
<p>Щоб краще розібратися з джойнами, розглянемо ще один тип об’єднання таблиць — <code>FULL OUTER JOIN</code> або просто <code>FULL JOIN</code>. Це оператор повного зовнішнього об’єднання, для якого, як і <code>INNER JOIN</code>, неважливий порядок вказівки таблиць. Проте працює він зовсім інакше.</p>
<p>Запит із <code>FULL OUTER JOIN</code> виглядає приблизно так:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="kw">FROM</span> table_1 <span class="kw">FULL</span> <span class="kw">JOIN</span> table_2</span>
<span id="cb23-3"><a href="#cb23-3"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="op">..</span>.</span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="kw">FROM</span> table_2 <span class="kw">FULL</span> <span class="kw">JOIN</span> table_1 </span>
<span id="cb23-9"><a href="#cb23-9"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="op">..</span>.</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат об’єднання <code>FULL JOIN</code> формується так:</p>
<ol type="1">
<li>Спочатку кожен рядок лівої таблиці зіставляється з кожним рядком правої таблиці (відбувається декартів добуток).</li>
<li>Потім для кожного об’єднаного рядка перевіряється умова об’єднання, вказана після оператора <code>ON</code>.</li>
<li>Після цього всі об’єднані рядки, для яких умова виявилася істинною, додаються до результуючої таблиці.</li>
<li>Далі в результат додаються ті записи з лівої та правої таблиць (<strong>увага: з обох таблиць</strong>), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля з іншої таблиці (для лівої це поля з правої, для правої це поля з лівої) заповнюються значеннями <code>NULL</code>.</li>
</ol>
<p>Цей алгоритм можна звести до наступної послідовності дій:</p>
<ul>
<li>Спочатку відповідно до зазначеної умови виконується <code>INNER JOIN</code> лівої та правої таблиць.</li>
<li>Далі в результат додаються ті записи з лівої та правої таблиць (<strong>увага: з обох таблиць</strong>), для яких умова виявилася хибною і які не увійшли до об’єднання на попередньому кроці. При цьому для таких записів відповідні поля з іншої таблиці (для лівої це поля з правої, для правої це поля з лівої) заповнюються значеннями <code>NULL</code>.</li>
</ul>
<p>Розглянемо найпростіший приклад.</p>
<p>Так буде виглядати запит та його результат з FULL JOIN:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">SELECT</span> A.<span class="kw">id</span> <span class="kw">as</span> <span class="kw">id</span>,</span>
<span id="cb24-2"><a href="#cb24-2"></a>       A.city <span class="kw">as</span> city,</span>
<span id="cb24-3"><a href="#cb24-3"></a>       B.country <span class="kw">as</span> country</span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="kw">FROM</span> table_A <span class="kw">as</span> A</span>
<span id="cb24-5"><a href="#cb24-5"></a>     <span class="kw">FULL</span> <span class="kw">JOIN</span> table_B <span class="kw">as</span> B</span>
<span id="cb24-6"><a href="#cb24-6"></a>     <span class="kw">ON</span> A.<span class="kw">id</span> <span class="op">=</span> B.<span class="kw">id</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="tbl-panel" class="tbl-parent quarto-layout-panel anchored">
<div class="panel-caption table-caption">
<p>Таблиця&nbsp;7.4: Приклад роботи <code>FULL JOIN</code></p>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-A-full" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-primary table-bordered small table">
<caption>(a) Таблиця A</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">city</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">01</td>
<td style="text-align: left;">London</td>
</tr>
<tr class="even">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Kyiv</td>
</tr>
</tbody>
</table>
</div>
<div id="tbl-B-full" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-secondary table-bordered small table">
<caption>(b) Таблиця B</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="even">
<td style="text-align: left;">03</td>
<td style="text-align: left;">Poland</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-C-full" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 100.0%;justify-content: center;">
<table class="table-sm table-success table-bordered small table">
<caption>(c) Таблиця C</caption>
<thead>
<tr class="header">
<th style="text-align: left;">id</th>
<th style="text-align: left;">city</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">01</td>
<td style="text-align: left;">London</td>
<td style="text-align: left;">NULL</td>
</tr>
<tr class="even">
<td style="text-align: left;">02</td>
<td style="text-align: left;">Kyiv</td>
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="odd">
<td style="text-align: left;">03</td>
<td style="text-align: left;">NULL</td>
<td style="text-align: left;">Poland</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>В результат потрапив спільний запис з <code>id 2</code>, а також всі записи, до яких не було знайдено відповідності з інших таблиць. Усі невідповідності були заповнені порожніми значеннями.</p>
<p>Діграма Венна для <code>FULL JOIN</code> наведено на <a href="#fig-sql-join-full-venn">рисунку&nbsp;<span>7.5</span></a>.</p>
<div class="cell" data-execution_count="12">
<div class="cell-output cell-output-display">
<div id="fig-sql-join-full-venn" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="sql_join_files/figure-html/fig-sql-join-full-venn-output-1.png" width="511" height="389" class="figure-img"></p>
<figcaption class="figure-caption">Рисунок&nbsp;7.5: Діаграма Венна: FULL JOIN</figcaption>
</figure>
</div>
</div>
</div>
<p>А тепер розберемося з <code>FULL JOIN</code> на прикладі нашої бази даних.</p>
<p>У нас є дві таблиці з датами народження користувачів та кур’єрів – <code>users</code> та <code>couriers</code>. Можна припустити, що в кожній таблиці у колонці <code>birth_date</code> є якісь дати, яких немає в іншій таблиці. Тобто такі дати, в які народився хтось із кур’єрів, але не народився жоден користувач, і навпаки. Ну що ж, спробуємо перевірити цю гіпотезу.</p>
<p>Для початку згрупуємо дві таблиці по колонці <code>birth_date</code> і порахуємо скільки користувачів/кур’єрів народилися в кожен з днів. Для цього можете виконати такий запит:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="op">%%</span>sql</span>
<span id="cb25-2"><a href="#cb25-2"></a>SELECT birth_date, COUNT(user_id) AS users_count</span>
<span id="cb25-3"><a href="#cb25-3"></a>FROM users</span>
<span id="cb25-4"><a href="#cb25-4"></a>WHERE birth_date IS NOT NULL</span>
<span id="cb25-5"><a href="#cb25-5"></a>GROUP BY birth_date</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="13">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">birth_date</th>
<th data-quarto-table-cell-role="th">users_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1991-05-24</td>
<td>11</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1994-07-21</td>
<td>6</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1992-01-09</td>
<td>13</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1997-05-05</td>
<td>3</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1990-08-16</td>
<td>5</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4471</td>
<td>1999-12-01</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">4472</td>
<td>1998-12-05</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4473</td>
<td>1987-09-24</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">4474</td>
<td>1998-01-02</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4475</td>
<td>1988-07-27</td>
<td>1</td>
</tr>
</tbody>
</table>

<p>4476 rows × 2 columns</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="op">%%</span>sql</span>
<span id="cb27-2"><a href="#cb27-2"></a>SELECT birth_date, COUNT(courier_id) AS couriers_count</span>
<span id="cb27-3"><a href="#cb27-3"></a>FROM couriers</span>
<span id="cb27-4"><a href="#cb27-4"></a>WHERE birth_date IS NOT NULL</span>
<span id="cb27-5"><a href="#cb27-5"></a>GROUP BY birth_date</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="14">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">birth_date</th>
<th data-quarto-table-cell-role="th">couriers_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1981-06-11</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1991-06-27</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1994-05-04</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1999-06-02</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1998-12-22</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2169</td>
<td>1999-09-19</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2170</td>
<td>1990-06-23</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2171</td>
<td>1991-02-21</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2172</td>
<td>1990-06-04</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2173</td>
<td>1997-04-15</td>
<td>1</td>
</tr>
</tbody>
</table>

<p>2174 rows × 2 columns</p>
</div>
</div>
</div>
<p>У результаті ви отримаєте дві таблиці з унікальними датами і кількістю людей, що народилися у кожен з днів. Давайте їх об’єднаємо.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-06" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.6 </strong></span><br> За допомогою <code>FULL JOIN</code> об’єднайте по ключу <code>birth_date</code> таблиці, отримані в результаті вищезазначених запитів (тобто об’єднайте один з одним два підзапити). Не потрібно змінювати їх, просто додайте потрібний <code>JOIN</code>.</p>
<p>У результат включіть дві колонки з <code>birth_date</code> з обох таблиць. Ці дві колонки назвіть відповідно <code>users_birth_date</code> та <code>couriers_birth_date</code>. Також включіть у результат колонки з кількістю користувачів та кур’єрів - <code>users_count</code> та <code>couriers_count</code>.</p>
<p>Відсортуйте таблицю спочатку по колонці <code>users_birth_date</code> за зростанням, потім по колонці <code>couriers_birth_date</code> - теж за зростанням.</p>
<p>Поля в результуючій таблиці: <code>users_birth_date</code>, <code>users_count</code>, <code>couriers_birth_date</code>, <code>couriers_count</code></p>
<p>Після того як розв’яжете завдання, проаналізуйте результат. Зверніть увагу на пропущені значення у колонках з датами народження кур’єрів та користувачів. Чи підтвердилося наше припущення?</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="15">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a><span class="op">%%</span>sql</span>
<span id="cb29-2"><a href="#cb29-2"></a>WITH a AS (</span>
<span id="cb29-3"><a href="#cb29-3"></a>    SELECT birth_date, COUNT(user_id) AS users_count</span>
<span id="cb29-4"><a href="#cb29-4"></a>    FROM users</span>
<span id="cb29-5"><a href="#cb29-5"></a>    WHERE birth_date IS NOT NULL</span>
<span id="cb29-6"><a href="#cb29-6"></a>    GROUP BY birth_date</span>
<span id="cb29-7"><a href="#cb29-7"></a>    ),</span>
<span id="cb29-8"><a href="#cb29-8"></a>    b AS (</span>
<span id="cb29-9"><a href="#cb29-9"></a>    SELECT birth_date, COUNT(courier_id) AS couriers_count</span>
<span id="cb29-10"><a href="#cb29-10"></a>    FROM couriers</span>
<span id="cb29-11"><a href="#cb29-11"></a>    WHERE birth_date IS NOT NULL</span>
<span id="cb29-12"><a href="#cb29-12"></a>    GROUP BY birth_date</span>
<span id="cb29-13"><a href="#cb29-13"></a>    )</span>
<span id="cb29-14"><a href="#cb29-14"></a>    </span>
<span id="cb29-15"><a href="#cb29-15"></a>SELECT </span>
<span id="cb29-16"><a href="#cb29-16"></a>    a.birth_date AS users_birth_date,</span>
<span id="cb29-17"><a href="#cb29-17"></a>    a.users_count,</span>
<span id="cb29-18"><a href="#cb29-18"></a>    b.birth_date AS couriers_birth_date,</span>
<span id="cb29-19"><a href="#cb29-19"></a>    b.couriers_count</span>
<span id="cb29-20"><a href="#cb29-20"></a>FROM a</span>
<span id="cb29-21"><a href="#cb29-21"></a>FULL JOIN b on a.birth_date <span class="op">=</span> b.birth_date</span>
<span id="cb29-22"><a href="#cb29-22"></a>ORDER BY users_birth_date, couriers_birth_date</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">users_birth_date</th>
<th data-quarto-table-cell-role="th">users_count</th>
<th data-quarto-table-cell-role="th">couriers_birth_date</th>
<th data-quarto-table-cell-role="th">couriers_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1981-11-05</td>
<td>1.0</td>
<td>None</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1982-04-05</td>
<td>1.0</td>
<td>None</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1982-09-12</td>
<td>1.0</td>
<td>None</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1983-01-06</td>
<td>1.0</td>
<td>None</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1983-01-23</td>
<td>1.0</td>
<td>None</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4841</td>
<td>None</td>
<td>NaN</td>
<td>2005-09-13</td>
<td>1.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">4842</td>
<td>None</td>
<td>NaN</td>
<td>2005-10-28</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4843</td>
<td>None</td>
<td>NaN</td>
<td>2006-08-01</td>
<td>1.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">4844</td>
<td>None</td>
<td>NaN</td>
<td>2007-08-09</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4845</td>
<td>None</td>
<td>NaN</td>
<td>2007-12-10</td>
<td>1.0</td>
</tr>
</tbody>
</table>

<p>4846 rows × 4 columns</p>
</div>
</div>
</div>
<hr>
</section>
<section id="операції-над-множинами" class="level2 page-columns page-full" data-number="7.6">
<h2 data-number="7.6" class="anchored" data-anchor-id="операції-над-множинами"><span class="header-section-number">7.6</span> Операції над множинами</h2>
<p>Чудово. Запит із <code>FULL JOIN</code> ми начебто склали, але як нам тепер визначити, що кількість записів в отриманій таблиці збігається із загальним числом унікальних дат у двох таблицях — <code>users</code> та <code>couriers</code>? Адже саме стільки рядків ми й очікували отримати, правда?</p>
<p>Перевірити себе нам допоможуть операції з множинами. У мові SQL їх три:</p>
<ul>
<li><code>UNION</code></li>
<li><code>EXCEPT</code></li>
<li><code>INTERSECT</code></li>
</ul>
<p>Вони дозволяють комбінувати результати кількох запитів один з одним та отримувати один загальний результат. Причому саме комбінувати, а не об’єднувати, як це роблять джойни.</p>
<p>Цю різницю важливо розуміти: в операціях з множинами не відбувається суміщення стовпців з двох таблиць - база даних просто відбирає рядки з таблиць, що задовольняють типу операції, і додає їх до загального результату.</p>
<p>Операції над множинами мають наступний синтаксис:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">FROM</span> table_1</span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="kw">UNION</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="kw">FROM</span> table_2</span>
<span id="cb31-6"><a href="#cb31-6"></a></span>
<span id="cb31-7"><a href="#cb31-7"></a></span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="kw">FROM</span> table_1</span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="kw">EXCEPT</span></span>
<span id="cb31-11"><a href="#cb31-11"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="kw">FROM</span> table_2</span>
<span id="cb31-13"><a href="#cb31-13"></a></span>
<span id="cb31-14"><a href="#cb31-14"></a></span>
<span id="cb31-15"><a href="#cb31-15"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb31-16"><a href="#cb31-16"></a><span class="kw">FROM</span> table_1</span>
<span id="cb31-17"><a href="#cb31-17"></a><span class="kw">INTERSECT</span></span>
<span id="cb31-18"><a href="#cb31-18"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb31-19"><a href="#cb31-19"></a><span class="kw">FROM</span> table_2</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Операція <code>EXCEPT</code> повертає всі записи, які є у першому запиті, але відсутні у другому (різниця множин).</li>
<li>Операція <code>INTERSECT</code> повертає всі записи, які є і в першому, і в другому запиті (перетин множин).</li>
<li>Операція <code>UNION</code> поєднує записи із двох запитів в один загальний результат (об’єднання множин).</li>
</ul>
<p>При цьому за замовчанням ці операції виключають із результату рядки-дублікати. Щоб дублікати не виключалися із результату, необхідно після імені операції вказати ключове слово <code>ALL</code>. Наприклад, так:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="kw">FROM</span> table_1</span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="kw">SELECT</span> column_1, column_2</span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="kw">FROM</span> table_2</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Діаграми Венна для операцій над множинами виглядають зображено на <a href="#fig-sql-join-venn">рисунку&nbsp;<span>7.6</span></a>.</p>
<div id="fig-sql-join-venn" class="cell column-page-inset quarto-layout-panel" data-execution_count="16">
<figure class="figure">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 33.3%;justify-content: center;">
<div id="fig-sql-join-venn-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="sql_join_files/figure-html/fig-sql-join-venn-output-1.png" class="img-fluid figure-img" data-ref-parent="fig-sql-join-venn" width="511"></p>
<figcaption class="figure-caption">(a)</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 33.3%;justify-content: center;">
<div id="fig-sql-join-venn-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="sql_join_files/figure-html/fig-sql-join-venn-output-2.png" class="img-fluid figure-img" data-ref-parent="fig-sql-join-venn" width="511"></p>
<figcaption class="figure-caption">(b)</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 33.3%;justify-content: center;">
<div id="fig-sql-join-venn-3" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="sql_join_files/figure-html/fig-sql-join-venn-output-3.png" class="img-fluid figure-img" data-ref-parent="fig-sql-join-venn" width="511"></p>
<figcaption class="figure-caption">(c)</figcaption>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Рисунок&nbsp;7.6: Операції над множинами: діаграма Венна</figcaption><p></p>
</figure>
</div>
<p>Для роботи цих операцій необхідно, щоб виконувались такі умови:</p>
<ol type="1">
<li>У кожному запиті <code>SELECT</code> має бути однакова кількість стовпців.</li>
<li>Типи даних у стовпцях мають бути сумісні.</li>
</ol>
<p>При цьому кількість стовпців в операторі <code>SELECT</code> може бути будь-якою — головне, щоб вона була однаковою.</p>
<p>Наприклад, наступний запит поверне унікальні ID користувачів, які щось замовляли в нашому сервісі, але яких з якоїсь причини немає в таблиці <code>users</code>:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a><span class="op">%%</span>sql</span>
<span id="cb33-2"><a href="#cb33-2"></a>SELECT user_id</span>
<span id="cb33-3"><a href="#cb33-3"></a>FROM user_actions</span>
<span id="cb33-4"><a href="#cb33-4"></a>EXCEPT</span>
<span id="cb33-5"><a href="#cb33-5"></a>SELECT user_id</span>
<span id="cb33-6"><a href="#cb33-6"></a>FROM users</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="17">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>54</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>86</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>116</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>120</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1065</td>
<td>18352</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1066</td>
<td>12713</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1067</td>
<td>18246</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1068</td>
<td>18015</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1069</td>
<td>20398</td>
</tr>
</tbody>
</table>

<p>1070 rows × 1 columns</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Примітка
</div>
</div>
<div class="callout-body-container callout-body">
<p>Докладніше про операції над множинами можна прочитати у <a href="https://duckdb.org/docs/sql/query_syntax/setops.html">документації DuckDB</a>.</p>
<p>Про теорію множин можна почитати у <a href="https://uk.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D1%96%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B8%D0%BD">статті на Вікіпедії</a>.</p>
</div>
</div>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-07" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.7 </strong></span><br> Поєднайте два наступні запити один з одним так, щоб на виході вийшов набір унікальних дат із таблиць <code>users</code> та <code>couriers</code>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">SELECT</span> birth_date</span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="kw">FROM</span> users</span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="kw">WHERE</span> birth_date <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">SELECT</span> birth_date</span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">FROM</span> couriers</span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="kw">WHERE</span> birth_date <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Помістіть у підзапит набраний після об’єднання набір дат і порахуйте їх кількість. Назвіть колонку з числом дат <code>dates_count</code>.</p>
<p>Поле у результуючій таблиці: <code>dates_count</code></p>
<p>Після того, як вирішите задачу, порівняйте отримане число дат з кількістю рядків у таблиці, яку ми отримали в минулому завданні. Чи збіглися ці значення?</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="18">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a><span class="op">%%</span>sql</span>
<span id="cb37-2"><a href="#cb37-2"></a>WITH sub_union <span class="im">as</span> (</span>
<span id="cb37-3"><a href="#cb37-3"></a>    SELECT birth_date</span>
<span id="cb37-4"><a href="#cb37-4"></a>    FROM users</span>
<span id="cb37-5"><a href="#cb37-5"></a>    WHERE birth_date IS NOT NULL</span>
<span id="cb37-6"><a href="#cb37-6"></a>    UNION</span>
<span id="cb37-7"><a href="#cb37-7"></a>    SELECT birth_date</span>
<span id="cb37-8"><a href="#cb37-8"></a>    FROM couriers</span>
<span id="cb37-9"><a href="#cb37-9"></a>    WHERE birth_date IS NOT NULL</span>
<span id="cb37-10"><a href="#cb37-10"></a>    )</span>
<span id="cb37-11"><a href="#cb37-11"></a>    </span>
<span id="cb37-12"><a href="#cb37-12"></a>SELECT COUNT(DISTINCT birth_date) <span class="im">as</span> dates_count</span>
<span id="cb37-13"><a href="#cb37-13"></a>FROM sub_union</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">dates_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>4846</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<hr>
</section>
<section id="cross-join" class="level2" data-number="7.7">
<h2 data-number="7.7" class="anchored" data-anchor-id="cross-join"><span class="header-section-number">7.7</span> CROSS JOIN</h2>
<p>Насправді <code>CROSS JOIN</code> - це просто декартів добуток двох таблиць, тобто саме те, що відбувається на першому етапі решти джойнів. Важлива відмінність у синтаксисі <code>CROSS JOIN</code> полягає в тому, що для нього не потрібно вказувати умову для об’єднання:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">SELECT</span> column_1, column_2, <span class="op">..</span>.</span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="kw">FROM</span> table_1</span>
<span id="cb38-3"><a href="#cb38-3"></a>     <span class="kw">CROSS</span> <span class="kw">JOIN</span> table_2</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Той самий результат можна отримати за допомогою наступного запису:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">SELECT</span> column_1, column_2, <span class="op">..</span>.</span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="kw">FROM</span> table_1, table_2</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Розглянемо простий приклад:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">SELECT</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>    A.city <span class="kw">as</span> city,</span>
<span id="cb40-3"><a href="#cb40-3"></a>    B.country <span class="kw">as</span> country</span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="kw">FROM</span> table_A <span class="kw">as</span> A</span>
<span id="cb40-5"><a href="#cb40-5"></a>     <span class="kw">CROSS</span> <span class="kw">JOIN</span> table_B <span class="kw">as</span> B</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>За допомогою <code>CROSS JOIN</code> ми отримуємо всі можливі комбінації значень із першої та другої таблиці:</p>
<div id="tbl-panel" class="tbl-parent quarto-layout-panel anchored">
<div class="panel-caption table-caption">
<p>Таблиця&nbsp;7.5: Приклад роботи <code>FULL JOIN</code></p>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-A-cross" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-primary table-bordered small table">
<caption>(a) Таблиця A</caption>
<thead>
<tr class="header">
<th style="text-align: left;">city</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">London</td>
</tr>
<tr class="even">
<td style="text-align: left;">Kyiv</td>
</tr>
</tbody>
</table>
</div>
<div id="tbl-B-cross" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<table class="table-sm table-secondary table-bordered small table">
<caption>(b) Таблиця B</caption>
<thead>
<tr class="header">
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">UK</td>
</tr>
<tr class="even">
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Poland</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div id="tbl-C-cross" class="quarto-layout-cell quarto-layout-cell-subref anchored" data-ref-parent="tbl-panel" style="flex-basis: 100.0%;justify-content: center;">
<table class="table-sm table-success table-bordered small table">
<caption>(c) Таблиця C</caption>
<thead>
<tr class="header">
<th style="text-align: left;">city</th>
<th style="text-align: left;">country</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">London</td>
<td style="text-align: left;">UK</td>
</tr>
<tr class="even">
<td style="text-align: left;">London</td>
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="odd">
<td style="text-align: left;">London</td>
<td style="text-align: left;">Poland</td>
</tr>
<tr class="even">
<td style="text-align: left;">Kyiv</td>
<td style="text-align: left;">UK</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Kyiv</td>
<td style="text-align: left;">Ukraine</td>
</tr>
<tr class="even">
<td style="text-align: left;">Kyiv</td>
<td style="text-align: left;">Poland</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>А теперь давайте решим простую задачу.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-08" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.8 </strong></span><br> З таблиці <code>users</code> відберіть id <strong>перших 100</strong> користувачів (просто виберіть перші 100 записів, використовуючи простий <code>LIMIT</code>) і за допомогою <code>CROSS JOIN</code> поєднайте їх з усіма найменуваннями товарів з таблиці <code>products</code>. Виведіть дві колонки - ID користувача та найменування товару. Результат відсортуйте спочатку за зростанням id користувача, потім на ім’я товару — теж за зростанням.</p>
<p>Поля у результуючій таблиці: <code>user_id</code>, <code>name</code></p>
<p>Після того як вирішите задачу, подивіться скільки спочатку було рядків у кожній таблиці і порівняйте з тим, скільки їх вийшло після об’єднання.</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="19">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1"></a><span class="op">%%</span>sql</span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="cf">with</span> user_100 <span class="im">as</span> (</span>
<span id="cb41-3"><a href="#cb41-3"></a>    SELECT user_id</span>
<span id="cb41-4"><a href="#cb41-4"></a>    <span class="im">from</span> users</span>
<span id="cb41-5"><a href="#cb41-5"></a>    LIMIT <span class="dv">100</span></span>
<span id="cb41-6"><a href="#cb41-6"></a>    )</span>
<span id="cb41-7"><a href="#cb41-7"></a></span>
<span id="cb41-8"><a href="#cb41-8"></a>SELECT  user_100.user_id,</span>
<span id="cb41-9"><a href="#cb41-9"></a>        products.name</span>
<span id="cb41-10"><a href="#cb41-10"></a>FROM user_100</span>
<span id="cb41-11"><a href="#cb41-11"></a>CROSS JOIN products</span>
<span id="cb41-12"><a href="#cb41-12"></a>ORDER BY user_id, name</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="19">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id</th>
<th data-quarto-table-cell-role="th">name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>185</td>
<td>apple juice</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>185</td>
<td>apples</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>185</td>
<td>bagels</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>185</td>
<td>bananas</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>185</td>
<td>beef</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8695</td>
<td>21402</td>
<td>waffles</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">8696</td>
<td>21402</td>
<td>watermelon</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8697</td>
<td>21402</td>
<td>white chocolate</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">8698</td>
<td>21402</td>
<td>yogurt</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8699</td>
<td>21402</td>
<td>сowberry juice</td>
</tr>
</tbody>
</table>

<p>8700 rows × 2 columns</p>
</div>
</div>
</div>
<hr>
<p>Здається, ми розглянули достатньо прикладів об’єднання таблиць. Час переходити до практики!</p>
<p>Проведемо невелику аналітику нашого сервісу і порахуємо, скільки в середньому товарів замовляє кожен користувач.</p>
<p>Завдання може звучати досить абстрактно мовою бізнесу, але не переживайте! Вирішуватимемо її поетапно, поступово перекладаючи її на мову SQL.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-09" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.9 </strong></span><br> Спочатку об’єднайте таблиці <code>user_actions</code> і <code>orders</code> — це ви вже вмієте робити. Як ключ використовуйте поле <code>order_id</code>. Виведіть id користувачів та замовлень, а також список товарів у замовленні. Відсортуйте таблицю за id користувача за зростанням, потім за id замовлення теж за зростанням.</p>
<p>Додайте в запит оператор <code>LIMIT</code> та виведіть лише <strong>перші 1000 рядків</strong> результуючої таблиці.</p>
<p>Поля в результуючій таблиці: <code>user_id</code>, <code>order_id</code>, <code>product_ids</code></p>
<p><strong>Пояснення:</strong> перед тим, як об’єднувати таблиці, подумайте, який тип з’єднання можна використовувати. Спробуйте різні способи та порівняйте результати.</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="20">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a><span class="op">%%</span>sql</span>
<span id="cb43-2"><a href="#cb43-2"></a>SELECT  user_id,</span>
<span id="cb43-3"><a href="#cb43-3"></a>        order_id,</span>
<span id="cb43-4"><a href="#cb43-4"></a>        product_ids</span>
<span id="cb43-5"><a href="#cb43-5"></a>FROM user_actions</span>
<span id="cb43-6"><a href="#cb43-6"></a>LEFT JOIN orders using (order_id)</span>
<span id="cb43-7"><a href="#cb43-7"></a>ORDER BY user_id, order_id</span>
<span id="cb43-8"><a href="#cb43-8"></a>LIMIT <span class="dv">1000</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="20">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id</th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product_ids</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>1</td>
<td>[65, 28]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>4683</td>
<td>[1, 15, 40]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>22901</td>
<td>[65, 72, 83]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>23149</td>
<td>[6, 84, 32]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2</td>
<td>2</td>
<td>[35, 30, 42, 34]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">995</td>
<td>227</td>
<td>12572</td>
<td>[76, 47, 37, 31]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">996</td>
<td>227</td>
<td>12578</td>
<td>[58]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">997</td>
<td>227</td>
<td>23268</td>
<td>[74, 25, 67]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">998</td>
<td>227</td>
<td>25873</td>
<td>[74, 72, 46]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">999</td>
<td>227</td>
<td>25885</td>
<td>[40, 58, 83]</td>
</tr>
</tbody>
</table>

<p>1000 rows × 3 columns</p>
</div>
</div>
</div>
<hr>
<p>Тепер трохи уточнимо наш запит, оскільки нас цікавлять не всі замовлення з таблиці <code>user_actions</code>, а лише ті, які не були скасовані користувачами, причому унікальні.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-10" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.10 </strong></span><br> Знову об’єднайте таблиці <code>user_actions</code> та <code>orders</code>, але тепер залиште лише унікальні нескасовані замовлення (ми робили схожий запит у <a href="sql_subquery.html#exr-sql-subquery-07">завданні&nbsp;<span>6.7</span></a>). Інші умови завдання ті самі: вивести ID користувачів та замовлень, а також список товарів у замовленні. Відсортуйте таблицю за id користувача за зростанням, потім за id замовлення теж за зростанням.</p>
<p>Додайте в запит оператор <code>LIMIT</code> та виведіть лише <strong>перші 1000 рядків</strong> результуючої таблиці.</p>
<p>Поля в результуючій таблиці: <code>user_id</code>, <code>order_id</code>, <code>product_ids</code></p>
</div>
</div>
</div>
<div class="cell" data-execution_count="21">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a><span class="op">%%</span>sql</span>
<span id="cb45-2"><a href="#cb45-2"></a>SELECT  user_id,</span>
<span id="cb45-3"><a href="#cb45-3"></a>        order_id,</span>
<span id="cb45-4"><a href="#cb45-4"></a>        product_ids</span>
<span id="cb45-5"><a href="#cb45-5"></a>FROM user_actions</span>
<span id="cb45-6"><a href="#cb45-6"></a>LEFT JOIN orders using (order_id)</span>
<span id="cb45-7"><a href="#cb45-7"></a>WHERE  order_id <span class="kw">in</span> (SELECT order_id</span>
<span id="cb45-8"><a href="#cb45-8"></a>                    FROM   courier_actions</span>
<span id="cb45-9"><a href="#cb45-9"></a>                    WHERE  action <span class="op">=</span> <span class="st">'deliver_order'</span>)</span>
<span id="cb45-10"><a href="#cb45-10"></a>ORDER BY user_id, order_id</span>
<span id="cb45-11"><a href="#cb45-11"></a>LIMIT <span class="dv">1000</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="21">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id</th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product_ids</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>1</td>
<td>[65, 28]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>4683</td>
<td>[1, 15, 40]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>22901</td>
<td>[65, 72, 83]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>23149</td>
<td>[6, 84, 32]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2</td>
<td>2</td>
<td>[35, 30, 42, 34]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">995</td>
<td>248</td>
<td>13935</td>
<td>[75, 28, 86]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">996</td>
<td>248</td>
<td>15518</td>
<td>[67, 79, 63]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">997</td>
<td>249</td>
<td>287</td>
<td>[26, 74, 53, 23]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">998</td>
<td>249</td>
<td>758</td>
<td>[45, 57, 78]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">999</td>
<td>249</td>
<td>7347</td>
<td>[30, 14, 6, 9]</td>
</tr>
</tbody>
</table>

<p>1000 rows × 3 columns</p>
</div>
</div>
</div>
<hr>
<p>Здається, все готове для того, щоб для кожного користувача порахувати середню кількість товарів у замовленні.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-11" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.11 </strong></span><br> Використовуючи запит із попереднього завдання, порахуйте, скільки в середньому товарів замовляє кожен користувач. Виведіть id користувача та середню кількість товарів у замовленні. Середнє значення округліть до двох знаків після коми. Колонку обчисленими значеннями назвіть <code>avg_order_size</code>. Результат виконання запиту відсортуйте за зростанням ID користувача.</p>
<p>Додайте в запит оператор <code>LIMIT</code> та виведіть лише <strong>перші 1000 рядків</strong> результуючої таблиці.</p>
<p>Поля у результуючій таблиці: <code>user_id</code>, <code>avg_order_size</code></p>
<p><strong>Пояснення:</strong> для вирішення вам знадобиться функція <code>array_length</code>. Ми розглядали її у <a href="sql_agg.html#exr-sql-agg-09">завданні&nbsp;<span>4.9</span></a>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-14-contents" aria-controls="callout-14" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Підказка на випадок, якщо зовсім не виходить
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-14" class="callout-14-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Щоб вирішити завдання, достатньо взяти запит з минулого завдання, порахувати розмір нескасованих замовлень, а потім зробити групування за користувачами і для кожного з них порахувати середній розмір замовлення.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell" data-execution_count="22">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a><span class="op">%%</span>sql</span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="cf">with</span> user_order_prod <span class="im">as</span> (</span>
<span id="cb47-3"><a href="#cb47-3"></a>    SELECT  user_id,</span>
<span id="cb47-4"><a href="#cb47-4"></a>            order_id,</span>
<span id="cb47-5"><a href="#cb47-5"></a>            product_ids</span>
<span id="cb47-6"><a href="#cb47-6"></a>    FROM user_actions</span>
<span id="cb47-7"><a href="#cb47-7"></a>    LEFT JOIN orders using (order_id)</span>
<span id="cb47-8"><a href="#cb47-8"></a>    WHERE  order_id <span class="kw">in</span> (SELECT order_id</span>
<span id="cb47-9"><a href="#cb47-9"></a>                    FROM   courier_actions</span>
<span id="cb47-10"><a href="#cb47-10"></a>                    WHERE  action <span class="op">=</span> <span class="st">'deliver_order'</span>)</span>
<span id="cb47-11"><a href="#cb47-11"></a>    )</span>
<span id="cb47-12"><a href="#cb47-12"></a>    </span>
<span id="cb47-13"><a href="#cb47-13"></a>SELECT  user_id,</span>
<span id="cb47-14"><a href="#cb47-14"></a>        ROUND(AVG(array_length(product_ids, <span class="dv">1</span>)), <span class="dv">2</span>) <span class="im">as</span> avg_order_size</span>
<span id="cb47-15"><a href="#cb47-15"></a>FROM user_order_prod</span>
<span id="cb47-16"><a href="#cb47-16"></a>GROUP BY user_id</span>
<span id="cb47-17"><a href="#cb47-17"></a>ORDER BY user_id</span>
<span id="cb47-18"><a href="#cb47-18"></a>LIMIT <span class="dv">1000</span></span>
<span id="cb47-19"><a href="#cb47-19"></a></span>
<span id="cb47-20"><a href="#cb47-20"></a><span class="op">--</span> або</span>
<span id="cb47-21"><a href="#cb47-21"></a><span class="op">--</span> SELECT user_id,</span>
<span id="cb47-22"><a href="#cb47-22"></a><span class="op">--</span>        <span class="bu">round</span>(avg(array_length(product_ids, <span class="dv">1</span>)), <span class="dv">2</span>) <span class="im">as</span> avg_order_size</span>
<span id="cb47-23"><a href="#cb47-23"></a><span class="op">--</span> FROM   (SELECT user_id,</span>
<span id="cb47-24"><a href="#cb47-24"></a><span class="op">--</span>                order_id</span>
<span id="cb47-25"><a href="#cb47-25"></a><span class="op">--</span>         FROM   user_actions</span>
<span id="cb47-26"><a href="#cb47-26"></a><span class="op">--</span>         WHERE  order_id <span class="kw">not</span> <span class="kw">in</span> (SELECT order_id</span>
<span id="cb47-27"><a href="#cb47-27"></a><span class="op">--</span>                                 FROM   user_actions</span>
<span id="cb47-28"><a href="#cb47-28"></a><span class="op">--</span>                                 WHERE  action <span class="op">=</span> <span class="st">'cancel_order'</span>)) t1</span>
<span id="cb47-29"><a href="#cb47-29"></a><span class="op">--</span>     LEFT JOIN orders using(order_id)</span>
<span id="cb47-30"><a href="#cb47-30"></a><span class="op">--</span> GROUP BY user_id</span>
<span id="cb47-31"><a href="#cb47-31"></a><span class="op">--</span> ORDER BY user_id limit <span class="dv">1000</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="22">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id</th>
<th data-quarto-table-cell-role="th">avg_order_size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>2.75</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2</td>
<td>4.00</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>3</td>
<td>4.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>4</td>
<td>3.00</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>5</td>
<td>1.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">995</td>
<td>1001</td>
<td>2.71</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">996</td>
<td>1002</td>
<td>2.67</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">997</td>
<td>1003</td>
<td>3.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">998</td>
<td>1004</td>
<td>3.40</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">999</td>
<td>1005</td>
<td>2.00</td>
</tr>
</tbody>
</table>

<p>1000 rows × 2 columns</p>
</div>
</div>
</div>
<hr>
<p>А що якби ми захотіли зробити докладнішу аналітику і, наприклад, порахувати середню вартість замовлення (середній чек) кожного клієнта? Для цього нам би знадобилася інформація про вартість кожного окремого замовлення. Давайте проведемо такі розрахунки.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-12" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.12 </strong></span><br> Для початку до таблиці із замовленнями (<code>orders</code>) застосуйте функцію <code>unnest</code>, як ми робили <a href="sql_subquery.html#exr-sql-subquery-12">завданні&nbsp;<span>6.12</span></a>. Колонку із id товарів назвіть <code>product_id</code>. Потім до розширеної таблиці, що утворилася, за ключом <code>product_id</code> додайте інформацію про ціни на товари (з таблиці <code>products</code>). Повинна вийти таблиця із замовленнями, товарами всередині кожного замовлення та цінами на ці товари. Виведіть колонки з id замовлення, id товару та ціною товару. Результат відсортуйте спочатку за зростанням id замовлення, потім за зростанням id товару.</p>
<p>Додайте в запит оператор <code>LIMIT</code> та виведіть лише <strong>перші 1000 рядків</strong> результуючої таблиці.</p>
<p>Поля у результуючій таблиці: <code>order_id</code>, <code>product_id</code>, <code>price</code></p>
</div>
</div>
</div>
<div class="cell" data-execution_count="23">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a><span class="op">%%</span>sql</span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="cf">with</span> unnest_id <span class="im">as</span> (SELECT order_id,</span>
<span id="cb49-3"><a href="#cb49-3"></a>                          unnest(orders.product_ids) <span class="im">as</span> product_id</span>
<span id="cb49-4"><a href="#cb49-4"></a>                   FROM   orders)</span>
<span id="cb49-5"><a href="#cb49-5"></a>SELECT order_id,</span>
<span id="cb49-6"><a href="#cb49-6"></a>       product_id,</span>
<span id="cb49-7"><a href="#cb49-7"></a>       products.price</span>
<span id="cb49-8"><a href="#cb49-8"></a>FROM   unnest_id</span>
<span id="cb49-9"><a href="#cb49-9"></a>    LEFT JOIN products using (product_id)</span>
<span id="cb49-10"><a href="#cb49-10"></a>ORDER BY order_id, product_id limit <span class="dv">1000</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="23">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product_id</th>
<th data-quarto-table-cell-role="th">price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>28</td>
<td>75.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>65</td>
<td>100.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>2</td>
<td>30</td>
<td>140.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>2</td>
<td>34</td>
<td>98.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2</td>
<td>35</td>
<td>90.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">995</td>
<td>299</td>
<td>83</td>
<td>55.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">996</td>
<td>299</td>
<td>87</td>
<td>398.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">997</td>
<td>300</td>
<td>57</td>
<td>450.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">998</td>
<td>300</td>
<td>67</td>
<td>30.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">999</td>
<td>301</td>
<td>1</td>
<td>150.0</td>
</tr>
</tbody>
</table>

<p>1000 rows × 3 columns</p>
</div>
</div>
</div>
<hr>
<p>Маючи таблицю із замовленнями, що містить список товарів та їх ціни, тепер можна легко порахувати вартість кожного замовлення.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-13" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.13 </strong></span><br> Використовуючи запит із <a href="#exr-sql-join-12">завдання&nbsp;<span>7.12</span></a>, розрахуйте сумарну вартість кожного замовлення. Виведіть колонки з id замовлень та їх вартістю. Колонку із вартістю замовлення назвіть <code>order_price</code>. Результат відсортуйте за зростанням id замовлення.</p>
<p>Додайте в запит оператор <code>LIMIT</code> та виведіть лише <strong>перші 1000 рядків</strong> результуючої таблиці.</p>
<p>Поля у результуючій таблиці: <code>order_id</code>, <code>order_price</code></p>
</div>
</div>
</div>
<div class="cell" data-execution_count="24">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a><span class="op">%%</span>sql</span>
<span id="cb51-2"><a href="#cb51-2"></a>SELECT order_id,</span>
<span id="cb51-3"><a href="#cb51-3"></a>       <span class="bu">sum</span>(price) <span class="im">as</span> order_price</span>
<span id="cb51-4"><a href="#cb51-4"></a>FROM   (SELECT order_id,</span>
<span id="cb51-5"><a href="#cb51-5"></a>               product_ids,</span>
<span id="cb51-6"><a href="#cb51-6"></a>               unnest(product_ids) <span class="im">as</span> product_id</span>
<span id="cb51-7"><a href="#cb51-7"></a>        FROM   orders) t1</span>
<span id="cb51-8"><a href="#cb51-8"></a>    LEFT JOIN products using(product_id)</span>
<span id="cb51-9"><a href="#cb51-9"></a>GROUP BY order_id</span>
<span id="cb51-10"><a href="#cb51-10"></a>ORDER BY order_id limit <span class="dv">1000</span></span>
<span id="cb51-11"><a href="#cb51-11"></a></span>
<span id="cb51-12"><a href="#cb51-12"></a><span class="op">--</span> або</span>
<span id="cb51-13"><a href="#cb51-13"></a><span class="op">--</span> <span class="cf">with</span>    unnest_id <span class="im">as</span> (</span>
<span id="cb51-14"><a href="#cb51-14"></a><span class="op">--</span>             SELECT  order_id,</span>
<span id="cb51-15"><a href="#cb51-15"></a><span class="op">--</span>                     unnest(orders.product_ids) <span class="im">as</span> product_id</span>
<span id="cb51-16"><a href="#cb51-16"></a><span class="op">--</span>             FROM   orders</span>
<span id="cb51-17"><a href="#cb51-17"></a><span class="op">--</span>         ),</span>
<span id="cb51-18"><a href="#cb51-18"></a><span class="op">--</span>         price_tbl <span class="im">as</span> (</span>
<span id="cb51-19"><a href="#cb51-19"></a><span class="op">--</span>             SELECT  order_id,</span>
<span id="cb51-20"><a href="#cb51-20"></a><span class="op">--</span>                     product_id,</span>
<span id="cb51-21"><a href="#cb51-21"></a><span class="op">--</span>                     products.price</span>
<span id="cb51-22"><a href="#cb51-22"></a><span class="op">--</span>             FROM   unnest_id</span>
<span id="cb51-23"><a href="#cb51-23"></a><span class="op">--</span>             LEFT JOIN products using (product_id)</span>
<span id="cb51-24"><a href="#cb51-24"></a><span class="op">--</span>                       )</span>
<span id="cb51-25"><a href="#cb51-25"></a>        </span>
<span id="cb51-26"><a href="#cb51-26"></a><span class="op">--</span> SELECT  order_id,</span>
<span id="cb51-27"><a href="#cb51-27"></a><span class="op">--</span>         <span class="bu">sum</span>(price) <span class="im">as</span> order_price</span>
<span id="cb51-28"><a href="#cb51-28"></a><span class="op">--</span> FROM price_tbl</span>
<span id="cb51-29"><a href="#cb51-29"></a><span class="op">--</span> GROUP BY order_id</span>
<span id="cb51-30"><a href="#cb51-30"></a><span class="op">--</span> ORDER BY order_id</span>
<span id="cb51-31"><a href="#cb51-31"></a><span class="op">--</span> LIMIT <span class="dv">1000</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="24">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">order_price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>175.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2</td>
<td>394.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>3</td>
<td>493.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>4</td>
<td>156.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>5</td>
<td>51.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">995</td>
<td>996</td>
<td>295.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">996</td>
<td>997</td>
<td>150.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">997</td>
<td>998</td>
<td>358.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">998</td>
<td>999</td>
<td>289.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">999</td>
<td>1000</td>
<td>69.0</td>
</tr>
</tbody>
</table>

<p>1000 rows × 2 columns</p>
</div>
</div>
</div>
<hr>
<p>Ось тепер у нас є все необхідне, щоб зробити наш перший серйозний аналітичний запит і порахувати різні метрики користувача!</p>
<p>Давайте об’єднаємо в один запит дані про кількість товарів на замовлення наших користувачів з інформацією про вартість кожного замовлення, а потім розрахуємо кілька корисних показників.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-14" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.14 </strong></span><br> Використовуючи результати попередніх завдань (<a href="#exr-sql-join-13">завд.&nbsp;<span>7.13</span></a> та <a href="#exr-sql-join-11">завд.&nbsp;<span>7.11</span></a>), напишіть запит для отримання інформації для кожного користувача:</p>
<ul>
<li>загальна кількість замовлень - колонку назвіть <code>orders_count</code></li>
<li>середня кількість товарів у замовленні — <code>avg_order_size</code></li>
<li>сумарну вартість усіх покупок - <code>sum_order_value</code></li>
<li>середня вартість замовлення - <code>avg_order_value</code></li>
<li>мінімальну вартість замовлення - <code>min_order_value</code></li>
<li>максимальну вартість замовлення - <code>max_order_value</code></li>
</ul>
<p>Отриманий результат відсортуйте за зростанням id користувача.</p>
<p>Додайте в запит оператор <code>LIMIT</code> та виведіть лише <strong>перші 1000 рядків</strong> результуючої таблиці.</p>
<p>Пам’ятайте, що в розрахунках ми, як і раніше, враховуємо лише нескасовані замовлення. При розрахунку середніх значень округляйте їх <strong>до двох знаків</strong> після коми.</p>
<p>Поля в результуючій таблиці: <code>user_id</code>, <code>orders_count</code>, <code>avg_order_size</code>, <code>sum_order_value</code>, <code>avg_order_value</code>, <code>min_order_value</code>, <code>max_order_value</code></p>
</div>
</div>
</div>
<div class="cell" data-execution_count="25">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a><span class="op">%%</span>sql</span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="cf">with</span>    unnest_id <span class="im">as</span> (</span>
<span id="cb53-3"><a href="#cb53-3"></a>            SELECT  order_id,</span>
<span id="cb53-4"><a href="#cb53-4"></a>                    unnest(orders.product_ids) <span class="im">as</span> product_id</span>
<span id="cb53-5"><a href="#cb53-5"></a>            FROM   orders</span>
<span id="cb53-6"><a href="#cb53-6"></a>            ),</span>
<span id="cb53-7"><a href="#cb53-7"></a>        price_tbl <span class="im">as</span> (</span>
<span id="cb53-8"><a href="#cb53-8"></a>            SELECT  order_id,</span>
<span id="cb53-9"><a href="#cb53-9"></a>                    product_id,</span>
<span id="cb53-10"><a href="#cb53-10"></a>                    products.price</span>
<span id="cb53-11"><a href="#cb53-11"></a>            FROM   unnest_id</span>
<span id="cb53-12"><a href="#cb53-12"></a>            LEFT JOIN products using (product_id)</span>
<span id="cb53-13"><a href="#cb53-13"></a>            ),</span>
<span id="cb53-14"><a href="#cb53-14"></a>        user_order_prod <span class="im">as</span> (</span>
<span id="cb53-15"><a href="#cb53-15"></a>            SELECT  user_id,</span>
<span id="cb53-16"><a href="#cb53-16"></a>                    order_id,</span>
<span id="cb53-17"><a href="#cb53-17"></a>                    product_ids</span>
<span id="cb53-18"><a href="#cb53-18"></a>            FROM   user_actions</span>
<span id="cb53-19"><a href="#cb53-19"></a>            LEFT JOIN orders using (order_id)</span>
<span id="cb53-20"><a href="#cb53-20"></a>            WHERE  order_id <span class="kw">in</span> (</span>
<span id="cb53-21"><a href="#cb53-21"></a>                SELECT order_id</span>
<span id="cb53-22"><a href="#cb53-22"></a>                FROM   courier_actions</span>
<span id="cb53-23"><a href="#cb53-23"></a>                WHERE  action <span class="op">=</span> <span class="st">'deliver_order'</span>)</span>
<span id="cb53-24"><a href="#cb53-24"></a>            ),</span>
<span id="cb53-25"><a href="#cb53-25"></a>        order_size <span class="im">as</span> (</span>
<span id="cb53-26"><a href="#cb53-26"></a>            SELECT user_id,</span>
<span id="cb53-27"><a href="#cb53-27"></a>                    order_id,</span>
<span id="cb53-28"><a href="#cb53-28"></a>                    <span class="bu">round</span>(avg(array_length(product_ids, <span class="dv">1</span>)), <span class="dv">2</span>) <span class="im">as</span> avg_order_size</span>
<span id="cb53-29"><a href="#cb53-29"></a>            FROM   user_order_prod</span>
<span id="cb53-30"><a href="#cb53-30"></a>            GROUP BY user_id, order_id</span>
<span id="cb53-31"><a href="#cb53-31"></a>            ),</span>
<span id="cb53-32"><a href="#cb53-32"></a>        order_price <span class="im">as</span> (</span>
<span id="cb53-33"><a href="#cb53-33"></a>            SELECT  order_id,</span>
<span id="cb53-34"><a href="#cb53-34"></a>                    <span class="bu">sum</span>(price) <span class="im">as</span> order_price</span>
<span id="cb53-35"><a href="#cb53-35"></a>            FROM   price_tbl</span>
<span id="cb53-36"><a href="#cb53-36"></a>            GROUP BY order_id</span>
<span id="cb53-37"><a href="#cb53-37"></a>            )</span>
<span id="cb53-38"><a href="#cb53-38"></a>            </span>
<span id="cb53-39"><a href="#cb53-39"></a>SELECT  user_id,</span>
<span id="cb53-40"><a href="#cb53-40"></a>        COUNT(user_id) <span class="im">as</span> orders_count,</span>
<span id="cb53-41"><a href="#cb53-41"></a>        ROUND(AVG(avg_order_size), <span class="dv">2</span>) <span class="im">as</span> avg_order_size,</span>
<span id="cb53-42"><a href="#cb53-42"></a>        SUM(order_price) <span class="im">as</span> sum_order_value,</span>
<span id="cb53-43"><a href="#cb53-43"></a>        ROUND(AVG(order_price), <span class="dv">2</span>) <span class="im">as</span> avg_order_value,</span>
<span id="cb53-44"><a href="#cb53-44"></a>        MIN(order_price) <span class="im">as</span> min_order_value,</span>
<span id="cb53-45"><a href="#cb53-45"></a>        MAX(order_price) <span class="im">as</span> max_order_value</span>
<span id="cb53-46"><a href="#cb53-46"></a>FROM order_size</span>
<span id="cb53-47"><a href="#cb53-47"></a>LEFT JOIN order_price using (order_id)</span>
<span id="cb53-48"><a href="#cb53-48"></a>GROUP BY user_id</span>
<span id="cb53-49"><a href="#cb53-49"></a>ORDER BY user_id</span>
<span id="cb53-50"><a href="#cb53-50"></a>LIMIT <span class="dv">1000</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="25">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">user_id</th>
<th data-quarto-table-cell-role="th">orders_count</th>
<th data-quarto-table-cell-role="th">avg_order_size</th>
<th data-quarto-table-cell-role="th">sum_order_value</th>
<th data-quarto-table-cell-role="th">avg_order_value</th>
<th data-quarto-table-cell-role="th">min_order_value</th>
<th data-quarto-table-cell-role="th">max_order_value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>4</td>
<td>2.75</td>
<td>1206.0</td>
<td>301.50</td>
<td>170.0</td>
<td>640.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2</td>
<td>2</td>
<td>4.00</td>
<td>590.0</td>
<td>295.00</td>
<td>196.0</td>
<td>394.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>3</td>
<td>4</td>
<td>4.00</td>
<td>2154.0</td>
<td>538.50</td>
<td>336.0</td>
<td>772.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>4</td>
<td>2</td>
<td>3.00</td>
<td>329.0</td>
<td>164.50</td>
<td>156.0</td>
<td>173.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>5</td>
<td>1</td>
<td>1.00</td>
<td>51.0</td>
<td>51.00</td>
<td>51.0</td>
<td>51.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">995</td>
<td>1001</td>
<td>7</td>
<td>2.71</td>
<td>2376.0</td>
<td>339.43</td>
<td>60.0</td>
<td>596.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">996</td>
<td>1002</td>
<td>3</td>
<td>2.67</td>
<td>1365.0</td>
<td>455.00</td>
<td>75.0</td>
<td>665.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">997</td>
<td>1003</td>
<td>1</td>
<td>3.00</td>
<td>200.0</td>
<td>200.00</td>
<td>200.0</td>
<td>200.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">998</td>
<td>1004</td>
<td>5</td>
<td>3.40</td>
<td>1906.0</td>
<td>381.20</td>
<td>245.0</td>
<td>498.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">999</td>
<td>1005</td>
<td>1</td>
<td>2.00</td>
<td>94.0</td>
<td>94.00</td>
<td>94.0</td>
<td>94.0</td>
</tr>
</tbody>
</table>

<p>1000 rows × 7 columns</p>
</div>
</div>
</div>
<hr>
<p>З великим завданням ми впоралися – тепер давайте вирішимо кілька додаткових завдань на закріплення нових знань.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-15" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.15 </strong></span><br> За таблицями <code>courier_actions</code>, <code>orders</code> та <code>products</code> визначте <strong>10 найпопулярніших товарів, доставлених у вересні 2022 року</strong>. Найпопулярнішими товарами вважатимемо ті, що зустрічалися в замовленнях найчастіше. Якщо товар зустрічається в одному замовленні кілька разів (було куплено кілька одиниць товару), то при підрахунку враховуємо лише одну одиницю товару. Виведіть найменування товарів та скільки разів вони зустрічалися в замовленнях. Нову колонку з кількістю покупок товару назвіть <code>times_purchased</code>.</p>
<p>Поля у результуючій таблиці: <code>name</code>, <code>times_purchased</code></p>
</div>
</div>
</div>
<div class="cell" data-execution_count="26">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a><span class="op">%%</span>sql</span>
<span id="cb55-2"><a href="#cb55-2"></a>SELECT name,</span>
<span id="cb55-3"><a href="#cb55-3"></a>       count(product_id) <span class="im">as</span> times_purchased</span>
<span id="cb55-4"><a href="#cb55-4"></a>FROM   (SELECT order_id,</span>
<span id="cb55-5"><a href="#cb55-5"></a>               product_id,</span>
<span id="cb55-6"><a href="#cb55-6"></a>               name</span>
<span id="cb55-7"><a href="#cb55-7"></a>        FROM   (SELECT DISTINCT order_id,</span>
<span id="cb55-8"><a href="#cb55-8"></a>                                unnest(product_ids) <span class="im">as</span> product_id</span>
<span id="cb55-9"><a href="#cb55-9"></a>                FROM   orders</span>
<span id="cb55-10"><a href="#cb55-10"></a>                    LEFT JOIN courier_actions using (order_id)</span>
<span id="cb55-11"><a href="#cb55-11"></a>                WHERE  action <span class="op">=</span> <span class="st">'deliver_order'</span></span>
<span id="cb55-12"><a href="#cb55-12"></a>                   <span class="kw">and</span> date_part(<span class="st">'month'</span>, time) <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb55-13"><a href="#cb55-13"></a>                   <span class="kw">and</span> date_part(<span class="st">'year'</span>, time) <span class="op">=</span> <span class="dv">2022</span>) t1</span>
<span id="cb55-14"><a href="#cb55-14"></a>            LEFT JOIN products using (product_id)) t2</span>
<span id="cb55-15"><a href="#cb55-15"></a>GROUP BY name</span>
<span id="cb55-16"><a href="#cb55-16"></a>ORDER BY times_purchased desc limit <span class="dv">10</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="26">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">name</th>
<th data-quarto-table-cell-role="th">times_purchased</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>bananas</td>
<td>2632</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>pasta</td>
<td>2623</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>long loaf</td>
<td>2622</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>sugar</td>
<td>2617</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>bread</td>
<td>2605</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>chicken</td>
<td>2585</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>black tea bags</td>
<td>2581</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>milk</td>
<td>2564</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>instant coffee</td>
<td>2460</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>apple juice</td>
<td>2373</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<hr>
<p>Раніше ми вважали рахували скасованих замовлень (<code>cancel_rate</code>) для кожного користувача. Тепер у нашому розпорядженні є всі необхідні знання, щоб порахувати цей показник у розрізі статі.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-16" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.16 </strong></span><br> Візьміть за основу запит із <a href="sql_groupby.html#exr-sql-groupby-11">завдання&nbsp;<span>5.16</span></a> і підтягніть до нього з таблиці <code>users</code> дані про поле користувачів таким чином, щоб усі користувачі з таблиці <code>users_actions</code> залишилися в результаті. Потім порахуйте середнє значення <code>cancel_rate</code> для кожної статі, заокругливши його <strong>до трьох знаків після ком</strong>и. Колонку з порахованим середнім значенням назвіть <code>avg_cancel_rate</code>.</p>
<p>Пам’ятайте про відсутність інформації про поле деяких користувачів після об’єднання таблиць, тому що не всі користувачі таблиці <code>user_action</code> є в таблиці users. Для цієї групи також порахуйте <code>cancel_rate</code> і в результуючій таблиці для порожнього значення в колонці з підлогою вкажіть <strong>‘unknown’</strong> (без лапок). Можливо, для цього доведеться згадати, як працює <code>COALESCE</code>.</p>
<p>Результат відсортуйте по колонці зі статтю користувача за зростанням.</p>
<p>Поля у результуючій таблиці: <code>sex</code>, <code>avg_cancel_rate</code></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-20-contents" aria-controls="callout-20" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Пояснення
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-20" class="callout-20-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Метрику <code>cancel_rate</code> у розрізі статі можна порахувати різними способами, у цій задачі пропонуємо наступний алгоритм:</p>
<ol type="1">
<li>Спочатку порахуйте <code>cancel_rate</code> для кожного користувача.</li>
<li>Потім додайте інформацію про поле користувачів.</li>
<li>Потім розрахуйте <code>avg_cancel_rate</code> для кожної статі та округліть значення до трьох знаків після коми.</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell" data-execution_count="27">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1"></a><span class="op">%%</span>sql</span>
<span id="cb56-2"><a href="#cb56-2"></a>SELECT coalesce(sex, <span class="st">'unknown'</span>) <span class="im">as</span> sex,</span>
<span id="cb56-3"><a href="#cb56-3"></a>       <span class="bu">round</span>(avg(cancel_rate), <span class="dv">3</span>) <span class="im">as</span> avg_cancel_rate</span>
<span id="cb56-4"><a href="#cb56-4"></a>FROM   (SELECT user_id,</span>
<span id="cb56-5"><a href="#cb56-5"></a>               sex,</span>
<span id="cb56-6"><a href="#cb56-6"></a>               count(distinct order_id) <span class="bu">filter</span> (WHERE action <span class="op">=</span> <span class="st">'cancel_order'</span>)::decimal <span class="op">/</span> count(distinct order_id) <span class="im">as</span> cancel_rate</span>
<span id="cb56-7"><a href="#cb56-7"></a>        FROM   user_actions</span>
<span id="cb56-8"><a href="#cb56-8"></a>            LEFT JOIN users using(user_id)</span>
<span id="cb56-9"><a href="#cb56-9"></a>        GROUP BY user_id, sex</span>
<span id="cb56-10"><a href="#cb56-10"></a>        ORDER BY cancel_rate desc) t</span>
<span id="cb56-11"><a href="#cb56-11"></a>GROUP BY sex</span>
<span id="cb56-12"><a href="#cb56-12"></a>ORDER BY sex</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="27">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">sex</th>
<th data-quarto-table-cell-role="th">avg_cancel_rate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>female</td>
<td>0.051</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>male</td>
<td>0.048</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>unknown</td>
<td>0.046</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-17" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.17 </strong></span><br> За таблицями <code>orders</code> та <code>courier_actions</code> визначте id десяти замовлень, які доставляли найдовше.</p>
<p>Поле у результуючій таблиці: <code>order_id</code></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-22-contents" aria-controls="callout-22" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Пояснення
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-22" class="callout-22-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Для розрахунку часу, витраченого на доставку замовлення, використовуйте інформацію про час доставки та час створення замовлення - з даними у форматі часу можна також проводити арифметичні операції (наприклад, обчислювати різницю між ними). Зауважте, що колонки з цими даними знаходяться в різних таблицях. Для визначення найдовших замовлень використовуйте оператор <code>LIMIT</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell" data-execution_count="28">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a><span class="op">%%</span>sql</span>
<span id="cb57-2"><a href="#cb57-2"></a>SELECT order_id</span>
<span id="cb57-3"><a href="#cb57-3"></a>FROM   (SELECT order_id,</span>
<span id="cb57-4"><a href="#cb57-4"></a>               time <span class="op">-</span> creation_time <span class="im">as</span> time_to_deliv</span>
<span id="cb57-5"><a href="#cb57-5"></a>        FROM   orders</span>
<span id="cb57-6"><a href="#cb57-6"></a>            LEFT JOIN courier_actions using (order_id)</span>
<span id="cb57-7"><a href="#cb57-7"></a>        WHERE  action <span class="op">=</span> <span class="st">'deliver_order'</span></span>
<span id="cb57-8"><a href="#cb57-8"></a>        ORDER BY time_to_deliv desc) <span class="im">as</span> t1 limit <span class="dv">10</span></span>
<span id="cb57-9"><a href="#cb57-9"></a></span>
<span id="cb57-10"><a href="#cb57-10"></a><span class="op">--</span> або</span>
<span id="cb57-11"><a href="#cb57-11"></a><span class="op">--</span> SELECT order_id</span>
<span id="cb57-12"><a href="#cb57-12"></a><span class="op">--</span> FROM   (SELECT order_id,</span>
<span id="cb57-13"><a href="#cb57-13"></a><span class="op">--</span>                time <span class="op">-</span> creation_time <span class="im">as</span> time_to_deliv</span>
<span id="cb57-14"><a href="#cb57-14"></a><span class="op">--</span>         FROM   orders</span>
<span id="cb57-15"><a href="#cb57-15"></a><span class="op">--</span>             LEFT JOIN courier_actions using (order_id)</span>
<span id="cb57-16"><a href="#cb57-16"></a><span class="op">--</span>         WHERE  action <span class="op">=</span> <span class="st">'deliver_order'</span></span>
<span id="cb57-17"><a href="#cb57-17"></a><span class="op">--</span>         ORDER BY time_to_deliv desc) <span class="im">as</span> t1 limit <span class="dv">10</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="28">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>22408</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>58491</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1155</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1464</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>4788</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>11064</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>12150</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>14647</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>18991</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>22907</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<hr>
</section>
<section id="збираємо-списки-array_agg" class="level2" data-number="7.8">
<h2 data-number="7.8" class="anchored" data-anchor-id="збираємо-списки-array_agg"><span class="header-section-number">7.8</span> Збираємо списки: <code>array_agg()</code></h2>
<p>Днями менеджер знову звернувся до вас із завданням: попросив зробити вивантаження з таблиці <code>orders</code> з усіма замовленнями та їх вмістом. З листування ви так і не зрозуміли, навіщо всі ці дані, але завдання зробили: натиснули <code>SELECT *</code> і відправили йому excel-файл із замовленнями. Наступного ранку з’ясувалося, що такі дані його не влаштовують, оскільки він не розуміє, що це за списки з наборами чисел. Справді, цей момент ви не врахували. Давайте виправлятися!</p>
<p><code>array_agg</code> — це просунута агрегатна функція, яка збирає всі значення в зазначеному стовпці в єдиний список (<code>ARRAY</code>). По суті <code>array_agg</code> - це операція, зворотна <code>unnest</code>, її синтаксис нічим не відрізняється від синтаксису інших агрегатних функцій:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb58-1"><a href="#cb58-1"></a><span class="kw">SELECT</span> column_1, array_agg(column_2) <span class="kw">AS</span> new_array</span>
<span id="cb58-2"><a href="#cb58-2"></a><span class="kw">FROM</span> <span class="kw">table</span></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="kw">GROUP</span> <span class="kw">BY</span> column_1</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Перед тим, як вирішувати завдання, спробуйте спочатку виконати просту вправу: розгорніть списки з id товарів, помістіть результат у підзапит, а потім відразу ж поверніть все назад у списки за допомогою <code>array_agg</code>. Алгоритм вирішення цього завдання приблизно такий самий.</p>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-18" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.18 </strong></span><br> Змініть списки з id товарів з таблиці <code>orders</code> на списки з найменуваннями товарів. Назви візьміть з таблиці <code>products</code>. Назвіть колонку з новими списками найменувань <code>product_names</code>.</p>
<p>Додайте в запит оператор <code>LIMIT</code> та виведіть лише <strong>перші 1000 рядків</strong> результуючої таблиці.</p>
<p>Поля у результуючій таблиці: <code>order_id</code>, <code>product_names</code></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-24-contents" aria-controls="callout-24" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Пояснення
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-24" class="callout-24-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Для вирішення задачі вам потрібно зробити <code>unnest</code> колонки <code>product_ids</code>, об’єднати проміжний результат з таблицею <code>products</code> для отримання найменувань товарів, а потім зробити групування з агрегацією в список найменувань.</p>
<p>Для того, щоб зробити агрегацію значень у колонці до списку, необхідно скористатися функцією <code>array_agg</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell" data-execution_count="29">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a><span class="op">%%</span>sql</span>
<span id="cb59-2"><a href="#cb59-2"></a>SELECT order_id,</span>
<span id="cb59-3"><a href="#cb59-3"></a>       array_agg(name) <span class="im">as</span> product_names</span>
<span id="cb59-4"><a href="#cb59-4"></a>FROM   (SELECT order_id,</span>
<span id="cb59-5"><a href="#cb59-5"></a>               unnest(product_ids) <span class="im">as</span> product_id</span>
<span id="cb59-6"><a href="#cb59-6"></a>        FROM   orders) t join products using(product_id)</span>
<span id="cb59-7"><a href="#cb59-7"></a>GROUP BY order_id limit <span class="dv">1000</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="29">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product_names</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>11</td>
<td>[tangerines, mayonnaise, pork]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>16</td>
<td>[apples, waffles, cookie]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>26</td>
<td>[salted fish, mutton, pears, black leaf tea]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>55</td>
<td>[bread, sour cream, kvass]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>67</td>
<td>[milk, black leaf tea, lollipops]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">995</td>
<td>18270</td>
<td>[bread, cookie, chicken]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">996</td>
<td>18311</td>
<td>[multifruit juice, salt, lemonade]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">997</td>
<td>18324</td>
<td>[black leaf tea, peas]</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">998</td>
<td>18335</td>
<td>[ivan-tea in bags, waffles, salt]</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">999</td>
<td>18340</td>
<td>[instant coffee, still water]</td>
</tr>
</tbody>
</table>

<p>1000 rows × 2 columns</p>
</div>
</div>
</div>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-19" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.19 </strong></span><br> З’ясуйте, хто замовляв та доставляв найбільші замовлення. Найбільшими вважають замовлення з найбільшою кількістю товарів.</p>
<p>Виведіть id замовлення, id користувача та id кур’єра. Також в окремих колонках вкажіть вік користувача та вік кур’єра. <strong>Вік виміряйте числом повних років</strong>, як ми робили раніше. Рахуйте його щодо останньої дати в таблиці <code>user_actions</code> як для користувачів, так і для кур’єрів. Колонки з віком назвіть <code>user_age</code> та <code>courier_age</code>. Результат відсортуйте за зростанням id замовлення.</p>
<p>Поля в результуючій таблиці: <code>order_id</code>, <code>user_id</code>, <code>user_age</code>, <code>courier_id</code>, <code>courier_age</code></p>
</div>
</div>
</div>
<div class="cell" data-execution_count="30">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a><span class="op">%%</span>sql</span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="cf">with</span> order_id_large_size <span class="im">as</span> (SELECT order_id</span>
<span id="cb61-3"><a href="#cb61-3"></a>                             FROM   orders</span>
<span id="cb61-4"><a href="#cb61-4"></a>                             WHERE  array_length(product_ids, <span class="dv">1</span>) <span class="op">=</span> (SELECT <span class="bu">max</span>(array_length(product_ids, <span class="dv">1</span>))</span>
<span id="cb61-5"><a href="#cb61-5"></a>                                                                    FROM   orders))</span>
<span id="cb61-6"><a href="#cb61-6"></a>SELECT DISTINCT order_id,</span>
<span id="cb61-7"><a href="#cb61-7"></a>                user_id,</span>
<span id="cb61-8"><a href="#cb61-8"></a>                date_part(<span class="st">'year'</span>, age((SELECT <span class="bu">max</span>(time)</span>
<span id="cb61-9"><a href="#cb61-9"></a>                       FROM   user_actions), users.birth_date))::integer <span class="im">as</span> user_age, courier_id, date_part(<span class="st">'year'</span>, age((SELECT <span class="bu">max</span>(time)</span>
<span id="cb61-10"><a href="#cb61-10"></a>                                                                                                  FROM   user_actions), couriers.birth_date))::integer <span class="im">as</span> courier_age</span>
<span id="cb61-11"><a href="#cb61-11"></a>FROM   (SELECT order_id,</span>
<span id="cb61-12"><a href="#cb61-12"></a>               user_id</span>
<span id="cb61-13"><a href="#cb61-13"></a>        FROM   user_actions</span>
<span id="cb61-14"><a href="#cb61-14"></a>        WHERE  order_id <span class="kw">in</span> (SELECT <span class="op">*</span></span>
<span id="cb61-15"><a href="#cb61-15"></a>                            FROM   order_id_large_size)) t1</span>
<span id="cb61-16"><a href="#cb61-16"></a>    LEFT JOIN (SELECT order_id,</span>
<span id="cb61-17"><a href="#cb61-17"></a>                      courier_id</span>
<span id="cb61-18"><a href="#cb61-18"></a>               FROM   courier_actions</span>
<span id="cb61-19"><a href="#cb61-19"></a>               WHERE  order_id <span class="kw">in</span> (SELECT <span class="op">*</span></span>
<span id="cb61-20"><a href="#cb61-20"></a>                                   FROM   order_id_large_size)) t2 using(order_id)</span>
<span id="cb61-21"><a href="#cb61-21"></a>    LEFT JOIN users using(user_id)</span>
<span id="cb61-22"><a href="#cb61-22"></a>    LEFT JOIN couriers using(courier_id)</span>
<span id="cb61-23"><a href="#cb61-23"></a>ORDER BY order_id</span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="30">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">user_id</th>
<th data-quarto-table-cell-role="th">user_age</th>
<th data-quarto-table-cell-role="th">courier_id</th>
<th data-quarto-table-cell-role="th">courier_age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>7949</td>
<td>3804</td>
<td>29</td>
<td>845</td>
<td>19</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>18853</td>
<td>5433</td>
<td>31</td>
<td>1537</td>
<td>33</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>29786</td>
<td>12728</td>
<td>33</td>
<td>431</td>
<td>26</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>49755</td>
<td>18622</td>
<td>29</td>
<td>1619</td>
<td>32</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>51414</td>
<td>17170</td>
<td>31</td>
<td>2564</td>
<td>27</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<hr>
</section>
<section id="self-join" class="level2" data-number="7.9">
<h2 data-number="7.9" class="anchored" data-anchor-id="self-join"><span class="header-section-number">7.9</span> SELF JOIN</h2>
<p>І насамкінець розглянемо ще один тип об’єднання таблиць, який теж потрібно знати. Це так званий <code>SELF JOIN</code>.</p>
<p><code>SELF JOIN</code> - не що інше, як об’єднання таблиці із самою собою. Так, така операція також можлива і, більше того, часто буває корисною.</p>
<p>Приєднати таблицю до себе можна з допомогою будь-якого розглянутого раніше типу джойна:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode numberSource sql number-lines code-with-copy"><code class="sourceCode sql"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="kw">FROM</span> <span class="kw">table</span> <span class="kw">JOIN</span> <span class="kw">table</span></span>
<span id="cb62-3"><a href="#cb62-3"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb62-4"><a href="#cb62-4"></a></span>
<span id="cb62-5"><a href="#cb62-5"></a></span>
<span id="cb62-6"><a href="#cb62-6"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb62-7"><a href="#cb62-7"></a><span class="kw">FROM</span> <span class="kw">table</span> <span class="kw">LEFT</span> <span class="kw">JOIN</span> <span class="kw">table</span></span>
<span id="cb62-8"><a href="#cb62-8"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb62-9"><a href="#cb62-9"></a></span>
<span id="cb62-10"><a href="#cb62-10"></a></span>
<span id="cb62-11"><a href="#cb62-11"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb62-12"><a href="#cb62-12"></a><span class="kw">FROM</span> <span class="kw">table</span> <span class="kw">FULL</span> <span class="kw">JOIN</span> <span class="kw">table</span></span>
<span id="cb62-13"><a href="#cb62-13"></a>     <span class="kw">ON</span> [condition]</span>
<span id="cb62-14"><a href="#cb62-14"></a></span>
<span id="cb62-15"><a href="#cb62-15"></a></span>
<span id="cb62-16"><a href="#cb62-16"></a><span class="kw">SELECT</span> <span class="op">..</span>.</span>
<span id="cb62-17"><a href="#cb62-17"></a><span class="kw">FROM</span> <span class="kw">table</span> <span class="kw">CROSS</span> <span class="kw">JOIN</span> <span class="kw">table</span></span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Завдання
</div>
</div>
<div class="callout-body-container callout-body">
<div id="exr-sql-join-20" class="theorem exercise">
<p><span class="theorem-title"><strong>Завдання 7.20 </strong></span><br> З’ясуйте, які пари товарів купують разом найчастіше.</p>
<p>Пари товарів сформуйте на основі таблиці із замовленнями. Скасовані замовлення не враховуйте. Як результат виведіть дві колонки - колонку з парами найменувань товарів і колонку зі значеннями, які показують, скільки разів конкретна пара зустрілася у замовленнях користувачів. Колонки назвіть відповідно <code>pair</code> та <code>count_pair</code>.</p>
<p>Пари товарів мають бути представлені у вигляді списків із двох найменувань. Пари товарів усередині списків мають бути відсортовані у порядку зростання найменування. Результат відсортуйте спочатку за зменшенням частоти зустрічі пари товарів у замовленнях, потім по колонці <code>pair</code> — за зростанням.</p>
<p>Поля у результуючій таблиці: <code>pair</code>, <code>count_pair</code></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-27-contents" aria-controls="callout-27" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Пояснення + підказка
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-27" class="callout-27-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>У цій задачі вам необхідно зробити <code>SELF JOIN</code>. Подумайте, яку таблицю потрібно приєднати до себе і заздалегідь обробіть дані. Для вирішення рекомендуємо скористатися табличними виразами. Також вам знадобляться <a href="https://duckdb.org/docs/sql/functions/nested.html">функції для роботи зі списками</a>. Ознайомтеся з прикладами документації та подумайте, що можна використовувати у своєму рішенні.</p>
<p>Завдання творче і може бути вирішене різними способами.</p>
<p>Для кожної пари товарів вам необхідно порахувати скільки разів вона зустрілася в замовленнях користувачів. Головна проблема полягає в тому, що при <code>SELF JOIN</code> кожен товар утворює пару з самим собою (<strong>«A-A»</strong>) і при цьому кожна пара зустрічається двічі (<strong>«A-B»</strong> та <strong>«B-A»</strong>). Суть завдання полягає в тому, щоб позбавитися цих двох проблем і отримати коректні розрахунки.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell" data-execution_count="31">
<details>
<summary>Рішення</summary>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode numberSource python code-overflow-scroll number-lines code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1"></a><span class="op">%%</span>sql</span>
<span id="cb63-2"><a href="#cb63-2"></a><span class="cf">with</span> main_table <span class="im">as</span> (SELECT DISTINCT order_id,</span>
<span id="cb63-3"><a href="#cb63-3"></a>                                    product_id,</span>
<span id="cb63-4"><a href="#cb63-4"></a>                                    name</span>
<span id="cb63-5"><a href="#cb63-5"></a>                    FROM   (SELECT order_id,</span>
<span id="cb63-6"><a href="#cb63-6"></a>                                   unnest(product_ids) <span class="im">as</span> product_id</span>
<span id="cb63-7"><a href="#cb63-7"></a>                            FROM   orders</span>
<span id="cb63-8"><a href="#cb63-8"></a>                            WHERE  order_id <span class="kw">not</span> <span class="kw">in</span> (SELECT order_id</span>
<span id="cb63-9"><a href="#cb63-9"></a>                                                    FROM   user_actions</span>
<span id="cb63-10"><a href="#cb63-10"></a>                                                    WHERE  action <span class="op">=</span> <span class="st">'cancel_order'</span>)</span>
<span id="cb63-11"><a href="#cb63-11"></a>                               <span class="kw">and</span> order_id <span class="kw">in</span> (SELECT order_id</span>
<span id="cb63-12"><a href="#cb63-12"></a>                                             FROM   user_actions</span>
<span id="cb63-13"><a href="#cb63-13"></a>                                             WHERE  action <span class="op">=</span> <span class="st">'create_order'</span>)) t join products using(product_id)</span>
<span id="cb63-14"><a href="#cb63-14"></a>                    ORDER BY order_id, name)</span>
<span id="cb63-15"><a href="#cb63-15"></a>SELECT pair,</span>
<span id="cb63-16"><a href="#cb63-16"></a>       count(order_id) <span class="im">as</span> count_pair</span>
<span id="cb63-17"><a href="#cb63-17"></a>FROM   (SELECT DISTINCT a.order_id,</span>
<span id="cb63-18"><a href="#cb63-18"></a>                        <span class="cf">case</span> when a.name <span class="op">&gt;</span> b.name then string_to_array(concat(b.name, <span class="st">'+'</span>, a.name), <span class="st">'+'</span>)</span>
<span id="cb63-19"><a href="#cb63-19"></a>                             <span class="cf">else</span> string_to_array(concat(a.name, <span class="st">'+'</span>, b.name), <span class="st">'+'</span>) end <span class="im">as</span> pair</span>
<span id="cb63-20"><a href="#cb63-20"></a>        FROM   main_table a join main_table b</span>
<span id="cb63-21"><a href="#cb63-21"></a>                ON a.order_id <span class="op">=</span> b.order_id <span class="kw">and</span></span>
<span id="cb63-22"><a href="#cb63-22"></a>                   a.name <span class="op">!=</span> b.name) t</span>
<span id="cb63-23"><a href="#cb63-23"></a>GROUP BY pair</span>
<span id="cb63-24"><a href="#cb63-24"></a>ORDER BY count_pair desc, pair</span>
<span id="cb63-25"><a href="#cb63-25"></a></span>
<span id="cb63-26"><a href="#cb63-26"></a><span class="op">--</span> або</span>
<span id="cb63-27"><a href="#cb63-27"></a><span class="op">--</span> <span class="cf">with</span> </span>
<span id="cb63-28"><a href="#cb63-28"></a><span class="op">--</span>     t <span class="im">as</span> (select order_id, </span>
<span id="cb63-29"><a href="#cb63-29"></a><span class="op">--</span>             unnest(product_ids) <span class="im">as</span> product_id <span class="im">from</span> orders</span>
<span id="cb63-30"><a href="#cb63-30"></a><span class="op">--</span>             left join user_actions using(order_id)</span>
<span id="cb63-31"><a href="#cb63-31"></a><span class="op">--</span>             where order_id NOT IN (SELECT order_id FROM user_actions WHERE action <span class="op">=</span> <span class="st">'cancel_order'</span>)</span>
<span id="cb63-32"><a href="#cb63-32"></a><span class="op">--</span>             ),</span>
<span id="cb63-33"><a href="#cb63-33"></a></span>
<span id="cb63-34"><a href="#cb63-34"></a><span class="op">--</span>     k <span class="im">as</span> (select order_id, t.product_id <span class="im">as</span> pr, t1.product_id <span class="im">as</span> pr1</span>
<span id="cb63-35"><a href="#cb63-35"></a><span class="op">--</span>             <span class="im">from</span> t</span>
<span id="cb63-36"><a href="#cb63-36"></a><span class="op">--</span>             join t <span class="im">as</span> t1 using(order_id)</span>
<span id="cb63-37"><a href="#cb63-37"></a><span class="op">--</span>             where t.product_id <span class="op">!=</span> t1.product_id),</span>
<span id="cb63-38"><a href="#cb63-38"></a><span class="op">--</span> </span>
<span id="cb63-39"><a href="#cb63-39"></a><span class="op">--</span>     p <span class="im">as</span> (select order_id, pr, pr1, name </span>
<span id="cb63-40"><a href="#cb63-40"></a><span class="op">--</span>             <span class="im">from</span> k</span>
<span id="cb63-41"><a href="#cb63-41"></a><span class="op">--</span>             left join products on pr <span class="op">=</span> products.product_id),</span>
<span id="cb63-42"><a href="#cb63-42"></a><span class="op">--</span> </span>
<span id="cb63-43"><a href="#cb63-43"></a><span class="op">--</span>     s <span class="im">as</span> (select order_id, p.name <span class="im">as</span> name, products.name <span class="im">as</span> name1</span>
<span id="cb63-44"><a href="#cb63-44"></a><span class="op">--</span>             <span class="im">from</span> p</span>
<span id="cb63-45"><a href="#cb63-45"></a><span class="op">--</span>             left join products on pr1 <span class="op">=</span> products.product_id),</span>
<span id="cb63-46"><a href="#cb63-46"></a><span class="op">--</span> </span>
<span id="cb63-47"><a href="#cb63-47"></a><span class="op">--</span>    l <span class="im">as</span> (select  distinct</span>
<span id="cb63-48"><a href="#cb63-48"></a><span class="op">--</span>                 order_id, </span>
<span id="cb63-49"><a href="#cb63-49"></a><span class="op">--</span>                 array_sort(array_cat(array[name], array[name1])) <span class="im">as</span> pair </span>
<span id="cb63-50"><a href="#cb63-50"></a><span class="op">--</span>             <span class="im">from</span> s)</span>
<span id="cb63-51"><a href="#cb63-51"></a></span>
<span id="cb63-52"><a href="#cb63-52"></a><span class="op">--</span> select pair, count(<span class="op">*</span>) <span class="im">as</span> count_pair <span class="im">from</span> l</span>
<span id="cb63-53"><a href="#cb63-53"></a><span class="op">--</span> group by  pair</span>
<span id="cb63-54"><a href="#cb63-54"></a><span class="op">--</span> order by count_pair desc, pair </span></code><button title="Копіювати" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Python\Python311\Lib\site-packages\sql\run.py:736: JupySQLDataFramePerformanceWarning:

It looks like you're using DuckDB with SQLAlchemy. For faster conversions, use  a DuckDB native connection. Docs: https://jupysql.ploomber.io/en/latest/integrations/duckdb.html. to suppress this warning, see: https://jupysql.ploomber.io/en/latest/tutorials/duckdb-native-sqlalchemy.html#supress-warnings
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="31">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">pair</th>
<th data-quarto-table-cell-role="th">count_pair</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>[bread, chicken]</td>
<td>249</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>[bread, sugar]</td>
<td>237</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>[black tea bags, coffee 3 in 1]</td>
<td>235</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>[bread, long loaf]</td>
<td>235</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>[chicken, sugar]</td>
<td>233</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">3735</td>
<td>[honey, sesame oil]</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3736</td>
<td>[jam, salted fish]</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">3737</td>
<td>[linseed oil, sesame oil]</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3738</td>
<td>[sesame oil, sprats]</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">3739</td>
<td>[dried fruits, tea mushroom]</td>
<td>1</td>
</tr>
</tbody>
</table>

<p>3740 rows × 2 columns</p>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Скопійовано!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Скопійовано!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./sql_subquery.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Підзапити</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./sql_window.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Віконні функції</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>