# Популярні питання

## Основи

### Що таке PEP-8?

**PEP** або **Python Enhancement Proposal** – це пропозиція щодо розвитку мови Python. Ці документи є механізмом для пропонування нових можливостей або для документування вже готових рішень, які увійшли до мови Python. 

**PEP-8** — це style guide того, як повинен бути оформлений код, написаний мовою Python, і яку повинні слідувати всі розробники, які пишуть цією мовою.

### Які типи даних є в Python? Або які типи даних є змінними, а які є незмінними?

Типи даних у Python можна розділити на змінні та незмінні. 

До незмінних можна віднести: рядки, байти, цілі числа, числа з плаваючою точкою, комплексні числа, булеві значення, none, картежі та frozenset. 

До змінюваних типів даних можна віднести списки, сети, словники, байт-масиви та memoryview.

| **Змінні**  | **Незмінні** |
|-------------|--------------|
| `str`       | `list`       |
| `bytes`     | `set`        |
| `int`       | `dict`       |
| `float`     | `bytearray`  |
| `complex`   | `memoryview` |
| `bool`      |              |
| `None`      |              |
| `tuple`     |              |
| `frozenset` |              |

### Що таке віртуальне оточення? Навіщо воно потрібне?

Уявімо ситуацію, що на одному комп'ютері нам потрібно запустити два Python-проекти, які використовують одну бібліотеку, тільки різних версій. Саме такі віртуальні оточення допомагають нам вирішити цей конфлікт. Коли ми використовуємо віртуальне оточення, ми створюємо щось на кшталт пісочниці, де ми ізолюємо локальний Python від глобального Python. Це дозволяє нам ставити різні бібліотеки локально, не впливаючи на Python, який встановлений глобально у нас на комп'ютері.

### Чи можна змінити елемент у кортежі, якщо кортеж незмінний тип даних?

Хоча по собі картеж — це незмінний тип даних, але може містити змінюване значення. Припустимо, у нас є картеж `a`, який містить список і одиницю. 

```{python}
a = ([], 1)
```

Хоча картеж і незмінний - це означає, що ми не можемо змінювати його структуру, але якщо він містить елементи, що змінюються, то ми можемо їх змінювати. Наприклад, якщо ми спробуємо додати до картежу третім елементом двійку, то ми отримаємо помилку, тому що картеж - це незмінний тип даних. 

```{python}
#| error: true

a[3] = 2
```

Але якщо ми візьмемо нульовий елемент, це список, і спробуємо додати до нього двійку в кінець, знову виведемо на екран наш картеж, то побачимо, що нам вдалося змінити нульовий елемент.

```{python}
a[0].append(2)
print(a)
```

Тобто картеж незмінний тип даних, змінювати структуру його не можна, але якщо є елементи, що змінюються всередині, то їх можна змінювати.

### Що таке List, Set та Dict comprehensions? Наведи приклад їхнього використання.

List, Set та Dict comprehensions – це скорочення для наступного запису:

```{python}
a = []

for i in range(5):
    a.append(i)

print(a)
```

Щоб отримати той самий результат, ми можемо скористатися List Comprehensions:

```{python}
l = [i for i in range(5)]
print(l)
```

Також у List, Set та Dict Comprehensions можна використовувати умови. Для цього потрібно після колекції або після генератора вказати ключове слово `if` і вказати умови, за якими ми вибиратимемо елементи, які вставлятимемо в цей список:

```{python}
# виведемо парні числа

l = [i for i in range(5) if i % 2 == 0]
print(l)
```

Різниця між List і Set Comprehension у тому, що в List Comprehension використовуються квадратні дужки, Set Comprehension використовуються круглі дужки:

```{python}
s = {i for i in range(5) if i % 2 == 0}
print(s)
```

Щоб отримати Dict Comprehension, у нас повинен бути тут не один елемент, а має бути два елементи. Тобто один для ключа, другий для значення. Ми також використовуємо фігурні дужки:

```{python}
d = {i: i ** 2 for i in range(5) if i % 2 == 0}
print(d)
```

В якості прикладів використання List Set та Dict Comprehension можна навести розпакування якихось колекцій, або якихось генераторів, або просто заміна якогось дуже простого циклу, коли це не заважає читабельності коду.

### Яка різниця між операторами `==` та `is`?

Оператор `==` порівнює два операнди за їх значеннями:

```{python}
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)
```

Оператор `is` перевіряє, що дві змінні, тобто `a` і `b` посилаються на один об'єкт. В даному випадку у нас `a` посилається на один список, `b` посилається на інший список, відповідно ми повинні отримати `false`:

```{python}
a = [1, 2, 3]
b = [1, 2, 3]

print(a is b)
```

Що буде, якщо `b` надамо не новий список, а передамо `a`? Ми отримаємо `true`, тому що і `a`, і `b` посилаються на той самий об'єкт:

```{python}
a = [1, 2, 3]
b = a

print(a is b)
```

### Що таке глибока (`deep`) та поверхнева (`shallow`) копія? Навіщо вони потрібні та як їх зробити?

Поверхнева копія копіює сам об'єкт. Всі внутрішні об'єкти вона не копіює, вони доступні за тими самими посиланнями. Глибока копія, мало того, що копіює зовнішній об'єкт, вона рекурсивно копіює всі внутрішні об'єкти в нову пам'ять. Якщо ми змінюємо новий об'єкт, то попередній стає незмінним.

Розглянемо приклад:

```{python}
a = [1, [2]]
b = a
b.append(3) # додаємо 3 до b
b[1].append(4) # додаємо 4 до списку, який знаходиться всередині b

print(a)
```

Оскільки змінні `a` і `b` посилаються на один і той самий об'єкт, то і `a` зміниться. Не завжди це та поведінка, яку ми очікуємо. Для цього у нас є два види копії, відповідно, глибока та поверхнева.

Найпростіший спосіб це імпортувати модуль `copy` і скористатися методом `copy()`. В такому випадку ми отримаємо поверхневу копію. Поверхнева копія створює копію самого об'єкта, але посилання на всі внутрішні об'єкти будуть збережені, вони не будуть скопійовані.

```{python}
import copy

a = [1, [2]]
b = copy.copy(a)
b.append(3)
b[1].append(4)

print(a)
```

Для створення глибокої копії ми можемо скористатися методом `deepcopy()`:

```{python}
import copy

a = [1, [2]]
b = copy.deepcopy(a)
b.append(3)
b[1].append(4)

print(a)
```

Якщо ж ми розглядаємо список, то існує багато способів, як ще можна створити поверхневу копію:

```{python}
a = [1, [2]]

b = list(a) # поверхнева копія через list()
b = a[:] # поверхнева копія через зріз
b = [i for i in a] # поверхнева копія через List Comprehension
b = a.copy() # поверхнева копія через вбудовану функцію copy()
```

### Як працюють оператори `and`, `or` та `not`? Що вони повертають?

Оператор `not` приводить свій операнд до типу `bool` і повертає його інверсію:

```{python}
# not

print(not [])
```

```{python}
# not

print(not {1, 2, 3})
```

Оператори `and` та `or` не приводять об'єкти до булевих значень, вони повертають самі об'єкти. 

Якщо перший операнд повертає `False`, то `and` поверне його:

```{python}
print([] and 123)
```

Якщо перший операнд повертає `True`, то `and` поверне другий операнд:

```{python}
print([1, 2, 3] and 123)
```

Якщо перший операнд повертає `True`, то `or` поверне його:

```{python}
print([1, 2, 3] or 123)
```

Якщо перший операнд повертає `False`, то `or` поверне другий операнд:

```{python}
print([] or 123)
```

### Як працює простір імен у Python? Або як працює правило LEGB (Local, Enclosing, Global, Built-in)?

Простір імен у Python працює за правилом LEGB. Це означає, що спочатку інтерпретатор шукає змінну в локальному просторі імен, потім в необов'язковому просторі імен зовнішньої функції, потім в глобальному просторі імен і, нарешті, в просторі імен вбудованих функцій.

Розглянемо приклад, в якому повертається локальна змінна `str`:

```{python}
str = 'global'

def outer():
    str = 'enclosing'
    
    def inner():
        str = 'local' # локальна змінна
        print(str)
    
    inner()

outer()
```

Якщо цієї змінної не має в локальному просторі імен, то інтерпретатор буде шукати її в зовнішньому просторі імен:

```{python}
str = 'global'

def outer():
    str = 'enclosing' # зовнішній простір імен
    
    def inner():
        print(str)
    
    inner()

outer()
```

Якщо цієї змінної не має в зовнішньому просторі імен, то інтерпретатор буде шукати її в глобальному просторі імен:

```{python}

str = 'global' # глобальний простір імен

def outer():

    def inner():
        print(str)
    
    inner()

outer()
```

```{python}
#| include: false

del str
```

Якщо цієї змінної не має в глобальному просторі імен, то інтерпретатор буде шукати її в просторі імен вбудованих функцій:

```{python}
def outer():

    def inner():
        print(str)
    
    inner()

outer()
```

Якщо ми спробуємо звернутися до змінної, якої немає ні в одному з просторів імен, то інтерпретатор викине помилку:

```{python}
#| error: true

def outer():
    def inner():
        print(variable) # змінна, якої немає ні в одному з просторів імен
    
    inner()

outer()
```

### Як працюють оператори `global` та `nonlocal`?

Розглянемо приклад:

```{python}
a = 1 # глобальна змінна

def outer():    # зовнішня функція
    b = 1       # змінна зовнішньої функції
    
    def inner():    # вкладена функція
        a = 2       # локальна змінна
        b = 2       # локальна змінна

    inner()             # виклик вкладеної функції
    print("a = ", a)    # виведення локальної змінної
    print("b = ", b)    # виведення змінної зовнішньої функції

outer() # виклик зовнішньої функції
```

Як бачимо з результату, змінні `a` та `b` використовуються відповідно до правила LEGB. Щоб змінити глобальну змінну `a` в локальній функції `inner`, потрібно використати оператор `global`, а для зміни змінної зовнішньої функції `b` в локальній функції `inner` потрібно використати оператор `nonlocal`:

```{python}
a = 1

def outer():
    b = 1
    
    def inner():
        global a # глобальна змінна
        a = 2

        nonlocal b # змінна зовнішньої функції
        b = 2

    inner()
    print("a = ", a)
    print("b = ", b)
```

### Чи знайомі тобі такі функції, як `map`, `filter`, `zip`? Наведи приклад їхнього використання.

- Функція `map()`може бути застосована до колекції, вона застосовує деяку функцію до кожного елемента нашої колекції:

```{python}
a = [i for i in range(6)]

b = map(lambda x: x ** 2, a)

print(list(b))
```

- Функція `filter()` може бути застосована до колекції, вона застосовує деяку функцію до кожного елемента нашої колекції і повертає лише ті елементи, для яких функція повертає `True`:

```{python}
a = [i for i in range(6)]

b = filter(lambda x: x % 2 == 0, a)

print(list(b))
```

- Функція `zip()` приймає декілька колекцій і повертає колекцію кортежів, в яких перший елемент - перший елемент першої колекції, другий елемент - другий елемент другої колекції і так до того моменту, поки не закінчаться елементи в одній з колекцій:

```{python}
a = [1, 2, 3]
b = [4, 5, 6, 7]
c = [8, 9]

for i in zip(a, b, c):
    print(i)
```

### Як оцінюється складність алгоритмів та чому? Що таке Big-O notation?

Алгоритмічна складність оцінюється в **Big-O notation**. 

Big-O notation – це метод оцінки, який визначає, як змінюються витрати виконання залежно від величини вхідних даних.

::: {.callout-note}
Шпаргалка з Big-O notation: [https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)
:::

```{python}
#| label: fig-big-o
#| fig-cap: Діаграма складності Big-O
#| echo: false

# Імпорт бібліотек
import plotly.graph_objects as go
import numpy as np

# Вхідні дані
n = np.linspace(1, 10, 100)

# Функції для різних складностей Big-O
def constant_time(n):
    return np.ones_like(n)

def logarithmic_time(n):
    return np.log2(n)

def linear_time(n):
    return n

def n_log_n_time(n):
    return n * np.log2(n)

def quadratic_time(n):
    return n ** 2

def cubic_time(n):
    return n ** 3

def exponential_time(n):
    return 2 ** n

# Трасування для кожної складності Big-O
traces = [
    go.Scatter(x=n, y=constant_time(n), mode='lines', name='O(1)'),
    go.Scatter(x=n, y=logarithmic_time(n), mode='lines', name='O(log n)'),
    go.Scatter(x=n, y=linear_time(n), mode='lines', name='O(n)'),
    go.Scatter(x=n, y=n_log_n_time(n), mode='lines', name='O(n log n)'),
    go.Scatter(x=n, y=quadratic_time(n), mode='lines', name='O(n^2)'),
    go.Scatter(x=n, y=cubic_time(n), mode='lines', name='O(n^3)'),
    go.Scatter(x=n, y=exponential_time(n), mode='lines', name='O(2^n)'),
]

# Конфігурація графіка
layout = go.Layout(
    xaxis=dict(title='Вхідний розмір (n)'),
    yaxis=dict(title='Операції'),
    legend=dict(orientation='h'),
)

# Створення графіка
fig = go.Figure(data=traces, layout=layout)
fig.show()
```

### Яка алгоритмічна складність основних операцій на колекціях?

Якщо ми говоримо про `list`, переважно це буде лінійна складність, за виключенням тих операцій, які виконуються наприкінці списку. Якщо ми говоримо про `set` та `dict`, то в основному це буде складність за одиницю, тому що `set` та `dict` під капотом є хеш-таблицями.

## Функції

### Що таке функція та які переваги використання функції?

Функція - це набір інструкцій, які виконуються після її виклику. Функції дозволяють нам уникнути дублювання коду, а також зробити код більш читабельним.

### Яким буде результат виконання функції, якщо в ній немає оператора `return`?

Якщо в функції немає оператора `return`, то результатом виконання функції буде `None`:

```{python}
def func():
    pass

a = func()

print(a)
```

### Що таке анотації типів? Навіщо вони потрібні? І коли виконуються анотації типів?

Анотації типів - це спосіб вказати типи аргументів та тип, який повертає функція. Анотації типів не впливають на роботу програми, але допомагають IDE та іншим інструментам аналізувати код та виявляти помилки.

Анотації типів виконуються під час виконання програми, тому їх можна використовувати для написання документації.

```{python}
def func(a: int, b: int) -> int:
    return a ** b

print(func(2, 3))
```

Насправді в Python анотації не працюють в рантаймі, тобто вони не використовуються для перевірки типів. Ми у будь-якому разі можемо передати аргумент будь-якого типу. У прикладі нижче отримаємо помилку, тому що рядок не підтримує зведення в квадрат

```{python}
#| error: true

def func(a: int, b: int) -> int:
    return a ** b

print(func('2', '3'))
```

Але якщо я передати `float`, то вже нічого поганого не станеться, тому що `float` можна звести в квадрат, хоча це не `int`:

```{python}
def func(a: int, b: int) -> int:
    return a ** b

print(func(2.2, 3.3))
```

Крім того є низка винятків. Наприклад, це бібліотека `pydentic`, яка може використовувати анотації типів у рантаймі для перевірки типу даних, наприклад атрибута класу.

### Як Python передає аргументи в функцію?

Є два типи передачі аргументу на функцію: за посиланням та за значенням.

Python передає аргументи в функцію за посиланням. Це означає, що якщо ми передаємо змінну в функцію, то функція отримує посилання на цю змінну, а не її копію. Якщо ми змінюємо змінну в функції, то змінна буде змінена і в глобальному просторі імен.

Розглянемо приклад:

```{python}
a = [1, 2, 3]

def func(arg):
    print(arg is a)

func(a)
```

Ми отримали `True`, тому що `arg` та `a` - це один і той же об'єкт.

### Що буде, якщо використовувати значення змінного типу як аргумент за замовчуванням функції? І як цього уникнути?

Якщо ми використовуємо змінну типу як аргумент за замовчуванням функції, то це може призвести до непередбачуваної поведінки. Наприклад, якщо ми використовуємо список як аргумент за замовчуванням, то цей список буде створений лише один раз, а не кожного разу, коли функція викликається без аргументів.

```{python}
def func(a=[]):
    a.append(1)
    return a

print(func())
print(func([]))
print(func())
print(func([]))
```

Коли Python читає код і натикається на сигнатуру функції нашої `func()`, ми маємо значення порожній список. Це значення він обчислює не коли ми викликаємо цю функцію щоразу, але в момент, коли ця функція готується до виконання. Тобто коли Python вперше читає цю функцію, він обчислює значення, які ми задали за умовчанням, кладе їх у пам'ять, і в подальшому вони будуть використані щоразу, коли ми будемо викликати цю функцію. Тобто не задаватимуться щоразу, а щоразу використовуватимуться ті самі, які були обчислені спочатку.

Як цього уникнути? Стандартний варіант – це використовувати `None`, як значення за замовчуванням, тому що це значення незмінного типу. І всередині поставити умову `if a is None: a = []`. Тобто створювати змінне значення всередині функції, а не в сигнатурі функції:

```{python}
def func(a=None):
    if a is None:
        a = []
    a.append(1)
    return a

print(func())
print(func([]))
print(func())
print(func([]))
```

### Що таке `*args` та `**quarks`? Які типи даних для них використовуються?

`*args` та `**quarks` – це спеціальні аргументи, які можна використовувати в сигнатурі функції. `*args` – це аргументи, які передаються в функцію позиційно. `**quarks` – це аргументи, які передаються в функцію по ключу.

```{python}
def func(*args, **quarks):
    print(locals())

func(1, 2, 3, a=1, b=2, c=3)
```

`*args` – це кортеж, `**quarks` – це словник.

### Що таке lambda функція та наведіть приклади їх використання?

Функція lambda це функція, яка не має імені. Як правило, це якась коротка функція, яка виконує деяку одну дію, і нам просто не потрібно виділяти для цього окреме ім'я.

Знайдемо ключ у якого найбільше значення в словнику. Якщо ми захочемо використати функцію `max()` для словника, то вона буде шукати максимальне значення серед ключів, а не серед значень:
```{python}
a = {
    1: 30,
    2: 20,
    3: 10
}

print(max(a))
```

Тому ми можемо використати lambda функцію, яка буде використовувати значення, а не ключі. Якщо я хочу знайти ключ, у якого найбільше значення, то в `max()` можна передати ще й `key` - це може бути лямбда функція, яка буде приймати кожен ключ і повертати значення цього ключа:

```{python}
print(max(a, key=lambda x: a[x]))
```

### Що таке рекурсія? Які обмеження мають рекурсія в Python? І розкажи про плюси та мінуси використання рекурсії.

**Рекурсія** – це механізм коли функція викликає сама себе. Це може бути корисно, коли ми маємо якусь задачу, яку можна розбити на більш прості задачі, і ці задачі можна розв'язати за допомогою тієї ж функції, яка викликає сама себе.

Які можуть бути плюси? Плюси це те, що код буде просто виглядати. Мінуси це те, що рекурсія використовує більше пам'яті, ніж якщо ми вирішуватимемо задачу за допомогою використання циклу. Як правило, більшість рекурсій можна замінити рішенням із циклом.

Приведемо приклад вирішення задачі через рекурсію та цикл, а також виміряємо використанням пам'яті.

Напишемо функцію, яка буде рахувати факторіал числа. Факторіал числа – це добуток всіх чисел від 1 до n. Наприклад, факторіал 5 – це 1 * 2 * 3 * 4 * 5 = 120.

::: {.panel-tabset}

### Рекурсія

```{python}
def factorial_rec(n):
    if n == 1:
        return n
    else:
        return n * factorial_rec(n - 1)

print(factorial_rec(1001))
```

### Цикл

```{python}
def factorial_loop(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

print(factorial_loop(5))
```

:::

Python накладає обмеження на 3000 викликів на рекурсію:

```{python}
import sys

print(sys.getrecursionlimit())
```

Це означає, що якщо ми будемо викликати функцію `factorial_rec()` з аргументом 3001, то ми отримаємо помилку:

```{python}
#| error: true
print(factorial_rec(3001))
```

Також за допомогою модуля `sys` ми можемо встановити обмеження на рекурсію:

```{python}
import sys

sys.setrecursionlimit(4000)
```

## Класи