# Популярні питання

## Основи

### Що таке PEP-8?

**PEP** або **Python Enhancement Proposal** – це пропозиція щодо розвитку мови Python. Ці документи є механізмом для пропонування нових можливостей або для документування вже готових рішень, які увійшли до мови Python. 

**PEP-8** — це style guide того, як повинен бути оформлений код, написаний мовою Python, і яку повинні слідувати всі розробники, які пишуть цією мовою.

### Які типи даних є в Python? Або які типи даних є змінними, а які є незмінними?

Типи даних у Python можна розділити на змінні та незмінні. 

До незмінних можна віднести: рядки, байти, цілі числа, числа з плаваючою точкою, комплексні числа, булеві значення, none, картежі та frozenset. 

До змінюваних типів даних можна віднести списки, сети, словники, байт-масиви та memoryview.

| **Змінні**  | **Незмінні** |
|-------------|--------------|
| `str`       | `list`       |
| `bytes`     | `set`        |
| `int`       | `dict`       |
| `float`     | `bytearray`  |
| `complex`   | `memoryview` |
| `bool`      |              |
| `None`      |              |
| `tuple`     |              |
| `frozenset` |              |

### Що таке віртуальне оточення? Навіщо воно потрібне?

Уявімо ситуацію, що на одному комп'ютері нам потрібно запустити два Python-проекти, які використовують одну бібліотеку, тільки різних версій. Саме такі віртуальні оточення допомагають нам вирішити цей конфлікт. Коли ми використовуємо віртуальне оточення, ми створюємо щось на кшталт пісочниці, де ми ізолюємо локальний Python від глобального Python. Це дозволяє нам ставити різні бібліотеки локально, не впливаючи на Python, який встановлений глобально у нас на комп'ютері.

### Чи можна змінити елемент у кортежі, якщо кортеж незмінний тип даних?

Хоча по собі картеж — це незмінний тип даних, але може містити змінюване значення. Припустимо, у нас є картеж `a`, який містить список і одиницю. 

```{python}
a = ([], 1)
```

Хоча картеж і незмінний - це означає, що ми не можемо змінювати його структуру, але якщо він містить елементи, що змінюються, то ми можемо їх змінювати. Наприклад, якщо ми спробуємо додати до картежу третім елементом двійку, то ми отримаємо помилку, тому що картеж - це незмінний тип даних. 

```{python}
#| error: true

a[3] = 2
```

Але якщо ми візьмемо нульовий елемент, це список, і спробуємо додати до нього двійку в кінець, знову виведемо на екран наш картеж, то побачимо, що нам вдалося змінити нульовий елемент.

```{python}
a[0].append(2)
print(a)
```

Тобто картеж незмінний тип даних, змінювати структуру його не можна, але якщо є елементи, що змінюються всередині, то їх можна змінювати.

### Що таке List, Set та Dict comprehensions? Наведи приклад їхнього використання.

List, Set та Dict comprehensions – це скорочення для наступного запису:

```{python}
a = []

for i in range(5):
    a.append(i)

print(a)
```

Щоб отримати той самий результат, ми можемо скористатися List Comprehensions:

```{python}
l = [i for i in range(5)]
print(l)
```

Також у List, Set та Dict Comprehensions можна використовувати умови. Для цього потрібно після колекції або після генератора вказати ключове слово `if` і вказати умови, за якими ми вибиратимемо елементи, які вставлятимемо в цей список:

```{python}
# виведемо парні числа

l = [i for i in range(5) if i % 2 == 0]
print(l)
```

Різниця між List і Set Comprehension у тому, що в List Comprehension використовуються квадратні дужки, Set Comprehension використовуються круглі дужки:

```{python}
s = {i for i in range(5) if i % 2 == 0}
print(s)
```

Щоб отримати Dict Comprehension, у нас повинен бути тут не один елемент, а має бути два елементи. Тобто один для ключа, другий для значення. Ми також використовуємо фігурні дужки:

```{python}
d = {i: i ** 2 for i in range(5) if i % 2 == 0}
print(d)
```

В якості прикладів використання List Set та Dict Comprehension можна навести розпакування якихось колекцій, або якихось генераторів, або просто заміна якогось дуже простого циклу, коли це не заважає читабельності коду.

### Яка різниця між операторами `==` та `is`?

Оператор `==` порівнює два операнди за їх значеннями:

```{python}
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)
```

Оператор `is` перевіряє, що дві змінні, тобто `a` і `b` посилаються на один об'єкт. В даному випадку у нас `a` посилається на один список, `b` посилається на інший список, відповідно ми повинні отримати `false`:

```{python}
a = [1, 2, 3]
b = [1, 2, 3]

print(a is b)
```

Що буде, якщо `b` надамо не новий список, а передамо `a`? Ми отримаємо `true`, тому що і `a`, і `b` посилаються на той самий об'єкт:

```{python}
a = [1, 2, 3]
b = a

print(a is b)
```

### Що таке глибока (`deep`) та поверхнева (`shallow`) копія? Навіщо вони потрібні та як їх зробити?

Поверхнева копія копіює сам об'єкт. Всі внутрішні об'єкти вона не копіює, вони доступні за тими самими посиланнями. Глибока копія, мало того, що копіює зовнішній об'єкт, вона рекурсивно копіює всі внутрішні об'єкти в нову пам'ять. Якщо ми змінюємо новий об'єкт, то попередній стає незмінним.

Розглянемо приклад:

```{python}
a = [1, [2]]
b = a
b.append(3) # додаємо 3 до b
b[1].append(4) # додаємо 4 до списку, який знаходиться всередині b

print(a)
```

Оскільки змінні `a` і `b` посилаються на один і той самий об'єкт, то і `a` зміниться. Не завжди це та поведінка, яку ми очікуємо. Для цього у нас є два види копії, відповідно, глибока та поверхнева.

Найпростіший спосіб це імпортувати модуль `copy` і скористатися методом `copy()`. В такому випадку ми отримаємо поверхневу копію. Поверхнева копія створює копію самого об'єкта, але посилання на всі внутрішні об'єкти будуть збережені, вони не будуть скопійовані.

```{python}
import copy

a = [1, [2]]
b = copy.copy(a)
b.append(3)
b[1].append(4)

print(a)
```

Для створення глибокої копії ми можемо скористатися методом `deepcopy()`:

```{python}
import copy

a = [1, [2]]
b = copy.deepcopy(a)
b.append(3)
b[1].append(4)

print(a)
```

Якщо ж ми розглядаємо список, то існує багато способів, як ще можна створити поверхневу копію:

```{python}
a = [1, [2]]

b = list(a) # поверхнева копія через list()
b = a[:] # поверхнева копія через зріз
b = [i for i in a] # поверхнева копія через List Comprehension
b = a.copy() # поверхнева копія через вбудовану функцію copy()
```

### Як працюють оператори `and`, `or` та `not`? Що вони повертають?

Оператор `not` приводить свій операнд до типу `bool` і повертає його інверсію:

```{python}
# not

print(not [])
```

```{python}
# not

print(not {1, 2, 3})
```

Оператори `and` та `or` не приводять об'єкти до булевих значень, вони повертають самі об'єкти. 

Якщо перший операнд повертає `False`, то `and` поверне його:

```{python}
print([] and 123)
```

Якщо перший операнд повертає `True`, то `and` поверне другий операнд:

```{python}
print([1, 2, 3] and 123)
```

Якщо перший операнд повертає `True`, то `or` поверне його:

```{python}
print([1, 2, 3] or 123)
```

Якщо перший операнд повертає `False`, то `or` поверне другий операнд:

```{python}
print([] or 123)
```

### Як працює простір імен у Python? Або як працює правило LEGB (Local, Enclosing, Global, Built-in)?

Простір імен у Python працює за правилом LEGB. Це означає, що спочатку інтерпретатор шукає змінну в локальному просторі імен, потім в необов'язковому просторі імен зовнішньої функції, потім в глобальному просторі імен і, нарешті, в просторі імен вбудованих функцій.

Розглянемо приклад, в якому повертається локальна змінна `str`:

```{python}
str = 'global'

def outer():
    str = 'enclosing'
    
    def inner():
        str = 'local' # локальна змінна
        print(str)
    
    inner()

outer()
```

Якщо цієї змінної не має в локальному просторі імен, то інтерпретатор буде шукати її в зовнішньому просторі імен:

```{python}
str = 'global'

def outer():
    str = 'enclosing' # зовнішній простір імен
    
    def inner():
        print(str)
    
    inner()

outer()
```

Якщо цієї змінної не має в зовнішньому просторі імен, то інтерпретатор буде шукати її в глобальному просторі імен:

```{python}

str = 'global' # глобальний простір імен

def outer():
    def inner():
        print(str)
    
    inner()

outer()
```

Якщо цієї змінної не має в глобальному просторі імен, то інтерпретатор буде шукати її в просторі імен вбудованих функцій:

```{python}
def outer():
    def inner():
        print(str)
    
    inner()

outer()
```

Якщо ми спробуємо звернутися до змінної, якої немає ні в одному з просторів імен, то інтерпретатор викине помилку:

```{python}
#| error: true

def outer():
    def inner():
        print(variable) # змінна, якої немає ні в одному з просторів імен
    
    inner()

outer()
```

